{
    "FUN_08007246": {
        "renaming": {
            "FUN_08007246": "process_input_and_display_output_08007246",
            "addByteToUintAndStoreResult_08003748": "add_byte_to_uint_and_store_result",
            "do_nothing_08004046": "do_nothing",
            "do_nothing_08007244": "do_nothing"
        },
        "code": "void process_input_and_display_output_08007246(void)\n{\n  addByteToUintAndStoreResult_08003748();\n  do_nothing_08007244();\n  do_nothing();\n  return;\n}",
        "called": [
            "FUN_08007244",
            "FUN_08003748",
            "FUN_08004046"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007246",
        "calling": [],
        "current_name": "process_input_and_display_output_08007246"
    },
    "FUN_0800a042": {
        "renaming": {
            "FUN_0800a042": "assign_value_if_condition_met_0800a042",
            "param_1": "result",
            "param_2": "input_value",
            "param_3": "unused_param1",
            "param_4": "unused_param2",
            "sVar1": "input_short",
            "puVar2": "PTR_DAT_0800a0c8",
            "iVar3": "check_result",
            "unaff_r4": "unused_param3",
            "unaff_r5": "unused_param4",
            "in_lr": "unused_param5"
        },
        "code": "void assign_value_if_condition_met_0800a042(int *result, int input_value, undefined4 unused_param1, undefined4 unused_param2)\n{\n  short input_short = *(short *)(input_value + 0xe);\n  int condition = (int)((uint)*(ushort *)(input_value + 0xc) << 0x17);\n  if (condition < 0) {\n    check_and_assign_value(result, input_short, 0, 2);\n  }\n  *(ushort *)(input_value + 0xc) &= 0xefff;\n  int check_result = check_input_and_return(input_short, unused_param1, unused_param2, unused_param2, unused_param2, 0, 0, 0);\n  if ((check_result == -1) && (*(int *)PTR_DAT_0800a0c8 != 0)) {\n    *result = *(int *)PTR_DAT_0800a0c8;\n  }\n  return;\n}",
        "called": [
            "FUN_0800a130",
            "FUN_0800885c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a042",
        "calling": [],
        "current_name": "assign_value_if_condition_met_0800a042"
    },
    "FUN_08008694": {
        "renaming": {
            "FUN_08008694": "store_data_and_set_bits_08008694",
            "param_1": "index",
            "param_2": "data",
            "bVar1": "byte_index",
            "PTR_DAT_080086dc": "data_pointer_1",
            "PTR_DAT_080086e0": "data_pointer_2",
            "set_bits_08003f30": "set_bits",
            "set_bit_at_index_08003f94": "set_bit_at_index",
            "set_data_0800688e": "set_data"
        },
        "code": "void store_data_and_set_bits_08008694(int data, int index)\n{\n  if (index != 0)\n  {\n    byte byte_index = *(byte *)(index + 0x44);\n    *(int *)(PTR_DAT_080086dc + (uint)byte_index * 4) = data;\n    *(int *)(PTR_DAT_080086e0 + (uint)byte_index * 4) = index;\n    int char_index = *(char *)(index + 0x5a);\n    set_bits_08003f30(char_index, 0, 2);\n    set_bit_at_index_08003f94(char_index);\n    int ptr_index = *(byte *)(index + 0x44);\n    set_data_0800688e(*(int *)(PTR_DAT_080086e4 + (uint)ptr_index * 4), *(int *)(index + 100) + (uint)*(ushort *)(index + 0x6a), 1);\n    return;\n  }\n  return;\n}",
        "called": [
            "FUN_0800688e",
            "FUN_08003f94",
            "FUN_08003f30"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008694",
        "calling": [],
        "current_name": "store_data_and_set_bits_08008694"
    },
    "FUN_08002ce0": {
        "renaming": {
            "FUN_08002ce0": "initialize_params_08002ce0",
            "param_1": "param_address",
            "iVar1": "data_struct_address",
            "set_param_value_0800314e": "set_param_value",
            "initialize_data_structure_080032bc": "initialize_data_structure",
            "execute_callback_if_available": "PTR_execute_callback_if_available_08002c2c_1_08002d90",
            "LAB_1": "PTR_LAB_08002c40_1_08002d94",
            "LAB_2": "PTR_LAB_08002c7c_1_08002d98",
            "LAB_3": "PTR_LAB_08002c90_1_08002d9c",
            "LAB_4": "PTR_LAB_08002c54_1_08002da0",
            "LAB_5": "PTR_LAB_08002c68_1_08002da4",
            "LAB_6": "PTR_LAB_08002ca4_1_08002da8",
            "LAB_7": "PTR_LAB_08002cb8_1_08002dac",
            "LAB_8": "PTR_LAB_08002e1a_1_08002db0",
            "LAB_9": "PTR_LAB_08002dea_1_08002db4",
            "LAB_10": "PTR_LAB_08002cd0_1_08002db8"
        },
        "code": "void initialize_params_08002ce0(int param_address)\n{\n  set_param_value_0800314e(param_address + 0x40);\n  int data_struct_address = param_address + 0x44;\n  initialize_data_structure_080032bc(data_struct_address, param_address, 0x40);\n  *(undefined *)(param_address + 0xc4) = 0;\n  *(undefined4 *)(param_address + 200) = 0;\n  *(undefined *)(param_address + 0x1f8) = 0;\n  set_values_08003306(data_struct_address, 0xe0, execute_callback_if_available, 0);\n  set_values_08003306(data_struct_address, 0x90, LAB_1, 0);\n  set_values_08003306(data_struct_address, 0xc0, LAB_2, 0);\n  set_values_08003306(data_struct_address, 0xd0, LAB_3, 0);\n  set_values_08003306(data_struct_address, 0xf4, LAB_4, 0);\n  set_values_08003306(data_struct_address, 0xf5, LAB_5, 0);\n  set_values_if_param2_equals_113_08003366(data_struct_address, 0x71, LAB_6, 0);\n  set_values_in_struct_08003370(data_struct_address, 0xf0, LAB_7, 0);\n  update_params_if_valid_08003346(data_struct_address, 0x79, LAB_8, param_address);\n  set_values_at_offsets_08003350(data_struct_address, 0xf9, LAB_9, param_address);\n  set_values_at_offsets_08003350(data_struct_address, 0xff, LAB_10, 0);\n  return;\n}",
        "called": [
            "FUN_080032bc",
            "FUN_08003306",
            "FUN_08003366",
            "FUN_08003370",
            "FUN_08003350",
            "FUN_0800314e",
            "FUN_08003346"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ce0",
        "calling": [
            "FUN_08002dbc"
        ],
        "current_name": "initialize_params_08002ce0"
    },
    "FUN_08005188": {
        "renaming": {
            "FUN_08005188": "process_data_and_return_result_08005188",
            "param_1": "data",
            "set_flags_based_on_conditions_080043a2": "set_flags_based_on_conditions",
            "set_param_value_08004396": "set_param_value",
            "set_flag_based_on_conditions_0800430c": "set_flag_based_on_conditions",
            "set_bit_and_update_08004d6c": "set_bit_and_update",
            "process_data_08004e3c": "process_data",
            "process_input_08004b82": "process_input",
            "execute_command_08004ccc": "execute_command",
            "process_input_08004ac2": "process_input",
            "execute_command_08005084": "execute_command",
            "process_data_08004a76": "process_data",
            "process_data_0800459c": "process_data",
            "process_input_data_08004a24": "process_input_data",
            "extract_byte_from_data_0800457c": "extract_byte_from_data"
        },
        "code": "void process_data_and_return_result_08005188(void* data) {\\n  int data_ptr = *(int *)data;\\n  uint flags = *(uint *)(data_ptr + 0x14);\\n  uint input_flags = *(uint *)(data_ptr + 4);\\n  uint output_flags = *(uint *)(data_ptr + 0x18);\\n  char input_type = *(char *)((int)data + 0x3e);\\n  if (input_type == '\\x10' || input_type == '@') {\\n    if ((flags & 0x10001) == 0 || (input_flags & 0x200) == 0) {\\n      if ((0x0000C0C0 & flags) == 0 || (input_flags & 0x200) == 0) {\\n        if ((0x00003030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n          set_flags_based_on_conditions_080043a2(data);\\n        }\\n      }\\n      else {\\n        set_param_value_08004396(data);\\n      }\\n    }\\n    else {\\n      set_flag_based_on_conditions_0800430c(data);\\n    }\\n    if ((output_flags & 0x00000040) == 0) {\\n      if ((0x0000E0C0 & flags) != 0 && (input_flags & 0x400) != 0 && (0x0000C030 & flags) == 0) {\\n        set_bit_and_update_08004d6c(data);\\n        return;\\n      }\\n      if ((0x0000C030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n        process_data_08004a76(data);\\n        return;\\n      }\\n    }\\n    else {\\n      if ((0x0000E000 & flags) != 0 && (input_flags & 0x400) != 0 && (0x0000C030 & flags) == 0) {\\n        process_input_08004b82(data);\\n        return;\\n      }\\n      if ((0x0000C030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n        execute_command_08004ccc(data);\\n        return;\\n      }\\n    }\\n  }\\n  else {\\n    if ((0x00003030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n      process_input_08004ac2();\\n      return;\\n    }\\n    if ((0x00006060 & flags) != 0 && (input_flags & 0x200) != 0) {\\n      execute_command(data);\\n      return;\\n    }\\n    if ((output_flags & 0x00000040) == 0) {\\n      if ((0x0000E0C0 & flags) != 0 && (input_flags & 0x400) != 0 && (0x0000C030 & flags) == 0) {\\n        process_data_0800459c(data);\\n        return;\\n      }\\n      if ((0x0000C030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n        process_data(data);\\n      }\\n    }\\n    else {\\n      if ((0x0000E000 & flags) != 0 && (input_flags & 0x400) != 0 && (0x0000C030 & flags) == 0) {\\n        process_input_data_08004a24(data);\\n        return;\\n      }\\n      if ((0x0000C030 & flags) != 0 && (input_flags & 0x200) != 0) {\\n        extract_byte_from_data_0800457c(data);\\n        return;\\n      }\\n    }\\n  }\\n  return;\\n}",
        "called": [
            "FUN_0800457c",
            "FUN_08005084",
            "FUN_08004ccc",
            "FUN_08004ac2",
            "FUN_08004b82",
            "FUN_080043a2",
            "FUN_08004396",
            "FUN_0800430c",
            "FUN_08004e3c",
            "FUN_08004a24",
            "FUN_08004d6c",
            "FUN_08004a76",
            "FUN_0800459c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005188",
        "calling": [],
        "current_name": "process_data_and_return_result_08005188"
    },
    "FUN_08007244": {
        "renaming": {
            "FUN_08007244": "do_nothing_08007244"
        },
        "code": "void do_nothing_08007244(void)\\n{\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007244",
        "calling": [
            "FUN_08007246"
        ],
        "current_name": "do_nothing_08007244"
    },
    "FUN_08009db0": {
        "renaming": {
            "FUN_08009db0": "allocate_and_initialize_block_08009db0",
            "param_1": "error_code",
            "param_2": "size",
            "param_3": "fill_value",
            "param_4": "param_4",
            "piVar1": "block_pointer",
            "piVar2": "current_block_pointer",
            "iVar3": "allocation_size",
            "ppiVar4": "next_block_pointer_ptr"
        },
        "code": "int * allocate_and_initialize_block_08009db0(int *error_code, int size, int fill_value, int param_4)\n{\n  int *block_pointer;\n  int *current_block_pointer;\n  int allocation_size;\n  int **next_block_pointer_ptr;\n  \n  allocation_size = *(int *)PTR_PTR_DAT_08009e24;\n  if (*(int *)(allocation_size + 0x18) == 0) {\n    initialize_allocation_system(allocation_size);\n  }\n  next_block_pointer_ptr = (int **)(allocation_size + 0x48);\n  do {\n    current_block_pointer = next_block_pointer_ptr[2];\n    block_pointer = next_block_pointer_ptr[1];\n    while (block_pointer = (int *)((int)block_pointer + -1), -1 < (int)block_pointer) {\n      if (*(short *)(current_block_pointer + 3) == 0) {\n        *(undefined2 *)((int)current_block_pointer + 0xe) = 0xffff;\n        current_block_pointer[0x19] = 0;\n        *(undefined2 *)(current_block_pointer + 3) = 1;\n        *current_block_pointer = 0;\n        current_block_pointer[2] = 0;\n        current_block_pointer[1] = 0;\n        current_block_pointer[4] = 0;\n        current_block_pointer[5] = 0;\n        current_block_pointer[6] = 0;\n        fill_memory_with_value(current_block_pointer + 0x17, size, 8, fill_value, param_4);\n        current_block_pointer[0xd] = 0;\n        current_block_pointer[0xe] = 0;\n        current_block_pointer[0x12] = 0;\n        current_block_pointer[0x13] = 0;\n        return current_block_pointer;\n      }\n      current_block_pointer = current_block_pointer + 0x1a;\n    }\n    if (*next_block_pointer_ptr == (int *)0x0) {\n      block_pointer = (int *)allocate_and_initialize_block_08009db0_08009d24(error_code, 4);\n      *next_block_pointer_ptr = block_pointer;\n      if (block_pointer == (int *)0x0) {\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    next_block_pointer_ptr = (int **)*next_block_pointer_ptr;\n  } while( true );\n}",
        "called": [
            "FUN_08009d50",
            "FUN_08009d24",
            "FUN_080091c6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009db0",
        "calling": [
            "FUN_08009d50"
        ],
        "current_name": "allocate_and_initialize_block_08009db0",
        "code_backup": "\nint * FUN_08009db0(undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  iVar3 = *(int *)PTR_PTR_DAT_08009e24;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_08009d50(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar2 = ppiVar4[2];\n    piVar1 = ppiVar4[1];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) = 0xffff;\n        piVar2[0x19] = 0;\n        *(undefined2 *)(piVar2 + 3) = 1;\n        *piVar2 = 0;\n        piVar2[2] = 0;\n        piVar2[1] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        piVar2[6] = 0;\n        fill_memory_with_value_080091c6(piVar2 + 0x17,0,8,1,param_4);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_block_08009d24(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
    },
    "FUN_08002c2c": {
        "renaming": {
            "FUN_08002c2c": "execute_callback_if_available_08002c2c",
            "param_1": "callback_ptr",
            "param_2": "param_1",
            "param_3": "param_2",
            "param_4": "param_3",
            "pcVar1": "callback_func"
        },
        "code": "void execute_callback_if_available_08002c2c(undefined4 callback_ptr, undefined4 param_1, undefined4 param_2, undefined4 param_3) {\\n  code *callback_func = *(code **)PTR_DAT_08002c3c;\\n  if (callback_func != (code *)0x0) {\\n    (*callback_func)(param_1, param_2, param_3, callback_func, callback_ptr);\\n  }\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002c2c",
        "calling": [],
        "current_name": "execute_callback_if_available_08002c2c"
    },
    "FUN_08001bf8": {
        "renaming": {
            "FUN_08001bf8": "copy_input_data_to_buffer_08001bf8",
            "param_1": "buffer_address",
            "param_2": "input_data",
            "param_3": "input_data_size",
            "param_4": "buffer_size",
            "PTR_DAT_08001c04": "buffer_pointer",
            "PTR_DAT_08001c00": "buffer_status",
            "PTR_DAT_08001c08": "buffer_size_ptr",
            "PTR_DAT_08001c0c": "buffer_used_size_ptr",
            "PTR_DAT_08001c10": "buffer_data_ptr"
        },
        "code": "void copy_input_data_to_buffer_08001bf8(uint buffer_address, uint input_data, uint input_data_size, uint buffer_size)\\n{\\n  uint PTR_DAT_08001c00;\\n  uint *PTR_DAT_08001c04;\\n  int result;\\n  uint buffer_used_size;\\n  \\n  PTR_DAT_08001c04 = PTR_DAT_08001c04;\\n  PTR_DAT_08001c00 = *PTR_DAT_08001c00;\\n  if (PTR_DAT_08001c00 == 0) {\\n    result = copy_input_data_to_buffer_08001bf8(buffer_address + 0x14, &input_data, input_data_size & 0xffff, buffer_size);\\n    if (result != 0) {\\n      return;\\n    }\\n    else {\\n      return;\\n    }\\n  }\\n  else {\\n    buffer_size = (*PTR_DAT_08001c08 + 1) & 0xff;\\n    buffer_used_size = (*PTR_DAT_08001c0c) & 0xff;\\n    if (buffer_used_size < buffer_size + input_data_size) {\\n      if (buffer_size + input_data_size < 0x20) {\\n        buffer_size = 0x20;\\n      }\\n      else {\\n        buffer_size = buffer_size + input_data_size;\\n      }\\n      result = allocate_and_copy_data(PTR_DAT_08001c08, buffer_size);\\n      *PTR_DAT_08001c04 = result;\\n      if (result == 0) {\\n        return;\\n      }\\n      else {\\n        *PTR_DAT_08001c0c = buffer_size;\\n      }\\n    }\\n    PTR_DAT_08001c04 = PTR_DAT_08001c10;\\n    if (*PTR_DAT_08001c08 == 0) {\\n      *(uint *)(buffer_address + 4) = 1;\\n      return;\\n    }\\n    else {\\n      copy_input_data_to_buffer_08001bf8((uint)PTR_DAT_08001c04 + *(int *)PTR_DAT_08001c08, &input_data, input_data_size);\\n      buffer_used_size = buffer_used_size + input_data_size;\\n      *PTR_DAT_08001c04 = buffer_used_size;\\n      *PTR_DAT_08001c0c = buffer_used_size;\\n      return;\\n    }\\n  }\\n}",
        "called": [
            "FUN_0800288c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08001bf8",
        "calling": [
            "FUN_08001cd0",
            "FUN_08001c18"
        ],
        "current_name": "copy_input_data_to_buffer_08001bf8"
    },
    "FUN_080072f0": {
        "renaming": {
            "FUN_080072f0": "check_bit_and_return_if_set_080072f0",
            "param_1": "bit_array_address",
            "param_2": "bit_index",
            "param_3": "param_1",
            "param_4": "param_2",
            "check_bit_080042d4": "is_bit_set_080042d4",
            "set_bit_080042e0": "set_bit_080042e0",
            "is_bit_set": "is_bit_set"
        },
        "code": "void check_bit_and_return_if_set_080072f0(undefined4 bit_array_address, undefined2 bit_index, undefined4 param_1, undefined4 param_2)\n{\n  bool is_bit_set = is_bit_set_080042d4(bit_array_address, bit_index);\n  if (is_bit_set)\n  {\n    return;\n  }\n  else\n  {\n    set_bit_080042e0(bit_array_address, bit_index);\n    return;\n  }\n}",
        "called": [
            "FUN_080042d4"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080072f0",
        "calling": [
            "FUN_08008a6c"
        ],
        "current_name": "check_bit_and_return_if_set_080072f0"
    },
    "FUN_08000178": {
        "renaming": {
            "FUN_08000178": "find_string_end_08000178",
            "param_1": "str",
            "pcVar2": "current_char",
            "pcVar3": "current_char_ptr",
            "cVar1": "current_char_val"
        },
        "code": "char* find_string_end_08000178(char* str) {\\n  char* current_char = str;\\n  while (*current_char != '\\0') {\\n    current_char++;\\n  }\\n  return current_char;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000178",
        "calling": [
            "FUN_08002e44",
            "FUN_080032a2",
            "FUN_08008e7c"
        ],
        "current_name": "find_string_end_08000178"
    },
    "FUN_080069ec": {
        "renaming": {
            "FUN_080069ec": "process_input_080069ec",
            "param_1": "input_data",
            "iVar1": "value",
            "uVar2": "input_flag_2",
            "uVar4": "input_flag_5",
            "uVar5": "input_flag_1",
            "puVar3": "input_flags",
            "process_input_string_0800694c": "process_input_string",
            "decode_message_080064cc": "decode_message",
            "process_selected_item_and_clear_flag_08006932": "process_selected_item_and_clear_flag",
            "clear_flags_080064b0": "clear_flags",
            "doNothing_0800877c": "do_nothing",
            "get_value_from_pointer_08004050": "get_value_from_pointer"
        },
        "code": "void process_input_080069ec(uint **input_data) {\n  uint *input_flags = *input_data;\n  uint input_flag_1 = *input_flags;\n  uint input_flag_2 = input_flags[3];\n  if ((input_flag_1 & 0xf) == 0 && (input_flag_1 & 0x20) != 0 && (input_flag_2 & 0x20) != 0) {\n    process_input_080069ec_string_0800694c(input_data);\n    return;\n  }\n  if ((input_flag_1 & 0xf) == 0 || (input_flags[5] & 1) == 0 && (input_flag_2 & 0x120) == 0) {\n    if ((input_flag_1 & 0x80) != 0 && (input_flag_2 & 0x80) != 0) {\n      decode_message_080064cc(input_data);\n      return;\n    }\n    if ((input_flag_1 & 0x40) != 0 && (input_flag_2 & 0x40) != 0) {\n      process_selected_item_and_clear_flag(input_data);\n    }\n  }\n  else {\n    if ((input_flag_1 & 1) != 0 && (input_flag_2 & 0x100) != 0) {\n      input_data[15] = (uint *)((uint)input_data[15] | 1);\n    }\n    if ((input_flag_1 & 4) != 0 && (input_flags[5] & 1) != 0) {\n      input_data[15] = (uint *)((uint)input_data[15] | 2);\n    }\n    if ((input_flag_1 & 2) != 0 && (input_flags[5] & 1) != 0) {\n      input_data[15] = (uint *)((uint)input_data[15] | 4);\n    }\n    if ((input_flag_1 & 8) != 0 && (input_flags[5] & 1) != 0) {\n      input_data[15] = (uint *)((uint)input_data[15] | 8);\n    }\n    if (input_data[15] != (uint *)0x0) {\n      if ((input_flag_1 & 0x20) != 0 && (input_flag_2 & 0x20) != 0) {\n        process_input_080069ec_string_0800694c(input_data);\n      }\n      if (((uint)input_data[15] & 8) == 0 && (input_flags[0][5] & 0x40) == 0) {\n        doNothing_0800877c(input_data);\n        input_data[15] = (uint *)0x0;\n        return;\n      }\n      clear_flags_080064b0(input_data);\n      uint *input_data_ptr = *input_data;\n      if ((input_data_ptr[5] & 0x40) == 0) {\n        doNothing_0800877c(input_data);\n        return;\n      }\n      input_data_ptr[5] = input_data_ptr[5] & 0xffffffbf;\n      if (input_data[13] == (uint *)0x0) {\n        doNothing_0800877c(input_data);\n        return;\n      }\n      input_data[13][13] = (uint)PTR_LAB_08006b0c_1_08006b08;\n      int value = get_value_from_pointer_08004050(input_data[13]);\n      if (value != 0) {\n        (*(code *)input_data[13][13])();\n        return;\n      }\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_0800877c",
            "FUN_08006932",
            "FUN_08004050",
            "FUN_080064b0",
            "FUN_080064cc",
            "FUN_0800694c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080069ec",
        "calling": [],
        "current_name": "process_input_080069ec"
    },
    "FUN_0800a168": {
        "renaming": {
            "FUN_0800a168": "processReturnValue_0800a168",
            "param_1": "outputValue",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "param_4",
            "puVar1": "pointerToData",
            "iVar2": "returnValue"
        },
        "code": "void processReturnValue_0800a168(int *outputValue, undefined4 param_2, undefined4 param_3, undefined4 param_4)\n{\n  undefined *pointerToData = PTR_DAT_0800a188;\n  *(undefined4 *)PTR_DAT_0800a188 = 0;\n  int returnValue = returnZero_08008858(param_2, param_3, param_4, param_4, param_4);\n  if ((returnValue == -1) && (*(int *)pointerToData != 0)) {\n    *outputValue = *(int *)pointerToData;\n  }\n  return;\n}",
        "called": [
            "FUN_08008858"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a168",
        "calling": [
            "FUN_0800a020"
        ],
        "current_name": "processReturnValue_0800a168"
    },
    "FUN_080067ac": {
        "renaming": {
            "FUN_080067ac": "check_if_valid_input_080067ac",
            "param_1": "input_array",
            "param_2": "input_string",
            "param_3": "string_length",
            "param_4": "pointer_value",
            "uVar1": "pointer_value_copy",
            "iVar2": "return_value",
            "first_char_of_input_array": "first_char_of_input_array"
        },
        "code": "int check_if_valid_input_080067ac(int *input_array, ushort *input_string, int string_length, undefined4 pointer_value)\\n{\\n  undefined4 pointer_value_copy;\\n  int return_value;\\n  char first_char_of_input_array = *(char *)((int)input_array + 0x39);\\n\\n  if (first_char_of_input_array == ' ')\\n  {\\n    if (input_string == (ushort *)0x0 || string_length == 0)\\n    {\\n      return_value = 1;\\n    }\\n    else if (*(char *)(input_array + 0xe) == '\\x01')\\n    {\\n      return_value = 2;\\n    }\\n    else\\n    {\\n      *(undefined *)(input_array + 0xe) = 1;\\n      input_array[0xf] = 0;\\n      *(undefined *)((int)input_array + 0x39) = 0x21;\\n      pointer_value_copy = get_pointer_value_08003760();\\n      *(short *)(input_array + 9) = (short)string_length;\\n      *(short *)((int)input_array + 0x26) = (short)string_length;\\n      while (*(short *)((int)input_array + 0x26) != 0)\\n      {\\n        *(short *)((int)input_array + 0x26) = *(short *)((int)input_array + 0x26) + -1;\\n        if (input_array[2] == 0x1000)\\n        {\\n          return_value = check_flags_and_values_080066e8(input_array,0x80,0,pointer_value_copy,pointer_value);\\n          if (return_value != 0)\\n          {\\n            return 3;\\n          }\\n          *(uint *)(*input_array + 4) = *input_string & 0x1ff;\\n          if (input_array[4] == 0)\\n          {\\n            input_string = input_string + 1;\\n          }\\n          else\\n          {\\n            input_string = (ushort *)((int)input_string + 1);\\n          }\\n        }\\n        else\\n        {\\n          return_value = check_flags_and_values_080066e8(input_array,0x80,0,pointer_value_copy,pointer_value);\\n          if (return_value != 0)\\n          {\\n            return 3;\\n          }\\n          *(uint *)(*input_array + 4) = (uint)*(byte *)input_string;\\n          input_string = (ushort *)((int)input_string + 1);\\n        }\\n      }\\n      return_value = check_flags_and_values_080066e8(input_array,0x40,0,pointer_value_copy,pointer_value);\\n      if (return_value == 0)\\n      {\\n        *(undefined *)((int)input_array + 0x39) = 0x20;\\n        *(undefined *)(input_array + 0xe) = 0;\\n      }\\n      else\\n      {\\n        return_value = 3;\\n      }\\n    }\\n  }\\n  else\\n  {\\n    return_value = 2;\\n  }\\n  return return_value;\\n}",
        "called": [
            "FUN_08003760",
            "FUN_080066e8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080067ac",
        "calling": [
            "FUN_08008500"
        ],
        "current_name": "check_if_valid_input_080067ac"
    },
    "FUN_0800735a": {
        "renaming": {
            "FUN_0800735a": "find_param_in_array_0800735a",
            "param_1": "search_param",
            "param_2": "array"
        },
        "code": "int find_param_in_array_0800735a(int search_param, char* array) {\\n  while (*array != -1) {\\n    if (*array == search_param) {\\n      return *(int *)(array + 8);\\n    }\\n    array += 0xc;\\n  }\\n  return -1;\\n}",
        "called": [
            "FUN_0800735a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800735a",
        "calling": [
            "FUN_08007376",
            "FUN_0800735a"
        ],
        "current_name": "find_param_in_array_0800735a"
    },
    "FUN_08008c20": {
        "renaming": {
            "FUN_08008c20": "initialize_data_structures_08008c20",
            "param_1": "data_structure_address",
            "PTR_": "pointer_",
            "DAT_": "data_"
        },
        "code": "void initialize_data_structures_08008c20(int DAT_structure_address) {\\n  int* DAT_structure_pointer = (int*)(DAT_structure_address + 0x130);\\n  *DAT_structure_pointer = DAT_structure_address + 0x11;\\n  short* short_PTR_1 = (short*)(DAT_structure_address + 0x134);\\n  *short_PTR_1 = 0;\\n  short* short_PTR_2 = (short*)(DAT_structure_address + 0x136);\\n  *short_PTR_2 = 0;\\n  int* int_pointer = (int*)(DAT_structure_address + 0x138);\\n  *int_pointer = DAT_structure_address + 0x51;\\n  short* short_PTR_3 = (short*)(DAT_structure_address + 0x13c);\\n  *short_PTR_3 = 0;\\n  short* short_PTR_4 = (short*)(DAT_structure_address + 0x13e);\\n  *short_PTR_4 = 0;\\n}\\n",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008c20",
        "calling": [
            "FUN_08008d30"
        ],
        "current_name": "initialize_data_structures_08008c20"
    },
    "FUN_08000a64": {
        "renaming": {
            "FUN_08000a64": "check_for_skipped_chars_08000a64",
            "iVar1": "find_index",
            "uVar2": "index",
            "char_value": "skip_char",
            "PTR_DAT_08000ad8": "char_array",
            "PTR_DAT_08000adc": "compare_value_1",
            "PTR_DAT_08000ae0": "compare_value_2",
            "FUNC_080005f8": "skip_char_function",
            "PTR_DAT_08000ae4": "flag_pointer",
            "initialize_data_08002a26": "initialize_data",
            "PTR_DAT_08000ae8": "data_pointer"
        },
        "code": "void check_for_skipped_chars_08000a64()\n{\n  int index = 0;\n  uint8_t char_value = 0;\n  for (index = 0; index < 0x3c; index++) {\n    if (PTR_DAT_08000ad8[index] == -1) {\n      char_value = 0;\n    }\n    else {\n      int find_index = find_char_index_080036ac((int)(char)PTR_DAT_08000ad8[index]);\n      if (find_index == 0) {\n        char_value = 0;\n      }\n      else if (find_index == 1) {\n        char_value = 0;\n      }\n      else {\n        int PTR_DAT_08000adc = compare_values_0800738a((int)(char)PTR_DAT_08000ad8[index],PTR_DAT_08000adc);\n        if (PTR_DAT_08000adc == 0) {\n          int PTR_DAT_08000ae0 = compare_values_0800738a((int)(char)PTR_DAT_08000ad8[index],PTR_DAT_08000ae0);\n          if (PTR_DAT_08000ae0 == 0) {\n            char_value = 0;\n          }\n        }\n      }\n    }\n    if (char_value != 0) {\n      FUNC_080005f8(index,6);\n    }\n  }\n  *PTR_DAT_08000ae4 = 1;\n  initialize_data_08002a26(PTR_DAT_08000ae8);\n}\n",
        "called": [
            "FUN_080005f8",
            "FUN_08002a26",
            "FUN_080036ac",
            "FUN_0800738a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000a64",
        "calling": [
            "FUN_08001cd0"
        ],
        "current_name": "check_for_skipped_chars_08000a64"
    },
    "FUN_0800723c": {
        "renaming": {
            "FUN_0800723c": "get_pointer_value_and_return_0800723c",
            "get_pointer_value_08003760": "get_pointer_value"
        },
        "code": "void get_pointer_value_and_return_0800723c(void)\n{\n  // Call function to get pointer value\n  get_pointer_value_08003760();\n  return;\n}",
        "called": [
            "FUN_08003760"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800723c",
        "calling": [
            "FUN_08008abc"
        ],
        "current_name": "get_pointer_value_and_return_0800723c"
    },
    "FUN_080043a2": {
        "renaming": {
            "FUN_080043a2": "set_flags_based_on_conditions_080043a2",
            "param_1": "ptr_array",
            "puVar1": "flag_ptr",
            "uint": "uint32_t",
            "undefined4": "uint32_t",
            "PTR_": "ptr_",
            "DAT_": "data_"
        },
        "code": "uint32_t set_flags_based_on_conditions_080043a2(uint32_t **PTR_array) {\n  uint32_t *flag_ptr;\n  flag_ptr = PTR_array[11];\n  if ((*(char *)((int)PTR_array + 0x3d) == '\"') && ((PTR_array[20] != (uint32_t *)0x0 || (*(char *)((int)PTR_array + 0x3e) != '@')))) {\n    if ((PTR_array[20] == (uint32_t *)0x0) && (PTR_array[4] == (uint32_t *)0xc000)) {\n      **PTR_array = **PTR_array | 0x100;\n      PTR_array[20] = (uint32_t *)((int)PTR_array[20] + 1);\n    }\n    else {\n      if (*(short *)((int)PTR_array + 0x2a) == 0) {\n        **PTR_array = **PTR_array | 0x200;\n      }\n      else if (*(short *)((int)PTR_array + 0x2a) == 1) {\n        if (flag_ptr == (uint32_t *)0xffff0000) {\n          **PTR_array = **PTR_array & 0xfffffbff;\n          flag_ptr = *PTR_array;\n          if ((flag_ptr[1] & 0x800) == 0) {\n            *flag_ptr = *flag_ptr | 0x200;\n          }\n          else {\n            *flag_ptr = *flag_ptr & 0xfffffbff;\n          }\n        }\n        else if (((flag_ptr == (uint32_t *)0x4) || (flag_ptr == (uint32_t *)0x8)) || (PTR_array[12] == (uint32_t *)0x12)) {\n          **PTR_array = **PTR_array & 0xfffffbff;\n          **PTR_array = **PTR_array | 0x200;\n        }\n        else if (PTR_array[11] == (uint32_t *)0x2) {\n          **PTR_array = **PTR_array | 0x400;\n        }\n        else {\n          **PTR_array = **PTR_array & 0xfffffbff;\n        }\n      }\n      else if (*(short *)((int)PTR_array + 0x2a) == 2) {\n        if (PTR_array[11] == (uint32_t *)0x2) {\n          **PTR_array = **PTR_array | 0x400;\n        }\n        else {\n          **PTR_array = **PTR_array | 0x800;\n          **PTR_array = **PTR_array & 0xfffffbff;\n        }\n        flag_ptr = *PTR_array;\n        if ((flag_ptr[1] & 0x800) != 0) {\n          flag_ptr[1] = flag_ptr[1] | 0x1000;\n        }\n      }\n      else {\n        **PTR_array = **PTR_array | 0x400;\n        flag_ptr = *PTR_array;\n        if ((flag_ptr[1] & 0x800) != 0) {\n          flag_ptr[1] = flag_ptr[1] | 0x1000;\n        }\n      }\n      PTR_array[20] = (uint32_t *)0x0;\n    }\n  }\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080043a2",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "set_flags_based_on_conditions_080043a2"
    },
    "FUN_0800694c": {
        "renaming": {
            "FUN_0800694c": "process_input_string_0800694c",
            "param_1": "input_array",
            "pbVar1": "byte_pointer",
            "sVar2": "remaining_input_length",
            "puVar3": "undefined_pointer"
        },
        "code": "int process_input_string_0800694c(int *input_array)\n{\n  byte *byte_pointer;\n  short remaining_input_length;\n  undefined *undefined_pointer;\n\n  if (*(char *)((int)input_array + 0x3a) != '\"') {\n    return 2;\n  }\n  if (input_array[2] == 0x1000) {\n    if (input_array[4] == 0) {\n      *(ushort *)input_array[10] = (ushort)((uint)(*(int *)(*input_array + 4) << 0x17) >> 0x17);\n      input_array[10] = input_array[10] + 2;\n    }\n    else {\n      *(ushort *)input_array[10] = (ushort)*(undefined4 *)(*input_array + 4) & 0xff;\n      input_array[10] = input_array[10] + 1;\n    }\n  }\n  else if (input_array[4] == 0) {\n    undefined_pointer = (undefined *)input_array[10];\n    input_array[10] = (int)(undefined_pointer + 1);\n    *undefined_pointer = (char)*(undefined4 *)(*input_array + 4);\n  }\n  else {\n    byte_pointer = (byte *)input_array[10];\n    input_array[10] = (int)(byte_pointer + 1);\n    *byte_pointer = (byte)*(undefined4 *)(*input_array + 4) & 0x7f;\n  }\n  remaining_input_length = *(short *)((int)input_array + 0x2e) + -1;\n  *(short *)((int)input_array + 0x2e) = remaining_input_length;\n  if (remaining_input_length != 0) {\n    return 0;\n  }\n  *(uint *)(*input_array + 0xc) &= 0xffffffdf;\n  *(uint *)(*input_array + 0xc) &= 0xfffffeff;\n  *(uint *)(*input_array + 0x14) &= 0xfffffffe;\n  *(undefined *)((int)input_array + 0x3a) = 0x20;\n  execute_operation_0800870c();\n  return 0;\n}",
        "called": [
            "FUN_0800870c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800694c",
        "calling": [
            "FUN_080069ec"
        ],
        "current_name": "process_input_string_0800694c"
    },
    "FUN_08006280": {
        "renaming": {
            "FUN_08006280": "set_bit_and_update_flags_08006280",
            "param_1": "data",
            "param_2": "bit_index",
            "puVar1": "data_ptr"
        },
        "code": "int set_bit_and_update_flags_08006280(uint **data, uint bit_index) {\n  uint *data_ptr = *data;\n  switch(bit_index) {\n    case 0:\n      data_ptr[3] |= 2;\n      break;\n    case 4:\n      data_ptr[3] |= 4;\n      break;\n    case 8:\n      data_ptr[3] |= 8;\n      break;\n    case 0xc:\n      data_ptr[3] |= 0x10;\n  }\n  set_bit_at_index(data_ptr, bit_index);\n  if (data_ptr == PTR_080062f0) {\n    data_ptr[0x11] |= 0x8000;\n  }\n  **data = **data | 1;\n  return 0;\n}",
        "called": [
            "FUN_08006262"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006280",
        "calling": [
            "FUN_08007648"
        ],
        "current_name": "set_bit_and_update_flags_08006280"
    },
    "FUN_08007258": {
        "renaming": {
            "FUN_08007258": "set_flag_and_update_data_08007258",
            "param_1": "flag_value",
            "param_2": "data_1",
            "param_3": "data_2",
            "uVar1": "flag",
            "local_20": "bit_mask",
            "local_1c": "data_4",
            "local_18": "data_5",
            "local_14": "data_3",
            "DAT_080072d0": "data_ptr_1",
            "DAT_080072d4": "data_ptr_2",
            "FUNC_080040e8": "skipped_function"
        },
        "code": "void set_flag_and_update_data_08007258(uint8_t flag_value, uint32_t data_1, uint32_t data_2) {\n  uint32_t flag = set_flag(flag_value);\n  uint16_t bit_mask = 1 << (data_1 & 0xf) & 0xffff;\n  uint32_t data_3 = 3;\n  *(uint32_t *)(DAT_080072d0 + 0x18) = *(uint32_t *)(DAT_080072d0 + 0x18) | 1;\n  if ((data_1 - 0xd & 0xff) < 2) {\n    *(uint32_t *)(DAT_080072d4 + 4) = *(uint32_t *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x4000000;\n  }\n  if (((data_1 == 0xf) || (data_1 == 0x13)) || (data_1 == 0x14)) {\n    *(uint32_t *)(DAT_080072d4 + 4) = *(uint32_t *)(DAT_080072d4 + 4) & 0xf8ffffff | 0x2000000;\n  }\n  uint32_t data_4 = data_2;\n  uint32_t data_5 = data_3;\n  FUNC_080040e8(flag, &bit_mask);\n  return;\n}",
        "called": [
            "FUN_080040e8",
            "FUN_08006bb8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007258",
        "calling": [
            "FUN_08008990"
        ],
        "current_name": "set_flag_and_update_data_08007258"
    },
    "FUN_0800a0ec": {
        "renaming": {
            "FUN_0800a0ec": "set_permission_and_copy_data_0800a0ec",
            "param_1": "result",
            "param_2": "addr",
            "param_3": "len",
            "param_4": "prot",
            "puVar1": "data_copy",
            "iVar2": "set_mem_perm_res"
        },
        "code": "void set_permission_and_copy_data_0800a0ec(int *result, void *addr, size_t len, int prot, off_t offset)\n{\n  void *data_copy = NULL;\n  int set_mem_perm_res;\n\n  data_copy = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  if (data_copy == MAP_FAILED) {\n    return;\n  }\n  memcpy(data_copy, addr, len);\n  set_mem_perm_res = mprotect(data_copy, len, prot);\n  if (set_mem_perm_res == -1) {\n    if (result != NULL && *result != 0) {\n      *result = *(int *)PTR_DAT_0800a10c;\n    }\n  }\n  else {\n    *result = (int)data_copy + offset;\n  }\n  return;\n}",
        "called": [
            "FUN_08008846"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a0ec",
        "calling": [
            "FUN_08009e64"
        ],
        "current_name": "set_permission_and_copy_data_0800a0ec"
    },
    "FUN_08008df8": {
        "renaming": {
            "FUN_08008df8": "set_data_in_memory_08008df8",
            "param_1": "memory_address",
            "param_2": "data_byte_1",
            "param_3": "data_byte_2",
            "param_4": "data_byte_3",
            "param_5": "data_byte_4"
        },
        "code": "void set_data_in_memory_08008df8(undefined4 *memory_address, undefined data_byte_1, undefined data_byte_2, undefined data_byte_3, undefined data_byte_4)\n{\n  *memory_address = PTR_PTR_LAB_08008dbe_1_08008e10;\n  *(undefined *)(memory_address + 1) = data_byte_1;\n  *(undefined *)((int)memory_address + 5) = data_byte_2;\n  *(undefined *)((int)memory_address + 6) = data_byte_3;\n  *(undefined *)((int)memory_address + 7) = data_byte_4;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008df8",
        "calling": [
            "FUN_08008e14"
        ],
        "current_name": "set_data_in_memory_08008df8"
    },
    "FUN_08009f4a": {
        "renaming": {
            "FUN_08009f4a": "do_nothing_08009f4a"
        },
        "code": "void do_nothing_08009f4a(void) {\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009f4a",
        "calling": [
            "FUN_08009270",
            "FUN_080091d8"
        ],
        "current_name": "do_nothing_08009f4a"
    },
    "FUN_08006c7c": {
        "renaming": {
            "FUN_08006c7c": "find_parameter_value_08006c7c",
            "param_1": "param_value",
            "param_2": "param_list",
            "param_3": "list_size",
            "param_4": "default_value1",
            "<unnamed>": "default_value2",
            "iVar1": "index",
            "uVar2": "shift_amount"
        },
        "code": "int find_parameter_value_08006c7c(int param_value, int* param_list, int list_size, int default_value1, int default_value2) {\n  int index = find_param_index(param_value, param_list, list_size, default_value1, default_value2);\n  uint shift_amount = (uint)(index << 0xc) >> 0x1b;\n  if (shift_amount == 3) {\n    return 8;\n  }\n  if (shift_amount != 4) {\n    if (shift_amount != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}",
        "called": [
            "FUN_08007376"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006c7c",
        "calling": [
            "FUN_08007118",
            "FUN_080071e4"
        ],
        "current_name": "find_parameter_value_08006c7c"
    },
    "FUN_08006b5c": {
        "renaming": {
            "FUN_08006b5c": "update_bit_08006b5c",
            "param_1": "bit_position",
            "param_2": "bit_array",
            "uVar1": "array_index",
            "PTR_": "",
            "DAT_": ""
        },
        "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ update_bit_08006b5c(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_,DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_<DAT_PDAT_TDAT_RDAT__DAT_<DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_8DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_>DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_kDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_~DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_<DAT_PDAT_TDAT_RDAT__DAT_<DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_kDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006b5c",
        "calling": [
            "FUN_08008990"
        ],
        "current_name": "update_bit_08006b5c"
    },
    "FUN_08007376": {
        "renaming": {
            "FUN_08007376": "find_param_08007376",
            "param_1": "param_index",
            "uVar1": "param_value",
            "find_param_in_array_0800735a": "find_param_in_array"
        },
        "code": "int find_param_08007376(int param_index) {\n  int param_value;\n  if (param_index == -1) {\n    return -1;\n  }\n  param_value = find_param_08007376_in_array_0800735a();\n  return param_value;\n}",
        "called": [
            "FUN_0800735a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007376",
        "calling": [
            "FUN_08006e68",
            "FUN_08007118",
            "FUN_08006c60",
            "FUN_080071e4",
            "FUN_08006c7c",
            "FUN_08008078",
            "FUN_080077b0"
        ],
        "current_name": "find_param_08007376"
    },
    "FUN_08000188": {
        "renaming": {
            "FUN_08000188": "interruptSoftwareCall_08000188"
        },
        "code": "void interruptSoftwareCall_08000188(void)\n{\n  software_interrupt(0x3f);\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000188",
        "calling": [
            "FUN_0800018c"
        ],
        "current_name": "interruptSoftwareCall_08000188"
    },
    "FUN_08004f3c": {
        "renaming": {
            "FUN_08004f3c": "execute_param_08004f3c",
            "param_1": "param",
            "iVar1": "value",
            "puVar2": "ptr1",
            "puVar3": "ptr2"
        },
        "code": "void execute_param_08004f3c(uint **param)\\n{\\n  int value;\\n  uint *ptr1;\\n  uint *ptr2;\\n  \\n  if (*(byte *)((int)param + 0x3d) - 0x29 < 2)) {\\n    param[0xc] = NULL;\\n    *(undefined *)((int)param + 0x3d) = 0x28;\\n  }\\n  else {\\n    if ((*(char *)((int)param + 0x3d) != '`') && (((*param)[1] & 0x800) == 0)) {\\n      *(undefined *)((int)param + 0x3d) = 0x20;\\n    }\\n    param[0xc] = NULL;\\n    *(undefined *)((int)param + 0x3e) = 0;\\n  }\\n  **param = **param & 0xfffff7ff;\\n  ptr2 = *param;\\n  if ((ptr2[1] & 0x800) == 0) {\\n    if (*(char *)((int)param + 0x3d) == '`') {\\n      *(undefined *)((int)param + 0x3d) = 0x20;\\n      param[0x10] = NULL;\\n      if ((ptr2[5] & 0x40) != 0) {\\n        ptr1 = param[9];\\n        param[9] = (uint *)((int)ptr1 + 1);\\n        *(char *)ptr1 = (char)ptr2[4];\\n      }\\n      **param = **param & 0xfffffffe;\\n      doNothing(param);\\n    }\\n    else {\\n      if ((ptr2[5] & 0x40) != 0) {\\n        ptr1 = param[9];\\n        param[9] = (uint *)((int)ptr1 + 1);\\n        *(char *)ptr1 = (char)ptr2[4];\\n      }\\n      check_and_set_values_for_input(param);\\n    }\\n  }\\n  else {\\n    ptr2[1] = ptr2[1] & 0xfffff7ff;\\n    if (*(char *)((int)param[0xd] + 0x21) == '\\x01') {\\n      param[0xe][0xd] = (uint)PTR_LAB_080053cc_1_0800507c;\\n      value = get_value_from_pointer(param[0xe]);\\n      if (value != 0) {\\n        if (((*param)[5] & 0x40) != 0) {\\n          ptr2 = param[9];\\n          param[9] = (uint *)((int)ptr2 + 1);\\n          *(char *)ptr2 = (char)(*param)[4];\\n        }\\n        **param = **param & 0xfffffffe;\\n        *(undefined *)((int)param + 0x3d) = 0x20;\\n        (*(code *)param[0xe][0xd])();\\n      }\\n    }\\n    else {\\n      param[0xd][0xd] = (uint)PTR_LAB_080053cc_1_0800507c;\\n      value = get_value_from_pointer(param[0xd]);\\n      if (value != 0) {\\n        **param = **param & 0xfffffffe;\\n        *(undefined *)((int)param + 0x3d) = 0x20;\\n        (*(code *)param[0xd][0xd])();\\n      }\\n    }\\n  }\\n  if ((*(char *)((int)param + 0x3d) == '(') && (((uint)param[0x10] & 4) != 0)) {\\n    param[0xb] = DAT_08005080;\\n    param[0xc] = NULL;\\n    *(undefined *)((int)param + 0x3d) = 0x20;\\n    *(undefined *)((int)param + 0x3e) = 0;\\n    execute_command_and_update_values(param);\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08008020",
            "FUN_08004050",
            "FUN_08004f3a",
            "FUN_08007ff0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004f3c",
        "calling": [
            "FUN_08005084",
            "FUN_080052f0"
        ],
        "current_name": "execute_param_08004f3c"
    },
    "FUN_080033cc": {
        "renaming": {
            "FUN_080033cc": "process_input_080033cc",
            "param_1": "input_ptr",
            "param_2": "arg1",
            "param_3": "arg2",
            "param_4": "arg3",
            "cVar1": "first_char",
            "iVar2": "shifted_bits",
            "pcVar3": "input_str"
        },
        "code": "void process_input_080033cc(int input_ptr, uint arg1, uint arg2, uint arg3)\n{\n  char first_char = *(char *)(input_ptr + 4);\n  char *input_str = *(char **)(input_ptr + 4);\n  if (first_char == 'q') {\n    if (*(int *)(input_ptr + 0x68) != 0) {\n      int shifted_bits = copy_and_shift_bits(input_ptr, *(int *)(input_ptr + 0x18) - 1, input_str + 1, input_str, arg3);\n      process_input_080033cc_08003376(input_ptr, 0, shifted_bits + 1);\n      (**(void (**)(void))(input_ptr + 0x68))(*(uint *)(input_ptr + 0x40), *(int *)(input_ptr + 4) + 1);\n      return;\n    }\n  }\n  else if (first_char == 'y') {\n    if (*(void (**)(void))(input_ptr + 0x70) != (void (*)(void))0x0) {\n      if (*(uint *)(input_ptr + 0x18) < 3) {\n        (**(void (**)(void))(input_ptr + 0x70))(*(uint *)(input_ptr + 0x34), 0, 0);\n        return;\n      }\n      int shifted_bits = copy_and_shift_bits(input_ptr, *(uint *)(input_ptr + 0x18) - 3, input_str + 3, input_str, arg3);\n      process_input_080033cc_08003376(input_ptr, 0, shifted_bits + 3);\n      int input_ptr_4 = *(int *)(input_ptr + 4);\n      (**(void (**)(void))(input_ptr + 0x70))(*(uint *)(input_ptr + 0x34), *(char *)(input_ptr_4 + 1), *(char *)(input_ptr_4 + 2), input_ptr_4 + 3);\n      return;\n    }\n  }\n  else if (*(void (**)(void))(input_ptr + 0x6c) != (void (*)(void))0x0) {\n    (**(void (**)(void))(input_ptr + 0x6c))(*(uint *)(input_ptr + 0x44), first_char, *(int *)(input_ptr + 0x18) - 1, input_str + 1);\n  }\n  return;\n}",
        "called": [
            "FUN_080033a8",
            "FUN_08003376"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080033cc",
        "calling": [
            "FUN_08003474"
        ],
        "current_name": "process_input_080033cc"
    },
    "FUN_08003de4": {
        "renaming": {
            "FUN_08003de4": "check_if_pointer_is_valid_08003de4",
            "param_1": "input_ptr",
            "iVar1": "is_valid",
            "is_pointer_valid": "is_pointer_valid"
        },
        "code": "int check_if_pointer_is_valid_08003de4(int input_ptr)\\n{\\n  int is_valid = 0;\\n  char is_pointer_valid = *(char *)(input_ptr + 0x24);\\n  if (is_pointer_valid == '\\x01') {\\n    is_valid = 2;\\n  }\\n  else {\\n    *(char *)(input_ptr + 0x24) = '\\x01';\\n    is_valid = check_if_pointer_is_valid_08003de4_08003b8c();\\n    *(uint *)(input_ptr + 0x28) = (*(uint *)(input_ptr + 0x28) & 0xffffeefe) | 1;\\n    *(char *)(input_ptr + 0x24) = 0;\\n  }\\n  return is_valid;\\n}",
        "called": [
            "FUN_08003b8c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003de4",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "check_if_pointer_is_valid_08003de4"
    },
    "FUN_08004f3a": {
        "renaming": {
            "FUN_08004f3a": "doNothing_08004f3a"
        },
        "code": "void doNothing_08004f3a(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004f3a",
        "calling": [
            "FUN_08004f3c"
        ],
        "current_name": "doNothing_08004f3a"
    },
    "FUN_08000500": {
        "renaming": {
            "FUN_08000500": "process_servo_data_08000500",
            "param_1": "servo_index",
            "param_2": "input_type",
            "param_3": "input_value",
            "param_4": "param_4",
            "bVar1": "servo_count",
            "bVar2": "last_servo_index",
            "PTR_DAT_0800056c": "servo_count_ptr",
            "PTR_DAT_08000570": "last_servo_index_ptr",
            "PTR_DAT_08000578": "servo_array",
            "PTR_DAT_08000574": "unknown_array",
            "PTR_DAT_0800057c": "input_array"
        },
        "code": "void process_servo_data_08000500(int servo_index, int input_type, int input_value, undefined4 param_4)\n{\n  byte servo_count = *PTR_DAT_0800056c;\n  if (servo_count > 11) {\n    process_data_and_return_result(PTR_DAT_08000584,PTR_s_Max_servos_attached_08000580,input_value,param_4,param_4);\n    return;\n  }\n  byte last_servo_index = *PTR_DAT_08000570;\n  if (last_servo_index == 0) {\n    PTR_DAT_08000578[servo_index] = servo_count;\n    *PTR_DAT_0800056c = servo_count + 1;\n  }\n  else {\n    PTR_DAT_08000578[servo_index] = last_servo_index - 1;\n    *PTR_DAT_08000570 = last_servo_index - 1;\n  }\n  if ((input_type > 0) && (input_value > 0)) {\n    process_input(PTR_DAT_0800057c + (uint)(byte)PTR_DAT_08000578[servo_index] * 3,servo_index,input_type,input_value);\n    return;\n  }\n  process_input_with_params(PTR_DAT_0800057c + (uint)(byte)PTR_DAT_08000578[servo_index] * 3,servo_index);\n  return;\n}",
        "called": [
            "FUN_08002634",
            "FUN_08002f14",
            "FUN_080025ac"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000500",
        "calling": [
            "FUN_080005f8",
            "FUN_08001cd0"
        ],
        "current_name": "process_servo_data_08000500"
    },
    "FUN_08009d24": {
        "renaming": {
            "FUN_08009d24": "allocate_and_initialize_block_08009d24",
            "param_1": "block_size",
            "param_2": "num_elements",
            "puVar1": "block_ptr",
            "iVar2": "total_size",
            "allocate_memory_block_08009270": "allocate_memory_block",
            "fill_memory_with_value_080091c6": "fill_memory_with_zero"
        },
        "code": "undefined4* allocate_and_initialize_block_08009d24(int block_size, int num_elements) {\n  undefined4* block_ptr;\n  int total_size = (num_elements - 1) * 0x68;\n  block_ptr = (undefined4*)allocate_memory_block(block_size, total_size + 0x74);\n  if (block_ptr != (undefined4*)0x0) {\n    *block_ptr = 0;\n    block_ptr[1] = num_elements;\n    block_ptr[2] = block_ptr + 3;\n    fill_memory_with_value_080091c6(block_ptr + 3, total_size + 0x68);\n  }\n  return block_ptr;\n}",
        "called": [
            "FUN_08009270",
            "FUN_080091c6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009d24",
        "calling": [
            "FUN_08009db0"
        ],
        "current_name": "allocate_and_initialize_block_08009d24"
    },
    "FUN_0800344a": {
        "renaming": {
            "FUN_0800344a": "initialize_data_structures_0800344a",
            "param_1": "data_structure_address",
            "uVar1": "index"
        },
        "code": "void initialize_data_structures_0800344a(int data_structure_address) {\n  uint index = 0;\n  *(undefined4 *)(data_structure_address + 0x10) = 0;\n  *(undefined *)(data_structure_address + 0xc) = 0;\n  *(undefined *)(data_structure_address + 0xd) = 0;\n  for (index = 0; index < *(uint *)(data_structure_address + 8); index++) {\n    *(undefined *)(*(int *)(data_structure_address + 4) + index) = 0;\n  }\n  *(undefined *)(data_structure_address + 0x14) = 0;\n  *(undefined4 *)(data_structure_address + 0x18) = 0;\n  if (*(code **)(data_structure_address + 0x78) != (code *)0x0) {\n    (**(code **)(data_structure_address + 0x78))(*(undefined4 *)(data_structure_address + 0x48));\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800344a",
        "calling": [
            "FUN_08003474"
        ],
        "current_name": "initialize_data_structures_0800344a"
    },
    "FUN_080071e4": {
        "renaming": {
            "FUN_080071e4": "check_and_update_flags_080071e4",
            "param_1": "param",
            "local_50": "parameter_value",
            "get_parameter_value_08007320": "get_parameter_value",
            "PTR_DAT_08007238": "parameter_ptr",
            "find_parameter_value_08006c7c": "find_parameter_value",
            "is_valid_parameter_value": "is_valid_parameter_value",
            "find_param_08007376": "find_flag_value",
            "update_flags_if_needed_080063c0": "update_flags_if_needed",
            "clearBitAndCheckForUpdates_08006460": "clear_bit_and_check_for_updates",
            "clearFlagsIfConditionsMet_08005e2e": "clear_flags_if_conditions_met"
        },
        "code": "void check_and_update_flags_080071e4(uint32_t param) {\n  int parameter_value = get_parameter_value_08007320(param, PTR_DAT_08007238);\n  if ((parameter_value != 0) && is_valid_parameter_value(param)) {\n    uint32_t flag_value = find_param_08007376(param, PTR_DAT_08007238);\n    if ((flag_value & 0x100000) == 0) {\n      update_flags_if_needed_080063c0(parameter_value, parameter_type);\n    }\n    else {\n      clear_bit_and_check_for_updates(parameter_value, parameter_type);\n    }\n    clear_flags_if_conditions_met(parameter_value);\n  }\n  return;\n}",
        "called": [
            "FUN_08007376",
            "FUN_08005e2e",
            "FUN_080063c0",
            "FUN_08006c7c",
            "FUN_08006460",
            "FUN_08007320"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080071e4",
        "calling": [
            "FUN_08008990"
        ],
        "current_name": "check_and_update_flags_080071e4"
    },
    "FUN_08008e72": {
        "renaming": {
            "FUN_08008e72": "execute_function_pointer_08008e72",
            "param_1": "function_pointer"
        },
        "code": "void execute_function_pointer_08008e72(void *function_pointer) {\n  (**(void (**)(void))function_pointer)();\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008e72",
        "calling": [],
        "current_name": "execute_function_pointer_08008e72"
    },
    "FUN_080022f8": {
        "renaming": {
            "FUN_080022f8": "process_device_data_080022f8",
            "iVar2": "char_value",
            "uVar3": "device_parameter",
            "uVar4": "i",
            "uVar5": "char_index",
            "PTR_DAT_080023e0": "device_data_pointer",
            "PTR_DAT_080023e4": "device_data_value_pointer",
            "PTR_DAT_080023e8": "device_data_start_pointer",
            "PTR_DAT_080023ec": "device_data_size_pointer",
            "PTR_DAT_080023f0": "valid_chars",
            "PTR_DAT_080023f4": "char_array",
            "PTR_DAT_080023f8": "input_data_count_pointer",
            "PTR_DAT_080023fc": "input_data_array",
            "puVar1": "is_valid_char",
            "iVar3": "input_data_offset"
        },
        "code": "void process_device_data_080022f8(void)\n{\n  bool is_valid_char;\n  int char_index;\n  int device_parameter;\n  int input_data_length;\n  int expected_output_length;\n  uint32_t input_data;\n  uint32_t PTR_DAT_080023e0 = get_PTR_DAT_080023e0();\n  while (execute_function(PTR_DAT_080023e0) != 0) {\n    execute_code(PTR_DAT_080023e0);\n  }\n  int device_data_value = get_pointer_value_and_return();\n  *(int *)PTR_DAT_080023e0 = device_data_value;\n  if (*(uint *)(PTR_DAT_080023e0 + 4) < (uint)(device_data_value - *(int *)(PTR_DAT_080023e0 + 8))) {\n    *(uint *)(PTR_DAT_080023e0 + 8) = *(int *)(PTR_DAT_080023e0 + 8) + *(uint *)(PTR_DAT_080023e0 + 12);\n    for (uint i = 0; i < 0x3c; i++) {\n      if (i < 0xe) {\n        int char_value = -1;\n        if (i < 0x3c) {\n          char_value = (int)(char)PTR_DAT_080023f4[i];\n        }\n        char_index = find_char_index(char_value);\n        if (char_index == 0) {\n          is_valid_char = false;\n        }\n        else if (char_index == 1) {\n          is_valid_char = false;\n        }\n        else if (get_value_at_offset(PTR_DAT_080023e0, i) == 2) {\n          is_valid_char = true;\n        }\n        else {\n          is_valid_char = false;\n        }\n      }\n      else {\n        is_valid_char = false;\n      }\n      if (is_valid_char && ((*(int *)(PTR_DAT_080023e0 + 16) >> (i - 0x2e) & 1U) != 0)) {\n        device_parameter = get_device_parameter(i);\n        send_data(PTR_DAT_080023e0, i, device_parameter);\n      }\n    }\n    if (-1 < (char)*PTR_DAT_080023f8) {\n      for (uint i = 0; (int)i < (char)*PTR_DAT_080023f8 + 1; i++) {\n        int input_data_offset = i * 0xc;\n        input_data_length = PTR_DAT_080023fc[input_data_offset + 4];\n        expected_output_length = PTR_DAT_080023fc[input_data_offset + 8];\n        input_data = PTR_DAT_080023fc[input_data_offset + 9];\n        process_input_data_and_return_result(PTR_DAT_080023e0, input_data_length, expected_output_length, input_data);\n      }\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_08008abc",
            "FUN_08008880",
            "FUN_08002ec4",
            "FUN_08002fa0",
            "FUN_08002ed2",
            "FUN_08001c18",
            "FUN_080036ac",
            "FUN_08000ef8",
            "FUN_08002ef2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080022f8",
        "calling": [
            "FUN_08008f1c"
        ],
        "current_name": "process_device_data_080022f8"
    },
    "FUN_080072fa": {
        "renaming": {
            "FUN_080072fa": "initialize_device_and_validate_input_080072fa"
        },
        "code": "void initialize_device_and_validate_input_080072fa(void)\\n{\\n  update_and_validate_input();\\n  initialize_device_settings();\\n  return;\\n}",
        "called": [
            "FUN_080035b8",
            "FUN_08003724"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080072fa",
        "calling": [
            "FUN_080036a2"
        ],
        "current_name": "initialize_device_and_validate_input_080072fa"
    },
    "FUN_08005084": {
        "renaming": {
            "FUN_08005084": "execute_command_08005084",
            "param_1": "command_data",
            "cVar1": "current_char",
            "puVar2": "command",
            "puVar3": "command_buffer"
        },
        "code": "uint execute_command_08005084(uint **command_data) {\n  char current_char = *(char *)((int)command_data + 0x3d);\n  (*command_data)[1] &= 0xfffff8ff;\n  **command_data |= 1;\n  **command_data &= 0xfffffbff;\n  uint *command = *command_data;\n  if ((command[1] & 0x800) != 0) {\n    if ((*(char *)((int)command_data + 0x3d) == '\"') || (*(char *)((int)command_data + 0x3d) == '*')) {\n      *(short *)((int)command_data + 0x2a) = (short)*(undefined4 *)(*command[0xe] + 4);\n    }\n    else {\n      *(short *)((int)command_data + 0x2a) = (short)*(undefined4 *)(*command[0xd] + 4);\n    }\n  }\n  if (*(short *)((int)command_data + 0x2a) != 0) {\n    if ((command[5] & 4) != 0) {\n      uint *command_buffer = command_data[9];\n      command_data[9] = (uint *)((int)command_buffer + 1);\n      *(char *)command_buffer = (char)command[4];\n      *(short *)((int)command_data + 0x2a) -= 1;\n    }\n    if (((*command_data)[5] & 0x40) != 0) {\n      uint *command_buffer = command_data[9];\n      command_data[9] = (uint *)((int)command_buffer + 1);\n      *(char *)command_buffer = (char)(*command_data)[4];\n      *(short *)((int)command_data + 0x2a) -= 1;\n    }\n    command_data[0x10] = (uint *)((uint)command_data[0x10] | 4);\n  }\n  if (command_data[0x10] == (uint *)0x0) {\n    if (((current_char == '(') || (current_char == '*')) || (current_char == ')')) {\n      command_data[0xb] = command_data[0x5184];\n      command_data[0xc] = (uint *)0x0;\n      *(undefined *)((int)command_data + 0x3d) = 0x20;\n      *(undefined *)((int)command_data + 0x3e) = 0;\n      execute_command_08005084_and_update_values();\n    }\n    else if ((command_data[0xc] == (uint *)0x22) || (current_char == '\"')) {\n      command_data[0xc] = (uint *)0x0;\n      *(undefined *)((int)command_data + 0x3d) = 0x20;\n      *(undefined *)((int)command_data + 0x3e) = 0;\n      do_nothing();\n    }\n  }\n  else {\n    execute_param();\n  }\n  return 0;\n}",
        "called": [
            "FUN_08004a74",
            "FUN_08007ff0",
            "FUN_08004f3c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005084",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "execute_command_08005084"
    },
    "FUN_0800291c": {
        "renaming": {
            "FUN_0800291c": "set_default_values_0800291c",
            "param_1": "params",
            "PTR_PTR_FUN_0800288c_1_08002940": "PTR_PTR_FUNC_A",
            "PTR_DAT_08002944": "PTR_DATA_A"
        },
        "code": "void set_default_values_0800291c(undefined4 *params) {\n  params[0] = PTR_PTR_copy_data_to_buffer_0800288c_1_08002940;\n  params[1] = 0;\n  params[2] = 1000;\n  *(undefined *)(params + 0x1b) = PTR_DAT_08002944[0xe];\n  *(undefined *)((int)params + 0x6d) = PTR_DAT_08002944[0xf];\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800291c",
        "calling": [
            "FUN_08002948"
        ],
        "current_name": "set_default_values_0800291c"
    },
    "FUN_08002ac0": {
        "renaming": {
            "FUN_08002ac0": "update_value_at_address_08002ac0",
            "param_1": "address",
            "param_2": "value",
            "param_3": "size",
            "param_4": "flags",
            "checkAndUpdateValue_08002a58": "check_and_update_value"
        },
        "code": "void update_value_at_address_08002ac0(uint32_t address, uint32_t value, uint32_t size, uint32_t flags) {\n  check_and_update_value(address, 1, size, value, flags);\n  return;\n}",
        "called": [
            "FUN_08002a58"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ac0",
        "calling": [
            "FUN_08001cd0"
        ],
        "current_name": "update_value_at_address_08002ac0"
    },
    "FUN_08003346": {
        "renaming": {
            "FUN_08003346": "update_params_if_valid_08003346",
            "param_1": "base_addr",
            "param_2": "param_value",
            "param_3": "new_param1",
            "param_4": "new_param2"
        },
        "code": "void update_params_if_valid_08003346(int base_addr, int param_value, undefined4 new_param1, undefined4 new_param2)\n{\n  if (param_value == 0x79) {\n    *(undefined4 *)(base_addr + 0x70) = new_param1;\n    *(undefined4 *)(base_addr + 0x34) = new_param2;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003346",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "update_params_if_valid_08003346"
    },
    "FUN_080032bc": {
        "renaming": {
            "FUN_080032bc": "initialize_data_structure_080032bc",
            "param_1": "data_structure",
            "param_2": "param_2",
            "param_3": "param_3",
            "uVar1": "leading_zeroes"
        },
        "code": "void initialize_data_structure_080032bc(int* data_structure, int param_2, int param_3) {\n  memset(data_structure, 0, 112);\n  int leading_zeroes = __builtin_clz(param_2);\n  data_structure[0] = (char)(leading_zeroes >> 5);\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080032bc",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "initialize_data_structure_080032bc"
    },
    "FUN_08003106": {
        "renaming": {
            "FUN_08003106": "encode_and_send_data_08003106",
            "param_1": "dataPtr",
            "param_2": "param_2",
            "param_3": "dataLength",
            "param_4": "param_4",
            "puVar1": "funcPtr"
        },
        "code": "void encode_and_send_data_08003106(undefined4 *dataPtr, undefined4 param_2, undefined4 dataLength, undefined4 param_4)\n{\n  undefined4 *funcPtr;\n  funcPtr = (undefined4 *)*dataPtr;\n  if (funcPtr != (undefined4 *)0x0) {\n    (**(code **)*funcPtr)(funcPtr,0xf0);\n    (***(code ***)(undefined4 *)*dataPtr)((undefined4 *)*dataPtr,0x6f);\n    (***(code ***)(undefined4 *)*dataPtr)((undefined4 *)*dataPtr,param_2);\n    encode_data_0800307a(dataPtr,dataLength,param_4,dataLength);\n    (***(code ***)(undefined4 *)*dataPtr)((undefined4 *)*dataPtr,0xf7);\n  }\n  return;\n}",
        "called": [
            "FUN_0800307a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003106",
        "calling": [
            "FUN_08003158"
        ],
        "current_name": "encode_and_send_data_08003106"
    },
    "FUN_080077b0": {
        "renaming": {
            "FUN_080077b0": "FUNC_080077b0"
        },
        "code": "\nvoid FUNC_080077b0(int *param_1,int param_2,int param_3,int param_4,undefined param_5)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  int *piVar9;\n  uint local_38;\n  uint local_34;\n  uint local_30;\n  undefined4 local_2c;\n  \n  if (param_1 != (int *)0x0) {\n    piVar9 = param_1 + 1;\n    iVar2 = get_parameter_value_08007320((int)*(char *)(param_1 + 0x16),PTR_DAT_08007a74);\n    iVar3 = get_parameter_value_08007320((int)*(char *)((int)param_1 + 0x59),PTR_DAT_08007a78);\n    if ((iVar2 == 0) || (iVar3 == 0)) {\n      initialize_and_call_function_080098d8(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      iVar3 = compare_and_return_080073ae(iVar2,iVar3);\n      *param_1 = iVar3;\n      iVar2 = DAT_08007a7c;\n      if (iVar3 == 0) {\n        initialize_and_call_function_080098d8(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (iVar3 == DAT_08007a7c) {\n          *(uint *)(DAT_08007a7c + 0x1bc1c) = *(uint *)(DAT_08007a7c + 0x1bc1c) | 0x200000;\n          *(uint *)(iVar2 + 0x1bc10) = *(uint *)(iVar2 + 0x1bc10) | 0x200000;\n          *(uint *)(iVar2 + 0x1bc10) = *(uint *)(iVar2 + 0x1bc10) & 0xffdfffff;\n          *(undefined *)((int)param_1 + 0x5a) = 0x1f;\n          *(undefined *)((int)param_1 + 0x5b) = 0x20;\n          *(int **)PTR_DAT_08007a90 = piVar9;\n        }\n        iVar2 = DAT_08007a80;\n        if (*param_1 == DAT_08007a80) {\n          *(uint *)(DAT_08007a80 + 0x1b81c) = *(uint *)(DAT_08007a80 + 0x1b81c) | 0x400000;\n          *(uint *)(iVar2 + 0x1b810) = *(uint *)(iVar2 + 0x1b810) | 0x400000;\n          *(uint *)(iVar2 + 0x1b810) = *(uint *)(iVar2 + 0x1b810) & 0xffbfffff;\n          *(undefined *)((int)param_1 + 0x5a) = 0x21;\n          *(undefined *)((int)param_1 + 0x5b) = 0x22;\n          *(int **)(PTR_DAT_08007a90 + 4) = piVar9;\n        }\n        uVar4 = set_flag_08006bb8((uint)((int)*(char *)((int)param_1 + 0x59) << 0x18) >> 0x1c);\n        puVar1 = PTR_DAT_08007a78;\n        local_38 = 1 << ((int)*(char *)((int)param_1 + 0x59) & 0xfU) & 0xffff;\n        uVar5 = find_param_08007376((int)*(char *)((int)param_1 + 0x59),PTR_DAT_08007a78);\n        uVar6 = find_param_08007376((int)*(char *)((int)param_1 + 0x59),puVar1);\n        local_34 = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        local_2c = 3;\n        iVar2 = find_param_08007376((int)*(char *)((int)param_1 + 0x59),puVar1);\n        local_30 = (uint)(iVar2 << 0x1a) >> 0x1e;\n        iVar3 = find_param_08007376((int)*(char *)((int)param_1 + 0x59),puVar1);\n        iVar2 = DAT_08007a84;\n        uVar7 = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        *(uint *)(DAT_08007a84 + 0x18) = uVar7;\n        uVar6 = DAT_08007d4c;\n        uVar5 = DAT_08007a94;\n        uVar8 = *(uint *)(iVar2 + 0x18) & 1;\n        switch((uint)(iVar3 << 0x11) >> 0x19) {\n        case 1:\n          uVar8 = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          *(uint *)(DAT_08007a94 + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 2:\n          uVar8 = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          *(uint *)(DAT_08007a94 + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 3:\n          uVar8 = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          *(uint *)(DAT_08007a94 + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 4:\n          uVar8 = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          *(uint *)(DAT_08007a94 + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 5:\n          uVar8 = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          *(uint *)(DAT_08007a94 + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 6:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 7:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 8:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 9:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 10:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xb:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xc:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xd:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xe:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xf:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x10:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x11:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x12:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x13:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x14:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x15:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x16:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x17:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x1b:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x1c:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x21:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x22:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x23:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x24:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar6;\n        }\n        FUNC_080040e8(uVar4,&local_38,uVar7,uVar8);\n        uVar4 = set_flag_08006bb8((uint)((int)*(char *)(param_1 + 0x16) << 0x18) >> 0x1c);\n        puVar1 = PTR_DAT_08007a74;\n        local_38 = 1 << ((int)*(char *)(param_1 + 0x16) & 0xfU) & 0xffff;\n        uVar5 = find_param_08007376((int)*(char *)(param_1 + 0x16),PTR_DAT_08007a74);\n        uVar6 = find_param_08007376((int)*(char *)(param_1 + 0x16),puVar1);\n        local_34 = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        local_2c = 3;\n        iVar2 = find_param_08007376((int)*(char *)(param_1 + 0x16),puVar1);\n        local_30 = (uint)(iVar2 << 0x1a) >> 0x1e;\n        iVar3 = find_param_08007376((int)*(char *)(param_1 + 0x16),puVar1);\n        iVar2 = DAT_08007a84;\n        uVar7 = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        *(uint *)(DAT_08007a84 + 0x18) = uVar7;\n        uVar6 = DAT_08007e70;\n        uVar5 = DAT_08007d4c;\n        uVar8 = *(uint *)(iVar2 + 0x18) & 1;\n        switch((uint)(iVar3 << 0x11) >> 0x19) {\n        case 1:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 2:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 3:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 4:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 5:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 6:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 7:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 8:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 9:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 10:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 0xb:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 0xc:\n          uVar8 = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          *(uint *)(DAT_08007d4c + 4) = uVar8;\n          uVar7 = uVar5;\n          break;\n        case 0xd:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xe:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0xf:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x10:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x11:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x12:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x13:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x14:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x15:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x16:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x17:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x1b:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x1c:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x21:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x22:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x23:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n          break;\n        case 0x24:\n          uVar8 = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n          *(uint *)(DAT_08007e70 + 4) = uVar8;\n          uVar7 = uVar6;\n        }\n        FUNC_080040e8(uVar4,&local_38,uVar7,uVar8);\n        param_1[1] = *param_1;\n        param_1[2] = param_2;\n        param_1[3] = 0;\n        param_1[4] = param_4;\n        param_1[7] = 0xff;\n        param_1[5] = param_3;\n        param_1[6] = 0;\n        param_1[8] = 0;\n        param_1[9] = 0;\n        *(undefined *)((int)param_1 + 0x41) = 0;\n        set_bits_08003f30((int)*(char *)((int)param_1 + 0x5a),0,1);\n        set_bit_at_index_08003f94((int)*(char *)((int)param_1 + 0x5a));\n        set_bits_08003f30((int)*(char *)((int)param_1 + 0x5b),0,1);\n        set_bit_at_index_08003f94((int)*(char *)((int)param_1 + 0x5b));\n        calculate_and_set_parameters_080045c0(piVar9);\n        *(undefined *)((int)param_1 + 0x5d) = param_5;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_080040e8",
            "FUN_08007376",
            "FUN_080045c0",
            "FUN_080098d8",
            "FUN_08003f94",
            "FUN_08006bb8",
            "FUN_08003f30",
            "FUN_080073ae",
            "FUN_08007320"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x080077b0",
        "calling": [
            "FUN_08002968"
        ],
        "current_name": "FUNC_080077b0"
    },
    "FUN_08007708": {
        "renaming": {
            "FUN_08007708": "set_flags_based_on_value_08007708"
        },
        "code": "void set_flags_based_on_value_08007708(void)\n{\n  // Set flags based on some value\n  return;\n}",
        "called": [
            "FUN_08007438"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007708",
        "calling": [
            "FUN_08006060"
        ],
        "current_name": "set_flags_based_on_value_08007708"
    },
    "FUN_0800018c": {
        "renaming": {
            "FUN_0800018c": "send_software_interrupt_0800018c",
            "param_1": "interrupt_number",
            "param_2": "parameter1",
            "param_3": "parameter2",
            "param_4": "parameter3",
            "uVar1": "interrupt_result"
        },
        "code": "int send_software_interrupt_0800018c(int interrupt_number, int parameter1, int parameter2, int parameter3, int parameter4)\n{\n  int interrupt_result;\n  if (*(int *)PTR_DAT_080001a4 != 0) {\n    return 0;\n  }\n  interrupt_result = software_interrupt_call_08000188(interrupt_number, parameter1, parameter2, parameter3, parameter4);\n  return interrupt_result;\n}",
        "called": [
            "FUN_08000188"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800018c",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "send_software_interrupt_0800018c"
    },
    "FUN_08003f94": {
        "renaming": {
            "FUN_08003f94": "set_bit_at_index_08003f94",
            "param_1": "index",
            "DAT_08003fac": "data_start_ptr"
        },
        "code": "void set_bit_at_index_08003f94(uint index) {\n  if (index >= 0) {\n    int* data_ptr = (int*)(DAT_08003fac + (index >> 5) * 4);\n    int bit_mask = 1 << (index & 0x1f);\n    *data_ptr = bit_mask;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003f94",
        "calling": [
            "FUN_08007648",
            "FUN_08008694",
            "FUN_0800863c",
            "FUN_080077b0"
        ],
        "current_name": "set_bit_at_index_08003f94"
    },
    "FUN_08008c44": {
        "renaming": {
            "FUN_08008c44": "process_assertion_08008c44",
            "param_1": "assertion_data",
            "param_2": "assertion_type",
            "param_3": "assertion_flags",
            "bVar1": "assertion_flag_3",
            "iVar2": "assertion_flag_2",
            "UNRECOVERED_JUMPTABLE": "jumptable"
        },
        "code": "void process_assertion_08008c44(int assertion_data, undefined4 assertion_type, byte assertion_flags) {\n  uint assertion_flag_3 = assertion_flags & 7;\n  int assertion_flag_2 = 0;\n  if (assertion_flag_3 == 4) {\n    assertion_flag_2 = 7;\n  }\n  else if (assertion_flag_3 == 6) {\n    assertion_flag_2 = 8;\n  }\n  else if (assertion_flag_3 == 2) {\n    assertion_flag_2 = 6;\n  }\n\n  if ((assertion_flags & 0x30) == 0x30) {\n    *(undefined4 *)(assertion_data + 0x128) = 0x600;\n    assertion_flag_2++;\n  }\n  else if ((assertion_flags & 0x20) == 0) {\n    *(undefined4 *)(assertion_data + 0x128) = 0;\n  }\n  else {\n    *(undefined4 *)(assertion_data + 0x128) = 0x400;\n    assertion_flag_2++;\n  }\n\n  if ((assertion_flags & 8) == 0) {\n    *(undefined4 *)(assertion_data + 0x124) = 0;\n  }\n  else {\n    *(undefined4 *)(assertion_data + 0x124) = 0x2000;\n  }\n\n  if (assertion_flag_2 == 8) {\n    *(undefined4 *)(assertion_data + 0x120) = 0;\n  }\n  else if (assertion_flag_2 == 9) {\n    *(undefined4 *)(assertion_data + 0x120) = 0x1000;\n  }\n\n  if (assertion_flag_2 != 0) {\n    initialize_data_structure(assertion_data + 0xd4);\n    add_combination_to_data_structure(assertion_data + 0xd4, uRam08008cf0);\n    return;\n  }\n\n  code *UNRECOVERED_JUMPTABLE = (code *)0x8008cee;\n  process_assertion_08008c44_data(uRam08008cfc,299,uRam08008cf8,uRam08008cf4);\n  if (extraout_r1 < 0x3c) {\n    uRam0000012d = PTR_DAT_08008d14[extraout_r1];\n  }\n  else {\n    uRam0000012d = 0xff;\n  }\n\n  (*UNRECOVERED_JUMPTABLE)(0,extraout_r1,&stack0x00000148);\n  return;\n}",
        "called": [
            "FUN_080090cc",
            "FUN_0800863c",
            "FUN_08008078"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008c44",
        "calling": [
            "FUN_08003048"
        ],
        "current_name": "process_assertion_08008c44"
    },
    "FUN_08002a26": {
        "renaming": {
            "FUN_08002a26": "initialize_data_08002a26",
            "param_1": "data_pointer",
            "param_2": "input_value",
            "param_3": "unused_param_3",
            "param_4": "unused_param_4",
            "initialize_data_08002a1c": "initialize_data",
            "iVar1": "memory_size",
            "iVar2": "index_offset",
            "is_special_case": "is_special_case",
            "PTR_DAT_080029ec": "flag_pointer",
            "PTR_DAT_080029f0": "reset_flag_pointer",
            "*(int *)PTR_DAT_080029f4": "memory_pointer",
            "memory_value": "memory_value",
            "PTR_DAT_080029f8": "memory_size_pointer",
            "PTR_DAT_080029fc": "flag_pointer_2",
            "PTR_DAT_08002a00": "reset_flag_pointer_2",
            "*(int *)PTR_DAT_08002a04": "memory_pointer_2",
            "PTR_DAT_08002a08": "memory_size_pointer_2",
            "PTR_DAT_08002a0c": "flag_pointer_3",
            "param_value": "param_value",
            "index_offset_value": "index_offset_value",
            "*(char *)(param_1 + 0x10)": "index_offset",
            "*(undefined *)(param_1 + 0x11)": "special_case_flag",
            "PTR_LAB_08002774_1_08002a14": "param_value",
            "PTR_LAB_08002b00_1_08002a18": "param_2_value",
            "fill_memory_with_value": "clear_and_initialize_data_08002968",
            "PTR_": "PTR_",
            "DAT_": "DAT_"
        },
        "code": "void initialize_data_08002a26(int data_pointer, uint8_t input_value)\n{\n  int memory_size = 0x4000;\n  int index_offset = data_pointer + 0x14;\n  uint8_t is_special_case = 0;\n  uint8_t *PTR_DAT_080029ec = PTR_DAT_080029ec;\n  uint8_t *PTR_DAT_080029f0 = PTR_DAT_080029f0;\n  int **(int *)PTR_DAT_080029f4 = *(int **)PTR_DAT_080029f4;\n  uint8_t memory_value = 0;\n  uint8_t *PTR_DAT_080029f8 = PTR_DAT_080029f8;\n  uint8_t *PTR_DAT_080029fc = PTR_DAT_080029fc;\n  uint8_t *PTR_DAT_08002a00 = PTR_DAT_08002a00;\n  int **(int *)PTR_DAT_08002a04 = *(int **)PTR_DAT_08002a04;\n  uint8_t *PTR_DAT_08002a08 = PTR_DAT_08002a08;\n  uint8_t *PTR_DAT_08002a0c = PTR_DAT_08002a0c;\n  uint8_t PTR_LAB_08002774_1_08002a14 = input_value & 0x7f;\n  uint8_t index_offset_value = PTR_LAB_08002774_1_08002a14 << 1;\n  *(char *)(data_pointer + 0x10) = index_offset_value;\n  *(undefined *)(data_pointer + 0x11) = (input_value == 0x33) ? 1 : 0;\n  if (*(char *)(data_pointer + 0x11) == 0) {\n    is_special_case = 1;\n  }\n  *PTR_DAT_080029ec = 0;\n  *PTR_DAT_080029f0 = 0;\n  if (**(int *)PTR_DAT_080029f4 != 0) {\n    clear_and_initialize_data_08002a26_08002968(**(int *)PTR_DAT_080029f4, memory_value, *PTR_DAT_080029f8);\n  }\n  *PTR_DAT_080029fc = 0;\n  *PTR_DAT_08002a00 = 0;\n  if (**(int *)PTR_DAT_08002a04 != 0) {\n    clear_and_initialize_data_08002a26_08002968(**(int *)PTR_DAT_08002a04, memory_value, *PTR_DAT_08002a08);\n  }\n  *PTR_DAT_08002a0c = 0;\n  clear_and_initialize_data_08002a26_08002968(index_offset, memory_value, memory_size, index_offset_value, *(undefined *)(data_pointer + 0x11));\n  if (is_special_case == 0) {\n    set_PTR_LAB_08002774_1_08002a14_if_not_null(index_offset, PTR_LAB_08002774_1_08002a14);\n    update_param_2_if_param_1_not_null(index_offset, PTR_LAB_08002b00_1_08002a18);\n  }\n}\n",
        "called": [
            "FUN_08002a1c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002a26",
        "calling": [
            "FUN_08000a64"
        ],
        "current_name": "initialize_data_08002a26"
    },
    "FUN_0800430c": {
        "renaming": {
            "FUN_0800430c": "set_flag_based_on_conditions_0800430c",
            "param_1": "ptr_param_1",
            "*(char *)((int)param_1 + 0x3e)": "*(char *)((int)ptr_param_1 + 0x3e)",
            "param_1[0x14]": "ptr_param_1[0x14]",
            "*(uint *)(*param_1 + 0x10)": "flag",
            "param_1[0x11]": "ptr_param_1[0x11]",
            "*(char *)((int)param_1 + 0x3d)": "*(char *)((int)ptr_param_1 + 0x3d)",
            "uint": "unsigned int",
            "&": "address of"
        },
        "code": "int set_flag_based_on_conditions_0800430c(int *ptr_param_1)\n{\n    int flag;\n    if (*(char *)((int)ptr_param_1 + 0x3e) == '@') {\n        if (ptr_param_1[0x14] == 0) {\n            flag = ptr_param_1[0x11] & 0xfe;\n        }\n        else {\n            flag = ptr_param_1[0x11] & 0xffU | 1;\n        }\n    }\n    else if (ptr_param_1[4] == 0x4000) {\n        if (*(char *)((int)ptr_param_1 + 0x3d) == '!') {\n            flag = ptr_param_1[0x11] & 0xfe;\n        }\n        else {\n            flag = ptr_param_1[0x11] & 0xffU | 1;\n        }\n    }\n    else if (ptr_param_1[0x14] == 0) {\n        flag = (uint)(ptr_param_1[0x11] << 0x10) >> 0x17 & 6 | 0xf0;\n    }\n    else if (ptr_param_1[0x14] == 1) {\n        flag = (uint)(ptr_param_1[0x11] << 0x10) >> 0x17 & 6 | 0xf1;\n    }\n    return flag;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800430c",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "set_flag_based_on_conditions_0800430c"
    },
    "FUN_08006060": {
        "renaming": {
            "FUN_08006060": "check_and_update_registers_08006060",
            "param_1": "register_values",
            "*param_1": "*register_values",
            "*(char *)((int)param_1 + 0x3d)": "*(char *)((int)register_values + 0x3d)",
            "*(undefined *)(param_1 + 0xf)": "*(unsigned int *)(register_values + 0xf)",
            "set_flags_based_on_value_08007708": "set_flags_based_on_value",
            "update_registers_08005fe8": "update_registers"
        },
        "code": "int check_and_update_registers_08006060(unsigned int *register_values)\\n{\\n    if (register_values != NULL) {\\n        if (*(char *)((int)register_values + 0x3d) == '\\0') {\\n            *(unsigned int *)(register_values + 0xf) = 0;\\n            set_flags_based_on_value_08007708();\\n        }\\n        *(char *)((int)register_values + 0x3d) = 2;\\n        update_registers_08005fe8(*register_values, register_values + 1);\\n        *(char *)((int)register_values + 0x3d) = 1;\\n        return 0;\\n    }\\n    return 1;\\n}",
        "called": [
            "FUN_08007708",
            "FUN_08005fe8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006060",
        "calling": [
            "FUN_08007648"
        ],
        "current_name": "check_and_update_registers_08006060"
    },
    "FUN_08003350": {
        "renaming": {
            "FUN_08003350": "set_values_at_offsets_08003350",
            "param_1": "base_address",
            "param_2": "offset",
            "param_3": "value1",
            "param_4": "value2",
            "*(undefined4 *)(param_1 + 0x74)": "*(int *)(base_address + 0x74)",
            "*(undefined4 *)(param_1 + 0x38)": "*(int *)(base_address + 0x38)",
            "*(undefined4 *)(param_1 + 0x78)": "*(int *)(base_address + 0x78)",
            "*(undefined4 *)(param_1 + 0x48)": "*(int *)(base_address + 0x48)"
        },
        "code": "void set_values_at_offsets_08003350(int base_address, int offset, int value1, int value2)\n{\n  if (offset == 0xf9) {\n    *(int *)(base_address + 0x74) = value1;\n    *(int *)(base_address + 0x38) = value2;\n    return;\n  }\n  if (offset != 0xff) {\n    return;\n  }\n  *(int *)(base_address + 0x78) = value1;\n  *(int *)(base_address + 0x48) = value2;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003350",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "set_values_at_offsets_08003350"
    },
    "FUN_08009698": {
        "renaming": {
            "FUN_08009698": "FUNC_08009698"
        },
        "code": "\nuint FUNC_08009698(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  int iVar4;\n  undefined *puVar5;\n  uint uVar6;\n  uint **ppuVar7;\n  uint uVar8;\n  uint uVar9;\n  undefined *puVar10;\n  undefined *puVar11;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  puVar11 = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar5 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar6 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar6 & 0x80) == 0) && ((int)(uVar6 << 0x19) < 0)) {\n            uVar8 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar8 = *puVar3;\n          }\n          if ((int)(uVar6 << 0x1f) < 0) {\n            *param_2 = uVar6 | 0x20;\n          }\n          if (uVar8 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar6 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar8 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar8 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar8 & 0x40) == 0) goto LAB_080096e8;\n            uVar8 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar8 = *puVar3;\n          }\n          if ((int)uVar8 < 0) {\n            uVar8 = -uVar8;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar6 = 10;\n          puVar5 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar9 = param_2[1];\n        param_2[2] = uVar9;\n        puVar10 = puVar11;\n        if ((int)uVar9 < 0) {\n          if (uVar8 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar5;\n          puVar10 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar8 == 0) {\n            if (uVar9 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar9 = uVar8 / uVar6;\n              puVar10 = puVar10 + -1;\n              *puVar10 = puVar5[uVar8 - uVar6 * uVar9];\n              uVar8 = uVar9;\n            } while (uVar9 != 0);\n          }\n        }\n        if (((uVar6 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar10[-1] = 0x30;\n          puVar10 = puVar10 + -1;\n        }\n        param_2[4] = (int)puVar11 - (int)puVar10;\n        puVar11 = puVar10;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      puVar11 = (undefined *)((int)param_2 + 0x42);\n      uVar8 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar8 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar8 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar8 & 0x40) == 0) goto LAB_0800975c;\n              uVar8 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar8 = *puVar3;\n            }\n            puVar5 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar6 = 8;\n            }\n            else {\n              uVar6 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar5 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      puVar11 = (undefined *)*puVar3;\n      iVar2 = find_character_08009f2c(puVar11,0,param_2[1]);\n      if (iVar2 != 0) {\n        param_2[1] = iVar2 - (int)puVar11;\n      }\n      uVar8 = param_2[1];\n    }\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar8 = *param_2;\n  ppuVar7 = (uint **)*param_5;\n  uVar6 = param_2[5];\n  if ((uVar8 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar7 + 1);\n    puVar3 = *ppuVar7;\n    if ((uVar8 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar6;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar7 + 1);\n    puVar3 = *ppuVar7;\nLAB_0800983e:\n    *puVar3 = uVar6;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = get_length_of_data_to_write_080095a8(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,puVar11,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar8 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar4 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar4 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar8 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar8 = local_24[0];\n    }\n  }\n  return uVar8;\n}\n\n",
        "called": [
            "FUN_080095a8",
            "FUN_08009f2c"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08009698",
        "calling": [
            "FUN_0800937c"
        ],
        "current_name": "FUNC_08009698"
    },
    "FUN_08006186": {
        "renaming": {
            "FUN_08006186": "update_flags_08006186",
            "param_1": "data",
            "param_2": "flags",
            "param_3": "value",
            "update_data_08005cec": "update_data",
            "update_data_080060c4": "update_data",
            "clear_bit_08005d48": "clear_bit",
            "update_flags_08005dac": "update_flags"
        },
        "code": "int update_flags_08006186(int *data, int flags, int value)\\n{\\n  if (*(char *)(data + 0xf) != '\\x01') {\\n    *(char *)(data + 0xf) = 1;\\n    *(char *)((int)data + 0x3d) = 2;\\n    switch(flags) {\\n    case 0:\\n      update_data_08005cec(*data);\\n      *(uint *)(*data + 0x18) |= 8;\\n      *(uint *)(*data + 0x18) &= 0xfffffffb;\\n      *(uint *)(*data + 0x18) |= *(uint *)(value + 0x10);\\n      break;\\n    case 4:\\n      update_data_080060c4(*data);\\n      *(uint *)(*data + 0x18) |= 0x800;\\n      *(uint *)(*data + 0x18) &= 0xfffffbff;\\n      *(uint *)(*data + 0x18) |= *(int *)(value + 0x10) << 8;\\n      break;\\n    case 8:\\n      clear_bit(*data);\\n      *(uint *)(*data + 0x1c) |= 8;\\n      *(uint *)(*data + 0x1c) &= 0xfffffffb;\\n      *(uint *)(*data + 0x1c) |= *(uint *)(value + 0x10);\\n      break;\\n    case 0xc:\\n      update_flags_08006186(*data);\\n      *(uint *)(*data + 0x1c) |= 0x800;\\n      *(uint *)(*data + 0x1c) &= 0xfffffbff;\\n      *(uint *)(*data + 0x1c) |= *(int *)(value + 0x10) << 8;\\n    }\\n    *(char *)((int)data + 0x3d) = 1;\\n    *(char *)(data + 0xf) = 0;\\n    return 0;\\n  }\\n  return 2;\\n}",
        "called": [
            "FUN_08005cec",
            "FUN_08005d48",
            "FUN_08005dac",
            "FUN_080060c4"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006186",
        "calling": [
            "FUN_08007118"
        ],
        "current_name": "update_flags_08006186"
    },
    "FUN_08007710": {
        "renaming": {
            "FUN_08007710": "set_flags_based_on_parameter_08007710",
            "set_flags_based_on_param_080074e0": "set_flags"
        },
        "code": "void set_flags_based_on_parameter_08007710(void)\n{\n  set_flags();\n  return;\n}",
        "called": [
            "FUN_080074e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007710",
        "calling": [
            "FUN_08005df4"
        ],
        "current_name": "set_flags_based_on_parameter_08007710"
    },
    "FUN_08003474": {
        "renaming": {
            "FUN_08003474": "FUNC_08003474"
        },
        "code": "\nvoid FUNC_08003474(int param_1,uint param_2)\n\n{\n  byte bVar1;\n  \n  if (*(char *)(param_1 + 0x14) != '\\0') {\n    if (param_2 != 0xf7) {\n      process_input_08003376(param_1,param_2,*(undefined4 *)(param_1 + 0x18));\n      *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + 1;\n      return;\n    }\n    *(undefined *)(param_1 + 0x14) = 0;\n    process_input_080033cc();\n    return;\n  }\n  if ((*(int *)(param_1 + 0x10) == 0) || (0x7f < (int)param_2)) {\n    if ((int)param_2 < 0xf0) {\n      *(byte *)(param_1 + 0xd) = (byte)param_2 & 0xf;\n      param_2 = param_2 & 0xf0;\n    }\n    if (param_2 == 0xf0) {\n      *(undefined *)(param_1 + 0x14) = 1;\n      *(undefined4 *)(param_1 + 0x18) = 0;\n      return;\n    }\n    if (param_2 < 0xf1) {\n      if (param_2 != 0xc0) {\n        if (param_2 < 0xc1) {\n          if (param_2 != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (param_2 == 0xd0) goto LAB_0800359c;\n          if (param_2 != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        *(undefined4 *)(param_1 + 0x10) = 2;\n        *(char *)(param_1 + 0xc) = (char)param_2;\n        return;\n      }\nLAB_0800359c:\n      *(undefined4 *)(param_1 + 0x10) = 1;\n      *(char *)(param_1 + 0xc) = (char)param_2;\n      return;\n    }\n    if (param_2 != 0xf9) {\n      if (0xf9 < param_2) {\n        if (param_2 == 0xff) {\n          initialize_data_structures_0800344a(param_1);\n          return;\n        }\n        return;\n      }\n      if (1 < param_2 - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (*(code **)(param_1 + 0x74) != (code *)0x0) {\n      (**(code **)(param_1 + 0x74))(*(undefined4 *)(param_1 + 0x38));\n    }\n  }\n  else {\n    *(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + -1;\n    process_input_08003376();\n    if ((*(int *)(param_1 + 0x10) == 0) && (bVar1 = *(byte *)(param_1 + 0xc), bVar1 != 0)) {\n      if (bVar1 == 0xd0) {\n        if (*(code **)(param_1 + 0x58) != (code *)0x0) {\n          (**(code **)(param_1 + 0x58))\n                    (*(undefined4 *)(param_1 + 0x28),*(undefined *)(param_1 + 0xd),\n                     **(undefined **)(param_1 + 4));\n        }\n      }\n      else if (bVar1 < 0xd1) {\n        if (bVar1 == 0x90) {\n          if (*(code **)(param_1 + 0x50) != (code *)0x0) {\n            (**(code **)(param_1 + 0x50))\n                      (*(undefined4 *)(param_1 + 0x20),*(undefined *)(param_1 + 0xd),\n                       (uint)(*(byte **)(param_1 + 4))[1] + (uint)**(byte **)(param_1 + 4) * 0x80);\n          }\n        }\n        else if ((bVar1 == 0xc0) && (*(code **)(param_1 + 0x54) != (code *)0x0)) {\n          (**(code **)(param_1 + 0x54))\n                    (*(undefined4 *)(param_1 + 0x24),*(undefined *)(param_1 + 0xd),\n                     **(undefined **)(param_1 + 4));\n        }\n      }\n      else if (bVar1 == 0xf4) {\n        if (*(code **)(param_1 + 0x5c) != (code *)0x0) {\n          (**(code **)(param_1 + 0x5c))\n                    (*(undefined4 *)(param_1 + 0x2c),(*(undefined **)(param_1 + 4))[1],\n                     **(undefined **)(param_1 + 4));\n        }\n      }\n      else if (bVar1 == 0xf5) {\n        if (*(code **)(param_1 + 0x60) != (code *)0x0) {\n          (**(code **)(param_1 + 0x60))\n                    (*(undefined4 *)(param_1 + 0x30),(*(undefined **)(param_1 + 4))[1],\n                     **(undefined **)(param_1 + 4));\n        }\n      }\n      else if ((bVar1 == 0xe0) && (*(code **)(param_1 + 0x4c) != (code *)0x0)) {\n        (**(code **)(param_1 + 0x4c))\n                  (*(undefined4 *)(param_1 + 0x1c),*(undefined *)(param_1 + 0xd),\n                   (uint)(*(byte **)(param_1 + 4))[1] + (uint)**(byte **)(param_1 + 4) * 0x80);\n      }\n      *(undefined *)(param_1 + 0xc) = 0;\n      return;\n    }\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_080033cc",
            "FUN_08003376",
            "FUN_0800344a"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08003474",
        "calling": [
            "FUN_08002ed2"
        ],
        "current_name": "FUNC_08003474"
    },
    "FUN_08006b7c": {
        "renaming": {
            "FUN_08006b7c": "get_data_by_index_08006b7c",
            "param_1": "index",
            "DAT_08006ba4": "data_0",
            "DAT_08006bb4": "data_1",
            "DAT_08006ba8": "data_2",
            "DAT_08006bac": "data_3",
            "DAT_08006bb0": "data_4"
        },
        "code": "int get_data_by_index_08006b7c(int index) {\n  switch(index) {\n    case 0:\n      return DAT_08006ba4;\n    case 1:\n      return DAT_08006bb4;\n    case 2:\n      return DAT_08006ba8;\n    case 3:\n      return DAT_08006bac;\n    case 4:\n      return DAT_08006bb0;\n    default:\n      return 0;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006b7c",
        "calling": [
            "FUN_08008a24",
            "FUN_08008a6c"
        ],
        "current_name": "get_data_by_index_08006b7c"
    },
    "FUN_08008e7c": {
        "renaming": {
            "FUN_08008e7c": "convert_base_08008e7c",
            "param_1": "param_array",
            "param_2": "num",
            "param_3": "base",
            "uVar2": "result",
            "uVar3": "remainder",
            "uVar4": "quotient",
            "pcVar5": "current_digit",
            "cVar1": "digit",
            "local_15": "reversed"
        },
        "code": "undefined4 convert_base_08008e7c(int *param_array, uint num, uint base)\n{\n  char digit;\n  undefined4 result;\n  uint quotient;\n  uint remainder;\n  char reversed[9];\n  reversed[1] = 0;\n  if ((int)base < 2) {\n    base = 10;\n  }\n  char *current_digit = reversed + 1;\n  do {\n    quotient = num / base;\n    remainder = (num & 0xff) - (quotient * base & 0xff) & 0xff;\n    current_digit = current_digit + -1;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit = digit + '0';\n    }\n    else {\n      digit = digit + '7';\n    }\n    *current_digit = digit;\n    num = quotient;\n  } while (quotient != 0);\n  if (current_digit == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    uint length = find_string_end_08000178(current_digit);\n    result = (**(code **)(*param_array + 4))(param_array,current_digit,length);\n  }\n  return result;\n}",
        "called": [
            "FUN_08000178"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008e7c",
        "calling": [
            "FUN_08008ed6"
        ],
        "current_name": "convert_base_08008e7c"
    },
    "FUN_08003aa0": {
        "renaming": {
            "FUN_08003aa0": "activate_device_if_not_activated_before_08003aa0",
            "param_1": "device",
            "iVar1": "activation_status",
            "puVar2": "global_device",
            "DAT_08003b84": "PTR_DAT_08003b84",
            "DAT_08003b88": "PTR_DAT_08003b88"
        },
        "code": "int activate_device_if_not_activated_before_08003aa0(undefined4 *device)\\n{\\n  int activation_status;\\n  int *device_type;\\n  int *device_flags;\\n  int *global_device;\\n\\n  if (*(char *)(device + 9) != '\\x01') {\\n    *(char *)(device + 9) = 1;\\n    activation_status = activate_device_08003a20();\\n    if (activation_status == 0) {\\n      device_flags = device + 10;\\n      *device_flags = *device_flags & 0xfffffcfe | 0x100;\\n      global_device = (int *)*device;\\n      if ((global_device == DAT_08003b84) && ((DAT_08003b84[-0xff] & 0xf0000) != 0)) {\\n        *device_flags = *device_flags | 0x100000;\\n        device_type = (int *)DAT_08003b88;\\n        if ((*device_type & 0x400) != 0) {\\n          *device_flags = *device_flags & 0xffffcfff | 0x1000;\\n        }\\n      }\\n      else {\\n        *device_flags = *device_flags & 0xffefffff;\\n        if ((global_device[1] & 0x400) != 0) {\\n          *device_flags = *device_flags & 0xffffcfff | 0x1000;\\n        }\\n      }\\n      if ((*device_flags & 0x1000) == 0) {\\n        device[0xb] = 0;\\n      }\\n      else {\\n        device[0xb] = device[0xb] & 0xfffffff9;\\n      }\\n      *(char *)(device + 9) = 0;\\n      *global_device = 0xfffffffd;\\n      device = (int *)*device;\\n      if (((device[2] & 0xe0000) == 0xe0000) && ((device != DAT_08003b84 || ((DAT_08003b84[-0xff] & 0xf0000) == 0)))) {\\n        device[2] = device[2] | 0x500000;\\n      }\\n      else {\\n        device[2] = device[2] | 0x100000;\\n      }\\n    }\\n    else {\\n      *(char *)(device + 9) = 0;\\n    }\\n    return activation_status;\\n  }\\n  return 2;\\n}",
        "called": [
            "FUN_08003a20"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003aa0",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "activate_device_if_not_activated_before_08003aa0"
    },
    "FUN_08003ce8": {
        "renaming": {
            "FUN_08003ce8": "deactivate_memory_region_08003ce8",
            "param_1": "memory_region",
            "iVar1": "status"
        },
        "code": "int deactivate_memory_region_08003ce8(int *memory_region)\n{\n  int status;\n\n  if (memory_region == NULL) {\n    status = 1;\n  }\n  else {\n    memory_region[10] |= 2;\n    status = check_memory_region_is_valid();\n    if (status == 0) {\n      *(int *)*memory_region = -32;\n      *(uint *)(*memory_region + 4) &= DAT_08003ddc;\n      *(uint *)(*memory_region + 8) &= DAT_08003de0;\n      *(uint *)(*memory_region + 0xc) &= 0xff000000;\n      *(uint *)(*memory_region + 0x10) &= 0xc0000000;\n      *(uint *)(*memory_region + 0x14) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x18) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x1c) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x20) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x24) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x28) &= 0xfffff000;\n      *(uint *)(*memory_region + 0x2c) &= 0xff000000;\n      *(uint *)(*memory_region + 0x2c) &= 0xff000000;\n      *(uint *)(*memory_region + 0x30) &= 0xc0000000;\n      *(uint *)(*memory_region + 0x34) &= 0xc0000000;\n      *(uint *)(*memory_region + 0x38) &= 0xffc00000;\n      *(uint *)(*memory_region + 0x38) &= 0xffc00000;\n      update_memory_region_permissions(memory_region);\n      memory_region[0xb] = 0;\n      memory_region[10] = 0;\n    }\n    *(char *)(memory_region + 9) = 0;\n  }\n  return status;\n}",
        "called": [
            "FUN_08003b8c",
            "FUN_08006d24"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003ce8",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "deactivate_memory_region_08003ce8"
    },
    "FUN_08005fe8": {
        "renaming": {
            "FUN_08005fe8": "update_registers_08005fe8",
            "param_1": "reg_values",
            "param_2": "new_values",
            "uVar1": "current_value",
            "DAT_0800605c": "PTR_SPECIAL_REG_1",
            "(uint *)0x40000000": "PTR_SPECIAL_REG_2",
            "DAT_0800605c + -0x4a00": "PTR_SPECIAL_REG_3",
            "DAT_0800605c + -0x4900": "PTR_SPECIAL_REG_4"
        },
        "code": "void update_registers_08005fe8(uint *reg_values, uint *new_values)\n{\n  uint current_value = *reg_values;\n  bool is_special_reg = (reg_values == DAT_0800605c || reg_values == PTR_SPECIAL_REG_2 || reg_values == DAT_0800605c + -0x4a00 || reg_values == DAT_0800605c + -0x4900);\n  if (is_special_reg) {\n    current_value = current_value & 0xffffff8f | new_values[1];\n  }\n  if (is_special_reg || reg_values == PTR_GENERAL_REG_1 || reg_values == PTR_GENERAL_REG_2 || reg_values == PTR_GENERAL_REG_3 || reg_values == PTR_GENERAL_REG_4) {\n    current_value = current_value & 0xfffffcff | new_values[3];\n  }\n  *reg_values = current_value & 0xffffff7f | new_values[5];\n  reg_values[11] = new_values[2];\n  reg_values[10] = *new_values;\n  if (reg_values == DAT_0800605c) {\n    reg_values[12] = new_values[4];\n  }\n  reg_values[5] = 1;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005fe8",
        "calling": [
            "FUN_08006092",
            "FUN_08006060"
        ],
        "current_name": "update_registers_08005fe8"
    },
    "FUN_08008804": {
        "renaming": {
            "FUN_08008804": "calculate_offset_08008804",
            "param_1": "offset_value",
            "iVar1": "current_offset",
            "puVar2": "stack_pointer"
        },
        "code": "int calculate_offset_08008804(int offset_value)\n{\n  int current_offset;\n  undefined *stack_pointer;\n  \n  if (*(int *)PTR_DAT_08008834 == 0) {\n    *(undefined **)PTR_DAT_08008834 = PTR_DAT_08008838;\n  }\n  current_offset = *(int *)PTR_DAT_08008834;\n  stack_pointer = (undefined *)(offset_value + current_offset);\n  if (stack_pointer <= &stack0x00000000) {\n    *(undefined **)PTR_DAT_08008834 = stack_pointer;\n    return current_offset;\n  }\n  *(undefined4 *)PTR_DAT_0800883c = 0xc;\n  return -1;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008804",
        "calling": [
            "FUN_08009918"
        ],
        "current_name": "calculate_offset_08008804"
    },
    "FUN_0800738a": {
        "renaming": {
            "FUN_0800738a": "compare_values_0800738a",
            "param_1": "value_to_compare",
            "param_2": "buffer",
            "undefined4": "int",
            "PTR_": "",
            "DAT_": ""
        },
        "code": "DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ compare_values_0800738a(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_,DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_wDAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_kDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_bDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800738a",
        "calling": [
            "FUN_080005f8",
            "FUN_08001cd0",
            "FUN_08000a64",
            "FUN_0800021a",
            "FUN_080088e0",
            "FUN_08008990"
        ],
        "current_name": "compare_values_0800738a"
    },
    "FUN_08004e3c": {
        "renaming": {
            "FUN_08004e3c": "process_data_08004e3c",
            "param_1": "data",
            "puVar1": "ptr1",
            "param_1[0xb]": "data[11]",
            "*(short *)((int)param_1 + 0x2a)": "*(uint16_t *)((int)data + 42)",
            "uint": "uint32_t",
            "*(char *)puVar1": "*(char *)ptr1",
            "puVar1 = param_1[9]": "ptr2 = data[9]",
            "param_1[9]": "data[9]",
            "(char)(*param_1)[4]": "(char)(*data)[4]",
            "*(undefined *)((int)param_1 + 0x3d)": "*(undefined *)((int)data + 61)",
            "param_1[0xc]": "data[12]",
            "*(char *)((int)param_1 + 0x3e)": "*(char *)((int)data + 62)",
            "do_nothing_08004d6a()": "do_nothing_08004d6a()",
            "do_nothing_08004a20()": "do_nothing_08004a20()"
        },
        "code": "uint32_t process_data_08004e3c(uint32_t **data)\n{\n  uint32_t *ptr1;\n  ptr1 = data[11];\n  if (*(uint16_t *)((int)data + 42) == 3) {\n    if (((ptr1 == (uint32_t *)0x4) || (ptr1 == (uint32_t *)0x8)) || (ptr1 == (uint32_t *)0xffff0000)) {\n      **data = **data & 0xfffffbff;\n    }\n    uint32_t *ptr2 = data[9];\n    data[9] = (uint32_t *)((int)ptr2 + 1);\n    *(char *)ptr2 = (char)(*data)[4];\n    *(uint16_t *)((int)data + 42) = *(uint16_t *)((int)data + 42) - 1;\n  }\n  else if (*(uint16_t *)((int)data + 42) == 2) {\n    if (((ptr1 == (uint32_t *)0x4) || (ptr1 == (uint32_t *)0x8)) || (ptr1 == (uint32_t *)0xffff0000)) {\n      (*data)[1] = (*data)[1] & 0xfffffcff;\n      **data = **data | 0x200;\n    }\n    else {\n      if (ptr1 == (uint32_t *)0x2) {\n        **data = **data | 0x400;\n      }\n      else {\n        **data = **data & 0xfffffbff;\n      }\n      (*data)[1] = (*data)[1] & 0xfffffcff;\n    }\n    uint32_t *ptr2 = data[9];\n    data[9] = (uint32_t *)((int)ptr2 + 1);\n    *(char *)ptr2 = (char)(*data)[4];\n    *(uint16_t *)((int)data + 42) = *(uint16_t *)((int)data + 42) - 1;\n    ptr2 = data[9];\n    data[9] = (uint32_t *)((int)ptr2 + 1);\n    *(char *)ptr2 = (char)(*data)[4];\n    *(undefined *)((int)data + 61) = 0x20;\n    data[12] = (uint32_t *)0x0;\n    if (*(char *)((int)data + 62) == '@') {\n      *(undefined *)((int)data + 62) = 0;\n      do_nothing_08004d6a();\n    }\n    else {\n      *(undefined *)((int)data + 62) = 0;\n      do_nothing_08004a20();\n    }\n  }\n  else {\n    uint32_t *ptr2 = data[9];\n    data[9] = (uint32_t *)((int)ptr2 + 1);\n    *(char *)ptr2 = (char)(*data)[4];\n    *(uint16_t *)((int)data + 42) = *(uint16_t *)((int)data + 42) - 1;\n  }\n  return 0;\n}",
        "called": [
            "FUN_08004a20",
            "FUN_08004d6a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004e3c",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_data_08004e3c"
    },
    "FUN_080091a0": {
        "renaming": {
            "FUN_080091a0": "add_element_to_list_at_head_080091a0",
            "param_1": "element",
            "PTR_PTR_DAT_080091ac": "head"
        },
        "code": "void add_element_to_list_at_head_080091a0(int *element)\n{\n  int **PTR_PTR_DAT_080091ac = (int **)PTR_PTR_DAT_080091ac;\n  add_to_linked_list_080091d8(*PTR_PTR_DAT_080091ac, element);\n  return;\n}",
        "called": [
            "FUN_080091d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080091a0",
        "calling": [
            "FUN_08002e44"
        ],
        "current_name": "add_element_to_list_at_head_080091a0"
    },
    "FUN_08002a1c": {
        "renaming": {
            "FUN_08002a1c": "initialize_data_08002a1c",
            "param_1": "data_pointer",
            "param_2": "input_value",
            "param_3": "unused_param_3",
            "param_4": "unused_param_4",
            "clear_and_initialize_data_08002968": "fill_memory_with_value",
            "iVar1": "memory_size",
            "iVar2": "index_offset",
            "is_special_case": "is_special_case",
            "PTR_DAT_080029ec": "flag_pointer",
            "PTR_DAT_080029f0": "reset_flag_pointer",
            "*(int *)PTR_DAT_080029f4": "memory_pointer",
            "memory_value": "memory_value",
            "PTR_DAT_080029f8": "memory_size_pointer",
            "PTR_DAT_080029fc": "flag_pointer_2",
            "PTR_DAT_08002a00": "reset_flag_pointer_2",
            "*(int *)PTR_DAT_08002a04": "memory_pointer_2",
            "PTR_DAT_08002a08": "memory_size_pointer_2",
            "PTR_DAT_08002a0c": "flag_pointer_3",
            "index_offset_value": "index_offset_value",
            "*(char *)(param_1 + 0x10)": "index_offset",
            "*(undefined *)(param_1 + 0x11)": "special_case_flag",
            "PTR_LAB_08002774_1_08002a14": "param_value",
            "PTR_LAB_08002b00_1_08002a18": "param_2_value"
        },
        "code": "void initialize_data_08002a1c(int data_pointer, uint8_t input_value)\n{\n  int memory_size = 0x4000;\n  int index_offset = data_pointer + 0x14;\n  uint8_t is_special_case = 0;\n  uint8_t *PTR_DAT_080029ec = PTR_DAT_080029ec;\n  uint8_t *PTR_DAT_080029f0 = PTR_DAT_080029f0;\n  int **(int *)PTR_DAT_080029f4 = *(int **)PTR_DAT_080029f4;\n  uint8_t memory_value = 0;\n  uint8_t *PTR_DAT_080029f8 = PTR_DAT_080029f8;\n  uint8_t *PTR_DAT_080029fc = PTR_DAT_080029fc;\n  uint8_t *PTR_DAT_08002a00 = PTR_DAT_08002a00;\n  int **(int *)PTR_DAT_08002a04 = *(int **)PTR_DAT_08002a04;\n  uint8_t *PTR_DAT_08002a08 = PTR_DAT_08002a08;\n  uint8_t *PTR_DAT_08002a0c = PTR_DAT_08002a0c;\n  uint8_t param_2 = input_value & 0x7f;\n  uint8_t index_offset_value = param_2 << 1;\n  *(char *)(data_pointer + 0x10) = index_offset_value;\n  *(undefined *)(data_pointer + 0x11) = (input_value == 0x33) ? 1 : 0;\n  if (*(char *)(data_pointer + 0x11) == 0) {\n    is_special_case = 1;\n  }\n  *PTR_DAT_080029ec = 0;\n  *PTR_DAT_080029f0 = 0;\n  if (**(int *)PTR_DAT_080029f4 != 0) {\n    fill_memory_with_value(**(int *)PTR_DAT_080029f4, memory_value, *PTR_DAT_080029f8);\n  }\n  *PTR_DAT_080029fc = 0;\n  *PTR_DAT_08002a00 = 0;\n  if (**(int *)PTR_DAT_08002a04 != 0) {\n    fill_memory_with_value(**(int *)PTR_DAT_08002a04, memory_value, *PTR_DAT_08002a08);\n  }\n  *PTR_DAT_08002a0c = 0;\n  fill_memory_with_value(index_offset, memory_value, memory_size, index_offset_value, *(undefined *)(data_pointer + 0x11));\n  if (is_special_case == 0) {\n    set_PTR_LAB_08002774_1_08002a14_if_not_null(index_offset, PTR_LAB_08002774_1_08002a14);\n    update_param_2_if_param_1_not_null(index_offset, PTR_LAB_08002b00_1_08002a18);\n  }\n}\n",
        "called": [
            "FUN_08002968"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002a1c",
        "calling": [
            "FUN_08002a26"
        ],
        "current_name": "initialize_data_08002a1c"
    },
    "FUN_08007718": {
        "renaming": {
            "FUN_08007718": "subtract_four_08007718",
            "param_1": "num"
        },
        "code": "int subtract_four_08007718(int num)\n{\n  return num - 4;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007718",
        "calling": [
            "FUN_08007736",
            "FUN_0800771c"
        ],
        "current_name": "subtract_four_08007718"
    },
    "FUN_08002948": {
        "renaming": {
            "FUN_08002948": "set_default_values_if_param_is_one_and_param2_is_0xffff_08002948",
            "param_1": "param1",
            "param_2": "param2",
            "set_default_values_0800291c": "set_default_values"
        },
        "code": "void set_default_values_if_param_is_one_and_param2_is_0xffff_08002948(int param1, int param2) {\n  if (param1 != 1) {\n    return;\n  }\n  if (param2 == 0xffff) {\n    set_default_values_0800291c(PTR_DAT_08002964);\n  }\n  return;\n}",
        "called": [
            "FUN_0800291c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002948",
        "calling": [
            "FUN_08002c1e"
        ],
        "current_name": "set_default_values_if_param_is_one_and_param2_is_0xffff_08002948"
    },
    "FUN_08009e64": {
        "renaming": {
            "FUN_08009e64": "check_permission_and_copy_data_08009e64",
            "param_1": "file_permissions",
            "param_2": "file_descriptor",
            "param_3": "permission_status",
            "param_4": "file_type",
            "auStack_4c": "local_flags",
            "iVar1": "set_permission_result"
        },
        "code": "int check_permission_and_copy_data_08009e64(uint16_t *file_permissions, int file_descriptor, uint32_t *permission_status, uint32_t *file_type)\n{\n    int set_permission_result;\n    uint32_t local_flags;\n    if (*(file_permissions + 7) < 0 || (set_permission_result = set_permission_and_copy_data(file_permissions, (int)*(file_permissions + 7), &local_flags)) < 0) {\n        *file_type = 0;\n        if ((int)((uint)*(file_permissions + 6) << 0x18) < 0) {\n            *permission_status = 0x40;\n            return 0;\n        }\n    }\n    else {\n        *file_type = (local_flags & 0xf000) == 0x2000;\n    }\n    *permission_status = 0x400;\n    return 0;\n}",
        "called": [
            "FUN_0800a0ec"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009e64",
        "calling": [
            "FUN_08009eac"
        ],
        "current_name": "check_permission_and_copy_data_08009e64"
    },
    "FUN_08002acc": {
        "renaming": {
            "FUN_08002acc": "allocate_and_update_data_08002acc",
            "param_1": "minimum_size",
            "param_2": "default_size",
            "param_3": "input_value_1",
            "param_4": "input_value_2",
            "puVar1": "data_pointer",
            "iVar2": "allocated_size",
            "uVar3": "current_size"
        },
        "code": "void allocate_and_update_data_08002acc(uint minimum_size, uint default_size, undefined4 input_value_1, uint input_value_2)\\n{\\n  undefined *data_pointer = PTR_DAT_08002afc;\\n  uint current_size = (uint)(byte)*PTR_DAT_08002af8;\\n  if (current_size < minimum_size) {\\n    if (minimum_size < 0x20) {\\n      minimum_size = 0x20;\\n    }\\n    int allocated_size = allocate_and_copy_data_08009908(*(undefined4 *)data_pointer, minimum_size, input_value_1, current_size, input_value_2);\\n    *(int *)data_pointer = allocated_size;\\n    if (allocated_size == 0) {\\n      *PTR_DAT_08002af8 = 0;\\n    }\\n    else {\\n      *PTR_DAT_08002af8 = (undefined)minimum_size;\\n    }\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08009908"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002acc",
        "calling": [
            "FUN_08002b68"
        ],
        "current_name": "allocate_and_update_data_08002acc"
    },
    "FUN_08002a30": {
        "renaming": {
            "FUN_08002a30": "initialize_data_08002a30",
            "param_1": "data_value",
            "param_2": "data_flag",
            "*PTR_DAT_08002a48": "*data_ptr_1",
            "*PTR_DAT_08002a4c": "*data_ptr_2",
            "*PTR_DAT_08002a50": "*data_ptr_3",
            "*PTR_DAT_08002a54": "*data_ptr_4"
        },
        "code": "void initialize_data_08002a30(int data_value, int data_flag) {\n  *PTR_DAT_08002a48 = 1;\n  *PTR_DAT_08002a4c = (char)(data_value << 1);\n  *PTR_DAT_08002a50 = 0;\n  *PTR_DAT_08002a54 = 0;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002a30",
        "calling": [
            "FUN_08001cd0",
            "FUN_08001c18",
            "FUN_08002b68"
        ],
        "current_name": "initialize_data_08002a30"
    },
    "FUN_0800932c": {
        "renaming": {
            "FUN_0800932c": "process_byte_0800932c",
            "param_1": "data_structure",
            "param_2": "byte_to_process",
            "param_3": "byte_array_ptr",
            "iVar1": "temp_integer",
            "pbVar2": "byte_array",
            "pbVar3": "next_byte_ptr",
            "uVar4": "byte_to_process_return",
            "block_initialized": "is_block_initialized",
            "last_byte_ptr": "last_byte_ptr",
            "next_byte_ptr_sign": "next_byte_ptr_sign",
            "byte_diff": "byte_diff",
            "shift": "shift"
        },
        "code": "uint process_byte_0800932c(int param_1, byte byte_to_process, byte **byte_array_ptr){\n  int block_initialized = 0;\n  byte *byte_array = *byte_array_ptr;\n  byte *last_byte_ptr = (*byte_array_ptr)[2] - 1;\n  (*byte_array_ptr)[2] = last_byte_ptr;\n  if ((last_byte_ptr >= -1) || ((byte_array_ptr[6] <= last_byte_ptr) && (byte_to_process != 0xa))){\n    *byte_array = byte_to_process;\n    *byte_array_ptr = byte_array + 1;\n    return (uint)byte_to_process;\n  }\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_blocks_08009d50();\n    block_initialized = 1;\n  }\n  if (byte_array_ptr == (byte **)PTR_DAT_08009a74) {\n    byte_array_ptr = *(byte ***)(param_1 + 4);\n  }\n  else if (byte_array_ptr == (byte **)PTR_DAT_08009a78) {\n    byte_array_ptr = *(byte ***)(param_1 + 8);\n  }\n  else if (byte_array_ptr == (byte **)PTR_DAT_08009a7c) {\n    byte_array_ptr = *(byte ***)(param_1 + 0xc);\n  }\n  byte_array_ptr[2] = byte_array_ptr[6];\n  byte *next_byte_ptr = (byte *)(uint)*(ushort *)(byte_array_ptr + 3);\n  int shift = 0x1c;\n  int next_byte_ptr_sign = (int)next_byte_ptr << shift;\n  if (((next_byte_ptr_sign < 0) && ((next_byte_ptr = byte_array_ptr[4]) != (byte *)0x0)) || (process_data_08009a80(param_1, byte_array_ptr, next_byte_ptr_sign, next_byte_ptr, byte_array) == 0)){\n    return 0xffffffff;\n  }\n  int byte_diff = (int)*byte_array_ptr - (int)byte_array_ptr[4];\n  if ((byte_diff < (int)byte_array_ptr[5]) || (process_data_08009c7c(param_1,byte_array_ptr) == 0)){\n    *byte_array = byte_to_process;\n    *byte_array_ptr = byte_array + 1;\n    if ((byte_array_ptr[5] - (byte *)(byte_diff + 1)) != 0){\n      if (next_byte_ptr_sign >= 0) {\n        return (uint)byte_to_process;\n      }\n      if (byte_to_process != 10) {\n        return (uint)byte_to_process;\n      }\n    }\n    if (process_data_08009c7c(param_1, byte_array_ptr) == 0){\n      return (uint)byte_to_process;\n    }\n  }\n  return 0xffffffff;\n}",
        "called": [
            "FUN_08009c7c",
            "FUN_08009d50",
            "FUN_08009a80"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800932c",
        "calling": [
            "FUN_08009358"
        ],
        "current_name": "process_byte_0800932c"
    },
    "FUN_0800322c": {
        "renaming": {
            "FUN_0800322c": "execute_commands_on_object_0800322c",
            "param_1": "object_ptr",
            "param_2": "command1",
            "param_3": "command2",
            "puVar1": "command_ptr"
        },
        "code": "void execute_commands_on_object_0800322c(undefined4 *object_ptr, undefined4 command1, undefined4 command2)\n{\n  undefined4 *command_ptr;\n  command_ptr = (undefined4 *)*object_ptr;\n  if (command_ptr != (undefined4 *)0x0) {\n    (**(code **)*command_ptr)(command_ptr, 0xf9);\n    (***(code ***)(undefined4 *)*object_ptr)((undefined4 *)*object_ptr, command1);\n    (***(code ***)(undefined4 *)*object_ptr)((undefined4 *)*object_ptr, command2);\n    return;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800322c",
        "calling": [
            "FUN_08002ddc"
        ],
        "current_name": "execute_commands_on_object_0800322c"
    },
    "FUN_080099a4": {
        "renaming": {
            "FUN_080099a4": "find_substring_080099a4",
            "param_1": "str",
            "param_2": "substr",
            "pcVar1": "str_ptr",
            "pcVar2": "str_temp",
            "pcVar3": "substr_start"
        },
        "code": "char* find_substring_080099a4(char* str, char* substr) {\n    char* str_ptr = str;\n    char* substr_ptr = substr;\n    \n    if (*str_ptr == '\\0') {\n        if (*substr_ptr != '\\0') {\n            str_ptr = NULL;\n        }\n        return str_ptr;\n    }\n    \n    while (true) {\n        char* str_start = str_ptr;\n        if (*str_start == '\\0') {\n            return NULL;\n        }\n        \n        char* substr_start = substr_ptr - 1;\n        char* str_temp = str_start - 1;\n        \n        while (*++substr_start == *++str_temp) {\n            if (*substr_start == '\\0') {\n                return str_start;\n            }\n        }\n        \n        str_ptr++;\n    }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080099a4",
        "calling": [
            "FUN_08002e44"
        ],
        "current_name": "find_substring_080099a4"
    },
    "FUN_08005a1c": {
        "renaming": {
            "FUN_08005a1c": "get_value_from_pointer_08005a1c",
            "PTR_DAT_08005a24": "pointer_value"
        },
        "code": "get_value_from_pointer_08005a1c() {\n  int *PTR_DAT_08005a24 = (int *)PTR_DAT_08005a24;\n  return *PTR_DAT_08005a24;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005a1c",
        "calling": [
            "FUN_08005a48",
            "FUN_080035b8",
            "FUN_08005a28"
        ],
        "current_name": "get_value_from_pointer_08005a1c"
    },
    "FUN_08001cd0": {
        "renaming": {
            "FUN_08001cd0": "FUNC_08001cd0"
        },
        "code": "\nvoid FUNC_08001cd0(undefined4 param_1,int param_2,byte *param_3,undefined4 param_4)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  undefined *puVar4;\n  undefined *puVar5;\n  undefined4 uVar6;\n  byte bVar7;\n  char cVar8;\n  int iVar9;\n  int iVar10;\n  char cVar11;\n  uint uVar12;\n  uint uVar13;\n  int iVar14;\n  bool bVar15;\n  \n  puVar5 = PTR_DAT_080022e8;\n  puVar4 = PTR_DAT_08002044;\n  switch(param_1) {\n  case 0x69:\n    execute_function_pointer_08002f1e(PTR_DAT_080022e8,0xf0);\n    execute_function_pointer_08002f1e(puVar5,0x6a);\n    for (uVar12 = 0; uVar12 < 0x3c; uVar12 = uVar12 + 1 & 0xff) {\n      uVar13 = uVar12 - 0x2e & 0xff;\n      if (uVar13 < 0xe) {\n        if (uVar12 < 0x3c) {\n          iVar9 = (int)(char)PTR_DAT_080022e4[uVar12];\n        }\n        else {\n          iVar9 = -1;\n        }\n        iVar9 = find_char_index_080036ac(iVar9);\n        if (iVar9 == 0) {\n          uVar13 = 0x7f;\n        }\n        else {\n          if (uVar12 < 0x3c) {\n            iVar9 = (int)(char)PTR_DAT_080022e4[uVar12];\n          }\n          else {\n            iVar9 = -1;\n          }\n          iVar9 = find_char_index_080036ac(iVar9);\n          if (iVar9 == 1) {\n            uVar13 = 0x7f;\n          }\n        }\n      }\n      else {\n        uVar13 = 0x7f;\n      }\n      execute_function_pointer_08002f1e(PTR_DAT_080022e8,uVar13);\n    }\n    execute_function_pointer_08002f1e(PTR_DAT_080022e8,0xf7);\n    break;\n  case 0x6b:\n    execute_function_pointer_08002f1e(PTR_DAT_08002044,0xf0);\n    execute_function_pointer_08002f1e(puVar4,0x6c);\n    for (uVar12 = 0; uVar12 < 0x3c; uVar12 = uVar12 + 1 & 0xff) {\n      if (uVar12 < 0x3c) {\n        if (PTR_DAT_080022e4[uVar12] == -1) {\n          bVar15 = false;\n        }\n        else {\n          iVar9 = find_char_index_080036ac();\n          if (iVar9 == 0) {\n            bVar15 = false;\n          }\n          else {\n            iVar9 = find_char_index_080036ac((int)(char)PTR_DAT_08002060[uVar12]);\n            if (iVar9 == 1) {\n              bVar15 = false;\n            }\n            else {\n              bVar15 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar15 = false;\n      }\n      puVar4 = PTR_DAT_08002044;\n      if (bVar15) {\n        execute_function_pointer_08002f1e(PTR_DAT_08002044,0);\n        execute_function_pointer_08002f1e(puVar4,1);\n        execute_function_pointer_08002f1e(puVar4,0xb);\n        execute_function_pointer_08002f1e(puVar4,1);\n        execute_function_pointer_08002f1e(puVar4,1);\n        execute_function_pointer_08002f1e(puVar4,1);\n      }\n      if ((uVar12 - 0x2e & 0xff) < 0xe) {\n        if (uVar12 < 0x3c) {\n          iVar9 = (int)(char)PTR_DAT_08002060[uVar12];\n        }\n        else {\n          iVar9 = -1;\n        }\n        iVar9 = find_char_index_080036ac(iVar9);\n        if (iVar9 == 0) {\n          bVar15 = false;\n        }\n        else {\n          if (uVar12 < 0x3c) {\n            iVar9 = (int)(char)PTR_DAT_08002060[uVar12];\n          }\n          else {\n            iVar9 = -1;\n          }\n          iVar9 = find_char_index_080036ac(iVar9);\n          if (iVar9 == 1) {\n            bVar15 = false;\n          }\n          else {\n            bVar15 = true;\n          }\n        }\n      }\n      else {\n        bVar15 = false;\n      }\n      puVar4 = PTR_DAT_080022e8;\n      if (bVar15) {\n        execute_function_pointer_08002f1e(PTR_DAT_080022e8,2);\n        execute_function_pointer_08002f1e(puVar4,10);\n      }\n      if (uVar12 < 0x3c) {\n        if (PTR_DAT_080022e4[uVar12] == -1) {\n          iVar9 = 0;\n        }\n        else {\n          iVar9 = find_char_index_080036ac();\n          if (iVar9 == 0) {\n            iVar9 = 0;\n          }\n          else {\n            iVar9 = find_char_index_080036ac((int)(char)PTR_DAT_080022e4[uVar12]);\n            if (iVar9 == 1) {\n              iVar9 = 0;\n            }\n            else {\n              iVar9 = compare_values_0800738a((int)(char)PTR_DAT_080022e4[uVar12],PTR_DAT_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        iVar9 = 0;\n      }\n      puVar4 = PTR_DAT_080022e8;\n      if (iVar9 != 0) {\n        execute_function_pointer_08002f1e(PTR_DAT_080022e8,3);\n        execute_function_pointer_08002f1e(puVar4,8);\n      }\n      if (uVar12 < 0x3c) {\n        if (PTR_DAT_080022e4[uVar12] == -1) {\n          bVar15 = false;\n        }\n        else {\n          iVar9 = find_char_index_080036ac();\n          if (iVar9 == 0) {\n            bVar15 = false;\n          }\n          else {\n            iVar9 = find_char_index_080036ac((int)(char)PTR_DAT_080022e4[uVar12]);\n            if (iVar9 == 1) {\n              bVar15 = false;\n            }\n            else {\n              bVar15 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar15 = false;\n      }\n      puVar4 = PTR_DAT_080022e8;\n      if (bVar15) {\n        execute_function_pointer_08002f1e(PTR_DAT_080022e8,4);\n        execute_function_pointer_08002f1e(puVar4,0xe);\n      }\n      if (uVar12 < 0x3c) {\n        if (PTR_DAT_080022e4[uVar12] == -1) {\n          iVar9 = 0;\n        }\n        else {\n          iVar9 = find_char_index_080036ac();\n          if (iVar9 == 0) {\n            iVar9 = 0;\n          }\n          else {\n            iVar9 = find_char_index_080036ac((int)(char)PTR_DAT_080022e4[uVar12]);\n            if (iVar9 == 1) {\n              iVar9 = 0;\n            }\n            else {\n              iVar9 = compare_values_0800738a((int)(char)PTR_DAT_080022e4[uVar12],PTR_DAT_080022f0);\n              if (iVar9 == 0) {\n                iVar9 = compare_values_0800738a((int)(char)PTR_DAT_080022e4[uVar12],PTR_DAT_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        iVar9 = 0;\n      }\n      puVar4 = PTR_DAT_080022e8;\n      if (iVar9 != 0) {\n        execute_function_pointer_08002f1e(PTR_DAT_080022e8,6);\n        execute_function_pointer_08002f1e(puVar4,1);\n      }\n      execute_function_pointer_08002f1e(PTR_DAT_080022e8,0x7f);\n    }\n    execute_function_pointer_08002f1e(PTR_DAT_080022e8,0xf7);\n    return;\n  case 0x6d:\n    if (param_2 != 0) {\n      bVar1 = *param_3;\n      execute_function_pointer_08002f1e(PTR_DAT_080022e8,0xf0);\n      execute_function_pointer_08002f1e(puVar5,0x6e);\n      execute_function_pointer_08002f1e(puVar5,bVar1);\n      if (bVar1 < 0x3c) {\n        uVar6 = get_value_at_offset_08002fa0(puVar5,bVar1);\n        execute_function_pointer_08002f1e(puVar5,uVar6);\n        uVar12 = get_value_at_offset_08002fba(puVar5,bVar1);\n        execute_function_pointer_08002f1e(puVar5,uVar12 & 0x7f);\n        uVar12 = get_value_at_offset_08002fba(puVar5,bVar1);\n        if ((uVar12 & 0xff80) != 0) {\n          iVar9 = get_value_at_offset_08002fba(puVar5,bVar1);\n          execute_function_pointer_08002f1e(puVar5,(uint)(iVar9 << 0x12) >> 0x19);\n        }\n        uVar12 = get_value_at_offset_08002fba(PTR_DAT_080022e8,bVar1);\n        puVar4 = PTR_DAT_080022e8;\n        if ((uVar12 & 0xc000) != 0) {\n          iVar9 = get_value_at_offset_08002fba(PTR_DAT_080022e8,bVar1);\n          execute_function_pointer_08002f1e(puVar4,(uint)(iVar9 << 0xb) >> 0x19);\n        }\n      }\n      execute_function_pointer_08002f1e(PTR_DAT_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 0x6f:\n    if (1 < param_2) {\n      uVar12 = (uint)param_3[1];\n      if (2 < param_2) {\n        uVar12 = uVar12 | (uint)param_3[2] << 7;\n      }\n      if (3 < param_2) {\n        uVar12 = uVar12 | (uint)param_3[3] << 0xe;\n      }\n      process_value_08000214(*param_3,uVar12);\n      return;\n    }\n    break;\n  case 0x70:\n    if (4 < param_2) {\n      uVar12 = (uint)*param_3;\n      bVar1 = param_3[1];\n      bVar7 = param_3[2];\n      bVar2 = param_3[3];\n      bVar3 = param_3[4];\n      if (uVar12 < 0x3c) {\n        if (PTR_DAT_08002060[uVar12] == -1) {\n          bVar15 = false;\n        }\n        else {\n          iVar9 = find_char_index_080036ac();\n          if (iVar9 == 0) {\n            bVar15 = false;\n          }\n          else {\n            iVar9 = find_char_index_080036ac((int)(char)PTR_DAT_08002060[uVar12]);\n            if (iVar9 == 1) {\n              bVar15 = false;\n            }\n            else {\n              bVar15 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar15 = false;\n      }\n      if (bVar15) {\n        if ((byte)PTR_DAT_08002064[uVar12] < 0xc) {\n          iVar9 = calculate_index_from_input_080026f8(PTR_DAT_08002068 + (uint)(byte)PTR_DAT_08002064[uVar12] * 3);\n        }\n        else {\n          iVar9 = 0;\n        }\n        if (iVar9 != 0) {\n          process_input_and_update_state_08000588(uVar12);\n        }\n        process_servo_data_08000500(uVar12,(uint)bVar1 + (uint)bVar7 * 0x80,(uint)bVar2 + (uint)bVar3 * 0x80);\n        FUNC_080005f8(uVar12,4);\n        return;\n      }\n    }\n    break;\n  case 0x76:\n    bVar1 = param_3[1];\n    bVar7 = bVar1 & 0x18;\n    if ((bVar1 & 0x20) != 0) {\n      process_data_and_return_result_08002f14(PTR_DAT_08002044,PTR_s_10_bit_addressing_not_supported_08002040,bVar7,bVar1,\n                   param_4);\n      return;\n    }\n    bVar2 = *param_3;\n    bVar15 = (bVar1 & 0x40) == 0;\n    if (bVar7 < 0x19) {\n      switch(bVar7) {\n      case 0:\n        initialize_data_08002a30(PTR_DAT_08002048,bVar2);\n        for (uVar12 = 2; (int)uVar12 < param_2; uVar12 = uVar12 + 2 & 0xff) {\n          copy_input_data_to_buffer_08001bf8(param_3[uVar12 + 1] * -0x80 + param_3[uVar12]);\n        }\n        update_value_at_address_08002ac0(PTR_DAT_08002048);\n        return;\n      case 8:\n        if (param_2 == 6) {\n          iVar9 = (uint)param_3[2] + (uint)param_3[3] * 0x80;\n          cVar8 = param_3[4] + param_3[5] * -0x80;\n        }\n        else {\n          cVar8 = param_3[2] + param_3[3] * -0x80;\n          iVar9 = -1;\n        }\n        process_input_data_and_return_result_08001c18(bVar2,iVar9,cVar8);\n        return;\n      case 0x10:\n        cVar8 = *PTR_DAT_0800204c;\n        if (cVar8 + 1 < 8) {\n          if (param_2 == 6) {\n            iVar9 = (uint)param_3[2] + (uint)param_3[3] * 0x80;\n            cVar11 = param_3[4] + param_3[5] * -0x80;\n          }\n          else {\n            cVar11 = param_3[2] + param_3[3] * -0x80;\n            iVar9 = -1;\n          }\n          *PTR_DAT_0800204c = cVar8 + '\\x01';\n          puVar4 = PTR_DAT_08002050;\n          iVar10 = (char)(cVar8 + '\\x01') * 0xc;\n          PTR_DAT_08002050[iVar10] = bVar2;\n          *(int *)(puVar4 + iVar10 + 4) = iVar9;\n          puVar4[iVar10 + 8] = cVar11;\n          puVar4[iVar10 + 9] = bVar15;\n          return;\n        }\n        process_data_and_return_result_08002f14(PTR_DAT_08002044,PTR_s_too_many_queries_08002054,(int)cVar8,bVar15,param_4);\n        return;\n      case 0x18:\n        cVar8 = *PTR_DAT_0800204c;\n        if (cVar8 < 1) {\n          *PTR_DAT_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar12 = 0; iVar9 = cVar8 + 1, (int)uVar12 < iVar9; uVar12 = uVar12 + 1 & 0xff) {\n        if (bVar2 == PTR_DAT_08002050[uVar12 * 0xc]) goto LAB_08001e66;\n      }\n      uVar12 = 0;\nLAB_08001e66:\n      for (; puVar4 = PTR_DAT_08002050, (int)uVar12 < iVar9; uVar12 = uVar12 + 1 & 0xff) {\n        if (uVar12 < 8) {\n          iVar10 = (uVar12 + 1) * 0xc;\n          iVar14 = uVar12 * 0xc;\n          PTR_DAT_08002050[iVar14] = PTR_DAT_08002050[iVar10];\n          *(undefined4 *)(puVar4 + iVar14 + 4) = *(undefined4 *)(puVar4 + iVar10 + 4);\n          puVar4[iVar14 + 8] = puVar4[iVar10 + 8];\n          puVar4[iVar14 + 9] = puVar4[iVar10 + 9];\n        }\n      }\n      *PTR_DAT_0800204c = cVar8 + -1;\n      return;\n    }\n    break;\n  case 0x78:\n    iVar9 = (uint)*param_3 + (uint)param_3[1] * 0x80;\n    if ((1 < param_2) && (iVar9 != 0)) {\n      *(int *)PTR_DAT_08002058 = iVar9;\n    }\n    if (*PTR_DAT_0800205c == '\\0') {\n      check_for_skipped_chars_08000a64();\n      return;\n    }\n    break;\n  case 0x7a:\n    if ((1 < param_2) &&\n       (iVar9 = (uint)*param_3 + (uint)param_3[1] * 0x80, *(int *)PTR_DAT_0800206c = iVar9,\n       iVar9 == 0)) {\n      *(undefined4 *)PTR_DAT_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_08000500",
            "FUN_080005f8",
            "FUN_08000214",
            "FUN_08000a64",
            "FUN_08002fba",
            "FUN_08001bf8",
            "FUN_08002f14",
            "FUN_080036ac",
            "FUN_080026f8",
            "FUN_0800738a",
            "FUN_08002a30",
            "FUN_08002ac0",
            "FUN_08000588",
            "FUN_08002fa0",
            "FUN_08002f1e",
            "FUN_08001c18"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08001cd0",
        "calling": [],
        "current_name": "FUNC_08001cd0"
    },
    "FUN_08003760": {
        "renaming": {
            "FUN_08003760": "get_pointer_value_08003760",
            "PTR_DAT_08003768": "pointer_data"
        },
        "code": "get_pointer_value_08003760() {\n    return *(undefined4 *)PTR_DAT_08003768;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003760",
        "calling": [
            "FUN_08003b8c",
            "FUN_08003e20",
            "FUN_08008500",
            "FUN_0800376c",
            "FUN_080058d2",
            "FUN_08005460",
            "FUN_080067ac",
            "FUN_08003a20",
            "FUN_08005aa4",
            "FUN_080066e8",
            "FUN_08007e74",
            "FUN_08007f0e",
            "FUN_0800723c"
        ],
        "current_name": "get_pointer_value_08003760"
    },
    "FUN_08007320": {
        "renaming": {
            "FUN_08007320": "get_parameter_value_08007320",
            "param_1": "parameter_id",
            "uVar1": "parameter_value",
            "find_parameter_value_08007306": "find_parameter_value"
        },
        "code": "int get_parameter_value_08007320(int parameter_id)\n{\n  int parameter_value = 0;\n  if (parameter_id != -1) {\n    parameter_value = find_parameter_value_08007306();\n  }\n  return parameter_value;\n}",
        "called": [
            "FUN_08007306"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007320",
        "calling": [
            "FUN_08006d80",
            "FUN_08007118",
            "FUN_080084b0",
            "FUN_08008500",
            "FUN_080071e4",
            "FUN_08008078",
            "FUN_080077b0"
        ],
        "current_name": "get_parameter_value_08007320"
    },
    "FUN_08000be8": {
        "renaming": {
            "FUN_08000be8": "execute_function_08000be8",
            "param_1": "function_id",
            "param_2": "bitmask",
            "param_3": "flag",
            "param_4": "param_4",
            "puVar1": "flag_ptr",
            "puVar2": "function_ptr"
        },
        "code": "void execute_function_08000be8(int function_id, uint16_t bitmask, int flag, undefined4 param_4)\n{\n  uint16_t* function_ptr = (uint16_t*)((byte)function_id & bitmask);\n  uint16_t* flag_ptr = function_id != 0 || function_ptr != (uint16_t*)(uint)(byte)PTR_DAT_08000c10[function_id] ? (uint16_t*)(uint)(byte)PTR_DAT_08000c10[function_id] : NULL;\n  if (flag != 0 || function_ptr != flag_ptr) {\n    execute_function_08000be8_with_params(PTR_DAT_08000c14, function_id, function_ptr, flag_ptr, param_4);\n    PTR_DAT_08000c10[function_id] = (char)function_ptr;\n  }\n  return;\n}",
        "called": [
            "FUN_08002efe"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000be8",
        "calling": [
            "FUN_08000ef8"
        ],
        "current_name": "execute_function_08000be8"
    },
    "FUN_08003fd8": {
        "renaming": {
            "FUN_08003fd8": "validate_input_08003fd8",
            "param_1": "input",
            "puVar1": "ptr_input_array",
            "DAT_08003ffc": "ptr_input_array",
            "DAT_08004000": "ptr_data_array"
        },
        "code": "int validate_input_08003fd8(unsigned int input) {\n  unsigned int *DAT_08003ffc = DAT_08003ffc;\n  if (input - 1U < 0x1000000) {\n    DAT_08003ffc[1] = input - 1U;\n    *(unsigned char *)(DAT_08004000 + 0x23) = 0xf0;\n    DAT_08003ffc[2] = 0;\n    *DAT_08003ffc = 7;\n    return 0;\n  }\n  return 1;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003fd8",
        "calling": [
            "FUN_080035b8",
            "FUN_080036d8"
        ],
        "current_name": "validate_input_08003fd8"
    },
    "FUN_0800307a": {
        "renaming": {
            "FUN_0800307a": "encode_data_0800307a",
            "param_1": "encoder",
            "param_2": "data_length",
            "param_3": "data",
            "param_4": "max_length",
            "uVar1": "current_byte",
            "uVar2": "bit_position",
            "uVar3": "encoded_length",
            "uVar4": "current_value"
        },
        "code": "void encode_data_0800307a(uint32_t *encoder, uint data_length, uint8_t *data, uint max_length) {\n  uint8_t current_byte = (uint8_t)*data;\n  if (max_length == 0) {\n    max_length = 0xffffffff;\n  }\n  uint bit_position = 0;\n  uint encoded_length = 0;\n  uint current_value = 0;\n  while ((encoded_length < data_length) && (bit_position < max_length)) {\n    (***(code ***)(uint32_t *)*encoder)((uint32_t *)*encoder,((uint)data[encoded_length] << (bit_position & 0xff) | current_byte) & 0x7f);\n    current_byte = (uint8_t)(uint)data[encoded_length] >> (7 - bit_position & 0xff) & 0xff;\n    bit_position++;\n    while ((encoded_length = encoded_length + 1, 6 < bit_position && (encoded_length < max_length))) {\n      (***(code ***)(uint32_t *)*encoder)((uint32_t *)*encoder,current_byte & 0x7f);\n      current_byte = current_byte >> 7;\n      bit_position = bit_position - 7;\n    }\n  }\n  if ((bit_position != 0) && (encoded_length < max_length)) {\n    (***(code ***)(uint32_t *)*encoder)((uint32_t *)*encoder,(1 << (bit_position & 0xff)) - 1U & current_byte);\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800307a",
        "calling": [
            "FUN_080031ce",
            "FUN_0800325a",
            "FUN_08003158",
            "FUN_08003106",
            "FUN_0800319e"
        ],
        "current_name": "encode_data_0800307a"
    },
    "FUN_08004b80": {
        "renaming": {
            "FUN_08004b80": "doNothing_08004b80"
        },
        "code": "void doNothing_08004b80(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004b80",
        "calling": [
            "FUN_08004b82",
            "FUN_08004ccc"
        ],
        "current_name": "doNothing_08004b80"
    },
    "FUN_0800319e": {
        "renaming": {
            "FUN_0800319e": "execute_function_if_not_null_0800319e",
            "param_1": "function_ptr",
            "param_2": "param_2",
            "param_3": "param_3",
            "puVar1": "function_address",
            "local_a": "local_param_3",
            "*puVar1": "*function_address",
            "encode_data_0800307a": "encode_data"
        },
        "code": "void execute_function_if_not_null_0800319e(uint32_t *function_ptr, uint32_t param_2, uint16_t param_3) {\n  uint32_t *function_address;\n  uint16_t local_param_3;\n  function_address = (uint32_t *)*function_ptr;\n  if (function_address != NULL) {\n    local_param_3 = param_3;\n    (**(code **)function_address)(function_address, param_2 & 0xf | 0x90);\n    encode_data_0800307a(function_ptr, 2, &local_param_3);\n  }\n  return;\n}",
        "called": [
            "FUN_0800307a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800319e",
        "calling": [
            "FUN_08002efe"
        ],
        "current_name": "execute_function_if_not_null_0800319e"
    },
    "FUN_08008d00": {
        "renaming": {
            "FUN_08008d00": "set_value_at_address_based_on_index_08008d00",
            "param_1": "address",
            "param_2": "index",
            "uVar1": "value",
            "UNRECOVERED_JUMPTABLE": "jump_table"
        },
        "code": "void set_value_at_address_based_on_index_08008d00(int address, uint index) {\n  undefined value;\n  code *jump_table;\n  if (index < 0x3c) {\n    value = PTR_DAT_08008d14[index];\n  }\n  else {\n    value = 0xff;\n  }\n  *(undefined *)(address + 0x12d) = value;\n  (*jump_table)();\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008d00",
        "calling": [
            "FUN_08008d30"
        ],
        "current_name": "set_value_at_address_based_on_index_08008d00"
    },
    "FUN_08009190": {
        "renaming": {
            "FUN_08009190": "allocate_memory_08009190",
            "param_1": "block_size",
            "allocate_memory_block_08009270": "allocate_memory_block",
            "PTR_PTR_DAT_0800919c": "PTR_PTR_DAT_memory_block"
        },
        "code": "void allocate_memory_08009190(uint32_t block_size) {\n  uint32_t** memory_block = *(uint32_t***)PTR_PTR_DAT_0800919c;\n  allocate_memory_08009190_block_08009270(memory_block, block_size);\n  return;\n}",
        "called": [
            "FUN_08009270"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009190",
        "calling": [
            "FUN_08002e44"
        ],
        "current_name": "allocate_memory_08009190"
    },
    "FUN_08004b82": {
        "renaming": {
            "FUN_08004b82": "process_input_08004b82",
            "param_1": "input",
            "cVar1": "current_char",
            "puVar2": "ptr_to_9th_element",
            "PTR_DAT_0804a1e0": "do_nothing_08004a1e",
            "PTR_FUN_08004b80": "do_nothing_08004b80"
        },
        "code": "uint32_t process_input_08004b82(uint32_t **input)\n{\n  char current_char = *(char *)((int)input + 0x3d);\n  uint32_t *ptr_to_11th_element = input[0xb];\n  if ((*(short *)(input + 10) == 0) && (current_char == '!')) {\n    if ((ptr_to_11th_element == (uint32_t *)0x4) || ((ptr_to_11th_element == (uint32_t *)0x8 || (ptr_to_11th_element == (uint32_t *)0xffff0000)))) {\n      (*input)[1] = (*input)[1] & 0xfffff8ff;\n      **input = **input | 0x200;\n      input[0xc] = (uint32_t *)0x0;\n      *(undefined *)((int)input + 0x3d) = 0x20;\n      if (*(char *)((int)input + 0x3e) == '@') {\n        *(undefined *)((int)input + 0x3e) = 0;\n        PTR_FUN_08004b80();\n      }\n      else {\n        *(undefined *)((int)input + 0x3e) = 0;\n        PTR_DAT_0804a1e0();\n      }\n    }\n    else {\n      (*input)[1] = (*input)[1] & 0xfffff8ff;\n      input[0xc] = (uint32_t *)0x11;\n      *(undefined *)((int)input + 0x3e) = 0;\n      *(undefined *)((int)input + 0x3d) = 0x20;\n      PTR_DAT_0804a1e0();\n    }\n  }\n  else if ((current_char == '!') || ((*(char *)((int)input + 0x3e) == '@' && (current_char == '\"')))) {\n    if (*(short *)((int)input + 0x2a) == 0) {\n      (*input)[1] = (*input)[1] & 0xfffffbff;\n    }\n    else if (*(char *)((int)input + 0x3e) == '@') {\n      if (input[0x14] == (uint32_t *)0x0) {\n        if (input[0x13] == (uint32_t *)0x1) {\n          (*input)[4] = (uint32_t)input[0x12] & 0xff;\n          input[0x14] = (uint32_t *)((int)input[0x14] + 2);\n        }\n        else {\n          (*input)[4] = (uint32_t)((int)input[0x12] << 0x10) >> 0x18;\n          input[0x14] = (uint32_t *)((int)input[0x14] + 1);\n        }\n      }\n      else if (input[0x14] == (uint32_t *)0x1) {\n        (*input)[4] = (uint32_t)input[0x12] & 0xff;\n        input[0x14] = (uint32_t *)((int)input[0x14] + 1);\n      }\n      else if (input[0x14] == (uint32_t *)0x2) {\n        if (*(char *)((int)input + 0x3d) == '\"') {\n          **input = **input | 0x100;\n        }\n        else if (*(char *)((int)input + 0x3d) == '!') {\n          uint32_t *ptr_to_9th_element = input[9];\n          input[9] = (uint32_t *)((int)ptr_to_9th_element + 1);\n          (*input)[4] = (uint32_t)*(byte *)ptr_to_9th_element;\n          *(short *)((int)input + 0x2a) = *(short *)((int)input + 0x2a) + -1;\n        }\n      }\n    }\n    else {\n      uint32_t *ptr_to_9th_element = input[9];\n      input[9] = (uint32_t *)((int)ptr_to_9th_element + 1);\n      (*input)[4] = (uint32_t)*(byte *)ptr_to_9th_element;\n      *(short *)((int)input + 0x2a) = *(short *)((int)input + 0x2a) + -1;\n    }\n  }\n  return 0;\n}",
        "called": [
            "FUN_08004a1e",
            "FUN_08004b80"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004b82",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_input_08004b82"
    },
    "FUN_0800997e": {
        "renaming": {
            "FUN_0800997e": "find_last_occurrence_of_character_in_string_0800997e",
            "param_1": "string",
            "param_2": "string_length",
            "param_3": "character_to_find",
            "param_4": "param_4",
            "iVar1": "current_index",
            "iVar2": "last_occurrence_index"
        },
        "code": "int find_last_occurrence_of_character_in_string_0800997e(int *string, int string_length, int character_to_find, undefined4 param_4)\n{\n  int last_occurrence_index = 0;\n  if (string_length != 0) {\n    int current_index = 0;\n    while (current_index = find_character_in_string(string, string_length, character_to_find, current_index, param_4), current_index != 0) {\n      string = current_index + 1;\n      last_occurrence_index = current_index;\n    }\n    return last_occurrence_index;\n  }\n  last_occurrence_index = find_character_in_string(string, string_length, character_to_find, 0, param_4);\n  return last_occurrence_index;\n}",
        "called": [
            "FUN_08009938"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800997e",
        "calling": [
            "FUN_08002e44"
        ],
        "current_name": "find_last_occurrence_of_character_in_string_0800997e"
    },
    "FUN_08002dbc": {
        "renaming": {
            "FUN_08002dbc": "initialize_if_first_time_08002dbc",
            "param_1": "is_first_time",
            "param_2": "param",
            "initialize_params_08002ce0": "initialize_params"
        },
        "code": "void initialize_if_first_time_08002dbc(int is_first_time, int param)\n{\n  if (is_first_time != 1) {\n    return;\n  }\n  if (param == 0xffff) {\n    initialize_params_08002ce0(PTR_DAT_08002dd8);\n  }\n  return;\n}",
        "called": [
            "FUN_08002ce0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002dbc",
        "calling": [],
        "current_name": "initialize_if_first_time_08002dbc"
    },
    "FUN_08002e44": {
        "renaming": {
            "FUN_08002e44": "create_new_element_in_list_08002e44",
            "param_1": "list_pointer",
            "param_2": "string_pointer",
            "param_3": "first_char",
            "param_4": "second_char",
            "bVar1": "string_length",
            "cVar2": "string_end",
            "iVar3": "substring_index",
            "iVar4": "last_slash_index",
            "puVar5": "new_string_pointer"
        },
        "code": "void create_new_element_in_list_08002e44(int list_pointer, int string_pointer, undefined first_char, undefined second_char)\n{\n  int substring_index = find_substring(string_pointer, \"cpp\");\n  int last_slash_index = find_last_occurrence_of_character_in_string(string_pointer, 0x2f);\n  if (last_slash_index == 0) {\n    last_slash_index = find_last_occurrence_of_character_in_string(string_pointer, 0x5c);\n  }\n  if (last_slash_index != 0) {\n    string_pointer = last_slash_index + 1;\n  }\n  if (substring_index == 0) {\n    char string_end = find_string_end(string_pointer);\n    *(char *)(list_pointer + 196) = string_end + 2;\n  }\n  else {\n    *(char *)(list_pointer + 196) = ((char)substring_index - (char)string_pointer) + 2;\n  }\n  add_element_to_list_at_head(*(int *)(list_pointer + 200));\n  byte string_length = *(byte *)(list_pointer + 196);\n  undefined *new_string_pointer = (undefined *)allocate_memory(string_length + 1);\n  *(undefined **)(list_pointer + 200) = new_string_pointer;\n  new_string_pointer[string_length] = 0;\n  *new_string_pointer = first_char;\n  new_string_pointer[1] = second_char;\n  copy_string(new_string_pointer + 2, string_pointer, *(byte *)(list_pointer + 196) - 2);\n  return;\n}",
        "called": [
            "FUN_0800997e",
            "FUN_080091a0",
            "FUN_080099a4",
            "FUN_08000178",
            "FUN_08009954",
            "FUN_08009190"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002e44",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "create_new_element_in_list_08002e44"
    },
    "FUN_0800242c": {
        "renaming": {
            "FUN_0800242c": "initialize_timer_with_callback_0800242c",
            "param_1": "callback_function",
            "param_2": "time_in_ms",
            "param_3": "callback_arg",
            "param_4": "arg"
        },
        "code": "void initialize_timer_with_callback_0800242c(void* callback_function, int time_in_ms, int callback_arg, void* arg){\n  initialize_timer_08007648(callback_function, time_in_ms, callback_arg, PTR_LAB_08002444_1_08002440, arg);\n  return;\n}",
        "called": [
            "FUN_08007648"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800242c",
        "calling": [
            "FUN_080025ac"
        ],
        "current_name": "initialize_timer_with_callback_0800242c"
    },
    "FUN_080058d2": {
        "renaming": {
            "FUN_080058d2": "validate_and_set_input_080058d2",
            "param_1": "input",
            "param_2": "input_length",
            "puVar1": "data",
            "iVar2": "start_time",
            "iVar3": "current_time",
            "uVar4": "value",
            "DAT_08005a10": "flags",
            "DAT_08005a0c": "data"
        },
        "code": "int validate_and_set_input_080058d2(uint *input, uint input_length)\n{\n  uint *DAT_08005a10 = (uint *)DAT_08005a10;\n  uint *DAT_08005a0c = (uint *)DAT_08005a0c;\n  uint value;\n  if ((*input & 2) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffff0f | input[2];\n  }\n  if ((*input & 1) != 0) {\n    uint type = input[1];\n    if (type == 1) {\n      if ((DAT_08005a10[0] & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if ((type != 2) && ((DAT_08005a10[0] & 2) == 0)) {\n      return 1;\n    }\n    DAT_08005a10[1] = type | DAT_08005a10[1] & 0xfffffffc;\n    uint start_time = get_current_time();\n    if (type == 1) {\n      while ((DAT_08005a10[1] & 0xc) != 4) {\n        uint current_time = get_current_time();\n        if (5000 < (current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else if (type == 2) {\n      while ((DAT_08005a10[1] & 0xc) != 8) {\n        uint current_time = get_current_time();\n        if (5000 < (current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      while ((DAT_08005a10[1] & 0xc) != 0) {\n        uint current_time = get_current_time();\n        if (5000 < (current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if ((input_length < (*DAT_08005a0c & 7)) && (*DAT_08005a0c = *DAT_08005a0c & 0xfffffff8 | input_length, input_length != (*DAT_08005a0c & 7))) {\n    return 1;\n  }\n  if ((*input & 4) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xfffff8ff | input[3];\n  }\n  if ((*input & 8) != 0) {\n    DAT_08005a10[1] = DAT_08005a10[1] & 0xffffc7ff | input[4] << 3;\n  }\n  value = calculate_value();\n  *(uint *)PTR_DAT_08005a18 = value >> PTR_DAT_08005a14[(DAT_08005a10[1] << 0x18) >> 0x1c];\n  validate_and_set_input_080058d2_080036d8(0xf);\n  return 0;\n}",
        "called": [
            "FUN_08005840",
            "FUN_08003760",
            "FUN_080036d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080058d2",
        "calling": [
            "FUN_080058ac"
        ],
        "current_name": "validate_and_set_input_080058d2"
    },
    "FUN_08002c00": {
        "renaming": {
            "FUN_08002c00": "process_data_and_return_08002c00"
        },
        "code": "void process_data_and_return_08002c00()\n{\n  process_data();\n  return;\n}",
        "called": [
            "FUN_08002b68"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002c00",
        "calling": [
            "FUN_08002c14"
        ],
        "current_name": "process_data_and_return_08002c00"
    },
    "FUN_08003f30": {
        "renaming": {
            "FUN_08003f30": "set_bits_08003f30",
            "param_1": "bit_offset",
            "param_2": "mask",
            "param_3": "value",
            "uVar1": "shift_amount",
            "uVar2": "inverted_shift_amount",
            "DAT_08003f8c": "data_pointer_1",
            "DAT_08003f90": "data_pointer_2"
        },
        "code": "void set_bits_08003f30(uint bit_offset, uint mask, uint value)\n{\n  uint shift_amount = (*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n  uint inverted_shift_amount = 7 - shift_amount;\n  if (inverted_shift_amount > 3) {\n    inverted_shift_amount = 4;\n  }\n  if (shift_amount + 4 < 7) {\n    shift_amount = 0;\n  }\n  else {\n    shift_amount = shift_amount - 3;\n  }\n  uint shifted_mask = (mask & (1 << (inverted_shift_amount & 0xff)) - 1U) << (shift_amount & 0xff);\n  uint shifted_value = (value & ((1 << (shift_amount & 0xff)) - 1U));\n  uint final_value = shifted_mask | shifted_value;\n  if ((int)bit_offset < 0) {\n    *(char *)(DAT_08003f90 + (bit_offset & 0xf)) = (char)(final_value << 4);\n  }\n  else {\n    *(char *)(bit_offset + 0xe000e400) = (char)(final_value << 4);\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003f30",
        "calling": [
            "FUN_08007648",
            "FUN_080035b8",
            "FUN_08008694",
            "FUN_0800863c",
            "FUN_080036d8",
            "FUN_080077b0"
        ],
        "current_name": "set_bits_08003f30"
    },
    "FUN_08007f78": {
        "renaming": {
            "FUN_08007f78": "subtract_four_from_input_08007f78",
            "param_1": "input",
            "PTR_": "PTR_",
            "DAT_": "DAT_"
        },
        "code": "int subtract_four_from_input_08007f78(int input) {\n  int result = input - 4;\n  return result;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007f78",
        "calling": [
            "FUN_08008020",
            "FUN_08007ff0",
            "FUN_08007fa0"
        ],
        "current_name": "subtract_four_from_input_08007f78"
    },
    "FUN_08006b28": {
        "renaming": {
            "FUN_08006b28": "read_bit_at_position_08006b28",
            "param_1": "num",
            "param_2": "pos",
            "PTR_": "ptr",
            "DAT_": "val"
        },
        "code": "uint read_bit_at_position_08006b28(uint num, int pos) {\n    uint* PTR_ = (uint*)(pos + ((num << 0x18) >> 0x1c) * 4);\n    uint DAT_ = *PTR_ >> (num & 0xf) & 1;\n    return DAT_;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006b28",
        "calling": [
            "FUN_08008a24",
            "FUN_08008a6c",
            "FUN_080088e0",
            "FUN_08008990"
        ],
        "current_name": "read_bit_at_position_08006b28"
    },
    "FUN_080085dc": {
        "renaming": {
            "FUN_080085dc": "is_combination_valid_080085dc",
            "param_1": "index",
            "uVar1": "combined_bytes",
            "PTR_DAT_080085fc": "get_address_from_index",
            "byte": "index_byte"
        },
        "code": "bool is_combination_valid_080085dc(int index)\n{\n  uint16_t combined_bytes = combine_two_bytes(PTR_DAT_080085fc(index));\n  return (combined_bytes & 0x21) == 0x21;\n}",
        "called": [
            "FUN_08006b1c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080085dc",
        "calling": [],
        "current_name": "is_combination_valid_080085dc"
    },
    "FUN_08006b1c": {
        "renaming": {
            "FUN_08006b1c": "combine_two_bytes_08006b1c",
            "param_1": "address",
            "*(byte *)(param_1 + 0x3a)": "first_byte",
            "*(byte *)(param_1 + 0x39)": "second_byte"
        },
        "code": "byte combine_two_bytes_08006b1c(int address)\n{\n  byte first_byte = *(byte *)(address + 0x3a);\n  byte second_byte = *(byte *)(address + 0x39);\n  return first_byte | second_byte;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006b1c",
        "calling": [
            "FUN_080085b8",
            "FUN_080085dc"
        ],
        "current_name": "combine_two_bytes_08006b1c"
    },
    "FUN_08008ed6": {
        "renaming": {
            "FUN_08008ed6": "convert_base_if_not_zero_08008ed6",
            "param_1": "function_pointer",
            "param_2": "length",
            "param_3": "parameter",
            "param_4": "additional_parameter"
        },
        "code": "void convert_base_if_not_zero_08008ed6(uint32_t *function_pointer, uint32_t length, uint32_t parameter, uint32_t additional_parameter) {\n  if (parameter != 0) {\n    convert_base(function_pointer, length, parameter & 0xff);\n    return;\n  }\n  (**(code **)*function_pointer)(function_pointer, length & 0xff, 0, *(code **)*function_pointer, additional_parameter);\n  return;\n}",
        "called": [
            "FUN_08008e7c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008ed6",
        "calling": [
            "FUN_08008eec"
        ],
        "current_name": "convert_base_if_not_zero_08008ed6"
    },
    "FUN_0800a130": {
        "renaming": {
            "FUN_0800a130": "check_and_assign_value_0800a130",
            "param_1": "result",
            "param_2": "arg2",
            "param_3": "arg3",
            "param_4": "arg4",
            "puVar1": "data_pointer",
            "iVar2": "return_value"
        },
        "code": "void check_and_assign_value_0800a130(int *result, undefined4 arg2, undefined4 arg3, undefined4 arg4)\n{\n  undefined *data_pointer = PTR_DAT_0800a150;\n  *(undefined4 *)PTR_DAT_0800a150 = 0;\n  int return_value = return_zero_08008854(arg2, arg3, arg4, arg4, arg4);\n  if ((return_value == -1) && (*(int *)data_pointer != 0)) {\n    *result = *(int *)data_pointer;\n  }\n  return;\n}",
        "called": [
            "FUN_08008854"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a130",
        "calling": [
            "FUN_0800a042",
            "FUN_0800a07a"
        ],
        "current_name": "check_and_assign_value_0800a130"
    },
    "FUN_08008f3c": {
        "renaming": {
            "FUN_08008f3c": "get_bit_position_08008f3c",
            "param_1": "number",
            "cVar1": "bit_position"
        },
        "code": "char get_bit_position_08008f3c(uint number) {\n  char bit_position = 0;\n  while (number != 1) {\n    number = number >> 1;\n    bit_position = bit_position + 1;\n  }\n  return bit_position;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008f3c",
        "calling": [
            "FUN_08009094"
        ],
        "current_name": "get_bit_position_08008f3c"
    },
    "FUN_08002ef2": {
        "renaming": {
            "FUN_08002ef2": "send_data_08002ef2",
            "param_1": "data_offset",
            "param_2": "data_size",
            "param_3": "data_type",
            "param_4": "param_4",
            "send_encoded_data_if_possible_08003158": "send_encoded_data"
        },
        "code": "void send_data_08002ef2(int data_offset, uint32_t data_size, uint16_t data_type, uint32_t param_4) {\n  send_encoded_data_if_possible_08003158(data_offset + 0x40, data_size, data_type, param_4, param_4);\n  return;\n}",
        "called": [
            "FUN_08003158"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ef2",
        "calling": [
            "FUN_08000488",
            "FUN_080022f8"
        ],
        "current_name": "send_data_08002ef2"
    },
    "FUN_08007332": {
        "renaming": {
            "FUN_08007332": "find_value_by_key_08007332",
            "param_1": "key",
            "param_2": "dictionary",
            "*param_2": "*dictionary"
        },
        "code": "int find_value_by_key_08007332(int key, char *dictionary) {\\n  while (true) {\\n    int current_key = *(int *)(dictionary + 4);\\n    if (current_key == 0) {\\n      return -1;\\n    }\\n    if (current_key == key) {\\n      return (int)(*dictionary);\\n    }\\n    dictionary = dictionary + 0xc;\\n  }\\n}",
        "called": [
            "FUN_08007332"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007332",
        "calling": [
            "FUN_0800734a",
            "FUN_08007332"
        ],
        "current_name": "find_value_by_key_08007332"
    },
    "FUN_08006128": {
        "renaming": {
            "FUN_08006128": "update_and_return_status_08006128",
            "param_1": "data",
            "param_2": "data_length",
            "param_3": "operation",
            "PTR_08005cec": "update_data",
            "PTR_080060c4": "update_data_with_param",
            "PTR_08005d48": "clear_data_bit",
            "PTR_08005dac": "update_flags"
        },
        "code": "int update_and_return_status_08006128(uint *data, uint data_length, uint operation)\\n{\\n  uint *flags = (uint *)data;\\n  uint status = 0;\\n  if (*(char *)(data + 0xf) != '\\x01') {\\n    *(char *)(data + 0xf) = 1;\\n    *(char *)((int)data + 0x3d) = 2;\\n    switch(operation) {\\n      case 0:\\n        PTR_08005cec(*data);\\n        break;\\n      case 4:\\n        PTR_080060c4(*data);\\n        break;\\n      case 8:\\n        PTR_08005d48(*data);\\n        break;\\n      case 0xc:\\n        PTR_08005dac(*data);\\n        break;\\n    }\\n    *(char *)((int)data + 0x3d) = 1;\\n    *(char *)(data + 0xf) = 0;\\n    status = 0;\\n  }\\n  else {\\n    status = 2;\\n  }\\n  return status;\\n}",
        "called": [
            "FUN_08005cec",
            "FUN_08005d48",
            "FUN_08005dac",
            "FUN_080060c4"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006128",
        "calling": [
            "FUN_08007648"
        ],
        "current_name": "update_and_return_status_08006128"
    },
    "FUN_08003658": {
        "renaming": {
            "FUN_08003658": "copy_data_and_clear_buffers_08003658",
            "iVar1": "index",
            "puVar2": "data_ptr",
            "UNRECOVERED_JUMPTABLE": "jump_table"
        },
        "code": "void copy_data_and_clear_buffers_08003658(void)\n{\n  int index;\n  undefined4 *data_ptr;\n  code *jump_table;\n  for (index = 0; PTR_DAT_08003690 + index < PTR_DAT_08003694; index += 4) {\n    *(undefined4 *)(PTR_DAT_08003690 + index) = *(undefined4 *)(DAT_0800368c + index);\n  }\n  for (data_ptr = (undefined4 *)PTR_DAT_08003698; data_ptr < PTR_DAT_0800369c; data_ptr++) {\n    *data_ptr = 0;\n  }\n  set_flags();\n  execute_all_functions();\n  jump_table = (code *)0x800368a;\n  process_data_and_calculate_shift();\n  (*jump_table)();\n  return;\n}",
        "called": [
            "FUN_08009148",
            "FUN_08008f1c",
            "FUN_080073ec"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003658",
        "calling": [],
        "current_name": "copy_data_and_clear_buffers_08003658"
    },
    "FUN_08009a80": {
        "renaming": {
            "FUN_08009a80": "process_data_08009a80",
            "param_1": "output",
            "param_2": "input",
            "uVar1": "result",
            "uVar2": "flags",
            "iVar3": "data_ptr",
            "PTR_PTR_DAT_08009b4c": "data_ptr_ptr",
            "PTR_DAT_08009b50": "input_ptr_1",
            "PTR_DAT_08009b54": "input_ptr_2",
            "PTR_DAT_08009b58": "input_ptr_3",
            "FUNC_08009d50": "cleanup_data",
            "add_to_linked_list_080091d8": "add_to_linked_list",
            "check_and_allocate_memory_block_08009eac": "allocate_memory_block"
        },
        "code": "uint process_data_08009a80(uint *output, uint *input)\n{\n  uint result;\n  ushort flags;\n  int data_ptr;\n  data_ptr = *(int *)PTR_PTR_DAT_08009b4c;\n  if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n    cleanup_data(data_ptr);\n  }\n  if (input == (uint *)PTR_DAT_08009b50) {\n    input = *(uint **)(data_ptr + 4);\n  }\n  else if (input == (uint *)PTR_DAT_08009b54) {\n    input = *(uint **)(data_ptr + 8);\n  }\n  else if (input == (uint *)PTR_DAT_08009b58) {\n    input = *(uint **)(data_ptr + 0xc);\n  }\n  flags = *(ushort *)(input + 3);\n  result = (uint)flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *output = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((uint *)input[0xd] != (uint *)0x0) {\n        if ((uint *)input[0xd] != input + 0x11) {\n          add_to_linked_list_080091d8(output);\n        }\n        input[0xd] = 0;\n      }\n      *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n      input[1] = 0;\n      *input = input[4];\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) | 8;\n  }\n  if ((input[4] == 0) && ((flags & 0x280) != 0x200)) {\n    check_and_allocate_memory_block_08009eac(output, input);\n  }\n  flags = *(ushort *)(input + 3);\n  result = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = input[5];\n    }\n    input[2] = result;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] == 0) {\n    flags = *(ushort *)(input + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\n      *(ushort *)(input + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
        "called": [
            "FUN_08009d50",
            "FUN_08009eac",
            "FUN_080091d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009a80",
        "calling": [
            "FUN_0800932c",
            "FUN_0800937c"
        ],
        "current_name": "process_data_08009a80",
        "code_backup": "\nuint FUN_08009a80(undefined4 *param_1,undefined4 *param_2)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)PTR_PTR_DAT_08009b4c;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    FUNC_08009d50(iVar3);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_08009b50) {\n    param_2 = *(undefined4 **)(iVar3 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_08009b54) {\n    param_2 = *(undefined4 **)(iVar3 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_08009b58) {\n    param_2 = *(undefined4 **)(iVar3 + 0xc);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = (uint)uVar2;\n  if (-1 < (int)(uVar1 << 0x1c)) {\n    if (-1 < (int)(uVar1 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(uVar1 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          add_to_linked_list_080091d8(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    check_and_allocate_memory_block_08009eac(param_1,param_2);\n  }\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar1 = uVar2 & 1;\n  if ((uVar2 & 1) == 0) {\n    if (-1 < (int)((uint)uVar2 << 0x1e)) {\n      uVar1 = param_2[5];\n    }\n    param_2[2] = uVar1;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] == 0) {\n    uVar2 = *(ushort *)(param_2 + 3);\n    uVar1 = (int)(short)uVar2 & 0x80;\n    if (uVar1 != 0) {\nLAB_08009ab0:\n      *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n"
    },
    "FUN_08004a74": {
        "renaming": {
            "FUN_08004a74": "doNothing_08004a74"
        },
        "code": "void doNothing_08004a74(void)\n{\n  // This function does nothing.\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a74",
        "calling": [
            "FUN_08005084",
            "FUN_08004a76"
        ],
        "current_name": "doNothing_08004a74"
    },
    "FUN_080062f4": {
        "renaming": {
            "FUN_080062f4": "set_bits_and_clear_flags_080062f4",
            "param_1": "bits",
            "param_2": "flag",
            "puVar1": "bit_array"
        },
        "code": "uint32_t set_bits_and_clear_flags_080062f4(uint32_t **bits, uint32_t flag) {\n  uint32_t *bit_array = *bits;\n  switch(flag) {\n    case 0:\n      bit_array[3] &= 0xfffffffd;\n      break;\n    case 4:\n      bit_array[3] &= 0xfffffffb;\n      break;\n    case 8:\n      bit_array[3] &= 0xfffffff7;\n      break;\n    case 0xc:\n      bit_array[3] &= 0xffffffef;\n  }\n  set_bit(bit_array, flag, 0);\n  if (((bit_array == PTR_DAT_0800638c) && ((bit_array[8] & 0x1111) == 0)) && ((bit_array[8] & 0x444) == 0)) {\n    bit_array[0x11] &= 0xffff7fff;\n  }\n  if (((bit_array[8] & 0x1111) == 0) && ((bit_array[8] & 0x444) == 0)) {\n    *bit_array &= 0xfffffffe;\n  }\n  return 0;\n}",
        "called": [
            "FUN_08006262"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080062f4",
        "calling": [
            "FUN_080076e0"
        ],
        "current_name": "set_bits_and_clear_flags_080062f4"
    },
    "FUN_080073e8": {
        "renaming": {
            "FUN_080073e8": "wait_forever_080073e8"
        },
        "code": "void wait_forever_080073e8(void)\n{\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
        "called": [
            "FUN_080073e8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080073e8",
        "calling": [
            "FUN_080035b8",
            "FUN_080073e8"
        ],
        "current_name": "wait_forever_080073e8"
    },
    "FUN_08004a76": {
        "renaming": {
            "FUN_08004a76": "process_data_08004a76",
            "param_1": "data",
            "cVar1": "flag",
            "puVar2": "current_position"
        },
        "code": "int process_data_08004a76(int *data){\n  char flag = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    undefined *current_position = (undefined *)data[9];\n    data[9] = (int)(current_position + 1);\n    *current_position = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (flag == '*')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      data[0xc] = 0x22;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      doNothing_08004a74();\n    }\n  }\n  return 0;\n}",
        "called": [
            "FUN_08004a74"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a76",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_data_08004a76"
    },
    "FUN_0800877c": {
        "renaming": {
            "FUN_0800877c": "doNothing_0800877c"
        },
        "code": "void doNothing_0800877c(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800877c",
        "calling": [
            "FUN_080069ec"
        ],
        "current_name": "doNothing_0800877c"
    },
    "FUN_0800267c": {
        "renaming": {
            "FUN_0800267c": "set_value_based_on_conditions_0800267c",
            "param_1": "input_array",
            "param_2": "value",
            "iVar1": "first_calculation"
        },
        "code": "void set_value_based_on_conditions_0800267c(byte *input_array, int value)\n{\n  int first_calculation;\n  if (*input_array < 0xc) {\n    first_calculation = (0x88 - (char)input_array[1]) * 4;\n    if ((first_calculation - value == 0 || first_calculation < value) &&\n        (value == (600 - (char)input_array[2]) * 4 || value + (600 - (char)input_array[2]) * -4 < 0 != SBORROW4(value, (600 - (char)input_array[2]) * 4)))\n    {\n      first_calculation = value;\n    }\n    *(int *)(PTR_DAT_080026ac + (uint)*input_array * 8 + 4) = first_calculation;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800267c",
        "calling": [
            "FUN_080026b0"
        ],
        "current_name": "set_value_based_on_conditions_0800267c"
    },
    "FUN_080047f4": {
        "renaming": {
            "FUN_080047f4": "send_message_080047f4",
            "param_1": "message_data",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "message_type",
            "uVar1": "result",
            "puVar2": "current_message",
            "local_c": "message_count"
        },
        "code": "uint32_t send_message_080047f4(uint32_t **message_data, uint32_t *param_2, uint32_t *param_3, uint16_t message_type)\\n{\\n  uint32_t result;\\n  uint32_t *current_message;\\n  uint32_t message_count;\\n  if (*(char *)((int)message_data + 0x3d) == ' ')\\n  {\\n    message_count = (uint32_t)((uint64_t)DAT_080048c0 * (uint64_t)(*(uint32_t *)PTR_DAT_080048bc >> 3) >> 0x28) * 0x19;\\n    do\\n    {\\n      if (message_count == 0)\\n      {\\n        message_data[0xc] = (uint32_t *)0x0;\\n        *(undefined *)((int)message_data + 0x3d) = 0x20;\\n        *(undefined *)(message_data + 0xf) = 0;\\n        return 3;\\n      }\\n      current_message = *message_data;\\n      message_count = message_count + -1;\\n    } while ((current_message[6] & 2) != 0);\\n    if (*(char *)(message_data + 0xf) == '\\x01')\\n    {\\n      result = 2;\\n    }\\n    else\\n    {\\n      *(undefined *)(message_data + 0xf) = 1;\\n      if ((*current_message & 1) == 0)\\n      {\\n        *current_message = *current_message | 1;\\n      }\\n      **message_data = **message_data & 0xfffff7ff;\\n      *(undefined *)((int)message_data + 0x3d) = 0x22;\\n      *(undefined *)((int)message_data + 0x3e) = 0x10;\\n      result = 0;\\n      message_data[0x10] = (uint32_t *)0x0;\\n      message_data[9] = param_3;\\n      *(uint16_t *)((int)message_data + 0x2a) = message_type;\\n      message_data[0xb] = DAT_080048c4;\\n      *(uint16_t *)(message_data + 10) = *(uint16_t *)((int)message_data + 0x2a);\\n      message_data[0x11] = param_2;\\n      **message_data = **message_data | 0x400;\\n      **message_data = **message_data | 0x100;\\n      *(undefined *)(message_data + 0xf) = 0;\\n      (*message_data)[1] = (*message_data)[1] | 0x700;\\n    }\\n  }\\n  else\\n  {\\n    result = 2;\\n  }\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080047f4",
        "calling": [
            "FUN_08007f0e"
        ],
        "current_name": "send_message_080047f4"
    },
    "FUN_0800376c": {
        "renaming": {
            "FUN_0800376c": "check_and_process_data_0800376c",
            "param_1": "data_ptr",
            "param_2": "data_size",
            "iVar1": "pointer_value",
            "puVar5": "data",
            "iVar3": "shifted_value",
            "uVar2": "multiplier",
            "local_1c": "counter"
        },
        "code": "int check_and_process_data_0800376c(uint **data_ptr, uint data_size) {\n  int pointer_value = get_pointer_value();\n  uint *data = *data_ptr;\n  if ((data[2] & 0x100) == 0) {\n    if (((data[1] & 0x100) == 0) && ((data[0xb] & 0xf00000) == 0)) {\n      while ((**data_ptr & 2) == 0) {\n        if ((data_size != 0xffffffff) && ((data_size != 0) && (get_pointer_value() - pointer_value > data_size))) {\n          (*data_ptr)[10] |= 4;\n          *(undefined *)(data_ptr + 9) = 0;\n          return 3;\n        }\n      }\n      (*data_ptr)[10] |= 4;\n      *(undefined *)(data_ptr + 9) = 0;\n      return 3;\n    }\n    else {\n      uint uVar6 = *(uint *)PTR_DAT_080038c8;\n      uint shifted_value = get_shifted_value(2);\n      if (((data[4] & DAT_080038cc) == 0) && ((data[3] & DAT_080038cc + 0xdc000000) == 0)) {\n        if ((data[4] & DAT_080038d0) == 0) {\n          if ((data[3] & DAT_080038d4) == 0) {\n            iVar3 = 0x14;\n          }\n          else {\n            iVar3 = 0x29;\n          }\n        }\n        else {\n          iVar3 = 0x29;\n        }\n      }\n      else if (((data[4] & DAT_080038d0) == 0) && ((data[3] & DAT_080038d0 + 0xee000000) == 0)) {\n        iVar3 = 0x54;\n      }\n      else if ((DAT_080038d8 & data[4]) == 0) {\n        if ((DAT_080038d8 & data[3]) == 0) {\n          iVar3 = 0x54;\n        }\n        else {\n          iVar3 = 0xfc;\n        }\n      }\n      else {\n        iVar3 = 0xfc;\n      }\n      uint uVar2 = (uVar6 / shifted_value) * iVar3;\n      while ((local_1c <= uVar2) && (uVar2 - local_1c != 0)) {\n        if ((data_size != 0xffffffff) && ((data_size != 0) && (get_pointer_value() - pointer_value > data_size))) {\n          (*data_ptr)[10] |= 4;\n          *(undefined *)(data_ptr + 9) = 0;\n          return 3;\n        }\n        local_1c++;\n      }\n      **data_ptr = 0xffffffed;\n      (*data_ptr)[10] |= 0x200;\n      if (((*data_ptr)[2] & 0xe0000) == 0xe0000) {\n        if (data_ptr[3] == (uint *)0x0) {\n          (*data_ptr)[10] &= 0xfffffeff;\n          if (((*data_ptr)[10] & 0x1000) == 0) {\n            (*data_ptr)[10] |= 1;\n            return 0;\n          }\n          else {\n            return 0;\n          }\n        }\n        else {\n          return 0;\n        }\n      }\n      else {\n        return 0;\n      }\n    }\n  }\n  else {\n    (*data_ptr)[10] |= 0x20;\n    *(undefined *)(data_ptr + 9) = 0;\n    return 1;\n  }\n}",
        "called": [
            "FUN_08003760",
            "FUN_08005bb8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800376c",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "check_and_process_data_0800376c"
    },
    "FUN_08003e20": {
        "renaming": {
            "FUN_08003e20": "check_and_activate_device_08003e20",
            "param_1": "data_ptr",
            "is_valid": "check_result",
            "uVar2": "shifted_value",
            "uVar5": "divisor",
            "local_14": "counter",
            "iVar1": "start_time",
            "iVar3": "current_time"
        },
        "code": "int check_and_activate_device_08003e20(int *data_ptr) {\n  int is_valid = check_if_pointer_is_valid();\n  if (is_valid == 0) {\n    data_ptr[10] = (data_ptr[10] & 0xffffeefd) | 2;\n    uint divisor = *(uint *)PTR_DAT_08003f08;\n    uint shifted_value = get_shifted_value_08005bb8(2);\n    int counter = divisor / shifted_value << 1;\n    while (counter != 0) {\n      counter--;\n    }\n    activate_device_08003a20(data_ptr);\n    *(uint *)(*data_ptr + 8) |= 8;\n    int start_time = get_pointer_value_08003760();\n    while ((*(uint *)(*data_ptr + 8) & 8) != 0) {\n      int current_time = get_pointer_value_08003760();\n      if (current_time - start_time > 10) {\n        data_ptr[10] = (data_ptr[10] & 0xffffffed) | 0x10;\n        *(undefined *)(data_ptr + 9) = 0;\n        return 1;\n      }\n    }\n    *(uint *)(*data_ptr + 8) |= 4;\n    start_time = get_pointer_value_08003760();\n    while ((*(uint *)(*data_ptr + 8) & 4) != 0) {\n      int current_time = get_pointer_value_08003760();\n      if (current_time - start_time > 10) {\n        data_ptr[10] = (data_ptr[10] & 0xffffffed) | 0x10;\n        *(undefined *)(data_ptr + 9) = 0;\n        return 1;\n      }\n    }\n    data_ptr[10] = (data_ptr[10] & 0xfffffffc) | 1;\n  }\n  return is_valid;\n}",
        "called": [
            "FUN_08003b8c",
            "FUN_08003760",
            "FUN_08003a20",
            "FUN_08005bb8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003e20",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "check_and_activate_device_08003e20"
    },
    "FUN_08005a48": {
        "renaming": {
            "FUN_08005a48": "get_shifted_value_from_pointer_08005a48",
            "uVar1": "shifted_value",
            "get_value_from_pointer_08005a1c": "get_value_from_pointer",
            "DAT_08005a60": "data_pointer",
            "PTR_DAT_08005a64": "shift_amount_pointer",
            "data_value": "shift_amount",
            "shifted_amount": "shift_amount_value",
            "shifted_result": "shifted_value"
        },
        "code": "uint get_shifted_value_from_pointer_08005a48(void)\n{\n  uint shifted_value = get_value_from_pointer_08005a1c();\n  int* DAT_08005a60 = DAT_08005a60 + 4;\n  int data_value = *DAT_08005a60 << 0x12;\n  uint shifted_amount = data_value >> 0x1d;\n  uint shifted_result = shifted_value >> PTR_DAT_08005a64[shifted_amount];\n  return shifted_result;\n}",
        "called": [
            "FUN_08005a1c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005a48",
        "calling": [
            "FUN_080075dc",
            "FUN_08005bb8",
            "FUN_08006538"
        ],
        "current_name": "get_shifted_value_from_pointer_08005a48"
    },
    "FUN_080033a8": {
        "renaming": {
            "FUN_080033a8": "copy_and_shift_bits_080033a8",
            "param_1": "dest",
            "param_2": "num_bytes",
            "param_3": "src",
            "bVar1": "current_byte",
            "iVar2": "dest_index",
            "uVar3": "src_index"
        },
        "code": "void copy_and_shift_bits_080033a8(byte* dest, const byte* src, const uint num_bytes) {\n  byte current_byte;\n  uint src_index = 0;\n  uint dest_index = 0;\n  for (uint i = 0; i < num_bytes; i += 2) {\n    current_byte = *(src + src_index);\n    *(dest + dest_index) = current_byte;\n    *(dest + dest_index + 1) = *(src + src_index + 1) << 7 | current_byte;\n    dest_index++;\n    src_index += 2;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080033a8",
        "calling": [
            "FUN_080033cc"
        ],
        "current_name": "copy_and_shift_bits_080033a8"
    },
    "FUN_08002c14": {
        "renaming": {
            "FUN_08002c14": "process_and_return_data_08002c14",
            "process_data_and_return_08002c00": "process_data_and_return",
            "process_data_08002c00": "process_data",
            "return_data_08002c0c": "return_data"
        },
        "code": "void process_and_return_data_08002c14(void)\n{\n  process_data();\n  return_data();\n}",
        "called": [
            "FUN_08002c00"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002c14",
        "calling": [
            "FUN_08001c18"
        ],
        "current_name": "process_and_return_data_08002c14"
    },
    "FUN_08008d18": {
        "renaming": {
            "FUN_08008d18": "setByteAtOffset_08008d18",
            "param_1": "offset",
            "param_2": "value",
            "uVar1": "byte"
        },
        "code": "void setByteAtOffset_08008d18(int offset, uint8_t value)\n{\n  uint8_t byte;\n  if (value < 0x3c) {\n    byte = PTR_DAT_08008d2c[value];\n  }\n  else {\n    byte = 0xff;\n  }\n  *(uint8_t *)(offset + 300) = byte;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008d18",
        "calling": [
            "FUN_08008d30"
        ],
        "current_name": "setByteAtOffset_08008d18"
    },
    "FUN_08009084": {
        "renaming": {
            "FUN_08009084": "execute_function_08009084",
            "param_1": "function_param",
            "iVar1": "bit_position",
            "update_pointers_and_call_0800a18c": "update_pointers_and_call",
            "get_bit_position_08008f3c": "get_bit_position"
        },
        "code": "void execute_function_08009084(int function_param) {\n  int bit_position = get_bit_position_08008f3c();\n  if (*(int *)(function_param + 8) != 0) {\n    (**(code **)(function_param + 0xc))();\n    return;\n  }\n  update_pointers_and_call();\n  if (*(int *)(PTR_DAT_080090b0 + bit_position * 0x14 + 0xc) != 0) {\n    execute_function_08009084(function_param);\n  }\n  return;\n}",
        "called": [
            "FUN_0800a18c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009084",
        "calling": [
            "FUN_08009094"
        ],
        "current_name": "execute_function_08009084"
    },
    "FUN_0800a020": {
        "renaming": {
            "FUN_0800a020": "processReturnValueAndUpdateValues_0800a020",
            "param_1": "processReturnValue",
            "param_2": "paramOffset",
            "iVar1": "returnValue",
            "uVar2": "updatedValue",
            "bVar3": "isReturnValuePositive"
        },
        "code": "void processReturnValueAndUpdateValues_0800a020(undefined4 processReturnValue, int paramOffset)\n{\n  int returnValue = processReturnValue(processReturnValue, (int)*(short *)(paramOffset + 0xe));\n  bool isReturnValuePositive = returnValue >= 0;\n  uint updatedValue;\n  if (isReturnValuePositive) {\n    updatedValue = *(int *)(paramOffset + 0x54) + returnValue;\n  }\n  else {\n    updatedValue = *(ushort *)(paramOffset + 0xc) & 0xffffefff;\n  }\n  if (isReturnValuePositive) {\n    *(uint *)(paramOffset + 0x54) = updatedValue;\n  }\n  if (!isReturnValuePositive) {\n    *(short *)(paramOffset + 0xc) = (short)updatedValue;\n  }\n  return;\n}",
        "called": [
            "FUN_0800a168"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a020",
        "calling": [],
        "current_name": "processReturnValueAndUpdateValues_0800a020"
    },
    "FUN_08005840": {
        "renaming": {
            "FUN_08005840": "calculate_value_08005840",
            "uVar1": "value",
            "uVar2": "flag",
            "local_1c": "offset",
            "abStack_18": "buffer",
            "uStack_14": "address1",
            "uStack_10": "address2",
            "uStack_c": "constant",
            "DAT_080058a0": "address0",
            "DAT_080058a4": "factor1",
            "DAT_080058a8": "factor2"
        },
        "code": "uint calculate_value_08005840(void)\\n{\\n  uint value = 0;\\n  uint flag = *(uint *)(DAT_080058a0 + 4);\\n  uint factor = DAT_080058a8;\\n  byte buffer[4];\\n  uint constant = *(uint *)(PTR_DAT_0800589c + 8);\\n  uint address2 = *(uint *)(PTR_DAT_0800589c + 4);\\n  uint address1 = *(uint *)PTR_DAT_0800589c;\\n  uint offset = *(uint *)(PTR_DAT_0800589c + 0x10);\\n  \\n  if ((flag & 0xc) == 8) {\\n    if ((flag & 0x10000) == 0) {\\n      value = DAT_080058a4 * (uint)buffer[(flag << 10) >> 0x1c];\\n    }\\n    else {\\n      value = (DAT_080058a8 * buffer[(flag << 10) >> 0x1c]) / (uint)*(byte *)((int)&offset - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\\n    }\\n  }\\n  return value;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005840",
        "calling": [
            "FUN_080058d2"
        ],
        "current_name": "calculate_value_08005840"
    },
    "FUN_08007f7c": {
        "renaming": {
            "FUN_08007f7c": "update_param_2_if_param_1_not_null_08007f7c",
            "param_1": "param_id",
            "param_2": "new_value",
            "PTR_": "",
            "DAT_": "",
            "int*": "pointer_to_int",
            "param_2_ptr": "pointer_to_param_2"
        },
        "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ update_param_2_if_param_1_not_null_08007f7c(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_,DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_wDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_wDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_6DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_wDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_8DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_4DAT_PDAT_TDAT_RDAT__DAT_9DAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_4DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\\DAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
        "called": [
            "FUN_080049e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007f7c",
        "calling": [
            "FUN_08002968"
        ],
        "current_name": "update_param_2_if_param_1_not_null_08007f7c"
    },
    "FUN_08006d80": {
        "renaming": {
            "FUN_08006d80": "process_device_parameter_08006d80",
            "param_1": "device_param",
            "iVar1": "param_value",
            "local_46": "result",
            "local_44": "param_index",
            "local_40": "ptr2",
            "local_3c": "ptr3",
            "local_38": "ptr",
            "local_34": "ptr4",
            "local_30": "ptr5",
            "local_2c": "ptr6",
            "local_28": "ptr7",
            "local_24": "ptr8",
            "local_20": "ptr9",
            "local_1c": "ptr6",
            "local_10": "ptr7",
            "PTR_DAT_08006e64": "ptr10",
            "fill_memory_with_value_080091c6": "fill_memory_with_value",
            "get_parameter_value_08007320": "get_parameter_value",
            "checkAndUpdatePointer_08003bd8": "check_and_update_pointer",
            "find_param_index_08006c60": "find_param_index",
            "set_param_value_080038e4": "set_param_value",
            "check_and_activate_device_08003e20": "check_and_activate_device",
            "activate_device_if_not_activated_before_08003aa0": "activate_device_if_not_activated_before",
            "check_and_process_data_0800376c": "check_and_process_data",
            "get_value_from_pointer_08003a1c": "get_value_from_pointer",
            "check_if_pointer_is_valid_08003de4": "check_if_pointer_is_valid",
            "deactivate_memory_region_08003ce8": "deactivate_memory_region"
        },
        "code": "undefined2 process_device_parameter_08006d80(undefined4 device_param)\n{\n  int param_value;\n  uint value_from_pointer;\n  undefined2 result = 0;\n  uint param_index;\n  undefined4 ptr;\n  undefined4 ptr2;\n  undefined4 ptr3;\n  undefined4 ptr4;\n  undefined4 ptr5;\n  undefined4 ptr6;\n  undefined4 ptr7;\n  undefined4 ptr8;\n  undefined4 ptr9;\n  undefined4 PTR_DAT_08006e64;\n  undefined4 ptr11;\n  undefined4 ptr12;\n  undefined4 ptr13;\n  undefined4 ptr14;\n  undefined4 ptr15;\n  undefined4 ptr16;\n  undefined4 ptr17;\n  undefined4 ptr18;\n  undefined4 ptr19;\n  undefined4 ptr20;\n  undefined4 ptr21;\n  undefined4 ptr22;\n  fill_memory_with_value_080091c6(&param_value,0,0x30);\n  ptr = get_parameter_value_08007320(device_param, 0x08006e60);\n  if (ptr == 0) {\n    result = 0;\n  }\n  else {\n    ptr2 = 0;\n    ptr3 = 0;\n    ptr4 = 0;\n    ptr5 = 0;\n    ptr6 = 0xe0000;\n    ptr7 = 0;\n    ptr8 = 1;\n    ptr9 = 0;\n    *PTR_DAT_08006e64 = (char)device_param;\n    if (check_and_update_pointer(&ptr) == 0) {\n      param_index = find_param_index_08006c60(device_param);\n      if (param_index < 0x12) {\n        ptr2 = 1;\n        ptr3 = 2;\n        if (set_param_value_080038e4(&ptr,&param_index) == 0) {\n          if (check_and_activate_device(&ptr) == 0) {\n            if (activate_device_if_not_activated_before_08003aa0(&ptr) == 0) {\n              if (check_and_process_data(&ptr,10) == 0) {\n                value_from_pointer = get_value_from_pointer_08003a1c(&ptr);\n                if ((value_from_pointer & 0x200) != 0) {\n                  result = get_value_from_pointer_08003a1c(&ptr);\n                }\n                if (check_if_pointer_is_valid_08003de4(&ptr) == 0) {\n                  if (deactivate_memory_region_08003ce8(&ptr) != 0) {\n                    result = 0;\n                  }\n                }\n                else {\n                  result = 0;\n                }\n              }\n              else {\n                result = 0;\n              }\n            }\n            else {\n              result = 0;\n            }\n          }\n          else {\n            result = 0;\n          }\n        }\n        else {\n          result = 0;\n        }\n      }\n      else {\n        result = 0;\n      }\n    }\n    else {\n      result = 0;\n    }\n  }\n  return result;\n}",
        "called": [
            "FUN_08003aa0",
            "FUN_080038dc",
            "FUN_08003e20",
            "FUN_08006c60",
            "FUN_08003de4",
            "FUN_08003ce8",
            "FUN_08003a1c",
            "FUN_08003bd8",
            "FUN_0800376c",
            "FUN_080091c6",
            "FUN_08007320",
            "FUN_080038e4"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006d80",
        "calling": [
            "FUN_08008880"
        ],
        "current_name": "process_device_parameter_08006d80"
    },
    "FUN_08006c60": {
        "renaming": {
            "FUN_08006c60": "find_param_index_08006c60",
            "param_1": "param_val",
            "param_2": "param_array",
            "param_3": "array_size",
            "param_4": "param_3",
            "iVar1": "index",
            "uVar2": "shifted_index"
        },
        "code": "uint find_param_index_08006c60(uint param_val, uint* param_array, uint array_size, uint param_3, uint param_4) {\n  int index = find_param_08007376(param_val, param_array, param_3, param_4, param_4);\n  uint shifted_index = (uint)(index << 12) >> 27;\n  if (shifted_index > 15) {\n    shifted_index = 0;\n  }\n  return shifted_index;\n}",
        "called": [
            "FUN_08007376"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006c60",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "find_param_index_08006c60"
    },
    "FUN_08003306": {
        "renaming": {
            "FUN_08003306": "set_values_08003306",
            "param_1": "obj_ptr",
            "param_2": "obj_id",
            "param_3": "value_a",
            "param_4": "value_b"
        },
        "code": "void set_values_08003306(int obj_ptr, uint8_t obj_id, uint32_t value_a, uint32_t value_b) {\n    switch(obj_id) {\n        case 0x90:\n            *(uint32_t *)(obj_ptr + 0x50) = value_a;\n            *(uint32_t *)(obj_ptr + 0x20) = value_b;\n            break;\n        case 0xc0:\n            *(uint32_t *)(obj_ptr + 0x54) = value_a;\n            *(uint32_t *)(obj_ptr + 0x24) = value_b;\n            break;\n        case 0xd0:\n            *(uint32_t *)(obj_ptr + 0x58) = value_a;\n            *(uint32_t *)(obj_ptr + 0x28) = value_b;\n            break;\n        case 0xe0:\n            *(uint32_t *)(obj_ptr + 0x4c) = value_a;\n            *(uint32_t *)(obj_ptr + 0x1c) = value_b;\n            break;\n        case 0xf4:\n            *(uint32_t *)(obj_ptr + 0x5c) = value_a;\n            *(uint32_t *)(obj_ptr + 0x2c) = value_b;\n            break;\n        case 0xf5:\n            *(uint32_t *)(obj_ptr + 0x60) = value_a;\n            *(uint32_t *)(obj_ptr + 0x30) = value_b;\n            break;\n        default:\n            break;\n    }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003306",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "set_values_08003306"
    },
    "FUN_08002578": {
        "renaming": {
            "FUN_08002578": "update_timer_status_08002578"
        },
        "code": "void update_timer_status_08002578() {\\n  update_timer_status_08002578_080076e0();\\n  return;\\n}",
        "called": [
            "FUN_080076e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002578",
        "calling": [
            "FUN_08002644"
        ],
        "current_name": "update_timer_status_08002578"
    },
    "FUN_08006932": {
        "renaming": {
            "FUN_08006932": "process_selected_item_and_clear_flag_08006932",
            "param_1": "selected_item_ptr",
            "PTR_DAT_08008730": "process_selected_item_08008730"
        },
        "code": "void process_selected_item_and_clear_flag_08006932(int *selected_item_ptr)\n{\n  uint *selected_item_ptr_offset_c = (uint *)(*selected_item_ptr + 0xc);\n  *selected_item_ptr_offset_c = (*selected_item_ptr_offset_c) & 0xffffffbf;\n  undefined *selected_item_ptr_offset_39 = (undefined *)((int)selected_item_ptr + 0x39);\n  *selected_item_ptr_offset_39 = 0x20;\n  PTR_DAT_08008730();\n  return;\n}",
        "called": [
            "FUN_08008730"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006932",
        "calling": [
            "FUN_080069ec"
        ],
        "current_name": "process_selected_item_and_clear_flag_08006932"
    },
    "FUN_080060c4": {
        "renaming": {
            "FUN_080060c4": "update_data_080060c4",
            "param_1": "data_address",
            "param_2": "data_values",
            "uVar1": "data_value_2",
            "uVar2": "data_mask_2",
            "iVar3": "data_value_1"
        },
        "code": "void update_data_080060c4(int data_address, int *data_values)\n{\n  uint data_mask_1 = *(uint *)(data_address + 0x20) & 0xffffffef;\n  uint data_mask_2 = *(uint *)(data_address + 4);\n  int data_value_1 = *data_values;\n  uint data_value_2 = ( *(uint *)(data_address + 0x20) & 0xffffffdf ) | ( data_values[2] << 4 );\n  if (data_address == DAT_08006124) {\n    data_value_2 = (data_value_2 & 0xffffff7f) | (data_values[3] << 4);\n    data_mask_2 = (data_mask_2 & 0xfffff3ff) | (data_values[5] << 2) | (data_values[6] << 2);\n  }\n  *(uint *)(data_address + 4) = data_mask_2;\n  *(uint *)(data_address + 0x18) = *(uint *)(data_address + 0x18) & 0xffff8cff | (data_value_1 << 8);\n  *(int *)(data_address + 0x38) = data_values[1];\n  *(uint *)(data_address + 0x20) = data_value_2;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080060c4",
        "calling": [
            "FUN_08006186",
            "FUN_08006128"
        ],
        "current_name": "update_data_080060c4"
    },
    "FUN_08009eac": {
        "renaming": {
            "FUN_08009eac": "check_and_allocate_memory_block_08009eac",
            "param_1": "device_id",
            "param_2": "device_data_ptr",
            "uVar1": "permission_result",
            "iVar2": "data_size",
            "local_18": "device_id_copy",
            "local_14": "data_ptr",
            "PTR_LAB_08009cd0_1_08009f28": "memory_block_pointer"
        },
        "code": "int check_and_allocate_memory_block_08009eac(int device_id, int *device_data_ptr) {\n  ushort permission_result;\n  int data_size;\n  int *data_ptr;\n  if ((uint)(*(ushort *)(device_data_ptr + 3)) << 0x1e < 0x80000000) {\n    permission_result = check_permission_and_copy_data(device_id, device_data_ptr, &data_size, &data_ptr);\n    int memory_block = allocate_memory_block(device_id, data_size);\n    if (memory_block != 0) {\n      *(undefined **)(device_id + 0x28) = PTR_LAB_08009cd0_1_08009f28;\n      *device_data_ptr = memory_block;\n      *(ushort *)(device_data_ptr + 3) |= 0x80;\n      device_data_ptr[4] = memory_block;\n      device_data_ptr[5] = data_size;\n      if (data_ptr != NULL) {\n        int function_result = set_value_from_function_result(device_id, *(short *)((int)device_data_ptr + 0xe));\n        if (function_result != 0) {\n          *(ushort *)(device_data_ptr + 3) &= 0xfffc | 1;\n        }\n      }\n      *(ushort *)(device_data_ptr + 3) |= permission_result;\n      return 1;\n    }\n    else if ((int)(short)*(ushort *)(device_data_ptr + 3) << 0x16 >= 0) {\n      *(ushort *)(device_data_ptr + 3) &= 0xfffc | 2;\n    }\n  }\n  else {\n    *device_data_ptr = (int)device_data_ptr + 0x47;\n    device_data_ptr[4] = (int)device_data_ptr + 0x47;\n    device_data_ptr[5] = 1;\n  }\n  return 0;\n}",
        "called": [
            "FUN_08009270",
            "FUN_08009e64",
            "FUN_0800a110"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009eac",
        "calling": [
            "FUN_08009a80"
        ],
        "current_name": "check_and_allocate_memory_block_08009eac"
    },
    "FUN_080072d8": {
        "renaming": {
            "FUN_080072d8": "set_parameter_value_based_on_condition_080072d8",
            "param_1": "parameter_value",
            "param_2": "parameter_type",
            "param_3": "condition",
            "param_4": "param_4",
            "set_parameter_value_080042e2": "set_parameter_value"
        },
        "code": "void set_parameter_value_based_on_condition_080072d8(uint *parameter_value, uint16_t *parameter_type, int condition, uint *param_4)\n{\n  if (condition == 0) {\n    set_parameter_value_080042e2(parameter_value, parameter_type, 0, param_4, param_4);\n    return;\n  }\n  set_parameter_value_080042e2(parameter_value, parameter_type, 1, param_4, param_4);\n  return;\n}",
        "called": [
            "FUN_080042e2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080072d8",
        "calling": [
            "FUN_08008a24"
        ],
        "current_name": "set_parameter_value_based_on_condition_080072d8"
    },
    "FUN_080045c0": {
        "renaming": {
            "FUN_080045c0": "calculate_and_set_parameters_080045c0",
            "param_1": "parameter_array",
            "bVar1": "condition",
            "uVar2": "shifted_value",
            "puVar3": "second_parameter",
            "uVar4": "calculated_value"
        },
        "code": "int calculate_and_set_parameters_080045c0(uint **parameter_array)\\n{\\n  if (parameter_array == NULL) {\\n    return 1;\\n  }\\n  if (*(char *)((int)parameter_array + 0x3d) == '\\0') {\\n    *(undefined *)(parameter_array + 0xf) = 0;\\n    do_nothing();\\n  }\\n  *(undefined *)((int)parameter_array + 0x3d) = 0x24;\\n  **parameter_array = **parameter_array & 0xfffffffe;\\n  uint shifted_value = get_shifted_value_from_pointer();\\n  bool condition = false;\\n  if (DAT_08004714 < parameter_array[1]) {\\n    condition = shifted_value <= DAT_08004720;\\n  }\\n  else if (DAT_08004718 < shifted_value) {\\n    condition = false;\\n  }\\n  else {\\n    condition = true;\\n  }\\n  if (condition) {\\n    return 1;\\n  }\\n  uint calculated_value = (uint)((ulonglong)DAT_0800471c * (ulonglong)shifted_value >> 0x32);\\n  (*parameter_array)[1] = calculated_value;\\n  if (DAT_08004714 < parameter_array[1]) {\\n    calculated_value = (uint)((ulonglong)DAT_08004724 * (ulonglong)(calculated_value * 300) >> 0x26);\\n  }\\n  (*parameter_array)[8] = calculated_value + 1;\\n  uint *second_parameter = parameter_array[1];\\n  if (DAT_08004714 < second_parameter) {\\n    uint divisor = parameter_array[2] == NULL ? 3 : 0x19;\\n    uint divisor_result = (shifted_value - 1) / (uint)((int)second_parameter * divisor) + 1 & 0xfff;\\n    uint leading_zeroes = count_leading_zeroes(divisor_result);\\n    if (leading_zeroes >> 5 == 0) {\\n      divisor_result |= parameter_array[2] == NULL ? 0x8000 : 0xc000;\\n    }\\n    else {\\n      divisor_result = 1;\\n    }\\n    (*parameter_array)[7] = divisor_result;\\n  }\\n  else {\\n    uint divisor = (int)second_parameter << 1;\\n    uint divisor_result = (shifted_value - 1) / divisor + 1 & 0xfff;\\n    if (divisor_result < 4) {\\n      divisor_result = 4;\\n    }\\n    (*parameter_array)[7] = divisor_result;\\n  }\\n  **parameter_array = (uint)parameter_array[7] | (uint)parameter_array[8];\\n  (*parameter_array)[2] = (uint)parameter_array[4] | (uint)parameter_array[3];\\n  (*parameter_array)[3] = (uint)parameter_array[5] | (uint)parameter_array[6];\\n  **parameter_array = **parameter_array | 1;\\n  parameter_array[0x10] = NULL;\\n  *(undefined *)((int)parameter_array + 0x3d) = 0x20;\\n  parameter_array[0xc] = NULL;\\n  *(undefined *)((int)parameter_array + 0x3e) = 0;\\n  return 0;\\n}",
        "called": [
            "FUN_080045bc",
            "FUN_08005a28"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080045c0",
        "calling": [
            "FUN_080077b0"
        ],
        "current_name": "calculate_and_set_parameters_080045c0"
    },
    "FUN_08007e74": {
        "renaming": {
            "FUN_08007e74": "check_and_update_value_08007e74",
            "param_1": "value_offset",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "param_4",
            "iVar1": "initial_pointer_value",
            "uVar3": "difference",
            "iVar4": "return_value",
            "iVar5": "current_value",
            "iVar2": "value_at_offset",
            "loop_condition": "loop_condition"
        },
        "code": "int check_and_update_value_08007e74(int value_offset, uint param_2, uint param_3, uint param_4)\n{\n  int initial_pointer_value = get_pointer_value_08003760();\n  uint difference = 0;\n  int return_value = 2;\n  do {\n    int current_value = value_offset + 4;\n    int check_result = check_and_update_08004728(current_value, param_2, param_3, param_4, param_4);\n    if (check_result == 0) {\n      return_value = 0;\n      int loop_condition = 0;\n      while ((loop_condition = get_character_at_offset_0800542a(current_value)) != 0x20 && (return_value == 0)) {\n        int pointer_value = get_pointer_value_08003760();\n        difference = pointer_value - initial_pointer_value;\n        if (difference < 0x65) {\n          int value_at_offset = get_value_from_offset_08005430(current_value);\n          if (value_at_offset != 0) {\n            return_value = 2;\n          }\n        }\n        else {\n          return_value = 1;\n        }\n      }\n    }\n    int value_at_offset = get_value_from_offset_08005430(current_value);\n  } while ((value_at_offset == 4) && (difference < 100));\n  return return_value;\n}",
        "called": [
            "FUN_08004728",
            "FUN_08003760",
            "FUN_0800542a",
            "FUN_08005430"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007e74",
        "calling": [
            "FUN_08002a58"
        ],
        "current_name": "check_and_update_value_08007e74"
    },
    "FUN_08002efe": {
        "renaming": {
            "FUN_08002efe": "execute_function_with_params_08002efe",
            "param_1": "base_offset",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "param_4",
            "execute_function_if_not_null_0800319e": "execute_function_if_not_null",
            "function_offset": "function_offset"
        },
        "code": "void execute_function_with_params_08002efe(int base_offset, undefined4 param_2, undefined2 param_3, undefined4 param_4)\n{\n  int function_offset = base_offset + 0x40;\n  execute_function_if_not_null_0800319e(function_offset, param_2, param_3, param_4, param_4);\n  return;\n}",
        "called": [
            "FUN_0800319e"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002efe",
        "calling": [
            "FUN_08000be8"
        ],
        "current_name": "execute_function_with_params_08002efe"
    },
    "FUN_08002f84": {
        "renaming": {
            "FUN_08002f84": "save_value_if_max_08002f84",
            "param_1": "value",
            "param_2": "max_value",
            "param_3": "ptr_max_value",
            "PTR_DAT_08002f90": "ptr_max_value"
        },
        "code": "void save_value_if_max_08002f84(uint8_t value, int max_value, uint32_t *PTR_DAT_08002f90) {\n  if (value == max_value) {\n    *PTR_DAT_08002f90 = value;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f84",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "save_value_if_max_08002f84"
    },
    "FUN_08002ddc": {
        "renaming": {
            "FUN_08002ddc": "executeCommandsOnObject_08002ddc",
            "param_1": "objectAddress",
            "param_2": "commandType",
            "param_3": "commandArg1",
            "param_4": "commandArg2"
        },
        "code": "void executeCommandsOnObject_08002ddc(int objectAddress, int commandType, int commandArg1, int commandArg2, int commandArg3) {\\n  execute_commands_on_object_0800322c(objectAddress + 0x40, commandType, commandArg1, commandArg2, commandArg3);\\n  return;\\n}",
        "called": [
            "FUN_0800322c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ddc",
        "calling": [
            "FUN_08002e26"
        ],
        "current_name": "executeCommandsOnObject_08002ddc"
    },
    "FUN_08009094": {
        "renaming": {
            "FUN_08009094": "execute_if_bit_set_08009094",
            "iVar1": "bit_position",
            "get_bit_position_08008f3c": "get_bit_position",
            "PTR_DAT_080090b0": "PTR",
            "execute_function_08009084": "execute_function"
        },
        "code": "void execute_if_bit_set_08009094() {\n  int bit_position = get_bit_position_08008f3c();\n  int* ptr = PTR_DAT_080090b0_DAT_080090b0 + bit_position * 0x14 + 0xc;\n  if (*ptr != 0) {\n    execute_function_08009084();\n  }\n  return;\n}",
        "called": [
            "FUN_08009084",
            "FUN_08008f3c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009094",
        "calling": [
            "FUN_080042f0"
        ],
        "current_name": "execute_if_bit_set_08009094"
    },
    "FUN_08009f2c": {
        "renaming": {
            "FUN_08009f2c": "find_character_08009f2c",
            "param_1": "string",
            "param_2": "target",
            "param_3": "length",
            "pcVar1": "current_char",
            "pcVar2": "next_char"
        },
        "code": "char* find_character_08009f2c(char* string, char target, int length) {\n  char* current_char = string;\n  while (current_char != string + length) {\n    if (*current_char == target) {\n      return current_char;\n    }\n    current_char++;\n  }\n  return NULL;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009f2c",
        "calling": [
            "FUN_0800937c",
            "FUN_08009698"
        ],
        "current_name": "find_character_08009f2c"
    },
    "FUN_0800a154": {
        "renaming": {
            "FUN_0800a154": "calculate_value_0800a154",
            "param_1": "ptr_value",
            "param_2": "ptr_offset",
            "iVar1": "value"
        },
        "code": "int calculate_value_0800a154(int ptr_value,int ptr_offset)\n{\n  int value = *(int *)(ptr_offset - 4) + -4;\n  if (*(int *)(ptr_offset - 4) < 0) {\n    value += *(int *)(ptr_offset + value);\n  }\n  return value;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a154",
        "calling": [
            "FUN_08009908"
        ],
        "current_name": "calculate_value_0800a154"
    },
    "FUN_08002580": {
        "renaming": {
            "FUN_08002580": "increment_and_set_08002580",
            "param_1": "output_byte",
            "bVar1": "current_byte_count"
        },
        "code": "void increment_and_set_08002580(byte *output_byte)\n{\n  byte current_byte_count = *PTR_DAT_080025a4;\n  if (current_byte_count > 11) {\n    *output_byte = 0xff;\n    return;\n  }\n  *PTR_DAT_080025a4 = current_byte_count + 1;\n  *output_byte = current_byte_count;\n  *(undefined4 *)(PTR_DAT_080025a8 + (uint)current_byte_count * 8 + 4) = 0x5dc;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002580",
        "calling": [
            "FUN_080004d4"
        ],
        "current_name": "increment_and_set_08002580"
    },
    "FUN_08007f8e": {
        "renaming": {
            "FUN_08007f8e": "set_param_value_if_not_null_08007f8e",
            "param_1": "param_value",
            "param_2": "param_address"
        },
        "code": "void set_param_value_if_not_null_08007f8e(int param_value, int param_address) {\n  if (param_address != 0) {\n    if (param_value != 0) {\n      *(int *)(param_address + 100) = param_value;\n      set_and_update_values_080049e0(param_address + 4);\n    }\n    return;\n  }\n  return;\n}",
        "called": [
            "FUN_080049e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007f8e",
        "calling": [
            "FUN_08002968"
        ],
        "current_name": "set_param_value_if_not_null_08007f8e"
    },
    "FUN_08006b3e": {
        "renaming": {
            "FUN_08006b3e": "set_bit_at_index_08006b3e",
            "param_1": "index",
            "param_2": "array",
            "uVar1": "shifted_index",
            "*(uint *)(param_2 + uVar1 * 4)": "target",
            "*(uint *)(param_2 + uVar1 * 4) | 1 << (param_1 & 0xf)": "*target |= mask"
        },
        "code": "void set_bit_at_index_08006b3e(uint index, int* array) {\\n  uint shifted_index = (index << 0x18) >> 0x1c;\\n  uint* target = (uint*)(array + shifted_index * 4);\\n  uint mask = 1 << (index & 0xf);\\n  *target |= mask;\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006b3e",
        "calling": [
            "FUN_080088e0",
            "FUN_08008990"
        ],
        "current_name": "set_bit_at_index_08006b3e"
    },
    "FUN_08006262": {
        "renaming": {
            "FUN_08006262": "set_bit_08006262",
            "param_1": "bit_array",
            "param_2": "bit_position",
            "param_3": "bit_value",
            "*(uint *)(param_1 + 0x20)": "*bit_array",
            "uint": "uint32_t",
            "&(1 << (param_2 & 0xff))": "mask",
            "|": "|=",
            "&": "&="
        },
        "code": "void set_bit_08006262(uint32_t *bit_array, uint32_t bit_position, uint32_t bit_value) {\\n  uint32_t mask = ~(1 << (bit_position & 0xff));\\n  *bit_array = (*bit_array & mask) | (bit_value << (bit_position & 0xff));\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006262",
        "calling": [
            "FUN_080062f4",
            "FUN_080063c0",
            "FUN_08006280",
            "FUN_08006390"
        ],
        "current_name": "set_bit_08006262"
    },
    "FUN_08007110": {
        "renaming": {
            "FUN_08007110": "set_flags_based_on_parameter_08007110"
        },
        "code": "void set_flags_based_on_parameter_08007110(void)\\n{\\n  set_flags_based_on_param_080074e0();\\n  return;\\n}",
        "called": [
            "FUN_080074e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007110",
        "calling": [
            "FUN_08005e2e"
        ],
        "current_name": "set_flags_based_on_parameter_08007110"
    },
    "FUN_08007594": {
        "renaming": {
            "FUN_08007594": "check_timer_08007594",
            "param_1": "timer_value",
            "DAT_080075d0": "timer_start_value",
            "DAT_080075d4": "timer_start_value_plus_1",
            "PTR_s_TIM__Unknown_timer_instance_080075d8": "timer_instance"
        },
        "code": "int check_timer_08007594(uint timer_value) {\n  if (timer_value == UINT32_MAX) {\n    return 0;\n  }\n  if (timer_value == DAT_080075d0) {\n    return 1;\n  }\n  if (DAT_080075d0 < timer_value) {\n    if (timer_value == DAT_080075d0 + 0x12400) {\n      return 2;\n    }\n    if (timer_value == DAT_080075d0 + 0x12400 + 0x12400) {\n      return 3;\n    }\n  }\n  else if (timer_value == 0x40000000) {\n    return 1;\n  }\n  initialize_and_call_timer_function(PTR_s_TIM__Unknown_timer_instance_080075d8);\n  return 0;\n}",
        "called": [
            "FUN_080098d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007594",
        "calling": [
            "FUN_080075dc"
        ],
        "current_name": "check_timer_08007594"
    },
    "FUN_080073ec": {
        "renaming": {
            "FUN_080073ec": "set_flags_080073ec",
            "puVar1": "flags_ptr",
            "DAT_0800742c": "flags_ptr",
            "DAT_08007430": "mask"
        },
        "code": "void set_flags_080073ec(void)\\n{\\n  uint *DAT_0800742c;\\n  DAT_0800742c = DAT_0800742c;\\n  *DAT_0800742c |= 1;\\n  DAT_0800742c[1] &= DAT_08007430;\\n  *DAT_0800742c &= 0xfef6ffff;\\n  *DAT_0800742c &= 0xfffbffff;\\n  DAT_0800742c[1] &= 0xff80ffff;\\n  DAT_0800742c[2] = 0x9f0000;\\n  *(undefined4 *)(DAT_08007434 + 8) = 0x8000000;\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080073ec",
        "calling": [
            "FUN_08003658"
        ],
        "current_name": "set_flags_080073ec"
    },
    "FUN_08008ef4": {
        "renaming": {
            "FUN_08008ef4": "calculate_new_value_08008ef4",
            "param_1": "initial_value",
            "param_2": "initial_range_start",
            "param_3": "initial_range_end",
            "param_4": "new_range_start",
            "param_5": "new_range_end"
        },
        "code": "int calculate_new_value_08008ef4(int initial_value, int initial_range_start, int initial_range_end, int new_range_start, int new_range_end) {\n    int initial_range = initial_range_end - initial_range_start;\n    int new_range = new_range_end - new_range_start;\n    int value_in_initial_range = initial_value - initial_range_start;\n    return (value_in_initial_range * new_range) / initial_range + new_range_start;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008ef4",
        "calling": [
            "FUN_080026b0"
        ],
        "current_name": "calculate_new_value_08008ef4"
    },
    "FUN_08002df6": {
        "renaming": {
            "FUN_08002df6": "encode_data_from_pointer_08002df6",
            "param_1": "pointer_address",
            "puVar1": "data",
            "data_size": "data_size",
            "encoded_data": "encoded_data",
            "data_size_minus_two": "data_size_minus_two",
            "data_offset": "data_offset"
        },
        "code": "void encode_data_from_pointer_08002df6(int pointer_address)\n{\n  byte* data = (byte*) *(pointer_address + 200);\n  byte data_size = *(byte*)(pointer_address + 0xc4);\n  if (data_size == 0) {\n    return;\n  }\n  byte* encoded_data = (byte*) (pointer_address + 0x40);\n  byte data_size_minus_two = data_size - 2;\n  byte* data_offset = data + 2;\n  encode_data_080031ce(encoded_data, data, data[1], data_size_minus_two, data_offset);\n  return;\n}",
        "called": [
            "FUN_080031ce"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002df6",
        "calling": [
            "FUN_08002e26"
        ],
        "current_name": "encode_data_from_pointer_08002df6"
    },
    "FUN_080045bc": {
        "renaming": {
            "FUN_080045bc": "do_nothing_080045bc"
        },
        "code": "void do_nothing_080045bc(void) {\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080045bc",
        "calling": [
            "FUN_080045c0"
        ],
        "current_name": "do_nothing_080045bc"
    },
    "FUN_08007118": {
        "renaming": {
            "FUN_08007118": "update_flags_and_registers_08007118",
            "param_1": "source",
            "param_2": "frequency",
            "param_3": "value",
            "param_4": "flag",
            "param_5": "enable_interrupts",
            "local_74": "flag_mask",
            "local_70": "set_flag",
            "local_6c": "interrupt_flag",
            "local_68": "register_flag",
            "local_64": "set_bit",
            "local_60": "bit_mask",
            "local_5c": "parameter",
            "local_58": "parameter_value",
            "local_54": "divisor",
            "local_50": "unused",
            "local_4c": "unused",
            "local_48": "unused",
            "local_44": "unused",
            "local_1b": "unused",
            "PTR_DAT_080071dc": "PARAMETER_POINTER",
            "PTR_DAT_080071e0": "PARAMETER_POINTER_2",
            "fill_memory_with_value_080091c6": "fill_memory_with_value",
            "get_parameter_value_08007320": "get_parameter_value",
            "check_clock_source_080075dc": "check_clock_source",
            "check_and_update_registers_08006092": "check_and_update_registers",
            "find_parameter_value_08006c7c": "find_parameter_value",
            "update_flags_08006186": "update_flags",
            "find_param_08007376": "find_param",
            "set_bit_and_update_08006390": "set_bit_and_update",
            "set_flag_and_enable_interrupts_0800643c": "set_flag_and_enable_interrupts"
        },
        "code": "void update_flags_and_registers_08007118(uint8_t source, uint frequency, int value, uint8_t flag, char enable_interrupts) {\\n  uint clock_source = check_clock_source();\\n  int divisor = clock_source / frequency - 1;\\n  int parameter_value = value + -1;\\n  uint bit_mask = 0;\\n  uint flag_mask = 0x60;\\n  uint parameter = get_parameter_value_08007320(source, PTR_DAT_080071dc);\\n  if (parameter != 0) {\\n    uint parameter_type = find_parameter_value_08006c7c(source);\\n    if ((((parameter_type == 0) || (parameter_type == 4)) || (parameter_type == 8)) || ((parameter_type == 0xc || (parameter_type == 0x18)))) {\\n      uint8_t interrupt_flag = 0;\\n      uint8_t register_flag = 0;\\n      uint8_t set_flag = 0;\\n      uint8_t set_bit = 0;\\n      if (enable_interrupts == '\\x01') {\\n        *PTR_DAT_080071e0 = (char)source;\\n        int register_check = check_and_update_registers_08006092(&parameter);\\n        if (register_check != 0) {\\n          return;\\n        }\\n      }\\n      flag_mask = 0x60;\\n      set_flag = 0;\\n      interrupt_flag = 0;\\n      register_flag = 0;\\n      bit_mask = flag;\\n      parameter_value = value + -1;\\n      divisor = clock_source / frequency - 1;\\n      parameter = PTR_DAT_080071dc_1;\\n      int flag_check = update_flags_08006186(&parameter, &flag_mask, parameter_type);\\n      if (flag_check == 0) {\\n        uint parameter_check = find_param_08007376(source, PTR_DAT_080071dc);\\n        if ((parameter_check & 0x100000) == 0) {\\n          set_bit_and_update_08006390(&parameter, parameter_type);\\n        }\\n        else {\\n          set_flag_and_enable_interrupts_0800643c(&parameter, parameter_type);\\n        }\\n      }\\n    }\\n  }\\n  return;\\n}",
        "called": [
            "FUN_080075dc",
            "FUN_08006186",
            "FUN_08007376",
            "FUN_0800643c",
            "FUN_08006092",
            "FUN_08006c7c",
            "FUN_08006390",
            "FUN_080091c6",
            "FUN_08007320"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007118",
        "calling": [
            "FUN_080088e0"
        ],
        "current_name": "update_flags_and_registers_08007118"
    },
    "FUN_08009fe8": {
        "renaming": {
            "FUN_08009fe8": "process_input_08009fe8",
            "param_1": "input_size",
            "puVar1": "error_ptr",
            "uVar2": "function_result",
            "piVar3": "function_ptr",
            "iVar4": "function_result_copy",
            "pcVar5": "function_ptr_value",
            "unaff_r4": "error_ptr_copy",
            "unaff_r5": "error_ptr_copy2",
            "in_lr": "unused",
            "puVar6": "error_ptr_copy3"
        },
        "code": "int process_input_08009fe8(uint input_size)\n{\n  int* error_ptr = *(int**)global_error_ptr;\n  if (input_size > 31) {\n    *error_ptr = 22;\n    return -1;\n  }\n  int* function_ptr = error_ptr[17];\n  if (function_ptr != 0 && function_ptr[input_size] != (code*)0) {\n    if (function_ptr[input_size] != (code*)1) {\n      if (function_ptr[input_size] == (code*)-1) {\n        *error_ptr = 22;\n        return 1;\n      }\n      function_ptr[input_size] = 0;\n      (*(code*)function_ptr[input_size])(input_size);\n    }\n    return 0;\n  }\n  undefined* error_ptr_copy = global_error_ptr;\n  int function_result = return_one(input_size, error_ptr);\n  undefined* error_ptr_copy2 = global_data_ptr;\n  *(undefined4*)global_data_ptr = 0;\n  int initialization_result = initialize_value(function_result, input_size, input_size, 0, error_ptr_copy, 0, 0, 0);\n  if (initialization_result == -1 && *(int*)error_ptr_copy2 != 0) {\n    *error_ptr = *(int*)error_ptr_copy2;\n  }\n  return initialization_result;\n}",
        "called": [
            "FUN_0800886c",
            "thunk_FUN_0800887c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009fe8",
        "calling": [
            "FUN_08009b5c"
        ],
        "current_name": "process_input_08009fe8"
    },
    "FUN_08002c1e": {
        "renaming": {
            "FUN_08002c1e": "set_default_values_if_param_is_one_and_param2_is_0xffff_08002c1e",
            "param_1": "is_param_one",
            "param_2": "param2",
            "param_3": "ptr_param3",
            "param_4": "ptr_param4"
        },
        "code": "void set_default_values_if_param_is_one_and_param2_is_0xffff_08002c1e(uint8_t is_param_one, uint16_t param2, uint32_t* ptr_param3, uint32_t* ptr_param4)\n{\n  if (is_param_one == 1 && param2 == 0xffff) {\n    *ptr_param3 = 0;\n    *ptr_param4 = 0;\n  }\n  return;\n}",
        "called": [
            "FUN_08002948"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002c1e",
        "calling": [],
        "current_name": "set_default_values_if_param_is_one_and_param2_is_0xffff_08002c1e"
    },
    "FUN_08005a68": {
        "renaming": {
            "FUN_08005a68": "extract_data_08005a68",
            "param_1": "data_out",
            "param_2": "data_in",
            "iVar1": "ptr_data"
        },
        "code": "void extract_data_08005a68(uint32_t *data_out, uint32_t *data_in)\n{\n  // Extract data from input\n  data_out[0] = 0xf;\n  uint32_t *ptr_data = (uint32_t*)(&DAT_08005a9c);\n  data_out[1] = ptr_data[1] & 3;\n  data_out[2] = ptr_data[1] & 0xf0;\n  data_out[3] = ptr_data[1] & 0x700;\n  data_out[4] = ptr_data[1] >> 3 & 0x700;\n  // Extract data from global variable\n  *data_in = *DAT_08005aa0 & 7;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005a68",
        "calling": [
            "FUN_080075dc"
        ],
        "current_name": "extract_data_08005a68"
    },
    "FUN_08008f78": {
        "renaming": {
            "FUN_08008f78": "initialize_data_08008f78",
            "param_1": "device_id",
            "param_2": "device_data_ptr",
            "param_3": "permission_result",
            "param_4": "data_size",
            "puVar1": "data_ptr"
        },
        "code": "void initialize_data_08008f78(int param_1, int param_2, undefined4 param_3, undefined4 param_4) {\n  undefined *data_ptr = PTR_DAT_08009018;\n  if (param_1 != 1) {\n    return;\n  }\n  if (param_2 == 0xffff) {\n    data_ptr[0] = 6;\n    *(undefined4 *)(data_ptr + 0xc) = 0;\n    data_ptr[0x14] = 7;\n    *(undefined4 *)(data_ptr + 0x20) = 0;\n    data_ptr[0x28] = 8;\n    *(undefined4 *)(data_ptr + 0x34) = 0;\n    data_ptr[0x3c] = 9;\n    *(undefined4 *)(data_ptr + 0x48) = 0;\n    data_ptr[0x50] = 10;\n    *(undefined4 *)(data_ptr + 0x5c) = 0;\n    data_ptr[100] = 0x17;\n    *(undefined4 *)(data_ptr + 0x70) = 0;\n    data_ptr[0x78] = 0x17;\n    *(undefined4 *)(data_ptr + 0x84) = 0;\n    data_ptr[0x8c] = 0x17;\n    *(undefined4 *)(data_ptr + 0x98) = 0;\n    data_ptr[0xa0] = 0x17;\n    *(undefined4 *)(data_ptr + 0xac) = 0;\n    data_ptr[0xb4] = 0x17;\n    *(undefined4 *)(data_ptr + 0xc0) = 0;\n    data_ptr[200] = 0x28;\n    *(undefined4 *)(data_ptr + 0xd4) = 0;\n    data_ptr[0xdc] = 0x28;\n    *(undefined4 *)(data_ptr + 0xe8) = 0;\n    data_ptr[0xf0] = 0x28;\n    *(undefined4 *)(data_ptr + 0xfc) = 0;\n    data_ptr[0x104] = 0x28;\n    *(undefined4 *)(data_ptr + 0x110) = 0;\n    data_ptr[0x118] = 0x28;\n    *(undefined4 *)(data_ptr + 0x124) = 0;\n    data_ptr[300] = 0x28;\n    *(undefined4 *)(data_ptr + 0x138) = 0;\n    combine_values(0, PTR_LAB_08008f50_1_08009020, PTR_DAT_0800901c, data_ptr, param_4);\n  }\n  return;\n}",
        "called": [
            "FUN_080090c2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008f78",
        "calling": [],
        "current_name": "initialize_data_08008f78"
    },
    "FUN_08008d30": {
        "renaming": {
            "FUN_08008d30": "initialize_data_structure_and_set_defaults_08008d30",
            "param_1": "data_structure",
            "param_2": "key",
            "param_3": "value1",
            "param_4": "value2"
        },
        "code": "undefined4* initialize_data_structure_and_set_defaults_08008d30(undefined4 *data_structure, undefined4 key, undefined4 value1, undefined4 value2)\n{\n  data_structure[1] = 0;\n  data_structure[2] = 1000;\n  *data_structure = PTR_PTR_LAB_08008ba4_1_08008d7c;\n  if (data_structure == (undefined4 *)PTR_DAT_08008d80) {\n    set_value_at_address_based_on_index_08008d00(data_structure, 0, value1, PTR_DAT_08008d80, value2);\n    setByteAtOffset_08008d18(data_structure, 1);\n  }\n  else {\n    undefined found_value = find_value_if_key_not_null_0800734a(key, PTR_DAT_08008d84);\n    *(undefined *)((int)data_structure + 0x12d) = found_value;\n    found_value = find_value_if_key_not_null_0800734a(key, PTR_DAT_08008d88);\n    *(undefined *)(data_structure + 0x4b) = found_value;\n  }\n  initialize_data_structures_08008c20(data_structure);\n  return data_structure;\n}",
        "called": [
            "FUN_0800734a",
            "FUN_08008d00",
            "FUN_08008d18",
            "FUN_08008c20"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008d30",
        "calling": [
            "FUN_08008d8c"
        ],
        "current_name": "initialize_data_structure_and_set_defaults_08008d30"
    },
    "FUN_08002f94": {
        "renaming": {
            "FUN_08002f94": "store_parameter_in_memory_location_08002f94",
            "param_1": "parameter_value",
            "param_2": "memory_location",
            "param_3": "memory_location_value",
            "*PTR_DAT_08002f9c": "memory_location"
        },
        "code": "void store_parameter_in_memory_location_08002f94(undefined4 parameter_value, undefined4* *PTR_DAT_08002f9c){\\n  **PTR_DAT_08002f9c = parameter_value;\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f94",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "store_parameter_in_memory_location_08002f94"
    },
    "FUN_0800734a": {
        "renaming": {
            "FUN_0800734a": "find_value_if_key_not_null_0800734a",
            "param_1": "key_address",
            "uVar1": "value"
        },
        "code": "int find_value_if_key_not_null_0800734a(int key_address) {\n  if (key_address != 0) {\n    int value = find_value_by_key_08007332();\n    return value;\n  }\n  return -1;\n}",
        "called": [
            "FUN_08007332"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800734a",
        "calling": [
            "FUN_08008d30",
            "FUN_080084b0"
        ],
        "current_name": "find_value_if_key_not_null_0800734a"
    },
    "FUN_08000aec": {
        "renaming": {
            "FUN_08000aec": "clear_data_and_reset_flags_08000aec",
            "bVar1": "is_valid_char",
            "iVar2": "char_value",
            "uVar3": "i",
            "uVar4": "char_index",
            "PTR_DAT_08000bc0": "flag_pointer",
            "PTR_DAT_08000bc4": "reset_flag_pointer",
            "PTR_DAT_08000bc8": "data_pointer_1",
            "PTR_DAT_08000bcc": "data_pointer_2",
            "PTR_DAT_08000bd0": "data_pointer_3",
            "PTR_DAT_08000bd4": "char_array",
            "PTR_DAT_08000bd8": "data_pointer_4",
            "PTR_DAT_08000bdc": "data_pointer_5",
            "PTR_DAT_08000be0": "data_pointer_6",
            "PTR_DAT_08000be4": "data_pointer_7",
            "clear_memory_080005e0": "clear_memory",
            "FUNC_080005f8": "send_data",
            "input_data": "input_char",
            "valid_chars": "valid_chars"
        },
        "code": "void clear_data_and_reset_flags_08000aec(void)\n{\n  bool is_valid_char;\n  int char_value;\n  int char_index;\n  int i;\n  uint8_t input_char;\n  uint8_t valid_chars[14] = {0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E};\n  *PTR_DAT_08000bc0 = 1;\n  if (*PTR_DAT_08000bc4 != 0x00) {\n    clear_memory_080005e0();\n  }\n  for (i = 0; i < 5; i++) {\n    PTR_DAT_08000bc8[i] = 0;\n    PTR_DAT_08000bcc[i] = 0;\n    PTR_DAT_08000bd0[i] = 0;\n  }\n  for (i = 0; i < 0x3c; i++) {\n    if ((i - 0x2e) < 0xe) {\n      if (i < 0x3c) {\n        char_value = (int)(char)PTR_DAT_08000bd4[i];\n      }\n      else {\n        char_value = -1;\n      }\n      char_index = find_char_index(char_value);\n      if (char_index == 0) {\n        is_valid_char = false;\n      }\n      else {\n        if (i < 0x3c) {\n          char_value = (int)(char)PTR_DAT_08000bd4[i];\n        }\n        else {\n          char_value = -1;\n        }\n        char_index = find_char_index(char_value);\n        if (char_index == 1) {\n          is_valid_char = false;\n        }\n        else {\n          is_valid_char = true;\n        }\n      }\n    }\n    else {\n      is_valid_char = false;\n    }\n    if (is_valid_char) {\n      input_char = 2;\n      send_data(i, input_char);\n    }\n    else {\n      if (i < 0x3c) {\n        if ((PTR_DAT_08000bd4[i] != -1) && (find_char_index(PTR_DAT_08000bd4[i]) != 0) && (find_char_index(PTR_DAT_08000bd4[i]) != 1)) {\n          input_char = 1;\n          send_data(i, input_char);\n        }\n      }\n    }\n    PTR_DAT_08000bd8[i] = 0xff;\n  }\n  *(int *)PTR_DAT_08000bdc = 0;\n  *PTR_DAT_08000be0 = 0;\n  *PTR_DAT_08000be4 = 0;\n  *PTR_DAT_08000bc0 = 0;\n  return;\n}",
        "called": [
            "FUN_080005f8",
            "FUN_080036ac",
            "FUN_080005e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000aec",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "clear_data_and_reset_flags_08000aec"
    },
    "FUN_08008eec": {
        "renaming": {
            "FUN_08008eec": "convert_base_if_not_zero_08008eec",
            "convert_base_if_not_zero_08008ed6": "check_if_base_should_be_converted",
            "convert_base": "convert_base"
        },
        "code": "void convert_base_if_not_zero_08008eec(void)\n{\n  bool should_convert = check_if_base_should_be_converted();\n  if (should_convert) {\n    convert_base();\n  }\n  return;\n}",
        "called": [
            "FUN_08008ed6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008eec",
        "calling": [],
        "current_name": "convert_base_if_not_zero_08008eec"
    },
    "FUN_080068d6": {
        "renaming": {
            "FUN_080068d6": "set_params_080068d6",
            "param_1": "param_list",
            "param_2": "param_2",
            "param_3": "param_3"
        },
        "code": "int set_params_080068d6(int *param_list, int param_2, int param_3) {\n  if (*(char *)((int)param_list + 0x3a) != ' ') {\n    return 2;\n  }\n  if (param_2 == 0) {\n    return 1;\n  }\n  if (param_3 == 0) {\n    return 1;\n  }\n  if (*(char *)(param_list + 0xe) != '\\x01') {\n    param_list[10] = param_2;\n    *(short *)(param_list + 0xb) = (short)param_3;\n    *(short *)((int)param_list + 0x2e) = (short)param_3;\n    param_list[0xf] = 0;\n    *(undefined *)((int)param_list + 0x3a) = 0x22;\n    *(undefined *)(param_list + 0xe) = 0;\n    *(uint *)(*param_list + 0xc) |= 0x100;\n    *(uint *)(*param_list + 0x14) |= 1;\n    *(uint *)(*param_list + 0xc) |= 0x20;\n    return 0;\n  }\n  return 2;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080068d6",
        "calling": [
            "FUN_0800863c",
            "FUN_08008600"
        ],
        "current_name": "set_params_080068d6"
    },
    "FUN_080032a2": {
        "renaming": {
            "FUN_080032a2": "process_string_data_if_not_empty_080032a2",
            "param_1": "destination",
            "param_2": "source",
            "param_3": "additional_data",
            "param_4": "DAT_080032a6",
            "uVar1": "string_end",
            "find_string_end_08000178": "find_string_end",
            "process_data_0800325a": "process_data",
            "data_type": "data_type"
        },
        "code": "void process_string_data_if_not_empty_080032a2(void* destination, void* source, void* additional_data)\n{\n  void* string_end = find_string_end_08000178(source);\n  int data_type = 0x71;\n  process_data(destination, data_type, string_end, source, additional_data);\n  return;\n}",
        "called": [
            "FUN_08000178",
            "FUN_0800325a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080032a2",
        "calling": [
            "FUN_08002f14"
        ],
        "current_name": "process_string_data_if_not_empty_080032a2"
    },
    "FUN_08001b48": {
        "renaming": {
            "FUN_08001b48": "initialize_device_08001b48",
            "PTR_DAT_08001bc0": "device_list_ptr",
            "PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4": "device_firmware_name_ptr",
            "PTR_FUN_08000214_1_08001bc8": "device_init_func_ptr",
            "PTR_LAB_080002ec_1_08001bcc": "device_init_label_ptr",
            "DAT_08001bd0": "device_data_ptr",
            "PTR_LAB_08000c18_1_08001bd4": "device_label_ptr",
            "DAT_08001bd8": "device_data_flag_ptr",
            "PTR_LAB_080001a8_1_08001bdc": "device_label_flag_ptr",
            "PTR_FUNC_08001cd0_1_08001be0": "device_func_ptr",
            "DAT_08001be4": "device_max_value_ptr",
            "executeDeviceCommandsAndWriteDataToDevice_08003048": "execute_device_commands_and_write_data_to_device",
            "clear_data_and_reset_flags_08000aec": "clear_data_and_reset_flags",
            "send_software_interrupt_0800018c": "send_software_interrupt"
        },
        "code": "void initialize_device_08001b48(void)\n{\n  undefined *device_ptr;\n  device_ptr = PTR_DAT_08001bc0;\n  create_new_element_in_list(PTR_DAT_08001bc0, PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4, 2, 5);\n  set_value_at_address(device_ptr, 0xe0, PTR_process_value_08000214_1_08001bc8);\n  set_value_at_address(device_ptr, 0x90, PTR_LAB_080002ec_1_08001bcc);\n  set_value_at_address(device_ptr, 0xc0, DAT_08001bd0);\n  set_value_at_address(device_ptr, 0xd0, PTR_LAB_08000c18_1_08001bd4);\n  set_value_at_address(device_ptr, 0xf4, DAT_08001bd8);\n  set_value_at_address(device_ptr, 0xf5, PTR_LAB_080001a8_1_08001bdc);\n  store_parameter_in_memory_location(device_ptr, 0xf0, PTR_FUNC_08001cd0_1_08001be0);\n  save_value_if_max(device_ptr, 0xff, DAT_08001be4);\n  execute_device_commands_and_write_data_to_device(device_ptr, 0xe100);\n  clear_data_and_reset_flags_08000aec();\n  send_software_interrupt_0800018c(0);\n  return;\n}",
        "called": [
            "FUN_08003048",
            "FUN_08002e44",
            "FUN_08002f2c",
            "FUN_08002f94",
            "FUN_0800018c",
            "FUN_08000aec",
            "FUN_08002f84"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08001b48",
        "calling": [
            "FUN_08008f1c"
        ],
        "current_name": "initialize_device_08001b48"
    },
    "FUN_08006390": {
        "renaming": {
            "FUN_08006390": "set_bit_and_update_08006390",
            "param_1": "bit_array",
            "param_2": "bit_index",
            "puVar1": "current_array"
        },
        "code": "int set_bit_and_update_08006390(uint** bit_array, uint bit_index) {\n  uint* current_array = *bit_array;\n  set_bit(current_array, bit_index, 1);\n\n  if (current_array == PTR_DAT_080063bc) {\n    current_array[17] |= 0x8000;\n  }\n\n  **bit_array |= 1;\n  return 0;\n}",
        "called": [
            "FUN_08006262"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006390",
        "calling": [
            "FUN_08007118"
        ],
        "current_name": "set_bit_and_update_08006390"
    },
    "FUN_08009f48": {
        "renaming": {
            "FUN_08009f48": "do_nothing_08009f48"
        },
        "code": "void do_nothing_08009f48() {\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009f48",
        "calling": [
            "FUN_08009270",
            "FUN_080091d8"
        ],
        "current_name": "do_nothing_08009f48"
    },
    "FUN_08004d6a": {
        "renaming": {
            "FUN_08004d6a": "do_nothing_08004d6a"
        },
        "code": "void do_nothing_08004d6a() {\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004d6a",
        "calling": [
            "FUN_08004e3c",
            "FUN_08004d6c"
        ],
        "current_name": "do_nothing_08004d6a"
    },
    "FUN_08008730": {
        "renaming": {
            "FUN_08008730": "process_selected_item_08008730",
            "uVar1": "selected_item_index",
            "iVar2": "selected_item_effect_result",
            "iVar3": "selected_item_data",
            "find_number_080086e8": "find_selected_item_index",
            "PTR_DAT_08008770": "PTR_ITEM_DATA_TABLE",
            "PTR_DAT_08008774": "PTR_ITEM_EFFECT_FUNCTION_TABLE",
            "PTR_DAT_08008778": "PTR_ITEM_EFFECT_DATA_TABLE",
            "*(byte *)(iVar3 + 0x44)": "*(byte *)(selected_item_data + ITEM_EFFECT_INDEX_OFFSET)",
            "*(int *)(iVar3 + 100)": "*(int *)(selected_item_data + ITEM_EFFECT_VALUE_OFFSET)",
            "*(ushort *)(iVar3 + 0x6a)": "*(ushort *)(selected_item_data + ITEM_EFFECT_ADDITIONAL_VALUE_OFFSET)"
        },
        "code": "void process_selected_item_08008730(void)\n{\n  uint selected_item_index = find_number_080086e8();\n  int selected_item_data = *(int *)(PTR_DAT_08008770 + selected_item_index * 4);\n  if ((selected_item_index < 5) && (selected_item_data != -1)) {\n    uint item_effect_index = (uint)*(byte *)(selected_item_data + ITEM_EFFECT_INDEX_OFFSET) * 4;\n    int item_effect_value = *(int *)(selected_item_data + ITEM_EFFECT_VALUE_OFFSET) + (uint)*(ushort *)(selected_item_data + ITEM_EFFECT_ADDITIONAL_VALUE_OFFSET);\n    set_data(item_effect_index, item_effect_value, 1);\n  }\n  return;\n}",
        "called": [
            "FUN_0800688e",
            "FUN_080086e8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008730",
        "calling": [
            "FUN_08006932"
        ],
        "current_name": "process_selected_item_08008730"
    },
    "FUN_08005df4": {
        "renaming": {
            "FUN_08005df4": "set_flags_and_clear_flag_if_appropriate_08005df4",
            "param_1": "selected_item_ptr",
            "puVar1": "item_ptr"
        },
        "code": "void set_flags_and_clear_flag_if_appropriate_08005df4(uint **selected_item_ptr)\n{\n  uint *item_ptr = *selected_item_ptr;\n  *(undefined *)((int)selected_item_ptr + 0x3d) = 2;\n  if ((item_ptr[8] & 0x1111) == 0 && (item_ptr[8] & 0x444) == 0) {\n    *item_ptr &= 0xfffffffe;\n  }\n  set_flags_based_on_parameter_08007710(selected_item_ptr);\n  *(undefined *)((int)selected_item_ptr + 0x3d) = 0;\n  *(undefined *)(selected_item_ptr + 0xf) = 0;\n  return;\n}",
        "called": [
            "FUN_08007710"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005df4",
        "calling": [
            "FUN_080076e0"
        ],
        "current_name": "set_flags_and_clear_flag_if_appropriate_08005df4"
    },
    "FUN_08009148": {
        "renaming": {
            "FUN_08009148": "execute_all_functions_08009148",
            "puVar1": "function_pointer_array",
            "iVar2": "function_pointer_array_size",
            "iVar3": "i",
            "PTR_DAT_08009180": "PTR_FUNCTION_POINTER_ARRAY_1",
            "PTR_DAT_08009184": "PTR_FUNCTION_POINTER_ARRAY_1_END",
            "PTR_DAT_08009188": "PTR_FUNCTION_POINTER_ARRAY_2",
            "PTR_DAT_0800918c": "PTR_FUNCTION_POINTER_ARRAY_2_END"
        },
        "code": "void execute_all_functions_08009148(void)\n{\n  uint function_count = (uint)(PTR_DAT_08009184 - PTR_DAT_08009180);\n  uint i;\n  for (i = 0; i < function_count; i++) {\n    (*(void (**)(void))(PTR_DAT_08009180 + i * 4))();\n  }\n  do_nothing_0800a424();\n  uint function_count_2 = (uint)(PTR_DAT_0800918c - PTR_DAT_08009188);\n  for (i = 0; i < function_count_2; i++) {\n    (*(void (**)(void))(PTR_DAT_08009188 + i * 4))();\n  }\n  return;\n}",
        "called": [
            "FUN_08008f0e",
            "FUN_0800a424"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009148",
        "calling": [
            "FUN_08003658"
        ],
        "current_name": "execute_all_functions_08009148"
    },
    "FUN_08005460": {
        "renaming": {
            "FUN_08005460": "FUNC_08005460"
        },
        "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUNC_08005460(uint *param_1)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  int iVar3;\n  int iVar4;\n  undefined4 uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  puVar1 = DAT_08005720;\n  if ((*param_1 & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (param_1[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      uVar6 = param_1[1];\n      if (uVar6 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar6 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar6 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (param_1[1] == 0) {\n        iVar3 = get_pointer_value_08003760();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          iVar4 = get_pointer_value_08003760();\n          if (100 < (uint)(iVar4 - iVar3)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        iVar3 = get_pointer_value_08003760();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          iVar4 = get_pointer_value_08003760();\n          if (100 < (uint)(iVar4 - iVar3)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*param_1 & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (param_1[4] != 1)) {\n        return 1;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | param_1[5] << 3;\n    }\n    else if (param_1[4] == 0) {\n      *DAT_08005724 = 0;\n      iVar3 = get_pointer_value_08003760();\n      while ((*DAT_08005720 & 2) != 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (2 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      iVar3 = get_pointer_value_08003760();\n      while ((*DAT_08005720 & 2) == 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (2 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | param_1[5] << 3;\n    }\n  }\n  if ((*param_1 & 8) != 0) {\n    if (param_1[6] == 0) {\n      *DAT_08005728 = 0;\n      iVar3 = get_pointer_value_08003760();\n      while ((DAT_08005720[9] & 2) != 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (2 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      iVar3 = get_pointer_value_08003760();\n      while ((DAT_08005720[9] & 2) == 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (2 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n      count_down_08005434(1);\n    }\n  }\n  if ((*param_1 & 4) != 0) {\n    bVar7 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar7) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      iVar3 = get_pointer_value_08003760();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (100 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar6 = param_1[3];\n    if (uVar6 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar6 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar6 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (param_1[3] == 0) {\n      iVar3 = get_pointer_value_08003760();\n      while ((DAT_08005838[8] & 2) != 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (5000 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      iVar3 = get_pointer_value_08003760();\n      while ((DAT_08005720[8] & 2) == 0) {\n        iVar4 = get_pointer_value_08003760();\n        if (5000 < (uint)(iVar4 - iVar3)) {\n          return 3;\n        }\n      }\n    }\n    if (bVar7) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  if (param_1[7] == 0) {\n    uVar5 = 0;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    uVar5 = 1;\n  }\n  else if (param_1[7] == 2) {\n    *DAT_0800583c = 0;\n    iVar3 = get_pointer_value_08003760();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if (param_1[8] == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | param_1[2];\n        }\n        DAT_08005838[1] = DAT_08005838[1] & 0xffc2ffff | param_1[8] | param_1[9];\n        *DAT_0800583c = 1;\n        iVar3 = get_pointer_value_08003760();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return 0;\n          }\n          iVar4 = get_pointer_value_08003760();\n        } while ((uint)(iVar4 - iVar3) < 3);\n        return 3;\n      }\n      iVar4 = get_pointer_value_08003760();\n    } while ((uint)(iVar4 - iVar3) < 3);\n    uVar5 = 3;\n  }\n  else {\n    *DAT_0800583c = 0;\n    iVar3 = get_pointer_value_08003760();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return 0;\n      }\n      iVar4 = get_pointer_value_08003760();\n    } while ((uint)(iVar4 - iVar3) < 3);\n    uVar5 = 3;\n  }\n  return uVar5;\n}\n\n",
        "called": [
            "FUN_08003760",
            "FUN_08005434"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08005460",
        "calling": [
            "FUN_080035b8"
        ],
        "current_name": "FUNC_08005460"
    },
    "FUN_08008854": {
        "renaming": {
            "FUN_08008854": "return_zero_08008854"
        },
        "code": "int32_t return_zero_08008854(void) { \n    return 0; \n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008854",
        "calling": [
            "FUN_0800a130"
        ],
        "current_name": "return_zero_08008854"
    },
    "FUN_080064cc": {
        "renaming": {
            "FUN_080064cc": "decode_message_080064cc",
            "param_1": "message_ptr",
            "pbVar2": "data_ptr",
            "sVar1": "remaining_attempts",
            "message_type": "message_type",
            "message_length": "message_length",
            "message_data_ptr": "message_data_ptr"
        },
        "code": "int decode_message_080064cc(int *message_ptr) {\n  char message_type = *(char *)((int)message_ptr + 0x39);\n  if (message_type != '!') {\n    return 2;\n  }\n  int message_length = message_ptr[2];\n  int *message_data_ptr = (int *)*message_ptr;\n  if (message_length == 0x1000) {\n    uint16_t *data_ptr = (uint16_t *)message_ptr[8];\n    message_data_ptr[1] = *data_ptr & 0x1ff;\n    if (message_ptr[4] == 0) {\n      message_ptr[8] = message_ptr[8] + 2;\n    }\n    else {\n      message_ptr[8] = message_ptr[8] + 1;\n    }\n  }\n  else {\n    uint8_t *data_ptr = (uint8_t *)message_ptr[8];\n    message_data_ptr[1] = (uint32_t)*data_ptr;\n    message_ptr[8] = (int)(data_ptr + 1);\n  }\n  short remaining_attempts = *(short *)((int)message_ptr + 0x26) - 1;\n  *(short *)((int)message_ptr + 0x26) = remaining_attempts;\n  if (remaining_attempts == 0) {\n    message_data_ptr[3] = message_data_ptr[3] & 0xffffff7f;\n    message_data_ptr[3] = message_data_ptr[3] | 0x40;\n    return 0;\n  }\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080064cc",
        "calling": [
            "FUN_080069ec"
        ],
        "current_name": "decode_message_080064cc"
    },
    "FUN_08004d6c": {
        "renaming": {
            "FUN_08004d6c": "set_bit_and_update_08004d6c",
            "param_1": "bit_array"
        },
        "code": "int set_bit_and_update_08004d6c(uint** bit_array, uint bit_index) {\\n  uint* current_array = *bit_array;\\n  set_bit(current_array, bit_index, 1);\\n\\n  if (current_array == PTR_DAT_080063bc) {\\n    current_array[17] |= 0x8000;\\n  }\\n\\n  **bit_array |= 1;\\n  return 0;\\n}",
        "called": [
            "FUN_08004a20",
            "FUN_08004d6a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004d6c",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "set_bit_and_update_08004d6c"
    },
    "FUN_08004ac2": {
        "renaming": {
            "FUN_08004ac2": "process_input_08004ac2",
            "param_1": "input_ptr",
            "param_2": "input_size",
            "param_3": "flags",
            "param_4": "output",
            "uVar1": "input_value",
            "uVar2": "input_flags"
        },
        "code": "void process_input_08004ac2(uint* input_ptr, uint input_size, uint flags, uint output)\\n{\\n  uint input_flags = *(uint *)(*input_ptr + 0x18);\\n  uint input_value;\\n  if ((input_flags & 0x80) == 0) {\\n    input_value = *(uint *)(input_ptr + 3);\\n  }\\n  else {\\n    input_value = *(uint *)(input_ptr + 6);\\n  }\\n  bool is_input_valid = (*(uint *)(*input_ptr + 0x18) & 4) == 0;\\n  process_input_08004ac2_08007fa0(input_ptr, is_input_valid, (undefined2)input_value, input_flags, output);\\n  return;\\n}",
        "called": [
            "FUN_08007fa0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004ac2",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_input_08004ac2"
    },
    "FUN_08008850": {
        "renaming": {
            "FUN_08008850": "returnOne_08008850",
            "undefined4": "int"
        },
        "code": "int returnOne_08008850(void) {\\n  int result = 1;\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008850",
        "calling": [
            "FUN_0800a110"
        ],
        "current_name": "returnOne_08008850"
    },
    "FUN_08006ca8": {
        "renaming": {
            "FUN_08006ca8": "set_flag_and_update_08006ca8",
            "param_1": "flag_array",
            "param_2": "flag_value",
            "iVar2": "data_08006d20",
            "uVar3": "flag_masked",
            "uVar4": "flag_mask",
            "uVar5": "current_flag",
            "local_18": "flag_bit",
            "local_14": "unused_08006ca8_1",
            "local_10": "unused_08006ca8_2",
            "DAT_08006d14": "flag_values_08006d14",
            "DAT_08006d18": "flag_values_08006d18"
        },
        "code": "void set_flag_and_update_08006ca8(uint *flag_array, undefined4 flag_value) {\n  uint current_flag = *flag_array;\n  uint updated_flag;\n  uint flag_mask;\n\n  if (current_flag == DAT_08006d14) {\n    flag_mask = *(uint *)(DAT_08006d20 + 0x18) | 0x200;\n    *(uint *)(DAT_08006d20 + 0x18) = flag_mask;\n    updated_flag = *(uint *)(DAT_08006d20 + 0x18) & 0x200;\n  }\n  else if (current_flag == DAT_08006d18) {\n    flag_mask = *(uint *)(DAT_08006d20 + 0x18) | 0x400;\n    *(uint *)(DAT_08006d20 + 0x18) = flag_mask;\n    updated_flag = *(uint *)(DAT_08006d20 + 0x18) & 0x400;\n  }\n\n  uint8_t flag_index = *(uint8_t *)(PTR_DAT_08006d1c);\n  uint flag_bit = 1 << (flag_index & 0xf) & 0xffff;\n  uint flag_masked = set_flag_08006bb8((uint)((int)(char)*PTR_DAT_08006d1c << 0x18) >> 0x1c, flag_value, flag_mask, updated_flag);\n  FUNC_080040e8(flag_masked, &flag_bit);\n}",
        "called": [
            "FUN_080040e8",
            "FUN_08006bb8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006ca8",
        "calling": [
            "FUN_08003bd8"
        ],
        "current_name": "set_flag_and_update_08006ca8"
    },
    "FUN_08002fc2": {
        "renaming": {
            "FUN_08002fc2": "set_value_at_index_08002fc2",
            "param_1": "array_base",
            "param_2": "index",
            "param_3": "value"
        },
        "code": "void set_value_at_index_08002fc2(int array_base, int index, int value) {\n  *(int *)(array_base + (index + 0x42) * 4) = value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002fc2",
        "calling": [
            "FUN_080005f8",
            "FUN_0800021a"
        ],
        "current_name": "set_value_at_index_08002fc2"
    },
    "FUN_08008afa": {
        "renaming": {
            "FUN_08008afa": "calculate_shift_amount_08008afa",
            "param_1": "address",
            "*(short *)(param_1 + 0x134)": "ptr_1",
            "*(short *)(param_1 + 0x136)": "ptr_2",
            "value_1": "ptr_1_value",
            "value_2": "ptr_2_value"
        },
        "code": "ushort calculate_shift_amount_08008afa(int address) {\n    short* ptr_1 = (short*)(address + 0x134);\n    short* ptr_2 = (short*)(address + 0x136);\n    short value_1 = *ptr_1;\n    short value_2 = *ptr_2;\n    return (ushort)(((value_1 + 0x40) - value_2) & 0x3f);\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008afa",
        "calling": [
            "FUN_08008bf4"
        ],
        "current_name": "calculate_shift_amount_08008afa"
    },
    "FUN_08003048": {
        "renaming": {
            "FUN_08003048": "executeDeviceCommandsAndWriteDataToDevice_08003048",
            "param_1": "deviceData",
            "param_2": "deviceParameter",
            "param_3": "parameterSize",
            "param_4": "assertionData",
            "puVar1": "deviceCommandData",
            "PTR_DAT_08003068": "deviceCommandData",
            "process_assertion_08008c44": "processAssertion",
            "write_data_to_device_08003002": "writeDataToDevice",
            "setParameterAndExecuteCommands_08002e26": "setParameterAndExecuteCommands"
        },
        "code": "void executeDeviceCommandsAndWriteDataToDevice_08003048(void *deviceData, void *deviceParameter, int parameterSize, void *assertionData){\n  void *PTR_DAT_08003068 = PTR_DAT_08003068;\n  processAssertion(assertionData, deviceParameter, 6, parameterSize, parameterSize);\n  write_data_to_device_08003002(deviceData);\n  setParameterAndExecuteCommands_08002e26(deviceData, PTR_DAT_08003068);\n  return;\n}",
        "called": [
            "FUN_08003002",
            "FUN_08002e26",
            "FUN_08008c44"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003048",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "executeDeviceCommandsAndWriteDataToDevice_08003048"
    },
    "FUN_0800937c": {
        "renaming": {
            "FUN_0800937c": "FUNC_0800937c"
        },
        "code": "\nint FUNC_0800937c(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int *piVar3;\n  bool bVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  int unaff_r9;\n  int iVar7;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_blocks_08009d50();\n  }\n  if (param_2 == PTR_DAT_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar7 = process_data_08009a80(param_1,param_2), iVar7 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar5 = param_3;\nLAB_080093be:\n  pbVar6 = pbVar5;\n  if (*pbVar6 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar5 = pbVar6 + 1;\n  if (*pbVar6 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar7 = (int)pbVar6 - (int)param_3;\n  if (iVar7 != 0) {\n    iVar2 = process_data_08009358(param_1,param_2,param_3,iVar7);\n    if (iVar2 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar7;\n  }\n  if (*pbVar6 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar5 = pbVar6 + 1;\n  while( true ) {\n    iVar7 = find_character_08009f2c(PTR_s___0__0800958c,*pbVar5);\n    puVar1 = PTR_DAT_08009598;\n    param_3 = pbVar5 + 1;\n    if (iVar7 == 0) break;\n    local_88 = 1 << (iVar7 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar5 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar5 == 0x2a) {\n    piVar3 = local_8c + 1;\n    iVar7 = *local_8c;\n    local_8c = piVar3;\n    if (-1 < iVar7) goto LAB_08009498;\n    local_7c = -iVar7;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar4 = false;\n    iVar7 = local_7c;\n    param_3 = pbVar5;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar7 = iVar7 * 10 + (*param_3 - 0x30);\n      bVar4 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar4) {\nLAB_08009498:\n      local_7c = iVar7;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar3 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar3;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar4 = false;\n      iVar7 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar7 = iVar7 * 10 + (*param_3 - 0x30);\n        bVar4 = true;\n      }\n      if (bVar4) {\n        local_84 = iVar7;\n      }\n    }\n  }\n  iVar7 = find_character_08009f2c(PTR_DAT_08009598,*param_3,3);\n  if (iVar7 != 0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << (iVar7 - (int)puVar1 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  iVar7 = find_character_08009f2c(PTR_s_efgEFG_0800959c,local_70,6);\n  if (iVar7 == 0) {\n    iVar7 = FUNC_08009698(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar7 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar7 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar7 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar7;\n  pbVar5 = param_3;\n  unaff_r9 = iVar7;\n  goto LAB_080093be;\n}\n\n",
        "called": [
            "FUN_08009d50",
            "FUN_08009358",
            "FUN_08009a80",
            "FUN_08009698",
            "FUN_08009f2c"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x0800937c",
        "calling": [
            "FUN_080098d8",
            "FUN_08009124"
        ],
        "current_name": "FUNC_0800937c"
    },
    "FUN_08000214": {
        "renaming": {
            "FUN_08000214": "process_value_08000214",
            "param_1": "index",
            "param_2": "value",
            "param_3": "arg1",
            "param_4": "arg2",
            "bVar1": "found_char",
            "iVar2": "char_index",
            "value_type": "value_type"
        },
        "code": "void process_value_08000214(uint index, uint value, uint arg1, uint arg2)\n{\n  bool found_char;\n  int char_index;\n  if (index > 59) {\n    return;\n  }\n  int value_type = get_value_type_at_index_08002fa0(PTR_DAT_080002d8, index, arg1, arg2, arg2);\n  if (value_type == 3) {\n    if (index < 60 && PTR_DAT_080002dc[index] != -1) {\n      char_index = find_char_index_080036ac();\n      if (char_index != 0) {\n        char_index = find_char_index_080036ac((int)(char)PTR_DAT_080002dc[index]);\n        if (char_index == 0) {\n          found_char = false;\n        }\n        else {\n          found_char = compare_values_0800738a((int)(char)PTR_DAT_080002dc[index], PTR_DAT_080002e8) != 0;\n        }\n      }\n      else {\n        found_char = false;\n      }\n    }\n    else {\n      found_char = false;\n    }\n    if (found_char) {\n      process_bit_080088e0(index, value);\n    }\n    set_value_at_index_08002fc2(PTR_DAT_080002d8, index, value);\n  }\n  else if (value_type == 4) {\n    if (index < 60 && PTR_DAT_080002dc[index] != -1) {\n      char_index = find_char_index_080036ac();\n      if (char_index != 0) {\n        char_index = find_char_index_080036ac((int)(char)PTR_DAT_080002dc[index]);\n        if (char_index == 0) {\n          found_char = false;\n        }\n        else {\n          found_char = true;\n        }\n      }\n      else {\n        found_char = false;\n      }\n    }\n    else {\n      found_char = false;\n    }\n    if (found_char) {\n      set_value_based_on_conditions_080026b0(PTR_DAT_080002e4 + (uint)(byte)PTR_DAT_080002e0[index] * 3, value);\n    }\n    set_value_at_index_08002fc2(PTR_DAT_080002d8, index, value);\n  }\n  return;\n}",
        "called": [
            "FUN_0800021a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000214",
        "calling": [
            "FUN_08001cd0"
        ],
        "current_name": "process_value_08000214"
    },
    "FUN_08003724": {
        "renaming": {
            "FUN_08003724": "update_and_validate_input_08003724",
            "DAT_08003744": "input_flag_ptr",
            "updateParameter_08003f0c": "update_parameter",
            "validate_and_set_input_080036d8": "validate_and_set_input",
            "do_nothing_080036d4": "do_nothing"
        },
        "code": "void update_and_validate_input_08003724(void)\n{\n  *DAT_08003744 |= 0x10;\n  updateParameter_08003f0c(3);\n  validate_and_set_input_080036d8(0xf);\n  do_nothing_080036d4();\n  return;\n}",
        "called": [
            "FUN_080036d4",
            "FUN_08003f0c",
            "FUN_080036d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003724",
        "calling": [
            "FUN_080072fa"
        ],
        "current_name": "update_and_validate_input_08003724"
    },
    "FUN_080038dc": {
        "renaming": {
            "FUN_080038dc": "getValueFromPointer_080038dc",
            "param_1": "pointerToValue",
            "*param_1": "dereferencedPointer",
            "undefined4": "int",
            "*(undefined4 *)(*param_1 + 0x4c)": "value"
        },
        "code": "int getValueFromPointer_080038dc(int *pointerToValue)\\n{\\n    int offset = 0x4c;\\n    int *addressOfValue = *pointerToValue + offset;\\n    int value = *addressOfValue;\\n    return value;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080038dc",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "getValueFromPointer_080038dc"
    },
    "FUN_080025ac": {
        "renaming": {
            "FUN_080025ac": "process_input_080025ac",
            "*param_1": "input_buffer",
            "param_2": "buffer_length",
            "param_3": "param_3",
            "param_4": "param_4",
            "uVar1": "ptr_dat_08002628",
            "uVar2": "input_length",
            "uVar3": "uVar3",
            "iVar4": "timer_value/data_value/is_valid",
            "PTR_DAT_08002628": "PTR_DAT_08002628",
            "DAT_0800262c": "dat_0800262c",
            "PTR_DAT_08002630": "PTR_DAT_08002630",
            "initialize_timer_with_callback_0800242c": "initialize_timer_with_callback_0800242c",
            "process_bit_08008990": "process_bit_08008990",
            "is_valid_input_08002400": "is_valid_input_08002400"
        },
        "code": "byte process_input_080025ac(byte *input_buffer, uint buffer_length, int param_3, int param_4)\n{\n  uint input_length = (uint)*input_buffer;\n  if (input_length < 0xc) {\n    process_bit_08008990(buffer_length, 1, param_3, input_length, param_4);\n    uint ptr_dat_08002628 = (byte)PTR_DAT_08002628[input_length * 8] & 0xffffffc0 | buffer_length & 0x3f;\n    PTR_DAT_08002628[input_length * 8] = (char)ptr_dat_08002628;\n    int timer_value = -param_3 + 0x220;\n    if (timer_value < 0) {\n      timer_value = -param_3 + 0x223;\n    }\n    input_buffer[1] = (byte)((uint)(timer_value << 0x16) >> 0x18);\n    int data_value = -param_4 + 0x960;\n    if (data_value < 0) {\n      data_value = -param_4 + 0x963;\n    }\n    input_buffer[2] = (byte)((uint)(data_value << 0x16) >> 0x18);\n    uint DAT_0800262c = DAT_0800262c;\n    uint uVar3 = (uint)((ulonglong)DAT_0800262c * (ulonglong)*input_buffer >> 0x23);\n    int is_valid = is_valid_input_08002400(uVar3,ptr_dat_08002628,input_length,(int)((ulonglong)DAT_0800262c * (ulonglong)*input_buffer));\n    if (is_valid == 0) {\n      PTR_DAT_08002630[0x44] = (char)uVar3;\n      initialize_timer_with_callback_0800242c();\n    }\n    PTR_DAT_08002628[input_length * 8] = PTR_DAT_08002628[input_length * 8] | 0x40;\n  }\n  return *input_buffer;\n}",
        "called": [
            "FUN_0800242c",
            "FUN_08008990",
            "FUN_08002400"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080025ac",
        "calling": [
            "FUN_08000500",
            "FUN_08002634"
        ],
        "current_name": "process_input_080025ac"
    },
    "FUN_08002634": {
        "renaming": {
            "FUN_08002634": "process_input_with_params_08002634",
            "param_1": "input",
            "param_2": "input_size",
            "param_3": "param1",
            "param_4": "param2"
        },
        "code": "void process_input_with_params_08002634(void* input, int input_size, int param1, int param2, void* param3)\\n{\\n  process_input(input, input_size, param1, param2, param3);\\n  return;\\n}",
        "called": [
            "FUN_080025ac"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002634",
        "calling": [
            "FUN_08000500"
        ],
        "current_name": "process_input_with_params_08002634"
    },
    "FUN_08002f0a": {
        "renaming": {
            "FUN_08002f0a": "process_data_and_offset_08002f0a",
            "param_1": "data_offset",
            "process_data_0800325a": "process_data"
        },
        "code": "void process_data_and_offset_08002f0a(int data_offset)\\n{\\n  int data_start = data_offset + 0x40;\\n  process_data_0800325a(data_start);\\n  return;\\n}",
        "called": [
            "FUN_0800325a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f0a",
        "calling": [
            "FUN_08001c18"
        ],
        "current_name": "process_data_and_offset_08002f0a"
    },
    "FUN_08005bb8": {
        "renaming": {
            "FUN_08005bb8": "get_shifted_value_08005bb8",
            "param_1": "shift_value",
            "uVar1": "result",
            "local_24": "value4",
            "abStack_20": "DAT_08005ca4",
            "uStack_1c": "value3",
            "uStack_18": "value2",
            "uStack_14": "value1"
        },
        "code": "uint get_shifted_value_08005bb8(uint shift_value)\n{\n  uint result = 0;\n  uint value1 = *(uint *)(PTR_DAT_08005ca0);\n  uint value2 = *(uint *)(PTR_DAT_08005ca0 + 4);\n  uint value3 = *(uint *)(PTR_DAT_08005ca0 + 8);\n  uint value4 = *(ushort *)(PTR_DAT_08005ca0 + 0x10);\n  if (shift_value == 2) {\n    result = get_shifted_value_08005bb8_from_pointer() / ((((DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (shift_value == 16) {\n    if ((*DAT_08005ca4 & 0x1000000) == 0) {\n      result = 0;\n    }\n    else {\n      result = DAT_08005cb0;\n      if ((DAT_08005ca4[1] & 0x10000) != 0) {\n        result = DAT_08005ca8 / *(byte *)((int)&value4 - ((int)(DAT_08005ca4[1] << 0xe) >> 0x1f));\n      }\n      result = result * DAT_08005ca4[4 + (DAT_08005ca4[1] >> 6 & 3)];\n      if ((DAT_08005ca4[1] & 0x400000) == 0) {\n        result = (uint)((ulonglong)DAT_08005cac * (ulonglong)(result * 2) >> 0x21);\n      }\n    }\n  }\n  else if (shift_value == 1) {\n    if ((DAT_08005ca4[0x20] & 0x302) == 0x102) {\n      result = 0x8000;\n    }\n    else {\n      uint value5 = DAT_08005ca4[0x20] & 0x300;\n      if ((value5 == 0x200) && ((DAT_08005ca4[0x21] & 2) != 0)) {\n        result = 32000;\n      }\n      else if (value5 == 0x300) {\n        if ((*DAT_08005ca4 & 0x20000) == 0) {\n          result = 0;\n        }\n        else {\n          result = 62500;\n        }\n      }\n      else {\n        result = 0;\n      }\n    }\n  }\n  return result;\n}",
        "called": [
            "FUN_08005a48"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005bb8",
        "calling": [
            "FUN_08003e20",
            "FUN_0800376c"
        ],
        "current_name": "get_shifted_value_08005bb8"
    },
    "FUN_08007648": {
        "renaming": {
            "FUN_08007648": "initialize_timer_08007648",
            "param_1": "timer_registers",
            "param_2": "timer_start_value",
            "param_3": "timer_type",
            "param_4": "timer_interrupt_value",
            "local_34": "timer_value_4",
            "local_30": "timer_value_6",
            "local_2c": "N/A",
            "local_28": "N/A",
            "local_24": "N/A",
            "local_20": "N/A",
            "local_1c": "timer_value_7",
            "puVar4": "register_pointer",
            "DAT_080076dc": "timer_interrupt_divisor"
        },
        "code": "void initialize_timer_08007648(uint32_t *timer_registers, uint32_t timer_start_value, uint32_t timer_type, uint32_t timer_interrupt_value)\n{\n  uint32_t clock_source_value;\n  uint32_t *register_pointer;\n  uint32_t timer_value_1 = 0;\n  uint32_t timer_value_2 = 0;\n  uint32_t timer_value_3 = 0;\n  uint32_t timer_value_4 = 0;\n  uint32_t timer_value_5 = 0;\n  uint32_t timer_value_6 = 0;\n  uint32_t timer_value_7 = 0;\n  \n  timer_value_1 = 0x40000000;\n  timer_value_2 = 0x40000000;\n  timer_value_5 = timer_start_value;\n  clock_source_value = check_clock_source();\n  timer_value_3 = (uint32_t)(((uint64_t)timer_interrupt_value * (uint64_t)clock_source_value) >> 0x32) - 1;\n  timer_registers[0] = timer_value_1;\n  timer_registers[1] = timer_value_2;\n  timer_registers[2] = timer_value_3;\n  timer_registers[3] = 0;\n  timer_registers[4] = timer_type;\n  timer_registers[5] = timer_value_5;\n  timer_registers[6] = timer_value_6;\n  timer_registers[7] = timer_value_7;\n  set_timer_type_bits(timer_registers);\n  if (check_and_update_registers(timer_registers + 1) == 0)\n  {\n    if (update_and_return_status(timer_registers + 1, &timer_value_4, 0) == 0)\n    {\n      set_bit_and_update_flags(timer_registers + 1, 0);\n    }\n  }\n}\n",
        "called": [
            "FUN_080075dc",
            "FUN_08003f94",
            "FUN_08006280",
            "FUN_08006128",
            "FUN_08003f30",
            "FUN_08007544",
            "FUN_08006060"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007648",
        "calling": [
            "FUN_0800242c"
        ],
        "current_name": "initialize_timer_08007648"
    },
    "FUN_08008858": {
        "renaming": {
            "FUN_08008858": "returnZero_08008858"
        },
        "code": "int returnZero_08008858(void) {\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008858",
        "calling": [
            "FUN_0800a168"
        ],
        "current_name": "returnZero_08008858"
    },
    "FUN_08004a20": {
        "renaming": {
            "FUN_08004a20": "do_nothing_08004a20"
        },
        "code": "void do_nothing_08004a20(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a20",
        "calling": [
            "FUN_08004e3c",
            "FUN_08004d6c"
        ],
        "current_name": "do_nothing_08004a20"
    },
    "FUN_080063c0": {
        "renaming": {
            "FUN_080063c0": "update_flags_if_needed_080063c0",
            "param_1": "flags",
            "param_2": "flag_value",
            "puVar1": "flag_array",
            "DAT_0800641c": "PTR_DAT_0800641c"
        },
        "code": "void update_flags_if_needed_080063c0(uint **flags, uint flag_value) {\n  uint *flag_array = *flags;\n  set_bit_08006262(flag_array, flag_value, 0);\n\n  if (flag_array == DAT_0800641c && (flag_array[8] & 0x555) == 0) {\n    flag_array[0x11] &= 0xffff7fff;\n  }\n\n  if ((flag_array[8] & 0x555) == 0) {\n    *flag_array &= 0xfffffffe;\n  }\n\n  *(undefined *)((int)flags + 0x3d) = 1;\n}",
        "called": [
            "FUN_08006262"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080063c0",
        "calling": [
            "FUN_080071e4"
        ],
        "current_name": "update_flags_if_needed_080063c0"
    },
    "FUN_08004a24": {
        "renaming": {
            "FUN_08004a24": "process_input_data_08004a24",
            "param_1": "input_data",
            "pbVar2": "data_ptr",
            "cVar1": "current_char"
        },
        "code": "void process_input_data_08004a24(int *input_data) {\n  char current_char = *(char *)(input_data + 0x3d);\n\n  if (*(short *)(input_data + 0x2a) != 0) {\n    byte *data_ptr = (byte *)input_data[9];\n    input_data[9] = (int)(data_ptr + 1);\n    uint data_value = (uint)*data_ptr;\n    *(uint *)(*input_data + 0x10) = data_value;\n    *(short *)(input_data + 0x2a) = *(short *)(input_data + 0x2a) - 1;\n\n    if ((*(short *)(input_data + 0x2a) == 0) && (current_char == ')')) {\n      *(uint *)(*input_data + 4) &= 0xfffffbff;\n      input_data[0xc] = 0x21;\n      *(undefined *)(input_data + 0x3d) = 0x28;\n      do_nothing();\n    }\n  }\n}",
        "called": [
            "FUN_08004a22"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a24",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_input_data_08004a24"
    },
    "FUN_08004a22": {
        "renaming": {
            "FUN_08004a22": "doNothing_08004a22"
        },
        "code": "void doNothing_08004a22(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a22",
        "calling": [
            "FUN_08004a24",
            "FUN_08004aec"
        ],
        "current_name": "doNothing_08004a22"
    },
    "FUN_08002fba": {
        "renaming": {
            "FUN_08002fba": "get_value_at_offset_08002fba",
            "param_1": "base_address",
            "param_2": "offset",
            "*PTR_": "address_to_value"
        },
        "code": "int get_value_at_offset_08002fba(int base_address, int offset)\\n{\\n  int* *PTR_ = (int*)(base_address + (offset + 0x42) * 4);\\n  return **PTR_;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002fba",
        "calling": [
            "FUN_08001cd0"
        ],
        "current_name": "get_value_at_offset_08002fba"
    },
    "FUN_080090cc": {
        "renaming": {
            "FUN_080090cc": "process_assertion_data_080090cc",
            "param_1": "count",
            "param_2": "size",
            "param_3": "data",
            "param_4": "data_type",
            "uVar1": "data_offset",
            "puVar2": "assertion_str",
            "uVar3": "random_value",
            "uVar4": "data_type_copy"
        },
        "code": "void process_assertion_data_080090cc(undefined4 count, undefined4 size, undefined *data, undefined4 data_type) {\n  undefined4 data_offset = *(undefined4 *)(*(int *)assertion_data_ptr + 0xc);\n  undefined *assertion_str = assertion_string_ptr;\n  undefined4 data_type_copy = data_type;\n  if (data == (undefined *)0x0) goto LAB_END;\n  do {\n    process_data(data_offset, assertion_str, data_type_copy, count, size, assertion_str, data, data_type_copy);\n    undefined8 random_value = get_random_value();\n    size = (undefined4)((ulonglong)random_value >> 0x20);\n    data_offset = (undefined4)random_value;\nLAB_END:\n    data = assertion_string_ptr;\n    assertion_str = assertion_string_ptr;\n  } while(true);\n}",
        "called": [
            "FUN_08009b5c",
            "FUN_08009124"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080090cc",
        "calling": [
            "FUN_08008c44"
        ],
        "current_name": "process_assertion_data_080090cc"
    },
    "FUN_080049e0": {
        "renaming": {
            "FUN_080049e0": "set_and_update_values_080049e0",
            "param_1": "data_ptr",
            "puVar1": "data",
            "*(char *)((int)param_1 + 0x3d)": "data[15]",
            "*(undefined *)((int)param_1 + 0x3d)": "data[15]",
            "*puVar1": "data[0]",
            "**param_1": "*data",
            "(*param_1)[1]": "data[1]"
        },
        "code": "int set_and_update_values_080049e0(uint **data_ptr) {\n  uint *data = *data_ptr;\n  if (data[15] != ' ') {\n    return 2;\n  }\n  data[15] = '(';\n  if ((data[0] & 1) == 0) {\n    data[0] |= 1;\n  }\n  *data |= 0x400;\n  data[1] |= 0x300;\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080049e0",
        "calling": [
            "FUN_08008020",
            "FUN_08007f8e",
            "FUN_08007ff0",
            "FUN_08007f7c"
        ],
        "current_name": "set_and_update_values_080049e0"
    },
    "FUN_08006d24": {
        "renaming": {
            "FUN_08006d24": "update_permissions_08006d24",
            "param_1": "permission_level",
            "iVar1": "current_permission_level",
            "DAT_08006d7c": "current_permission_level",
            "DAT_08006d74": "default_permission_level",
            "DAT_08006d78": "special_permission_level",
            "*(uint *)(DAT_08006d7c + 0xc)": "*ptr_permission_flags",
            "*(uint *)(iVar1 + 0xc)": "*(uint *)(current_permission_level + 0xc)",
            "*(uint *)(iVar1 + 0x18)": "*(uint *)(current_permission_level + 0x18)"
        },
        "code": "void update_permissions_08006d24(int *permission_level) {\n  int DAT_08006d7c = DAT_08006d7c;\n  if (*permission_level != DAT_08006d74) {\n    if (*permission_level == DAT_08006d78) {\n      uint *(uint *)(DAT_08006d7c + 0xc) = (uint *)(DAT_08006d7c + 0xc);\n      *(uint *)(DAT_08006d7c + 0xc) |= 0x400;\n      *(uint *)(DAT_08006d7c + 0xc) &= 0xfffffbff;\n      *(uint *)(DAT_08006d7c + 0x18) &= 0xfffffbff;\n      *(uint *)(DAT_08006d7c + 0x18) &= 0xfffffbff;\n    }\n    return;\n  }\n  uint *(uint *)(DAT_08006d7c + 0xc) = (uint *)(DAT_08006d7c + 0xc);\n  *(uint *)(DAT_08006d7c + 0xc) |= 0x200;\n  *(uint *)(DAT_08006d7c + 0xc) &= 0xfffffdff;\n  *(uint *)(DAT_08006d7c + 0x18) &= 0xfffffdff;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006d24",
        "calling": [
            "FUN_08003ce8"
        ],
        "current_name": "update_permissions_08006d24"
    },
    "FUN_080098d8": {
        "renaming": {
            "FUN_080098d8": "initialize_and_call_function_080098d8",
            "param_1": "arg1",
            "param_2": "arg2",
            "param_3": "arg3",
            "param_4": "arg4",
            "iVar1": "block_ptr",
            "uVar2": "arg1",
            "uStack_c": "arg2",
            "uStack_8": "arg3",
            "uStack_4": "arg4"
        },
        "code": "void initialize_and_call_function_080098d8(int param1, int param2, int param3, int param4)\n{\n  int block_ptr = *(int *)PTR_PTR_DAT_08009904;\n  undefined4 arg1 = param1;\n  undefined4 arg2 = param2;\n  undefined4 arg3 = param3;\n  undefined4 arg4 = param4;\n  if ((block_ptr != 0) && (*(int *)(block_ptr + 0x18) == 0)) {\n    initialize_blocks_08009d50(block_ptr);\n  }\n  FUNC_0800937c(block_ptr, *(undefined4 *)(block_ptr + 8), param1, &arg2, arg1, &arg3);\n  return;\n}",
        "called": [
            "FUN_08009d50",
            "FUN_0800937c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080098d8",
        "calling": [
            "FUN_080075dc",
            "FUN_08008078",
            "FUN_08007594",
            "FUN_08007544",
            "FUN_080077b0"
        ],
        "current_name": "initialize_and_call_function_080098d8"
    },
    "FUN_08009270": {
        "renaming": {
            "FUN_08009270": "allocate_memory_block_08009270",
            "param_1": "block_start",
            "param_2": "block_size",
            "puVar1": "unused_pointer",
            "uVar2": "result",
            "puVar3": "current_block",
            "iVar4": "padding_size",
            "puVar5": "next_block_start",
            "puVar7": "previous_block",
            "uVar6": "block_diff",
            "aligned_block_size": "aligned_block_size",
            "PTR_DAT_08009328": "PTR_DAT_08009328",
            "PTR_DAT_08009324": "PTR_DAT_08009324"
        },
        "code": "uint allocate_memory_block_08009270(uint *block_start, uint block_size)\n{\n  uint aligned_block_size = (block_size + 3 & 0xfffffffc) + 8;\n  if (aligned_block_size < 0xc) {\n    aligned_block_size = 0xc;\n  }\n  if (((int)aligned_block_size < 0) || (aligned_block_size < block_size)) {\n    *block_start = 0xc;\n  }\n  else {\n    do_nothing_08009f48();\n    uint *current_block = *(uint **)PTR_DAT_08009324;\n    uint *previous_block = *(uint **)PTR_DAT_08009324;\n    while (current_block != (uint *)0x0) {\n      uint block_diff = *current_block - aligned_block_size;\n      if (-1 < (int)block_diff) {\n        if (block_diff < 0xc) {\n          if (previous_block == current_block) {\n            uint next_block_start = previous_block[1];\n            *(uint *)PTR_DAT_08009324 = next_block_start;\n          }\n          else {\n            uint next_block_start = current_block[1];\n          }\n          if (previous_block != current_block) {\n            previous_block[1] = next_block_start;\n            previous_block = current_block;\n          }\n        }\n        else {\n          *current_block = block_diff;\n          *(uint *)((int)current_block + block_diff) = aligned_block_size;\n          previous_block = (uint *)((int)current_block + block_diff);\n        }\n        goto LAB_080092d4;\n      }\n      previous_block = current_block;\n      current_block = (uint *)current_block[1];\n    }\n    if (*(int *)PTR_DAT_08009328 == 0) {\n      uint result = check_and_set_offset_08009918(block_start);\n      *(uint *)PTR_DAT_08009328 = result;\n    }\n    uint *new_block_start = (uint *)check_and_set_offset_08009918(block_start, aligned_block_size);\n    if ((new_block_start != (uint *)0xffffffff) && ((previous_block = (uint *)((int)new_block_start + 3U & 0xfffffffc), new_block_start == previous_block || (int)check_and_set_offset_08009918(block_start,(int)previous_block - (int)new_block_start) != -1))) {\n      *previous_block = aligned_block_size;\nLAB_080092d4:\n      do_nothing_08009f4a(block_start);\n      uint aligned_block_end = (int)previous_block + 0xbU & 0xfffffff8;\n      int padding_size = aligned_block_end - (int)(previous_block + 1);\n      if (padding_size != 0) {\n        *(int *)((int)previous_block + padding_size) = -padding_size;\n        return aligned_block_end;\n      }\n      return aligned_block_end;\n    }\n    *block_start = 0xc;\n    do_nothing_08009f4a(block_start);\n  }\n  return 0;\n}",
        "called": [
            "FUN_08009f4a",
            "FUN_08009f48",
            "FUN_08009918"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009270",
        "calling": [
            "FUN_08009908",
            "FUN_08009d24",
            "FUN_08009eac",
            "FUN_08009190"
        ],
        "current_name": "allocate_memory_block_08009270"
    },
    "FUN_08005e6c": {
        "renaming": {
            "FUN_08005e6c": "doNothing_08005e6c"
        },
        "code": "void doNothing_08005e6c(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005e6c",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "doNothing_08005e6c"
    },
    "FUN_08008500": {
        "renaming": {
            "FUN_08008500": "check_valid_input_08008500",
            "param_1": "input",
            "param_2": "param",
            "iVar2": "ptr_val1",
            "cVar1": "char_val1",
            "iVar3": "param_val1",
            "uVar4": "uVar1"
        },
        "code": "uint check_valid_input_08008500(uint input, uint param) {\n  int ptr_val1 = get_pointer_value();\n  char char_val1 = PTR_DAT_080085a8[1];\n  int param_val1 = get_parameter_value((int)char_val1, PTR_DAT_080085ac);\n  if (param_val1 == 0) {\n    return 0;\n  }\n  uint uVar1 = 0;\n  while ((uVar1 < 5 && ((*(int *)(PTR_DAT_080085b0 + uVar1 * 4) == 0 || ((param_val1 = get_parameter_value((int)char_val1, PTR_DAT_080085ac)), **(int **)(PTR_DAT_080085b0 + uVar1 * 4) != param_val1))))) {\n    uVar1 = uVar1 + 1 & 0xff;\n  }\n  if (4 < uVar1) {\n    if ((4 < (byte)PTR_DAT_080085b4[0x44]) && (process_parameter(), 4 < (byte)PTR_DAT_080085b4[0x44])) {\n      return 0;\n    }\n    uVar1 = (uint)(byte)PTR_DAT_080085b4[0x44];\n  }\n  do {\n    param_val1 = check_if_valid_input(*(undefined4 *)(PTR_DAT_080085b0 + uVar1 * 4), input, param & 0xffff, 1000);\n    if (param_val1 == 0) {\n      return param;\n    }\n    param_val1 = get_pointer_value();\n  } while ((uint)(param_val1 - ptr_val1) < 1000);\n  return 0;\n}",
        "called": [
            "FUN_080084b0",
            "FUN_080067ac",
            "FUN_08003760",
            "FUN_08007320"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008500",
        "calling": [
            "FUN_0800885c"
        ],
        "current_name": "check_valid_input_08008500"
    },
    "FUN_080048c8": {
        "renaming": {
            "FUN_080048c8": "validate_input_080048c8",
            "param_1": "input_ptr",
            "param_2": "input_data",
            "param_3": "input_len",
            "param_4": "input_flags",
            "uVar1": "result",
            "puVar2": "data_ptr"
        },
        "code": "int validate_input_080048c8(uint **input_ptr, uint *input_data, int input_len, uint *input_flags){\\n  int result = 0;\\n  uint *data_ptr;\\n  if (*(char *)((int)input_ptr + 0x3d) == '(') {\\n    if (input_data == NULL) {\\n      result = 1;\\n    }\\n    else if (input_len == 0) {\\n      result = 1;\\n    }\\n    else if (*(char *)(input_ptr + 0xf) == '\\x01') {\\n      result = 2;\\n    }\\n    else {\\n      *(undefined *)(input_ptr + 0xf) = 1;\\n      data_ptr = *input_ptr;\\n      if ((*data_ptr & 1) == 0) {\\n        *data_ptr |= 1;\\n      }\\n      **input_ptr &= 0xfffff7ff;\\n      *(undefined *)((int)input_ptr + 0x3d) = 0x29;\\n      *(undefined *)((int)input_ptr + 0x3e) = 0x20;\\n      result = 0;\\n      input_ptr[0x10] = NULL;\\n      input_ptr[9] = input_data;\\n      *(short *)((int)input_ptr + 0x2a) = (short)input_len;\\n      input_ptr[0xb] = input_flags;\\n      *(undefined2 *)(input_ptr + 10) = *(undefined2 *)((int)input_ptr + 0x2a);\\n      *(undefined *)(input_ptr + 0xf) = 0;\\n      (*input_ptr)[1] |= 0x700;\\n    }\\n  }\\n  else {\\n    result = 2;\\n  }\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080048c8",
        "calling": [
            "FUN_08007fa0"
        ],
        "current_name": "validate_input_080048c8"
    },
    "FUN_08009954": {
        "renaming": {
            "FUN_08009954": "copy_string_08009954",
            "param_1": "destination",
            "param_2": "source",
            "param_3": "max_length",
            "pcVar3": "current_destination",
            "iVar2": "remaining_length",
            "cVar1": "current_character"
        },
        "code": "void copy_string_08009954(char *destination, char *source, int max_length)\n{\n  char current_character;\n  int remaining_length;\n  char *current_destination;\n  \n  do {\n    current_destination = destination;\n    remaining_length = max_length;\n    if (remaining_length == 0) {\n      return;\n    }\n    current_character = *source;\n    destination = current_destination + 1;\n    *current_destination = current_character;\n    source = source + 1;\n    max_length = remaining_length - 1;\n  } while (current_character != '\\0');\n  for (; destination != current_destination + remaining_length; destination = destination + 1) {\n    *destination = '\\0';\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009954",
        "calling": [
            "FUN_08002e44"
        ],
        "current_name": "copy_string_08009954"
    },
    "FUN_08005aa4": {
        "renaming": {
            "FUN_08005aa4": "update_settings_08005aa4",
            "param_1": "settings",
            "puVar1": "pointer",
            "iVar2": "memory_location",
            "iVar3": "current_time",
            "uVar4": "bitmask",
            "bVar5": "is_bit_set",
            "is_bit_set2": "is_bit_set2",
            "start_time": "start_time",
            "settings_ptr": "settings_ptr",
            "settings_memory": "settings_memory",
            "settings_value": "settings_value",
            "start_time2": "start_time2",
            "current_time2": "current_time2"
        },
        "code": "int update_settings_08005aa4(uint *settings)\n{\n  bool is_bit_set = (*settings & 1) != 0;\n\n  if (is_bit_set) {\n    bool is_bit_set2 = (*(uint *)(DAT_08005bac + 0x1c) & 0x10000000) == 0;\n\n    if (is_bit_set2) {\n      *(uint *)(DAT_08005bac + 0x1c) |= 0x10000000;\n    }\n\n    if ((*DAT_08005bb0 & 0x100) == 0) {\n      *DAT_08005bb0 |= 0x100;\n      int start_time = get_pointer_value_08003760();\n\n      while ((*DAT_08005bb0 & 0x100) == 0) {\n        int current_time = get_pointer_value_08003760();\n\n        if (100 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n\n    uint *settings_ptr = DAT_08005bb4;\n    int settings_memory = DAT_08005bac;\n    uint settings_value = *(uint *)(DAT_08005bac + 0x20) & 0x300;\n\n    if ((settings_value != 0) && (settings_value != (settings[1] & 0x300))) {\n      settings_value = *(uint *)(DAT_08005bac + 0x20);\n      *settings_ptr = 1;\n      *settings_ptr = 0;\n      *(uint *)(settings_memory + 0x20) = settings_value & 0xfffffcff;\n\n      if ((settings_value & 1) != 0) {\n        int start_time2 = get_pointer_value_08003760();\n\n        while ((*(uint *)(DAT_08005bac + 0x20) & 2) == 0) {\n          int current_time2 = get_pointer_value_08003760();\n\n          if (5000 < (uint)(current_time2 - start_time2)) {\n            return 3;\n          }\n        }\n      }\n    }\n\n    *(uint *)(DAT_08005bac + 0x20) = *(uint *)(DAT_08005bac + 0x20) & 0xfffffcff | settings[1];\n\n    if (is_bit_set2) {\n      *(uint *)(settings_memory + 0x1c) &= 0xefffffff;\n    }\n  }\n\n  if ((*settings & 2) != 0) {\n    *(uint *)(DAT_08005bac + 4) = *(uint *)(DAT_08005bac + 4) & 0xffff3fff | settings[2];\n  }\n\n  if ((*settings & 0x10) != 0) {\n    *(uint *)(DAT_08005bac + 4) = *(uint *)(DAT_08005bac + 4) & 0xffbfffff | settings[3];\n  }\n\n  return 0;\n}",
        "called": [
            "FUN_08003760"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005aa4",
        "calling": [
            "FUN_080035b8"
        ],
        "current_name": "update_settings_08005aa4"
    },
    "FUN_08005e6e": {
        "renaming": {
            "FUN_08005e6e": "process_flags_08005e6e",
            "param_1": "flag_ptr",
            "iVar1": "current_flag_ptr",
            "execute_callback_if_flag_set_0800771c": "execute_callback_if_flag_set",
            "doNothing_08005e6a": "perform_nothing",
            "do_nothing_08005e68": "perform_nothing",
            "execute_subtract_four_result_08007736": "subtract_four_from_result",
            "do_nothing_080064ae": "perform_nothing",
            "doNothing_08005e6c": "perform_nothing",
            "do_nothing_080064ac": "perform_nothing"
        },
        "code": "void process_flags_08005e6e(int *flag_ptr)\n{\n  int current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 2) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 2) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xfffffffd;\n    *(undefined *)(flag_ptr + 7) = 1;\n    if ((*(uint *)(*flag_ptr + 0x18) & 3) == 0) {\n      execute_callback_if_flag_set_0800771c();\n      doNothing_08005e6a_08005e6a(flag_ptr);\n    }\n    else {\n      do_nothing_08005e68_08005e68();\n    }\n    *(undefined *)(flag_ptr + 7) = 0;\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 4) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 4) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xfffffffb;\n    *(undefined *)(flag_ptr + 7) = 2;\n    if ((*(uint *)(*flag_ptr + 0x18) & 0x300) == 0) {\n      execute_callback_if_flag_set_0800771c(flag_ptr);\n      do_nothing_080064ae_08005e6a(flag_ptr);\n    }\n    else {\n      doNothing_08005e6c_08005e68(flag_ptr);\n    }\n    *(undefined *)(flag_ptr + 7) = 0;\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 8) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 8) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xfffffff7;\n    *(undefined *)(flag_ptr + 7) = 4;\n    if ((*(uint *)(*flag_ptr + 0x1c) & 3) == 0) {\n      execute_callback_if_flag_set_0800771c(flag_ptr);\n      do_nothing_080064ac_08005e6a(flag_ptr);\n    }\n    else {\n      perform_nothing_08005e68(flag_ptr);\n    }\n    *(undefined *)(flag_ptr + 7) = 0;\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 0x10) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 0x10) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xffffffef;\n    *(undefined *)(flag_ptr + 7) = 8;\n    if ((*(uint *)(*flag_ptr + 0x1c) & 0x300) == 0) {\n      execute_callback_if_flag_set_0800771c(flag_ptr);\n      perform_nothing_08005e6a(flag_ptr);\n    }\n    else {\n      perform_nothing_08005e68(flag_ptr);\n    }\n    *(undefined *)(flag_ptr + 7) = 0;\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 1) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 1) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xfffffffe;\n    execute_subtract_four_result_08007736_08007736(flag_ptr);\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 0x80) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 0x80) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xffffff7f;\n    perform_nothing_080064ae(flag_ptr);\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 0x40) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 0x40) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xffffffbf;\n    perform_nothing_08005e6c(flag_ptr);\n  }\n  current_flag_ptr = *flag_ptr;\n  if (((*(uint *)(current_flag_ptr + 0x10) & 0x20) != 0) && ((*(uint *)(current_flag_ptr + 0xc) & 0x20) != 0)) {\n    *(undefined4 *)(current_flag_ptr + 0x10) = 0xffffffdf;\n    perform_nothing_080064ac(flag_ptr);\n  }\n  return;\n}",
        "called": [
            "FUN_08005e6c",
            "FUN_08005e68",
            "FUN_08005e6a",
            "FUN_08007736",
            "FUN_080064ac",
            "FUN_0800771c",
            "FUN_080064ae"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005e6e",
        "calling": [],
        "current_name": "process_flags_08005e6e"
    },
    "FUN_08004024": {
        "renaming": {
            "FUN_08004024": "set_flag_08004024",
            "param_1": "flag_value",
            "DAT_08004040": "flag_ptr"
        },
        "code": "void set_flag_08004024(int flag_value) {\n  if (flag_value != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004024",
        "calling": [
            "FUN_080035b8"
        ],
        "current_name": "set_flag_08004024"
    },
    "FUN_08005e6a": {
        "renaming": {
            "FUN_08005e6a": "doNothing_08005e6a"
        },
        "code": "void doNothing_08005e6a(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005e6a",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "doNothing_08005e6a"
    },
    "FUN_08002400": {
        "renaming": {
            "FUN_08002400": "is_valid_input_08002400",
            "param_1": "input_index",
            "uVar1": "index"
        },
        "code": "int is_valid_input_08002400(int input_index) {\n  int index = 0;\n  while (index <= 11) {\n    if ((PTR_DAT_08002428[(input_index * 0xc + index) * 8] & 0x40) != 0) {\n      return 1;\n    }\n    index++;\n  }\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002400",
        "calling": [
            "FUN_08002644",
            "FUN_080025ac"
        ],
        "current_name": "is_valid_input_08002400"
    },
    "FUN_08004a1e": {
        "renaming": {
            "FUN_08004a1e": "doNothing_08004a1e"
        },
        "code": "void doNothing_08004a1e(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004a1e",
        "calling": [
            "FUN_08004b82",
            "FUN_08004ccc"
        ],
        "current_name": "doNothing_08004a1e"
    },
    "FUN_08000588": {
        "renaming": {
            "FUN_08000588": "process_input_and_update_state_08000588",
            "param_1": "input_index",
            "cVar1": "current_char",
            "cVar2": "current_input_char",
            "puVar3": "input_array"
        },
        "code": "void process_input_and_update_state_08000588(int input_index) {\\n  char current_input_char;\\n  char current_char;\\n  undefined *input_array;\\n  input_array = PTR_DAT_080005cc;\\n  process_input_08002644(PTR_DAT_080005d0 + (uint)(byte)PTR_DAT_080005cc[input_index] * 3);\\n  current_input_char = input_array[input_index];\\n  current_char = *PTR_DAT_080005d4;\\n  if ((current_input_char == current_char) && (current_char != '\\0')) {\\n    *PTR_DAT_080005d4 = current_char + -1;\\n  }\\n  else if (current_char != '\\0') {\\n    char next_char = *PTR_DAT_080005d8;\\n    *PTR_DAT_080005d8 = next_char + 1U;\\n    PTR_DAT_080005dc[(byte)(next_char + 1U) - 1] = current_input_char;\\n  }\\n  input_array[input_index] = 0xff;\\n  return;\\n}",
        "called": [
            "FUN_08002644"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000588",
        "calling": [
            "FUN_080005f8",
            "FUN_08001cd0"
        ],
        "current_name": "process_input_and_update_state_08000588"
    },
    "FUN_08002644": {
        "renaming": {
            "FUN_08002644": "process_input_08002644",
            "param_1": "input_buffer",
            "param_2": "input_length",
            "param_3": "timer_value",
            "param_4": "timer_status",
            "bVar1": "modified_byte",
            "uVar2": "first_byte",
            "iVar3": "is_input_valid"
        },
        "code": "void process_input_08002644(byte *input_buffer, uint input_length, uint timer_value, uint timer_status) {\n  byte first_byte = input_buffer[0];\n  byte modified_byte = PTR_DAT_08002670[first_byte * 8] & 0xbf;\n  PTR_DAT_08002670[first_byte * 8] = modified_byte;\n  int is_input_valid = is_valid_input_08002400((uint)((ulonglong)DAT_08002674 * (ulonglong)first_byte >> 0x23), input_length, modified_byte, (int)((ulonglong)DAT_08002674 * (ulonglong)first_byte), timer_status);\n  if (is_input_valid == 0) {\n    update_timer_status_08002578(PTR_DAT_08002678);\n  }\n  return;\n}",
        "called": [
            "FUN_08002578",
            "FUN_08002400"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002644",
        "calling": [
            "FUN_08000588"
        ],
        "current_name": "process_input_08002644"
    },
    "FUN_08008868": {
        "renaming": {
            "FUN_08008868": "wait_forever_08008868"
        },
        "code": "void wait_forever_08008868(void)\n{\n  while(true);\n}",
        "called": [
            "FUN_08008868"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008868",
        "calling": [
            "FUN_08009b5c",
            "FUN_08008868"
        ],
        "current_name": "wait_forever_08008868"
    },
    "FUN_080036ac": {
        "renaming": {
            "FUN_080036ac": "find_char_index_080036ac",
            "param_1": "input_char",
            "uVar1": "index",
            "PTR_DAT_080036d0": "CHAR_ARRAY"
        },
        "code": "uint find_char_index_080036ac(int input_char)\n{\n  uint index = 0;\n  if ((uint)(input_char << 0x18) >> 0x1c < 5) {\n    for (index = 0; (index < 0x3c && (input_char != (char)PTR_DAT_080036d0[index])); index = index + 1)\n    {\n    }\n  }\n  else {\n    index = 0xffffffff;\n  }\n  return index;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080036ac",
        "calling": [
            "FUN_080022f8",
            "FUN_080005f8",
            "FUN_08001cd0",
            "FUN_08000a64",
            "FUN_0800021a",
            "FUN_08000aec",
            "FUN_08000ef8"
        ],
        "current_name": "find_char_index_080036ac"
    },
    "FUN_08002f1e": {
        "renaming": {
            "FUN_08002f1e": "execute_function_pointer_08002f1e",
            "param_1": "param_address",
            "**(code **)**(undefined4 **)(param_1 + 0xc0)": "*(void (**)(void))(param_address + 0xc0)"
        },
        "code": "void execute_function_pointer_08002f1e(int param_address)\\n{\\n  void (*function_pointer)() = *(void (**)(void))(param_address + 0xc0);\\n  function_pointer();\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f1e",
        "calling": [
            "FUN_08001cd0"
        ],
        "current_name": "execute_function_pointer_08002f1e"
    },
    "FUN_0800885c": {
        "renaming": {
            "FUN_0800885c": "check_input_and_return_0800885c",
            "param_1": "input1",
            "param_2": "input2",
            "param_3": "input3",
            "param_4": "input4",
            "check_valid_input_08008500": "check_valid_input"
        },
        "code": "void check_input_and_return_0800885c(undefined4 input1, undefined4 input2, undefined4 input3, undefined4 input4)\n{\n  check_valid_input(input2, input3, input3, input4, input4);\n  return;\n}",
        "called": [
            "FUN_08008500"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800885c",
        "calling": [
            "FUN_0800a042"
        ],
        "current_name": "check_input_and_return_0800885c"
    },
    "FUN_0800643c": {
        "renaming": {
            "FUN_0800643c": "set_flag_and_enable_interrupts_0800643c",
            "param_1": "flag_ptr",
            "param_2": "flag_index",
            "set_bit_in_uint_at_index_08006420": "set_bit_in_uint_at_index"
        },
        "code": "void set_flag_and_enable_interrupts_0800643c(uint **flag_ptr, uint flag_index)\n{\n  set_bit_in_uint_at_index_08006420(*flag_ptr, flag_index, 4);\n  (*flag_ptr)[0x11] |= 0x8000;\n  **flag_ptr |= 1;\n  return;\n}",
        "called": [
            "FUN_08006420"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800643c",
        "calling": [
            "FUN_08007118"
        ],
        "current_name": "set_flag_and_enable_interrupts_0800643c"
    },
    "FUN_08002fca": {
        "renaming": {
            "FUN_08002fca": "write_bits_to_device_08002fca",
            "param_1": "device_id",
            "param_2": "device_data_ptr",
            "param_3": "num_bits",
            "param_4": "high_bit_value",
            "param_5": "low_bit_value",
            "uVar1": "bit_index"
        },
        "code": "void write_bits_to_device_08002fca(int device_id, int device_data_ptr, int num_bits, int high_bit_value, int low_bit_value) {\n  uint bit_index;\n  for (bit_index = 0; bit_index < num_bits; bit_index++) {\n    wait_for_device_response(high_bit_value);\n    set_bit_value(device_data_ptr, 1);\n    wait_for_device_response(low_bit_value);\n    set_bit_value(device_data_ptr, 0);\n  }\n  return;\n}",
        "called": [
            "FUN_08008a24",
            "FUN_08008ac4"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002fca",
        "calling": [
            "FUN_08003002"
        ],
        "current_name": "write_bits_to_device_08002fca"
    },
    "FUN_08009c7c": {
        "renaming": {
            "FUN_08009c7c": "process_data_08009c7c",
            "param_1": "data",
            "param_2": "params",
            "uVar1": "result",
            "iVar2": "offset",
            "piVar3": "param_ptr",
            "uVar4": "value",
            "uVar5": "flags",
            "iVar6": "count",
            "unaff_r4": "unaff_r4",
            "unaff_r5": "unaff_r5",
            "pcVar7": "callback",
            "iVar8": "read_result",
            "uVar9": "original_data",
            "UNRECOVERED_JUMPTABLE_00": "UNRECOVERED_JUMPTABLE_00",
            "bVar10": "is_valid"
        },
        "code": "uint32_t process_data_08009c7c(uint32_t *data, int *params) {\n  uint32_t result;\n  int *param_ptr;\n  uint32_t value;\n  uint16_t flags;\n  int offset;\n  int count;\n  int block_size;\n  code *callback;\n  int read_result;\n  uint32_t original_data;\n  bool is_valid;\n  \n  if (params[4] == 0) {\n    return 0;\n  }\n  \n  if (data == NULL) {\n    return 0;\n  }\n  \n  if (data[6] != 0) {\n    return 0;\n  }\n  \n  if (params == (int *)PTR_DAT_08009cc4) {\n    param_ptr = (int *)data[1];\n  }\n  else if (params == (int *)PTR_DAT_08009cc8) {\n    param_ptr = (int *)data[2];\n  }\n  else if (params == (int *)PTR_DAT_08009ccc) {\n    param_ptr = (int *)data[3];\n  }\n  else {\n    return 0;\n  }\n  \n  flags = *(uint16_t *)(param_ptr + 3);\n  \n  if (flags == 0) {\n    return 0;\n  }\n  \n  block_size = params[4];\n  callback = (code *)param_ptr[11];\n  \n  if (flags & 0x1000) {\n    read_result = params[21];\n  }\n  else {\n    original_data = *data;\n    *data = 0;\n    read_result = (*callback)(data, param_ptr[8], flags & 0x1000, 1);\n    if ((read_result == -1) && (*data != 0)) {\n      if ((*data != 0x1d) && (*data != 0x16)) {\n        *(uint16_t *)(param_ptr + 3) |= 0x40;\n        return (*UNRECOVERED_JUMPTABLE_00)();\n      }\n      *data = original_data;\n      goto LAB_08009b86;\n    }\n  }\n  \n  if ((flags & 0x4000) && (read_result == 0)) {\n    *(uint16_t *)(param_ptr + 3) |= 0x40;\n    return (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n  }\n  \n  if ((flags & 0x8000) && (read_result == 0)) {\n    return 0;\n  }\n  \n  count = params[1];\n  offset = params[16];\n  is_valid = params[13] != 0;\n  \n  if (is_valid) {\n    count -= params[16];\n    if (params[13] != 0) {\n      count -= params[19];\n    }\n  }\n  \n  while (count > 0) {\n    if (is_valid) {\n      block_size = params[4];\n      if (params[13] != 0) {\n        block_size -= params[19];\n      }\n    }\n    \n    read_result = (*callback)(data, param_ptr[8], block_size, count, unaff_r4, unaff_r5);\n    if (read_result < 1) {\n      *(uint16_t *)(param_ptr + 3) |= 0x40;\n      return (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n    }\n    \n    count -= read_result;\n    offset += read_result;\n  }\n  \nLAB_08009b86:\n  *(uint16_t *)(param_ptr + 3) &= 0x3fff;\n  params[1] = 0;\n  *params = params[4];\n  \n  if ((flags & 0x2000) && (read_result != -1)) {\n    params[21] = read_result;\n  }\n  \n  if ((flags & 0x400) && (read_result != -1 || (*data == 0))) {\n    params[21] = read_result;\n  }\n  \n  if (params[13] != 0) {\n    param_ptr[13] = 0;\n    if (param_ptr[13] != param_ptr + 17) {\n      add_to_linked_list_080091d8(data);\n    }\n    param_ptr[13] = 0;\n    return (*UNRECOVERED_JUMPTABLE_00)();\n  }\n  \n  return (*UNRECOVERED_JUMPTABLE_00)(0);\n}",
        "called": [
            "FUN_08009d50"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009c7c",
        "calling": [
            "FUN_0800932c"
        ],
        "current_name": "process_data_08009c7c",
        "code_backup": "\nundefined4 FUN_08009c7c(uint *param_1,int *param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int *piVar3;\n  uint uVar4;\n  ushort uVar5;\n  int iVar6;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  code *pcVar7;\n  int iVar8;\n  uint uVar9;\n  code *UNRECOVERED_JUMPTABLE_00;\n  bool bVar10;\n  \n  if (param_2[4] != 0) {\n    if ((param_1 != (uint *)0x0) && (param_1[6] == 0)) {\n      FUNC_08009d50();\n    }\n    if (param_2 == (int *)PTR_DAT_08009cc4) {\n      param_2 = (int *)param_1[1];\n    }\n    else if (param_2 == (int *)PTR_DAT_08009cc8) {\n      param_2 = (int *)param_1[2];\n    }\n    else if (param_2 == (int *)PTR_DAT_08009ccc) {\n      param_2 = (int *)param_1[3];\n    }\n    if (*(short *)(param_2 + 3) != 0) {\n      uVar5 = *(ushort *)(param_2 + 3);\n      uVar4 = (uint)uVar5;\n      if ((int)(uVar4 << 0x1c) < 0) {\n        iVar2 = param_2[4];\n        if (iVar2 != 0) {\n          iVar6 = uVar4 << 0x1e;\n          bVar10 = iVar6 != 0;\n          if (bVar10) {\n            iVar6 = 0;\n          }\n          iVar8 = *param_2;\n          if (!bVar10) {\n            iVar6 = param_2[5];\n          }\n          *param_2 = iVar2;\n          param_2[2] = iVar6;\n          for (iVar8 = iVar8 - iVar2; 0 < iVar8; iVar8 = iVar8 - iVar6) {\n            iVar6 = (*(code *)param_2[10])(param_1,param_2[8],iVar2,iVar8,unaff_r4,unaff_r5);\n            if (iVar6 < 1) {\n              uVar5 = *(ushort *)(param_2 + 3);\n              goto LAB_08009c62;\n            }\n            iVar2 = iVar2 + iVar6;\n          }\n        }\n      }\n      else if (((0 < param_2[1]) || (0 < param_2[0x10])) &&\n              (pcVar7 = (code *)param_2[0xb], pcVar7 != (code *)0x0)) {\n        uVar9 = *param_1;\n        *param_1 = 0;\n        if ((uVar5 & 0x1000) == 0) {\n          iVar2 = (*pcVar7)(param_1,param_2[8],uVar4 & 0x1000,1);\n          if ((iVar2 == -1) && (uVar4 = *param_1, uVar4 != 0)) {\n            if ((uVar4 != 0x1d) && (uVar4 != 0x16)) {\n              *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c2c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              uVar1 = (*UNRECOVERED_JUMPTABLE_00)();\n              return uVar1;\n            }\n            *param_1 = uVar9;\n            goto LAB_08009b86;\n          }\n        }\n        else {\n          iVar2 = param_2[0x15];\n        }\n        if (((int)((uint)*(ushort *)(param_2 + 3) << 0x1d) < 0) &&\n           (iVar2 = iVar2 - param_2[1], param_2[0xd] != 0)) {\n          iVar2 = iVar2 - param_2[0x10];\n        }\n        iVar2 = (*(code *)param_2[0xb])(param_1,param_2[8],iVar2,0);\n        uVar5 = *(ushort *)(param_2 + 3);\n        if ((iVar2 == -1) &&\n           ((0x1d < *param_1 || (-1 < (int)((DAT_08009c78 >> (*param_1 & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n          *(ushort *)(param_2 + 3) = uVar5 | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c6c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          uVar1 = (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n          return uVar1;\n        }\n        param_2[1] = 0;\n        *param_2 = param_2[4];\n        if (((int)((uint)uVar5 << 0x13) < 0) && ((iVar2 != -1 || (*param_1 == 0)))) {\n          param_2[0x15] = iVar2;\n        }\n        piVar3 = (int *)param_2[0xd];\n        *param_1 = uVar9;\n        if (piVar3 != (int *)0x0) {\n          if (piVar3 != param_2 + 0x11) {\n            add_to_linked_list_080091d8(param_1);\n          }\n          param_2[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08009c02. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          uVar1 = (*UNRECOVERED_JUMPTABLE_00)();\n          return uVar1;\n        }\n      }\nLAB_08009b86:\n                    /* WARNING: Could not recover jumptable at 0x08009b88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      uVar1 = (*UNRECOVERED_JUMPTABLE_00)(0);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
    },
    "FUN_08009b5c": {
        "renaming": {
            "FUN_08009b5c": "FUNC_08009b5c"
        },
        "code": "\nvoid FUNC_08009b5c(void)\n\n{\n  uint *puVar1;\n  int iVar2;\n  int *piVar3;\n  int *piVar4;\n  uint uVar5;\n  ushort uVar6;\n  int iVar7;\n  code *pcVar8;\n  int iVar9;\n  uint uVar10;\n  code *UNRECOVERED_JUMPTABLE_00;\n  bool bVar11;\n  undefined8 uVar12;\n  \n  process_input_08009fe8(6);\n  UNRECOVERED_JUMPTABLE_00 = (code *)0x8009b6b;\n  uVar12 = wait_forever_08008868(1);\n  piVar3 = (int *)((ulonglong)uVar12 >> 0x20);\n  puVar1 = (uint *)uVar12;\n  uVar6 = *(ushort *)(piVar3 + 3);\n  uVar5 = (uint)uVar6;\n  if ((int)(uVar5 << 0x1c) < 0) {\n    iVar2 = piVar3[4];\n    if (iVar2 != 0) {\n      iVar7 = uVar5 << 0x1e;\n      bVar11 = iVar7 != 0;\n      if (bVar11) {\n        iVar7 = 0;\n      }\n      iVar9 = *piVar3;\n      if (!bVar11) {\n        iVar7 = piVar3[5];\n      }\n      *piVar3 = iVar2;\n      piVar3[2] = iVar7;\n      for (iVar9 = iVar9 - iVar2; 0 < iVar9; iVar9 = iVar9 - iVar7) {\n        iVar7 = (*(code *)piVar3[10])(puVar1,piVar3[8],iVar2,iVar9);\n        if (iVar7 < 1) {\n          uVar6 = *(ushort *)(piVar3 + 3);\n          goto LAB_08009c62;\n        }\n        iVar2 = iVar2 + iVar7;\n      }\n    }\n  }\n  else if (((0 < piVar3[1]) || (0 < piVar3[0x10])) &&\n          (pcVar8 = (code *)piVar3[0xb], pcVar8 != (code *)0x0)) {\n    uVar10 = *puVar1;\n    *puVar1 = 0;\n    if ((uVar6 & 0x1000) == 0) {\n      iVar2 = (*pcVar8)(puVar1,piVar3[8],uVar5 & 0x1000,1);\n      if ((iVar2 == -1) && (uVar5 = *puVar1, uVar5 != 0)) {\n        if ((uVar5 != 0x1d) && (uVar5 != 0x16)) {\n          *(ushort *)(piVar3 + 3) = *(ushort *)(piVar3 + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c2c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          (*UNRECOVERED_JUMPTABLE_00)();\n          return;\n        }\n        *puVar1 = uVar10;\n        goto LAB_08009b86;\n      }\n    }\n    else {\n      iVar2 = piVar3[0x15];\n    }\n    if (((int)((uint)*(ushort *)(piVar3 + 3) << 0x1d) < 0) &&\n       (iVar2 = iVar2 - piVar3[1], piVar3[0xd] != 0)) {\n      iVar2 = iVar2 - piVar3[0x10];\n    }\n    iVar2 = (*(code *)piVar3[0xb])(puVar1,piVar3[8],iVar2,0);\n    uVar6 = *(ushort *)(piVar3 + 3);\n    if ((iVar2 == -1) &&\n       ((0x1d < *puVar1 || (-1 < (int)((DAT_08009c78 >> (*puVar1 & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(piVar3 + 3) = uVar6 | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08009c6c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n      return;\n    }\n    piVar3[1] = 0;\n    *piVar3 = piVar3[4];\n    if (((int)((uint)uVar6 << 0x13) < 0) && ((iVar2 != -1 || (*puVar1 == 0)))) {\n      piVar3[0x15] = iVar2;\n    }\n    piVar4 = (int *)piVar3[0xd];\n    *puVar1 = uVar10;\n    if (piVar4 != (int *)0x0) {\n      if (piVar4 != piVar3 + 0x11) {\n        add_to_linked_list_080091d8(puVar1);\n      }\n      piVar3[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08009c02. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*UNRECOVERED_JUMPTABLE_00)();\n      return;\n    }\n  }\nLAB_08009b86:\n                    /* WARNING: Could not recover jumptable at 0x08009b88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE_00)(0);\n  return;\n}\n\n",
        "called": [
            "FUN_08008868",
            "FUN_08009fe8",
            "FUN_080091d8"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08009b5c",
        "calling": [
            "FUN_080090cc",
            "FUN_0800a18c"
        ],
        "current_name": "FUNC_08009b5c"
    },
    "FUN_0800021a": {
        "renaming": {
            "FUN_0800021a": "process_value_0800021a",
            "param_1": "index",
            "param_2": "value",
            "param_3": "param1",
            "param_4": "param2",
            "bVar1": "is_value_valid",
            "iVar2": "char_index",
            "PTR_DAT_080002d8": "ptr_data_1",
            "PTR_DAT_080002dc": "ptr_data_2",
            "PTR_DAT_080002e0": "ptr_data_3",
            "PTR_DAT_080002e4": "ptr_data_4",
            "PTR_DAT_080002e8": "ptr_data_5",
            "get_value_at_offset_08002fa0": "get_value_type_at_offset",
            "find_char_index_080036ac": "find_char_index",
            "compare_values_0800738a": "compare_values",
            "process_bit_080088e0": "process_bit",
            "set_value_at_index_08002fc2": "set_value_at_index",
            "set_value_based_on_conditions_080026b0": "set_value_based_on_conditions"
        },
        "code": "void process_value_0800021a(uint index, uint value, uint param1, uint param2)\n{\n  bool is_value_valid;\n  int char_index;\n  int compare_result;\n  \n  int value_type = get_value_at_offset_08002fa0(PTR_DAT_080002d8, index, param1, param2, param2);\n  if (value_type == 3) {\n    if (index < 0x3c) {\n      if (PTR_DAT_080002dc[index] == -1) {\n        is_value_valid = false;\n      }\n      else {\n        char_index = find_char_index_080036ac();\n        if (char_index == 0) {\n          is_value_valid = false;\n        }\n        else {\n          char_index = find_char_index_080036ac((int)(char)PTR_DAT_080002dc[index]);\n          if (char_index == 1) {\n            is_value_valid = false;\n          }\n          else {\n            compare_result = compare_values_0800738a((int)(char)PTR_DAT_080002dc[index], PTR_DAT_080002e8);\n            is_value_valid = (compare_result != 0);\n          }\n        }\n      }\n    }\n    else {\n      is_value_valid = false;\n    }\n    if (is_value_valid) {\n      process_bit(index, value);\n    }\n    set_value_at_index_08002fc2(PTR_DAT_080002d8, index, value);\n  }\n  else if (value_type == 4) {\n    if (index < 0x3c) {\n      if (PTR_DAT_080002dc[index] == -1) {\n        is_value_valid = false;\n      }\n      else {\n        char_index = find_char_index_080036ac();\n        if (char_index == 0) {\n          is_value_valid = false;\n        }\n        else {\n          char_index = find_char_index_080036ac((int)(char)PTR_DAT_080002dc[index]);\n          if (char_index == 1) {\n            is_value_valid = false;\n          }\n          else {\n            is_value_valid = true;\n          }\n        }\n      }\n    }\n    else {\n      is_value_valid = false;\n    }\n    if (is_value_valid) {\n      set_value_based_on_conditions_080026b0(PTR_DAT_080002e4 + (uint)(byte)PTR_DAT_080002e0[index] * 3, value);\n    }\n    set_value_at_index_08002fc2(PTR_DAT_080002d8, index, value);\n    return;\n  }\n  return;\n}",
        "called": [
            "FUN_080026b0",
            "FUN_08002fc2",
            "FUN_08002fa0",
            "FUN_080036ac",
            "FUN_080088e0",
            "FUN_0800738a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800021a",
        "calling": [
            "FUN_08000214"
        ],
        "current_name": "process_value_0800021a"
    },
    "FUN_08008a6c": {
        "renaming": {
            "FUN_08008a6c": "check_bit_and_return_if_set_08008a6c",
            "param_1": "bit_data",
            "PTR_DAT_08008ab4": "bit_positions",
            "uVar4": "bit_position",
            "read_bit_at_position_08006b28": "read_bit_at_position",
            "PTR_DAT_08008ab8": "bit_data_array",
            "uVar3": "data",
            "get_data_by_index_08006b7c": "get_data_by_index"
        },
        "code": "char check_bit_and_return_if_set_08008a6c(uint bit_data, uint bit_position)\n{\n  uint bit_mask = 1 << (bit_position & 0xf) & 0xffff;\n  if (bit_data & bit_mask) {\n    return 1;\n  }\n  return 0;\n}",
        "called": [
            "FUN_08006b28",
            "FUN_080072f0",
            "FUN_08006b7c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008a6c",
        "calling": [
            "FUN_08000ef8"
        ],
        "current_name": "check_bit_and_return_if_set_08008a6c"
    },
    "FUN_080026f8": {
        "renaming": {
            "FUN_080026f8": "calculate_index_from_input_080026f8",
            "param_1": "input",
            "PTR_DAT_08002708": "PTR_DATA_08002708"
        },
        "code": "uint calculate_index_from_input_080026f8(byte *input) {\\n  uint input_value = (uint)*input;\\n  uint index = input_value * 8;\\n  uint byte_value = (uint)(byte)PTR_DAT_08002708[index];\\n  uint shifted_value = byte_value << 0x19;\\n  uint result = shifted_value >> 0x1f;\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080026f8",
        "calling": [
            "FUN_080005f8",
            "FUN_08001cd0"
        ],
        "current_name": "calculate_index_from_input_080026f8"
    },
    "FUN_080085b8": {
        "renaming": {
            "FUN_080085b8": "check_combination_080085b8",
            "param_1": "index",
            "uVar1": "combined_value"
        },
        "code": "bool check_combination_080085b8(int index)\n{\n  uint combined_value = combine_two_bytes(*(undefined4 *)(PTR_DAT_080085d8 + (uint)*(byte *)(index + 0x44) * 4));\n  return (combined_value & 0x22) == 0x22;\n}",
        "called": [
            "FUN_08006b1c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080085b8",
        "calling": [
            "FUN_0800863c",
            "FUN_08008600"
        ],
        "current_name": "check_combination_080085b8"
    },
    "FUN_08001c08": {
        "renaming": {
            "FUN_08001c08": "readNextByte_08001c08",
            "uVar1": "nextByte",
            "get_next_byte_08002720": "getNextByteFromPointer",
            "PTR_DAT_08001c14": "PTR_DATA_08001c14"
        },
        "code": "uint8_t readNextByte_08001c08(void)\n{\n  uint8_t nextByte = get_next_byte_08002720(PTR_DAT_08001c14);\n  return nextByte;\n}",
        "called": [
            "FUN_08002720"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08001c08",
        "calling": [
            "FUN_08001c18"
        ],
        "current_name": "readNextByte_08001c08"
    },
    "FUN_080075dc": {
        "renaming": {
            "FUN_080075dc": "check_clock_source_080075dc",
            "param_1": "clock_source",
            "local_1c": "extracted_data1",
            "local_20": "extracted_data2",
            "local_18": "local_var1",
            "local_14": "local_var2",
            "local_10": "local_var3",
            "local_c": "local_var4",
            "check_timer_08007594": "check_timer_status",
            "get_shifted_value_from_pointer_08005a28": "get_shifted_value_from_pointer1",
            "get_shifted_value_from_pointer_08005a48": "get_shifted_value_from_pointer2",
            "initialize_and_call_function_080098d8": "initialize_and_call_function",
            "PTR_s_TIM__Unknown_clock_source_08007644": "PTR_s_TIM__Unknown_clock_source_08007644"
        },
        "code": "int check_clock_source_080075dc(uint8_t clock_source)\n{\n  uint16_t extracted_data1;\n  uint16_t extracted_data2;\n  uint16_t extracted_data3;\n  uint16_t extracted_data4;\n  uint16_t local_var1 = 0;\n  uint16_t local_var2 = 0;\n  uint16_t local_var3 = 0;\n  uint16_t local_var4 = 0;\n  uint16_t local_var5 = 0;\n  extract_data(&extracted_data1, &extracted_data2);\n  int timer_status = check_timer_status(clock_source);\n  uint16_t shifted_value = 0;\n  if (timer_status == 1) {\n    shifted_value = get_shifted_value_from_pointer_08005a28();\n  }\n  else if (timer_status == 2) {\n    shifted_value = get_shifted_value_from_pointer_08005a48();\n    local_var4 = local_var5;\n  }\n  else {\n    initialize_and_call_function(PTR_s_TIM__Unknown_clock_source_08007644);\n    shifted_value = 0;\n    local_var4 = 0;\n  }\n  if (local_var4 != 0x500) {\n    if (local_var4 < 0x501) {\n      if (local_var4 != 0x400) {\n        return shifted_value;\n      }\n    }\n    else if ((local_var4 != 0x600) && (local_var4 != 0x700)) {\n      return shifted_value;\n    }\n  }\n  return shifted_value << 1;\n}",
        "called": [
            "FUN_08005a48",
            "FUN_080098d8",
            "FUN_08005a68",
            "FUN_08007594",
            "FUN_08005a28"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080075dc",
        "calling": [
            "FUN_08007648",
            "FUN_08007118"
        ],
        "current_name": "check_clock_source_080075dc"
    },
    "FUN_08007544": {
        "renaming": {
            "FUN_08007544": "determine_timer_type_08007544",
            "param_1": "timer_value",
            "DAT_08007588": "timer_type1_value",
            "DAT_0800758c": "timer_type2_value"
        },
        "code": "int determine_timer_type_08007544(uint32_t timer_value) {\n  if (timer_value == 0xffffffff) {\n    return 0;\n  }\n  if (timer_value == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < timer_value) {\n    if (timer_value == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (timer_value == DAT_0800758c + 0x12400) {\n      return 0x19;\n    }\n  }\n  else if (timer_value == 0x40000000) {\n    return 0x1c;\n  }\n  initialize_and_call_function(PTR_s_TIM__Unknown_timer_IRQn_08007590);\n  return 0;\n}",
        "called": [
            "FUN_080098d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007544",
        "calling": [
            "FUN_08007648",
            "FUN_080076e0"
        ],
        "current_name": "determine_timer_type_08007544"
    },
    "FUN_08007ff0": {
        "renaming": {
            "FUN_08007ff0": "execute_command_and_update_values_08007ff0",
            "param_1": "input_value",
            "iVar1": "command_result",
            "PTR_DAT_08007f78": "SUBTRACT_FUNCTION_OFFSET",
            "PTR_DAT_080049e0": "SET_AND_UPDATE_FUNCTION_OFFSET",
            "0x60": "COMMAND_FUNCTION_OFFSET",
            "0x5c": "COMMAND_VALID_FLAG_OFFSET",
            "0x2c": "COMMAND_CHAR_OFFSET",
            "0x68": "COMMAND_ARGUMENT_OFFSET",
            "DAT_08007f7c": "VALID_COMMAND_FLAG"
        },
        "code": "void execute_command_and_update_values_08007ff0(uint input_value)\n{\n  int command_result = subtract_four_from_input();\n  bool is_valid_command = (*(code **)(command_result + COMMAND_FUNCTION_OFFSET) != (code *)0x0) && (*(char *)(command_result + COMMAND_VALID_FLAG_OFFSET) == DAT_08007f7c) && (*(char *)(command_result + COMMAND_CHAR_OFFSET) != ' ');\n  if (is_valid_command) {\n    (**(code **)(command_result + COMMAND_FUNCTION_OFFSET))(command_result + COMMAND_ARGUMENT_OFFSET);\n  }\n  set_and_update_values(input_value);\n  return;\n}",
        "called": [
            "FUN_080049e0",
            "FUN_08007f78"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007ff0",
        "calling": [
            "FUN_08005084",
            "FUN_08004f3c",
            "FUN_08004aec"
        ],
        "current_name": "execute_command_and_update_values_08007ff0"
    },
    "FUN_08008990": {
        "renaming": {
            "FUN_08008990": "process_bit_08008990",
            "param_1": "bit_index",
            "param_2": "operation_type",
            "param_3": "update_value",
            "param_4": "data_array",
            "iVar1": "flag_index",
            "puVar2": "flag_array",
            "iVar3": "bit_value",
            "PTR_DAT_08008a14": "flag_array",
            "PTR_DAT_08008a18": "flag_array",
            "PTR_DAT_08008a1c": "flag_array",
            "PTR_DAT_08008a20": "flag_array",
            "read_bit_at_position_08006b28": "read_bit_at_position",
            "compare_values_0800738a": "compare_values",
            "check_and_update_flags_080071e4": "check_and_update_flags",
            "update_bit_08006b5c": "update_bit",
            "set_flag_and_update_data_08007258": "set_flag_and_update_data",
            "set_bit_at_index_08006b3e": "set_bit_at_index"
        },
        "code": "void process_bit_08008990(uint bit_index, uint operation_type, uint update_value, uint *data_array)\n{\n  int flag_index;\n  uint *PTR_DAT_08008a14;\n  int bit_value;\n\n  if (bit_index < 0x3c) {\n    flag_index = (int)(char)PTR_DAT_08008a14[bit_index];\n    PTR_DAT_08008a14 = PTR_DAT_08008a14;\n  }\n  else {\n    flag_index = -1;\n    PTR_DAT_08008a14 = data_array;\n  }\n\n  if (flag_index != -1) {\n    bit_value = read_bit_at_position_08006b28(flag_index, PTR_DAT_08008a14, update_value, data_array);\n    if (bit_value != 0) {\n      bit_value = compare_values_0800738a(flag_index, PTR_DAT_08008a14);\n      if (bit_value != 0) {\n        check_and_update_flags(flag_index);\n      }\n      update_bit_08006b5c(flag_index, PTR_DAT_08008a14);\n    }\n\n    switch (operation_type) {\n      case 0:\n        set_flag_and_update_data_08007258(flag_index, 0);\n        break;\n      case 1:\n        set_flag_and_update_data_08007258(flag_index, 1, 0);\n        break;\n      case 2:\n        set_flag_and_update_data_08007258(flag_index, 0, 1);\n        break;\n      case 3:\n        set_flag_and_update_data_08007258(flag_index, 0, 2);\n        break;\n    }\n\n    set_bit_at_index_08006b3e(flag_index, PTR_DAT_08008a14);\n  }\n  return;\n}",
        "called": [
            "FUN_08006b5c",
            "FUN_08006b28",
            "FUN_08007258",
            "FUN_080071e4",
            "FUN_08006b3e",
            "FUN_0800738a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008990",
        "calling": [
            "FUN_08003002",
            "FUN_080005f8",
            "FUN_080088e0",
            "FUN_080025ac"
        ],
        "current_name": "process_bit_08008990"
    },
    "FUN_08008078": {
        "renaming": {
            "FUN_08008078": "FUNC_08008078"
        },
        "code": "\nvoid FUNC_08008078(int *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  undefined4 uVar5;\n  uint uVar6;\n  uint local_20;\n  uint local_1c;\n  uint local_18;\n  undefined4 local_14;\n  \n  if (param_1 != (int *)0x0) {\n    iVar2 = get_parameter_value_08007320((int)*(char *)(param_1 + 0x16),PTR_DAT_08008330);\n    iVar3 = get_parameter_value_08007320((int)*(char *)((int)param_1 + 0x59),PTR_DAT_08008334);\n    if ((iVar3 == 0) || (iVar2 == 0)) {\n      initialize_and_call_function_080098d8(PTR_s_ERROR__at_least_one_UART_pin_has_08008348,iVar3);\n    }\n    else {\n      iVar4 = compare_and_return_080073ae(iVar2);\n      *param_1 = iVar4;\n      iVar1 = DAT_08008340;\n      iVar3 = DAT_0800833c;\n      iVar2 = DAT_08008338;\n      if (iVar4 == 0) {\n        initialize_and_call_function_080098d8(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (iVar4 == DAT_08008338) {\n          *(uint *)(DAT_08008338 + 0xd80c) = *(uint *)(DAT_08008338 + 0xd80c) | 0x4000;\n          *(uint *)(iVar2 + 0xd80c) = *(uint *)(iVar2 + 0xd80c) & 0xffffbfff;\n          *(uint *)(iVar2 + 0xd818) = *(uint *)(iVar2 + 0xd818) | 0x4000;\n          *(undefined *)(param_1 + 0x11) = 0;\n          *(undefined *)((int)param_1 + 0x5a) = 0x25;\n        }\n        else if (iVar4 == DAT_0800833c) {\n          *(uint *)(DAT_0800833c + 0x1cc10) = *(uint *)(DAT_0800833c + 0x1cc10) | 0x20000;\n          *(uint *)(iVar3 + 0x1cc10) = *(uint *)(iVar3 + 0x1cc10) & 0xfffdffff;\n          *(uint *)(iVar3 + 0x1cc1c) = *(uint *)(iVar3 + 0x1cc1c) | 0x20000;\n          *(undefined *)(param_1 + 0x11) = 1;\n          *(undefined *)((int)param_1 + 0x5a) = 0x26;\n        }\n        else if (iVar4 == DAT_08008340) {\n          *(uint *)(DAT_08008340 + 0x1c810) = *(uint *)(DAT_08008340 + 0x1c810) | 0x40000;\n          *(uint *)(iVar1 + 0x1c810) = *(uint *)(iVar1 + 0x1c810) & 0xfffbffff;\n          *(uint *)(iVar1 + 0x1c81c) = *(uint *)(iVar1 + 0x1c81c) | 0x40000;\n          *(undefined *)(param_1 + 0x11) = 2;\n          *(undefined *)((int)param_1 + 0x5a) = 0x27;\n        }\n        uVar5 = set_flag_08006bb8((uint)((int)*(char *)((int)param_1 + 0x59) << 0x18) >> 0x1c);\n        uVar6 = find_param_08007376((int)*(char *)((int)param_1 + 0x59),PTR_DAT_08008334);\n        local_20 = 1 << (*(byte *)((int)param_1 + 0x59) & 0xf) & 0xffff;\n        local_1c = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        local_18 = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        local_14 = 3;\n        FUNC_080040e8(uVar5,&local_20);\n        uVar5 = set_flag_08006bb8((uint)((int)*(char *)(param_1 + 0x16) << 0x18) >> 0x1c);\n        uVar6 = find_param_08007376((int)*(char *)(param_1 + 0x16),PTR_DAT_08008330);\n        local_20 = 1 << (*(byte *)(param_1 + 0x16) & 0xf) & 0xffff;\n        local_1c = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        local_18 = (uVar6 << 0x1a) >> 0x1e;\n        FUNC_080040e8(uVar5,&local_20);\n        *(int **)(PTR_DAT_08008354 + (uint)*(byte *)(param_1 + 0x11) * 4) = param_1 + 1;\n        param_1[1] = *param_1;\n        param_1[2] = param_1[0x12];\n        param_1[3] = param_1[0x13];\n        param_1[4] = param_1[0x14];\n        param_1[5] = param_1[0x15];\n        param_1[6] = 0xc;\n        param_1[7] = 0;\n        param_1[8] = 0;\n        check_and_set_value_0800674e(param_1 + 1);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_080040e8",
            "FUN_0800674e",
            "FUN_08007376",
            "FUN_080098d8",
            "FUN_08006bb8",
            "FUN_080073ae",
            "FUN_08007320"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08008078",
        "calling": [
            "FUN_080084b0",
            "FUN_08008c44"
        ],
        "current_name": "FUNC_08008078"
    },
    "FUN_08004396": {
        "renaming": {
            "FUN_08004396": "set_param_value_08004396",
            "param_1": "param_array",
            "*param_1": "*param_array",
            "PTR_": "",
            "DAT_": "",
            "uint": "uint32_t",
            "param_value": "param_value",
            "ptr_value": "ptr_value"
        },
        "code": "DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_oDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_dDAT_PDAT_TDAT_RDAT__DAT_ set_param_value_08004396(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_3DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_3DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_[DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_]DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_3DAT_PDAT_TDAT_RDAT__DAT_2DAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_yDAT_PDAT_TDAT_RDAT__DAT_[DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_]DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_&DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004396",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "set_param_value_08004396"
    },
    "FUN_08003fb0": {
        "renaming": {
            "FUN_08003fb0": "set_bit_in_array_08003fb0",
            "param_1": "index",
            "DAT_08003fd4": "array_start"
        },
        "code": "void set_bit_in_array_08003fb0(uint index) {\\n  if (index >= 0) {\\n    int array_index = (index >> 5) + 0x20;\\n    int* array_ptr = (int *)(DAT_08003fd4 + array_index * 4);\\n    int bit_index = index & 0x1f;\\n    int bit_mask = 1 << bit_index;\\n    *array_ptr = bit_mask;\\n    DataSynchronizationBarrier(0xf);\\n    InstructionSynchronizationBarrier(0xf);\\n  }\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003fb0",
        "calling": [
            "FUN_080076e0"
        ],
        "current_name": "set_bit_in_array_08003fb0"
    },
    "FUN_080052f0": {
        "renaming": {
            "FUN_080052f0": "check_and_execute_command_080052f0",
            "param_1": "command_data_ptr",
            "puVar2": "command_data",
            "uVar3": "command_flags",
            "uVar4": "command_status",
            "DAT_080053c8": "COMMAND_FLAG_A",
            "0x100": "COMMAND_STATUS_B",
            "0x10200": "COMMAND_FLAG_E",
            "0x10400": "COMMAND_FLAG_G",
            "0x10800": "COMMAND_FLAG_J",
            "*(char *)((int)command_data_ptr + 0x3d)": "command_char",
            "*(char *)((int)command_data_ptr + 0x3e)": "command_char_2",
            "*(short *)((int)command_data_ptr + 0x2a)": "command_short",
            "0xc": "command_c_offset",
            "(uint *)0x21": "command_c_value",
            "execute_param_08004f3c": "execute_command",
            "updateCommand_08004aec": "execute_update_command",
            "COMMAND_FLAG_C": "COMMAND_FLAG_UPDATED",
            "COMMAND_FLAG_F": "COMMAND_FLAG_MODIFIED",
            "COMMAND_FLAG_H": "COMMAND_FLAG_ERROR",
            "COMMAND_FLAG_K": "COMMAND_FLAG_OTHER",
            "COMMAND_STATUS_D": "COMMAND_STATUS_UPDATED",
            "COMMAND_STATUS_I": "COMMAND_STATUS_MODIFIED",
            "COMMAND_PTR_OFFSET": "0x10"
        },
        "code": "void check_and_execute_command_080052f0(uint **command_data_ptr) {\n  uint *command_data = *command_data_ptr;\n  uint command_flags = command_data[5];\n  uint command_status = command_data[1];\n\n  if (((command_flags & DAT_080053c8) != 0) && ((command_status & COMMAND_STATUS_B) != 0)) {\n    command_data_ptr[COMMAND_PTR_OFFSET] = (uint *)((uint)command_data_ptr[COMMAND_PTR_OFFSET] | COMMAND_FLAG_C);\n    command_data[5] = 0xfffffeff;\n    **command_data_ptr = **command_data_ptr | COMMAND_STATUS_D;\n  }\n\n  if (((command_flags & COMMAND_FLAG_E) != 0) && ((command_status & COMMAND_STATUS_B) != 0)) {\n    command_data_ptr[COMMAND_PTR_OFFSET] = (uint *)((uint)command_data_ptr[COMMAND_PTR_OFFSET] | COMMAND_FLAG_F);\n    (*command_data_ptr)[5] = 0xfffffdff;\n  }\n\n  if (((command_flags & COMMAND_FLAG_G) != 0) && ((command_status & COMMAND_STATUS_B) != 0)) {\n    char command_char = *(char *)((int)command_data_ptr + 0x3d);\n    if (((*(char *)((int)command_data_ptr + 0x3e) == ' ') && (*(short *)((int)command_data_ptr + 0x2a) == 0)) && (((command_char == '!' || (command_char == ')')) || ((command_char == '(' && (command_data_ptr[0xc] == (uint *)0x21)))))) {\n      execute_update_command(command_data_ptr);\n    }\n    else {\n      command_data_ptr[COMMAND_PTR_OFFSET] = (uint *)((uint)command_data_ptr[COMMAND_PTR_OFFSET] | COMMAND_FLAG_H);\n      if (*(char *)((int)command_data_ptr + 0x3e) == '\\x10') {\n        **command_data_ptr = **command_data_ptr | COMMAND_STATUS_I;\n      }\n      (*command_data_ptr)[5] = 0xfffffbff;\n    }\n  }\n\n  if (((command_flags & COMMAND_FLAG_J) != 0) && ((command_status & COMMAND_STATUS_B) != 0)) {\n    command_data_ptr[COMMAND_PTR_OFFSET] = (uint *)((uint)command_data_ptr[COMMAND_PTR_OFFSET] | COMMAND_FLAG_K);\n    (*command_data_ptr)[5] = 0xfffff7ff;\n  }\n\n  if (command_data_ptr[COMMAND_PTR_OFFSET] != (uint *)0x0) {\n    execute_param_08004f3c(command_data_ptr);\n  }\n  return;\n}",
        "called": [
            "FUN_08004f3c",
            "FUN_08004aec"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080052f0",
        "calling": [],
        "current_name": "check_and_execute_command_080052f0"
    },
    "FUN_08008f0c": {
        "renaming": {
            "FUN_08008f0c": "doNothing_08008f0c"
        },
        "code": "void doNothing_08008f0c(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008f0c",
        "calling": [
            "FUN_08008f1c"
        ],
        "current_name": "doNothing_08008f0c"
    },
    "FUN_08002ec4": {
        "renaming": {
            "FUN_08002ec4": "execute_function_08002ec4",
            "param_1": "param",
            "function_pointer": "function_pointer"
        },
        "code": "void execute_function_08002ec4(int param){\n    void (*function_pointer)() = (**(code **)(**(int **)(param + 0xc0) + 8));\n    function_pointer();\n    return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ec4",
        "calling": [
            "FUN_080022f8"
        ],
        "current_name": "execute_function_08002ec4"
    },
    "FUN_08007306": {
        "renaming": {
            "FUN_08007306": "find_parameter_value_08007306",
            "param_1": "target_value",
            "param_2": "parameter_list",
            "*param_2": "*parameter_list",
            "PTR_": "",
            "DAT_": "",
            "undefined4": "int",
            "0": "0",
            "-1": "-1",
            "*(undefined4 *)(param_2 + 4)": "*(int *)(parameter_list + 4)"
        },
        "code": "DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ find_parameter_value_08007306(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_,DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_wDAT_PDAT_TDAT_RDAT__DAT_hDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_!DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_-DAT_PDAT_TDAT_RDAT__DAT_1DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_fDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_gDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_vDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_{DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_*DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_(DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_4DAT_PDAT_TDAT_RDAT__DAT_)DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_pDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_aDAT_PDAT_TDAT_RDAT__DAT_mDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT__DAT_PDAT_TDAT_RDAT__DAT_lDAT_PDAT_TDAT_RDAT__DAT_iDAT_PDAT_TDAT_RDAT__DAT_sDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_+DAT_PDAT_TDAT_RDAT__DAT_=DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_xDAT_PDAT_TDAT_RDAT__DAT_cDAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_eDAT_PDAT_TDAT_RDAT__DAT_tDAT_PDAT_TDAT_RDAT__DAT_uDAT_PDAT_TDAT_RDAT__DAT_rDAT_PDAT_TDAT_RDAT__DAT_nDAT_PDAT_TDAT_RDAT__DAT_ DAT_PDAT_TDAT_RDAT__DAT_0DAT_PDAT_TDAT_RDAT__DAT_;DAT_PDAT_TDAT_RDAT__DAT_\nDAT_PDAT_TDAT_RDAT__DAT_}DAT_PDAT_TDAT_RDAT__DAT_",
        "called": [
            "FUN_08007306"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007306",
        "calling": [
            "FUN_08007306",
            "FUN_08007320"
        ],
        "current_name": "find_parameter_value_08007306"
    },
    "FUN_08008f0e": {
        "renaming": {
            "FUN_08008f0e": "initialize_device_and_validate_input_08008f0e",
            "updateParameter_08003f0c": "update_parameter",
            "initialize_device_and_validate_input_080036a2": "validate_input"
        },
        "code": "void initialize_device_and_validate_input_08008f0e()\n{\n  updateParameter_08003f0c(3);\n  validate_input();\n  return;\n}",
        "called": [
            "FUN_080036a2",
            "FUN_08003f0c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008f0e",
        "calling": [
            "FUN_08009148"
        ],
        "current_name": "initialize_device_and_validate_input_08008f0e"
    },
    "FUN_08002f2c": {
        "renaming": {
            "FUN_08002f2c": "set_value_at_address_08002f2c",
            "param_1": "value",
            "param_2": "address",
            "param_3": "value",
            "PTR_DAT_08002f74": "address_0x90",
            "PTR_DAT_08002f70": "address_0xc0",
            "PTR_DAT_08002f78": "address_0xd0",
            "PTR_DAT_08002f6c": "address_0xe0",
            "PTR_DAT_08002f7c": "address_0xf4",
            "PTR_DAT_08002f80": "address_0xf5"
        },
        "code": "void set_value_at_address_08002f2c(uint8_t value, uint16_t address) {\n  switch(address) {\n    case 0x90:\n      *(uint8_t*)PTR_DAT_08002f74 = value;\n      break;\n    case 0xc0:\n      *(uint8_t*)PTR_DAT_08002f70 = value;\n      break;\n    case 0xd0:\n      *(uint8_t*)PTR_DAT_08002f78 = value;\n      break;\n    case 0xe0:\n      *(uint8_t*)PTR_DAT_08002f6c = value;\n      break;\n    case 0xf4:\n      *(uint8_t*)PTR_DAT_08002f7c = value;\n      break;\n    case 0xf5:\n      *(uint8_t*)PTR_DAT_08002f80 = value;\n      break;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f2c",
        "calling": [
            "FUN_08001b48"
        ],
        "current_name": "set_value_at_address_08002f2c"
    },
    "FUN_08004954": {
        "renaming": {
            "FUN_08004954": "process_input_08004954",
            "param_1": "input_pointer",
            "param_2": "input_data",
            "param_3": "input_length",
            "param_4": "output_data",
            "uVar1": "result",
            "puVar2": "pointer_to_input_data"
        },
        "code": "int process_input_08004954(uint **input_pointer, uint *input_data, int input_length, uint *output_data) {\\n  int result;\\n  uint *pointer_to_input_data;\\n  if (*(char *)((int)input_pointer + 0x3d) == '(') {\\n    if (input_data == NULL) {\\n      result = 1;\\n    }\\n    else if (input_length == 0) {\\n      result = 1;\\n    }\\n    else if (*(char *)(input_pointer + 0xf) == '\\x01') {\\n      result = 2;\\n    }\\n    else {\\n      *(undefined *)(input_pointer + 0xf) = 1;\\n      pointer_to_input_data = *input_pointer;\\n      if ((*pointer_to_input_data & 1) == 0) {\\n        *pointer_to_input_data = *pointer_to_input_data | 1;\\n      }\\n      **input_pointer = **input_pointer & 0xfffff7ff;\\n      *(undefined *)((int)input_pointer + 0x3d) = 0x2a;\\n      *(undefined *)((int)input_pointer + 0x3e) = 0x20;\\n      result = 0;\\n      input_pointer[0x10] = NULL;\\n      input_pointer[9] = input_data;\\n      *(short *)((int)input_pointer + 0x2a) = (short)input_length;\\n      input_pointer[0xb] = output_data;\\n      *(undefined2 *)(input_pointer + 10) = *(undefined2 *)((int)input_pointer + 0x2a);\\n      *(undefined *)(input_pointer + 0xf) = 0;\\n      (*input_pointer)[1] = (*input_pointer)[1] | 0x700;\\n    }\\n  }\\n  else {\\n    result = 2;\\n  }\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004954",
        "calling": [
            "FUN_08007fa0"
        ],
        "current_name": "process_input_08004954"
    },
    "FUN_08005cec": {
        "renaming": {
            "FUN_08005cec": "update_data_08005cec",
            "param_1": "data_index",
            "param_2": "data_array",
            "uVar1": "new_flags",
            "uVar2": "updated_flags",
            "uVar3": "old_flags"
        },
        "code": "void update_data_08005cec(int data_index, uint *data_array)\n{\n  uint updated_flags;\n  uint old_flags;\n  uint new_flags;\n\n  old_flags = *(uint *)(data_index + 0x20);\n  *(uint *)(data_index + 0x20) = old_flags & 0xfffffffe;\n  new_flags = (old_flags & 0xfffffffd) | data_array[2];\n  if (data_index == DAT_08005d44) {\n    new_flags = (new_flags & 0xfffffff7) | data_array[3];\n    updated_flags = (*(uint *)(data_index + 4) & 0xfffffcff) | data_array[5] | data_array[6];\n  }\n  else {\n    updated_flags = *(uint *)(data_index + 4);\n  }\n  *(uint *)(data_index + 4) = updated_flags;\n  *(uint *)(data_index + 0x18) = (*(uint *)(data_index + 0x18) & 0xffffff8c) | data_array[0];\n  *(uint *)(data_index + 0x34) = data_array[1];\n  *(uint *)(data_index + 0x20) = new_flags;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005cec",
        "calling": [
            "FUN_08006186",
            "FUN_08006128"
        ],
        "current_name": "update_data_08005cec"
    },
    "FUN_0800886c": {
        "renaming": {
            "FUN_0800886c": "initialize_ptr_dat_value_0800886c",
            "PTR_DAT_08008878": "ptr_dat_value"
        },
        "code": "void initialize_ptr_dat_value_0800886c(void)\\n{\\n  int new_value = 22;\\n  int* PTR_DAT_08008878 = (int*)PTR_DAT_08008878;\\n  *PTR_DAT_08008878 = new_value;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800886c",
        "calling": [
            "FUN_08009fe8"
        ],
        "current_name": "initialize_ptr_dat_value_0800886c"
    },
    "FUN_08003748": {
        "renaming": {
            "FUN_08003748": "addByteToUintAndStoreResult_08003748",
            "PTR_DAT_08003758": "resultPtr",
            "PTR_DAT_0800375c": "bytePtr",
            "*(uint *)PTR_DAT_08003758": "*resultPtr",
            "*(byte *)PTR_DAT_0800375c": "byteValue",
            "*(int *)PTR_DAT_08003758": "*intPtr"
        },
        "code": "void addByteToUintAndStoreResult_08003748(void)\n{\n  uint *(uint *)PTR_DAT_08003758 = (uint *)PTR_DAT_08003758;\n  byte *(byte *)PTR_DAT_0800375c = *(byte *)PTR_DAT_0800375c;\n  int *(int *)PTR_DAT_08003758 = (int *)PTR_DAT_08003758;\n  *(uint *)PTR_DAT_08003758 = (uint)*(byte *)PTR_DAT_0800375c + *(int *)PTR_DAT_08003758;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003748",
        "calling": [
            "FUN_08007246"
        ],
        "current_name": "addByteToUintAndStoreResult_08003748"
    },
    "FUN_080040e8": {
        "renaming": {
            "FUN_080040e8": "FUNC_080040e8"
        },
        "code": "\nvoid FUNC_080040e8(uint *param_1,uint *param_2)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  \n  uVar7 = 0;\n  uVar5 = 0;\n  do {\n    if (0xf < uVar5) {\n      return;\n    }\n    uVar3 = 1 << (uVar5 & 0xff);\n    uVar4 = *param_2 & uVar3;\n    if (uVar3 == uVar4) {\n      uVar6 = param_2[1];\n      if (uVar6 == 0x12) {\n        uVar7 = param_2[3] + 0xc;\n      }\n      else if (uVar6 < 0x13) {\n        if (uVar6 == 2) {\n          uVar7 = param_2[3] + 8;\n        }\n        else if (uVar6 < 3) {\n          if (uVar6 == 0) goto LAB_0800423a;\n          if (uVar6 == 1) {\n            uVar7 = param_2[3];\n          }\n        }\n        else if (uVar6 == 3) {\n          uVar7 = 0;\n        }\n        else if (uVar6 == 0x11) {\n          uVar7 = param_2[3] + 4;\n        }\n      }\n      else {\n        if (uVar6 != DAT_080042c8) {\n          if (DAT_080042c8 < uVar6) {\n            if (uVar6 == DAT_080042cc) goto LAB_0800423a;\n            uVar9 = DAT_080042cc + 0x10000;\n            uVar2 = DAT_080042cc;\n          }\n          else {\n            uVar9 = DAT_080042c8 - 0x100000;\n            uVar2 = DAT_080042c8;\n          }\n          if ((uVar6 != uVar9) && (uVar6 != uVar2 - 0xf0000)) goto LAB_080040fe;\n        }\nLAB_0800423a:\n        if (param_2[2] == 0) {\n          uVar7 = 4;\n        }\n        else if (param_2[2] == 1) {\n          param_1[4] = uVar3;\n          uVar7 = 8;\n        }\n        else {\n          param_1[5] = uVar3;\n          uVar7 = 8;\n        }\n      }\nLAB_080040fe:\n      uVar3 = uVar5;\n      puVar1 = param_1;\n      if (0xff < uVar4) {\n        uVar3 = uVar5 - 8;\n        puVar1 = param_1 + 1;\n      }\n      *puVar1 = *puVar1 & ~(0xf << (uVar3 << 2 & 0xff)) | uVar7 << (uVar3 << 2 & 0xff);\n      if ((param_2[1] & 0x10000000) != 0) {\n        *(uint *)(DAT_080042bc + 0x18) = *(uint *)(DAT_080042bc + 0x18) | 1;\n        iVar8 = (uVar5 & 3) << 2;\n        if (param_1 == DAT_080042d0) {\n          iVar10 = 0;\n        }\n        else if (param_1 == DAT_080042d0 + 0x100) {\n          iVar10 = 1;\n        }\n        else if (param_1 == DAT_080042d0 + 0x200) {\n          iVar10 = 2;\n        }\n        else if (param_1 == DAT_080042d0 + 0x300) {\n          iVar10 = 3;\n        }\n        else {\n          iVar10 = 4;\n        }\n        *(uint *)(DAT_080042c0 + ((uVar5 >> 2) + 2) * 4) =\n             *(uint *)(DAT_080042c0 + ((uVar5 >> 2) + 2) * 4) & ~(0xf << iVar8) | iVar10 << iVar8;\n        if ((param_2[1] & 0x10000) == 0) {\n          *DAT_080042c4 = *DAT_080042c4 & ~uVar4;\n        }\n        else {\n          *DAT_080042c4 = *DAT_080042c4 | uVar4;\n        }\n        if ((param_2[1] & 0x20000) == 0) {\n          DAT_080042c4[1] = DAT_080042c4[1] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[1] = DAT_080042c4[1] | uVar4;\n        }\n        if ((param_2[1] & 0x100000) == 0) {\n          DAT_080042c4[2] = DAT_080042c4[2] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[2] = DAT_080042c4[2] | uVar4;\n        }\n        if ((param_2[1] & 0x200000) == 0) {\n          DAT_080042c4[3] = DAT_080042c4[3] & ~uVar4;\n        }\n        else {\n          DAT_080042c4[3] = uVar4 | DAT_080042c4[3];\n        }\n      }\n    }\n    uVar5 = uVar5 + 1;\n  } while( true );\n}\n\n",
        "called": [],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x080040e8",
        "calling": [
            "FUN_08006e68",
            "FUN_08007258",
            "FUN_08006ca8",
            "FUN_08008078",
            "FUN_080077b0"
        ],
        "current_name": "FUNC_080040e8"
    },
    "FUN_080036d4": {
        "renaming": {
            "FUN_080036d4": "do_nothing_080036d4"
        },
        "code": "void do_nothing_080036d4(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080036d4",
        "calling": [
            "FUN_08003724"
        ],
        "current_name": "do_nothing_080036d4"
    },
    "FUN_0800288c": {
        "renaming": {
            "FUN_0800288c": "copy_data_to_buffer_0800288c",
            "param_1": "buffer_address",
            "param_2": "data",
            "puVar1": "buffer_pointer",
            "iVar2": "result",
            "uVar3": "result",
            "cVar4": "buffer_used_size",
            "uVar5": "result",
            "uVar6": "buffer_size",
            "local_11": "data",
            "PTR_DAT_08002908": "PTR_DATA_BUFFER_STATUS",
            "PTR_DAT_0800290c": "PTR_DATA_BUFFER_USED_SIZE",
            "PTR_DAT_08002910": "PTR_DATA_BUFFER_SIZE",
            "PTR_DAT_08002914": "PTR_DATA_BUFFER_ADDRESS",
            "PTR_DAT_08002918": "PTR_DATA_BUFFER_POINTER_2",
            "copy_data_to_buffer_08007ede": "copy_data_to_buffer",
            "allocate_and_copy_data_08009908": "allocate_and_copy_data"
        },
        "code": "int copy_data_to_buffer_0800288c(int buffer_address, char data, int data_size)\n{\n  int result;\n  char *buffer_pointer;\n  int buffer_size;\n\n  buffer_pointer = PTR_DATA_BUFFER_POINTER;\n  if (*PTR_DAT_08002908 == 0) {\n    result = copy_data_to_buffer_0800288c_08007ede(buffer_address + 0x14, &data, data_size);\n    if (result == 0) {\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    buffer_size = (int)(unsigned char)*PTR_DAT_08002910 + 1;\n    if ((unsigned char)*PTR_DAT_0800290c < buffer_size) {\n      if (buffer_size < 0x20) {\n        buffer_size = 0x20;\n      }\n      result = allocate_and_copy_data(PTR_DAT_08002914, buffer_size);\n      *PTR_DATA_BUFFER_POINTER = result;\n      if (result == 0) {\n        result = 0;\n      }\n      else {\n        result = (int)(unsigned char)buffer_size;\n      }\n      *PTR_DAT_0800290c = result;\n    }\n    buffer_pointer = PTR_DAT_08002918;\n    if (*PTR_DAT_08002914 == 0) {\n      *(int *)(buffer_address + 4) = 1;\n      result = 0;\n    }\n    else {\n      *(char *)(*(int *)PTR_DAT_08002914 + (int)(unsigned char)*PTR_DAT_08002918) = data;\n      char buffer_used_size = *buffer_pointer + 1;\n      *buffer_pointer = buffer_used_size;\n      *PTR_DAT_0800290c = buffer_used_size;\n      result = 1;\n    }\n  }\n  return result;\n}",
        "called": [
            "FUN_08009908",
            "FUN_08007ede"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800288c",
        "calling": [
            "FUN_08001bf8"
        ],
        "current_name": "copy_data_to_buffer_0800288c"
    },
    "FUN_0800010c": {
        "renaming": {
            "FUN_0800010c": "isFirstCallToFunction_0800010c",
            "param_1": "isFirstCall",
            "PTR_DAT_08000124": "isFirstCall",
            "DAT_08000128": "hasFunctionPointer",
            "PTR_FUN_0800012c": "functionPointer"
        },
        "code": "bool isFirstCallToFunction_0800010c(bool *PTR_DAT_08000124, bool DAT_08000128, bool (*PTR_FUN_0800012c)()){\n  if (!*PTR_DAT_08000124) {\n    if (DAT_08000128) {\n      PTR_FUN_0800012c();\n    }\n    *PTR_DAT_08000124 = true;\n  }\n  return *PTR_DAT_08000124;\n}",
        "called": [
            "FUN_0800a424"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800010c",
        "calling": [],
        "current_name": "isFirstCallToFunction_0800010c"
    },
    "FUN_08002e26": {
        "renaming": {
            "FUN_08002e26": "setParameterAndExecuteCommands_08002e26",
            "param_1": "objectAddress",
            "param_2": "parameterValue",
            "copy_value_to_pointer_08003154": "copyValueToPointer",
            "executeCommandsOnObject_08002ddc": "executeCommands",
            "encode_data_from_pointer_08002df6": "encodeDataFromPointer"
        },
        "code": "void setParameterAndExecuteCommands_08002e26(int objectAddress, int parameterValue)\n{\n  *(int *)(objectAddress + 0xc0) = parameterValue;\n  copy_value_to_pointer_08003154(objectAddress + 0x40);\n  executeCommandsOnObject_08002ddc(objectAddress);\n  encode_data_from_pointer_08002df6(objectAddress);\n  return;\n}",
        "called": [
            "FUN_08003154",
            "FUN_08002df6",
            "FUN_08002ddc"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002e26",
        "calling": [
            "FUN_08003048"
        ],
        "current_name": "setParameterAndExecuteCommands_08002e26"
    },
    "FUN_080036d8": {
        "renaming": {
            "FUN_080036d8": "validate_and_set_input_080036d8",
            "param_1": "input",
            "iVar1": "validated_input",
            "PTR_DAT_0800371c": "CONSTANT_POINTER",
            "PTR_DAT_08003718": "DIVISOR_POINTER",
            "set_bits_08003f30": "set_bits_to_one"
        },
        "code": "int validate_and_set_input_080036d8(uint input)\n{\n  int validated_input = validate_input_divided_by_constant(input);\n  if (validated_input != 0) {\n    return 1;\n  }\n  if (validated_input > 15) {\n    return 1;\n  }\n  set_bits_08003f30(validated_input);\n  *(uint *)PTR_DAT_08003720 = validated_input;\n  return 0;\n}",
        "called": [
            "FUN_08003fd8",
            "FUN_08003f30"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080036d8",
        "calling": [
            "FUN_08003724",
            "FUN_080058d2"
        ],
        "current_name": "validate_and_set_input_080036d8"
    },
    "FUN_08006e68": {
        "renaming": {
            "FUN_08006e68": "FUNC_08006e68"
        },
        "code": "\nvoid FUNC_08006e68(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint local_20;\n  undefined4 local_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  \n  puVar1 = PTR_DAT_08007100;\n  iVar2 = find_param_08007376((int)(char)*PTR_DAT_08007100,PTR_DAT_08007104);\n  set_flags_based_on_value_08007438(param_1);\n  uVar3 = set_flag_08006bb8((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  local_1c = 2;\n  local_18 = 0;\n  local_14 = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uint)(iVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  local_20 = 1 << ((byte)*PTR_DAT_08007100 & 0xf) & 0xffff;\n  FUNC_080040e8(uVar3,&local_20);\n  return;\n}\n\n",
        "called": [
            "FUN_080040e8",
            "FUN_08007438",
            "FUN_08007376",
            "FUN_08006bb8"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08006e68",
        "calling": [
            "FUN_08006092"
        ],
        "current_name": "FUNC_08006e68"
    },
    "FUN_080086e8": {
        "renaming": {
            "FUN_080086e8": "find_number_080086e8",
            "param_1": "target",
            "uVar1": "index"
        },
        "code": "unsigned int find_number_080086e8(int target) {\n  unsigned int index;\n  if (target == 0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while (true) {\n      if (index > 4) {\n        return index;\n      }\n      if (target == *(int *)(PTR_DAT_08008708 + index * 4)) {\n        break;\n      }\n      index = (index + 1) & 0xff;\n    }\n  }\n  return index;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080086e8",
        "calling": [
            "FUN_0800870c",
            "FUN_08008730"
        ],
        "current_name": "find_number_080086e8"
    },
    "FUN_0800a110": {
        "renaming": {
            "FUN_0800a110": "set_value_from_function_result_0800a110",
            "param_1": "output_value",
            "param_2": "input_value",
            "puVar1": "constant_pointer",
            "iVar2": "function_result"
        },
        "code": "void set_value_from_function_result_0800a110(int *output_value, undefined4 input_value)\n{\n  undefined *constant_pointer = PTR_DAT_0800a12c;\n  *(undefined4 *)PTR_DAT_0800a12c = 0;\n  int function_result = returnOne_08008850(input_value);\n  if ((function_result == -1) && (*(int *)constant_pointer != 0)) {\n    *output_value = *(int *)constant_pointer;\n  }\n  return;\n}",
        "called": [
            "FUN_08008850"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a110",
        "calling": [
            "FUN_08009eac"
        ],
        "current_name": "set_value_from_function_result_0800a110"
    },
    "FUN_08003b8c": {
        "renaming": {
            "FUN_08003b8c": "check_if_pointer_is_valid_08003b8c",
            "param_1": "pointer",
            "iVar1": "current_pointer_value",
            "iVar2": "pointer_value",
            "get_pointer_value_08003760": "get_current_pointer_value"
        },
        "code": "int check_if_pointer_is_valid_08003b8c(int *pointer)\n{\n  int pointer_value = *pointer;\n  if ((*(uint *)(pointer_value + 8) & 1) == 0) {\n    return 0;\n  }\n  *(uint *)(pointer_value + 8) = *(uint *)(pointer_value + 8) & 0xfffffffe;\n  int initial_pointer_value = get_pointer_value_08003760();\n  do {\n    if ((*(uint *)(*pointer + 8) & 1) == 0) {\n      return 0;\n    }\n    int current_pointer_value = get_pointer_value_08003760();\n  } while ((uint)(current_pointer_value - initial_pointer_value) < 3);\n  pointer[10] = pointer[10] | 0x10;\n  pointer[0xb] = pointer[0xb] | 1;\n  return 1;\n}",
        "called": [
            "FUN_08003760"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003b8c",
        "calling": [
            "FUN_08003e20",
            "FUN_08003ce8",
            "FUN_08003de4",
            "FUN_08003bd8"
        ],
        "current_name": "check_if_pointer_is_valid_08003b8c"
    },
    "FUN_080035b8": {
        "renaming": {
            "FUN_080035b8": "initialize_device_settings_080035b8",
            "local_54": "settings",
            "local_4c": "settings_2",
            "local_44": "bit_array",
            "local_40": "bit_array_2",
            "local_3c": "bit_array_3",
            "local_38": "bit_array_4",
            "local_34": "bit_array_5",
            "local_30": "bit_array",
            "local_20": "bit_array_6",
            "local_1c": "bit_array_7",
            "local_14": "bit_array_8",
            "local_10": "bit_array_9",
            "local_c": "bit_array_10",
            "FUNC_08005460": "initialize_device",
            "validateAndUpdateBitArray_080058ac": "validate_and_update_bit_array",
            "update_settings_08005aa4": "update_device_settings",
            "wait_forever_080073e8": "wait_forever",
            "get_value_from_pointer_08005a1c": "get_value_from_pointer",
            "validate_input_08003fd8": "validate_input",
            "set_flag_08004024": "set_flag",
            "set_bits_08003f30": "set_bits",
            "DAT_08003650": "data_constant",
            "PTR_s__home_bo__arduino15_packages_STM_08003654": "pointer_constant"
        },
        "code": "void initialize_device_settings_080035b8(void)\n{\n  int function_result;\n  uint value_from_pointer;\n  uint bit_array_update_result;\n  uint settings_update_result;\n\n  uint bit_array[] = {0xf, 2, 0, 0x400, 0, 0};\n  uint settings[] = {2, 0x8000};\n\n  function_result = FUNC_08005460(&bit_array[0]);\n  if (function_result != 0) {\n    wait_forever_080073e8(PTR_s__home_bo__arduino15_packages_STM_08003654, 0x88);\n  }\n\n  bit_array_update_result = validate_and_update_bit_array(&bit_array[0]);\n  if (bit_array_update_result != 0) {\n    wait_forever_080073e8(PTR_s__home_bo__arduino15_packages_STM_08003654, 0x95);\n  }\n\n  settings_update_result = update_settings_08005aa4(&settings[0]);\n  if (settings_update_result != 0) {\n    wait_forever_080073e8(PTR_s__home_bo__arduino15_packages_STM_08003654, 0x9c);\n  }\n\n  value_from_pointer = get_value_from_pointer_08005a1c();\n  validate_input_08003fd8((uint)((ulonglong)DAT_08003650 * (ulonglong)value_from_pointer >> 0x26));\n  set_flag_08004024(4);\n  set_bits_08003f30(0xffffffff, 0);\n  return;\n}",
        "called": [
            "FUN_08005460",
            "FUN_08003fd8",
            "FUN_08005aa4",
            "FUN_08004024",
            "FUN_080058ac",
            "FUN_08005a1c",
            "FUN_08003f30",
            "FUN_080073e8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080035b8",
        "calling": [
            "FUN_080072fa"
        ],
        "current_name": "initialize_device_settings_080035b8"
    },
    "FUN_08001c18": {
        "renaming": {
            "FUN_08001c18": "process_input_data_and_return_result_08001c18",
            "param_1": "device_address",
            "param_2": "input_data_length",
            "param_3": "expected_output_length",
            "param_4": "input_data",
            "puVar1": "input_buffer",
            "uVar2": "next_byte",
            "iVar3": "input_byte_index",
            "iVar4": "input_byte_diff",
            "bVar5": "input_buffer_not_empty"
        },
        "code": "void process_input_data_and_return_result_08001c18(uint8_t device_address, uint32_t input_data_length, int expected_output_length, uint32_t input_data)\n{\n  uint8_t *input_buffer = PTR_DAT_08001cbc;\n  uint8_t *output_buffer = PTR_DAT_08001cc8;\n  if (input_data_length != 0xffffffff) {\n    initialize_data(input_buffer, device_address);\n    copy_input_data_to_buffer(input_data & 0xff);\n    check_and_update_input_data(input_buffer, input_data);\n  }\n  process_and_return_data(input_buffer, device_address, expected_output_length);\n  int input_data_diff = calculate_difference_between_two_bytes(input_buffer);\n  if (expected_output_length < input_data_diff) {\n    process_data_and_return_result(PTR_DAT_08001cc4, PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else {\n    int output_data_diff = calculate_difference_between_two_bytes(output_buffer);\n    if (output_data_diff < expected_output_length) {\n      process_data_and_return_result(PTR_DAT_08001cc4, PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  output_buffer[0] = (char)device_address;\n  output_buffer[1] = (char)input_data_length;\n  for (int i = 0; i < expected_output_length; i++) {\n    int input_byte_diff = calculate_difference_between_two_bytes(input_buffer);\n    bool input_buffer_not_empty = (input_byte_diff != 0);\n    if (input_buffer_not_empty) {\n      output_buffer[i + 2] = read_next_byte();\n    }\n  }\n  process_data_and_offset(PTR_DAT_08001cc4, 0x77, expected_output_length + 2U & 0xff, output_buffer);\n  return;\n}",
        "called": [
            "FUN_08001c08",
            "FUN_0800270c",
            "FUN_08002f0a",
            "FUN_08002a58",
            "FUN_08001bf8",
            "FUN_08002f14",
            "FUN_08002a30",
            "FUN_08002c14"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08001c18",
        "calling": [
            "FUN_080022f8",
            "FUN_08001cd0"
        ],
        "current_name": "process_input_data_and_return_result_08001c18"
    },
    "FUN_08006460": {
        "renaming": {
            "FUN_08006460": "clearBitAndCheckForUpdates_08006460",
            "param_1": "bitArray",
            "param_2": "bitIndex",
            "set_bit_in_uint_at_index_08006420": "setBitInUintAtIndex",
            "puVar1": "arrayPointer"
        },
        "code": "void clearBitAndCheckForUpdates_08006460(uint **bitArray, uint bitIndex)\n{\n  set_bit_in_uint_at_index_08006420(*bitArray, bitIndex, 0);\n  uint *arrayPointer = *bitArray;\n  if (((arrayPointer[8] & 0x1111) == 0) && ((arrayPointer[8] & 0x444) == 0)) {\n    arrayPointer[0x11] &= 0xffff7fff;\n  }\n  arrayPointer = *bitArray;\n  if (((arrayPointer[8] & 0x1111) == 0) && ((arrayPointer[8] & 0x444) == 0)) {\n    *arrayPointer &= 0xfffffffe;\n  }\n  return;\n}",
        "called": [
            "FUN_08006420"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006460",
        "calling": [
            "FUN_080071e4"
        ],
        "current_name": "clearBitAndCheckForUpdates_08006460"
    },
    "FUN_08004046": {
        "renaming": {
            "FUN_08004046": "do_nothing_08004046"
        },
        "code": "void do_nothing_08004046()\n{\n  // This function does nothing\n  return;\n}",
        "called": [
            "FUN_08004044"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004046",
        "calling": [
            "FUN_08007246"
        ],
        "current_name": "do_nothing_08004046"
    },
    "FUN_08008880": {
        "renaming": {
            "FUN_08008880": "get_device_parameter_08008880",
            "param_1": "input_param",
            "is_param_valid": "is_valid_param",
            "device_param_value": "param_value",
            "processed_param": "processed_param",
            "device_param_bits": "param_bits"
        },
        "code": "uint get_device_parameter_08008880(uint param)\n{\n  bool is_param_valid;\n  char device_param_value;\n  uint processed_param = 0;\n  uint device_param_bits = 0;\n  \n  if (param < 14) {\n    is_param_valid = (param + 46 < 60);\n  }\n  else {\n    is_param_valid = (param < 60);\n  }\n  \n  if (is_param_valid) {\n    if (param < 14) {\n      param += 46;\n    }\n    device_param_value = PTR_DAT_080088d8[param];\n  }\n  else {\n    device_param_value = -1;\n  }\n  \n  if (device_param_value != -1) {\n    processed_param = process_device_parameter_08006d80();\n    device_param_bits = *(uint *)PTR_DAT_080088dc;\n    if (device_param_bits != 12) {\n      if (device_param_bits < 12) {\n        processed_param >>= (12 - device_param_bits) & 0xff;\n      }\n      else {\n        processed_param <<= (device_param_bits - 12) & 0xff;\n      }\n    }\n  }\n  return processed_param;\n}",
        "called": [
            "FUN_08006d80"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008880",
        "calling": [
            "FUN_08000488",
            "FUN_080022f8"
        ],
        "current_name": "get_device_parameter_08008880"
    },
    "FUN_08004044": {
        "renaming": {
            "FUN_08004044": "do_nothing_08004044"
        },
        "code": "void do_nothing_08004044(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004044",
        "calling": [
            "FUN_08004046"
        ],
        "current_name": "do_nothing_08004044"
    },
    "FUN_08002ed2": {
        "renaming": {
            "FUN_08002ed2": "execute_code_08002ed2",
            "param_1": "input_value",
            "uVar1": "result_value",
            "FUNC_08003474": "execute_skipped_code"
        },
        "code": "void execute_code_08002ed2(int input_value)\n{\n  uint result_value;\n  uint bitmask = 0xff;\n\n  result_value = (**(code **)(**(int **)(input_value + 0xc0) + 0xc))();\n  if (result_value != 0xffffffff) {\n    execute_skipped_code(input_value + 0x44, result_value & bitmask);\n  }\n  return;\n}",
        "called": [
            "FUN_08003474"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002ed2",
        "calling": [
            "FUN_080022f8"
        ],
        "current_name": "execute_code_08002ed2"
    },
    "FUN_080073ae": {
        "renaming": {
            "FUN_080073ae": "compare_and_return_080073ae",
            "param_1": "first_num",
            "param_2": "second_num"
        },
        "code": "int compare_and_return_080073ae(int first_num, int second_num) {\n  if (first_num != second_num) {\n    if (first_num == 0) {\n      return second_num;\n    }\n    if (second_num == 0) {\n      return first_num;\n    }\n    first_num = 0;\n  }\n  return first_num;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080073ae",
        "calling": [
            "FUN_08008078",
            "FUN_080077b0"
        ],
        "current_name": "compare_and_return_080073ae"
    },
    "FUN_08000488": {
        "renaming": {
            "FUN_08000488": "set_device_parameter_08000488",
            "param_1": "parameter_index",
            "param_2": "value",
            "uVar1": "parameter_value",
            "PTR_DAT_080004c8": "device_parameters_bitmap",
            "PTR_DAT_080004cc": "device_parameters_initialized",
            "get_device_parameter_08008880": "get_device_parameter_value",
            "send_data_08002ef2": "send_parameter_data",
            "PTR_DAT_080004d0": "device_parameter_data"
        },
        "code": "void set_device_parameter_08000488(uint parameter_index, int value)\n{\n  if (parameter_index < 0xE) {\n    if (value == 0) {\n      *PTR_DAT_080004c8 &= ~(1 << (parameter_index & 0xFF));\n      return;\n    }\n    *PTR_DAT_080004c8 |= 1 << (parameter_index & 0xFF);\n    if (*PTR_DAT_080004cc == 0) {\n      uint parameter_value = get_device_parameter_value();\n      send_parameter_data(PTR_DAT_080004d0, parameter_index, parameter_value);\n      return;\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_08008880",
            "FUN_08002ef2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08000488",
        "calling": [
            "FUN_080005f8"
        ],
        "current_name": "set_device_parameter_08000488"
    },
    "FUN_08003f0c": {
        "renaming": {
            "FUN_08003f0c": "updateParameter_08003f0c",
            "param_1": "parameter",
            "PTR_DAT_08003f2c": "ptr",
            "DAT_08003f2c": "ptrOffset"
        },
        "code": "void updateParameter_08003f0c(uint parameter) {\\n    uint* PTR_DAT_08003f2c = (uint*)(DAT_08003f2c + 0xc);\\n    uint mask = 0xf8ff;\\n    uint value = (parameter & 7) << 8 | (*PTR_DAT_08003f2c & mask) | 0x5fa0000;\\n    *PTR_DAT_08003f2c = value;\\n    return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003f0c",
        "calling": [
            "FUN_08008f0e",
            "FUN_08003724"
        ],
        "current_name": "updateParameter_08003f0c"
    },
    "FUN_08008f1c": {
        "renaming": {
            "FUN_08008f1c": "process_device_data_and_calculate_shift_08008f1c",
            "doNothing_08008f0c": "do_nothing",
            "initialize_device_08001b48": "initialize_device",
            "process_device_data_080022f8": "process_device_data",
            "DAT_08008f38": "device_data_processed",
            "calculate_shift_if_needed_08008bf4": "calculate_shift_if_needed"
        },
        "code": "void process_device_data_and_calculate_shift_08008f1c(void)\n{\n  doNothing_08008f0c();\n  initialize_device();\n  do {\n    do {\n      process_device_data_080022f8();\n    } while (DAT_08008f38 == 0);\n    calculate_shift_if_needed_08008bf4();\n  } while( true );\n}",
        "called": [
            "FUN_080022f8",
            "FUN_08008f0c",
            "FUN_08008bf4",
            "FUN_08001b48"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008f1c",
        "calling": [
            "FUN_08003658"
        ],
        "current_name": "process_device_data_and_calculate_shift_08008f1c"
    },
    "FUN_080058ac": {
        "renaming": {
            "FUN_080058ac": "validateAndUpdateBitArray_080058ac",
            "param_1": "bitArray",
            "param_2": "bitIndex",
            "puVar1": "arrayPointer",
            "DAT_08005a0c": "constantArray",
            "DAT_08005a10": "globalArray",
            "get_pointer_value_08003760": "getPointerValue",
            "calculate_value_08005840": "calculateValue",
            "validate_and_set_input_080036d8": "validateAndSetInput",
            "PTR_DAT_08005a18": "pointerToData1",
            "PTR_DAT_08005a14": "pointerToData2"
        },
        "code": "void validateAndUpdateBitArray_080058ac(uint **bitArray, uint bitIndex)\n{\n  setBitInUintAtIndex(*bitArray, bitIndex, 0);\n  uint *arrayPointer = *bitArray;\n  if (((arrayPointer[8] & 0x1111) == 0) && ((arrayPointer[8] & 0x444) == 0)) {\n    arrayPointer[0x11] &= 0xffff7fff;\n  }\n  arrayPointer = *bitArray;\n  if (((arrayPointer[8] & 0x1111) == 0) && ((arrayPointer[8] & 0x444) == 0)) {\n    *arrayPointer &= 0xfffffffe;\n  }\n  return;\n}",
        "called": [
            "FUN_080058d2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080058ac",
        "calling": [
            "FUN_080035b8"
        ],
        "current_name": "validateAndUpdateBitArray_080058ac"
    },
    "FUN_08006bb8": {
        "renaming": {
            "FUN_08006bb8": "set_flag_08006bb8",
            "param_1": "flag_index",
            "uVar1": "flag_value",
            "DAT_08006c48": "flag_ptr",
            "DAT_08006c4c": "FLAG_0",
            "DAT_08006c50": "FLAG_1",
            "DAT_08006c54": "FLAG_2",
            "DAT_08006c58": "FLAG_3",
            "DAT_08006c5c": "FLAG_4"
        },
        "code": "uint32_t set_flag_08006bb8(uint32_t flag_index){\n    uint32_t* DAT_08006c48 = (uint32_t*) (DAT_08006c48 + 0x18);\n    uint32_t flag_value = 0;\n    switch(flag_index) {\n        case 0:\n            flag_value = DAT_08006c4c;\n            break;\n        case 1:\n            flag_value = DAT_08006c50;\n            break;\n        case 2:\n            flag_value = DAT_08006c54;\n            break;\n        case 3:\n            flag_value = DAT_08006c58;\n            break;\n        case 4:\n            flag_value = DAT_08006c5c;\n            break;\n        default:\n            flag_value = 0;\n            break;\n    }\n    *DAT_08006c48 |= flag_value;\n    return flag_value;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006bb8",
        "calling": [
            "FUN_08006e68",
            "FUN_08007258",
            "FUN_08006ca8",
            "FUN_08008078",
            "FUN_080077b0"
        ],
        "current_name": "set_flag_08006bb8"
    },
    "FUN_08007438": {
        "renaming": {
            "FUN_08007438": "set_flags_based_on_value_08007438",
            "param_1": "value_ptr",
            "*param_1": "value",
            "DAT_080074d0": "FLAG_1",
            "*(uint *)(DAT_080074d0 + 0xe418)": "FLAG_1_REGISTER",
            "PTR_DAT_080074dc": "FLAG_PTR",
            "0x40000000": "FLAG_2",
            "_DAT_4002101c": "FLAG_2_REGISTER",
            "DAT_080074d4": "FLAG_3",
            "*(uint *)(DAT_080074d4 + 0x20c1c)": "FLAG_3_REGISTER",
            "DAT_080074d8": "FLAG_4",
            "*(uint *)(DAT_080074d8 + 0x2081c)": "FLAG_4_REGISTER"
        },
        "code": "void set_flags_based_on_value_08007438(int* value_ptr)\n{\n  int value = *value_ptr;\n\n  if (value == DAT_080074d0) {\n    *(uint *)(DAT_080074d0 + 0xe418) |= 0x800;\n    *(int **)PTR_DAT_080074dc = value_ptr;\n  }\n\n  if (value == 0x40000000) {\n    _DAT_4002101c |= 1;\n    *(int **)(PTR_DAT_080074dc + 4) = value_ptr;\n  }\n\n  if (value == DAT_080074d4) {\n    *(uint *)(DAT_080074d4 + 0x20c1c) |= 2;\n    *(int **)(PTR_DAT_080074dc + 8) = value_ptr;\n  }\n\n  if (value == DAT_080074d8) {\n    *(uint *)(DAT_080074d8 + 0x2081c) |= 4;\n    *(int **)(PTR_DAT_080074dc + 0xc) = value_ptr;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007438",
        "calling": [
            "FUN_08006e68",
            "FUN_08007708"
        ],
        "current_name": "set_flags_based_on_value_08007438"
    },
    "FUN_08004aec": {
        "renaming": {
            "FUN_08004aec": "updateCommand_08004aec",
            "param_1": "command",
            "DAT_08004b7c": "globalData1",
            "execute_command_and_update_values_08007ff0": "executeCommandAndUpdateValues",
            "doNothing_08004a22": "doNothing"
        },
        "code": "void updateCommand_08004aec(uint **command)\n{\n  char commandChar = *(char *)((int)*command + 0x3d);\n  if (((*command)[0xb] == (uint *)0x4) || ((*command)[0xb] == (uint *)0x8)) {\n    if (commandChar == '(') {\n      (*command)[0xb] = DAT_08004b7c;\n      (*command)[1] &= 0xfffff8ff;\n      (*command)[5] = 0xfffffbff;\n      **command &= 0xfffffbff;\n      (*command)[0xc] = (uint *)0x0;\n      *(undefined *)((int)*command + 0x3d) = 0x20;\n      *(undefined *)((int)*command + 0x3e) = 0;\n      execute_command_and_update_values_08007ff0();\n    }\n    else {\n      (*command)[5] = 0xfffffbff;\n    }\n  }\n  else if (commandChar == '!') {\n    (*command)[0xb] = DAT_08004b7c;\n    (*command)[0xc] = (uint *)0x21;\n    *(undefined *)((int)*command + 0x3d) = 0x20;\n    *(undefined *)((int)*command + 0x3e) = 0;\n    (*command)[1] &= 0xfffff8ff;\n    (*command)[5] = 0xfffffbff;\n    **command &= 0xfffffbff;\n    doNothing_08004a22();\n  }\n  else {\n    (*command)[5] = 0xfffffbff;\n  }\n  return;\n}",
        "called": [
            "FUN_08004a22",
            "FUN_08007ff0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004aec",
        "calling": [
            "FUN_080052f0"
        ],
        "current_name": "updateCommand_08004aec"
    },
    "FUN_0800887c": {
        "renaming": {
            "FUN_0800887c": "return_one_0800887c"
        },
        "code": "int return_one_0800887c()\\n{\\n  int result = 1;\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800887c",
        "calling": [
            "thunk_FUN_0800887c"
        ],
        "current_name": "return_one_0800887c"
    },
    "FUN_08004728": {
        "renaming": {
            "FUN_08004728": "check_and_update_08004728",
            "param_1": "input_array",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "param_4",
            "uVar1": "result",
            "puVar2": "current_element",
            "local_c": "loop_counter",
            "PTR_DAT_080047e8": "global_pointer_1",
            "DAT_080047ec": "constant_1",
            "param_1[0xc]": "input_array[0xc]",
            "*(undefined *)((int)param_1 + 0x3d)": "*(undefined *)((int)input_array + 0x3d)",
            "*(undefined *)(param_1 + 0xf)": "*(undefined *)(input_array + 0xf)",
            "puVar2[6]": "current_element[6]",
            "*(char *)(param_1 + 0xf)": "*(char *)(input_array + 0xf)",
            "*(undefined *)((int)param_1 + 0x3e)": "*(undefined *)((int)input_array + 0x3e)",
            "param_1[0x10]": "input_array[0x10]",
            "*(undefined2 *)((int)param_1 + 0x2a)": "*(uint16_t *)((int)input_array + 0x2a)",
            "param_1[0xb]": "global_pointer_2",
            "*(undefined2 *)(param_1 + 10)": "*(uint16_t *)(input_array + 10)",
            "param_1[0x11]": "param_2",
            "(*param_1)[1]": "(*input_array)[1]",
            "(*param_1 & 1)": "(*current_element & 1)",
            "**param_1": "**input_array"
        },
        "code": "int check_and_update_08004728(uint **input_array, uint *param_2, uint *param_3, uint16_t param_4)\\n{\\n  int result = 0;\\n  uint *current_element;\\n  int loop_counter = (uint)((unsigned long long)DAT_080047ec * (unsigned long long)(*(uint *)PTR_DAT_080047e8 >> 3) >> 0x28) * 0x19;\\n  if (*(char *)((int)input_array + 0x3d) == ' ') {\\n    do {\\n      if (loop_counter == 0) {\\n        input_array[0xc] = (uint *)0x0;\\n        *(undefined *)((int)input_array + 0x3d) = 0x20;\\n        *(undefined *)(input_array + 0xf) = 0;\\n        result = 3;\\n        break;\\n      }\\n      current_element = *input_array;\\n      loop_counter--;\\n    } while ((current_element[6] & 2) != 0);\\n    if (*(char *)(input_array + 0xf) == '\\x01') {\\n      result = 2;\\n    }\\n    else {\\n      *(undefined *)(input_array + 0xf) = 1;\\n      if ((*current_element & 1) == 0) {\\n        *current_element = *current_element | 1;\\n      }\\n      **input_array = **input_array & 0xfffff7ff;\\n      *(undefined *)((int)input_array + 0x3d) = 0x21;\\n      *(undefined *)((int)input_array + 0x3e) = 0x10;\\n      input_array[0x10] = (uint *)0x0;\\n      input_array[9] = param_3;\\n      *(uint16_t *)((int)input_array + 0x2a) = param_4;\\n      input_array[0xb] = global_pointer_2;\\n      *(uint16_t *)(input_array + 10) = *(uint16_t *)((int)input_array + 0x2a);\\n      input_array[0x11] = param_2;\\n      **input_array = **input_array | 0x100;\\n      *(undefined *)(input_array + 0xf) = 0;\\n      (*input_array)[1] = (*input_array)[1] | 0x700;\\n    }\\n  }\\n  else {\\n    result = 2;\\n  }\\n  return result;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004728",
        "calling": [
            "FUN_08007e74"
        ],
        "current_name": "check_and_update_08004728"
    },
    "FUN_08007ede": {
        "renaming": {
            "FUN_08007ede": "copy_data_to_buffer_08007ede",
            "param_1": "dest_buffer",
            "param_2": "src_buffer",
            "param_3": "buffer_size",
            "uVar1": "current_index"
        },
        "code": "int copy_data_to_buffer_08007ede(int dest_buffer, int src_buffer, uint buffer_size)\n{\n  uint current_index;\n  if (buffer_size > 0x20) {\n    return 2;\n  }\n  for (current_index = 0; current_index < buffer_size; current_index++) {\n    *(char *)(dest_buffer + current_index + 0x68) = *(char *)(src_buffer + current_index);\n    *(char *)(dest_buffer + 0x88) = *(char *)(dest_buffer + 0x88) + 1;\n  }\n  return 0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007ede",
        "calling": [
            "FUN_080027f0",
            "FUN_0800288c"
        ],
        "current_name": "copy_data_to_buffer_08007ede"
    },
    "FUN_0800863c": {
        "renaming": {
            "FUN_0800863c": "addCombinationToDataStructure_0800863c",
            "param_1": "combination",
            "param_2": "value",
            "param_3": "param_3",
            "param_4": "param_4",
            "iVar1": "isCombinationValid",
            "uVar2": "index",
            "PTR_DAT_08008688": "combinationDataStructure",
            "PTR_DAT_0800868c": "combinationIndexDataStructure",
            "PTR_DAT_08008690": "combinationDataStructureIndex",
            "check_combination_080085b8": "checkCombinationValidity",
            "set_bits_08003f30": "setBitAtIndexInDataStructure",
            "set_bit_at_index_08003f94": "setBitAtIndexInDataStructure",
            "set_params_080068d6": "setParametersInDataStructure"
        },
        "code": "void addCombinationToDataStructure_0800863c(int combination, int value, int param_3, int param_4)\n{\n  if (combination != 0) {\n    int isCombinationValid = check_combination_080085b8(combination);\n    if (isCombinationValid == 0) {\n      uint index = (uint)*(byte *)(combination + 0x44);\n      *(int *)(PTR_DAT_08008688 + index * 4) = value;\n      *(int *)(PTR_DAT_0800868c + index * 4) = combination;\n      set_bits_08003f30((int)*(char *)(combination + 0x5a), 0, 1, index, param_4);\n      set_bit_at_index_08003f94((int)*(char *)(combination + 0x5a), index);\n      set_params_080068d6(*(int *)(PTR_DAT_08008690 + index * 4), combination + 0x45, 1);\n    }\n  }\n}",
        "called": [
            "FUN_080085b8",
            "FUN_080068d6",
            "FUN_08003f94",
            "FUN_08003f30"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800863c",
        "calling": [
            "FUN_08008c44"
        ],
        "current_name": "addCombinationToDataStructure_0800863c"
    },
    "thunk_FUN_0800887c": {
        "renaming": {
            "thunk_return_one_0800887c": "return_one",
            "thunk_FUN_0800887c": "return_one_thunk_0800887c"
        },
        "code": "int return_one_thunk_0800887c()\n{\n  return 1;\n}",
        "called": [
            "FUN_0800887c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a01c",
        "calling": [
            "FUN_08009fe8"
        ],
        "current_name": "return_one_thunk_0800887c"
    },
    "FUN_080074e0": {
        "renaming": {
            "FUN_080074e0": "set_flags_based_on_param_080074e0",
            "param_1": "param",
            "DAT_08007534": "PTR_DAT_08007534",
            "DAT_08007540": "PTR_DAT_08007540",
            "DAT_08007538": "PTR_DAT_08007538",
            "DAT_0800753c": "PTR_DAT_0800753c"
        },
        "code": "void set_flags_based_on_param_080074e0(int *param)\n{\n  int flag1 = 0x800;\n  int flag2 = 0x1;\n  int flag3 = 0x2;\n  int flag4 = 0x4;\n  if (*param == DAT_08007534) {\n    DAT_08007540[0x18] &= ~flag1;\n  }\n  if (*param == 0x40000000) {\n    DAT_08007540[0x1c] &= ~flag2;\n  }\n  if (*param == DAT_08007538) {\n    DAT_08007540[0x1c] &= ~flag3;\n  }\n  if (*param == DAT_0800753c) {\n    DAT_08007540[0x1c] &= ~flag4;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080074e0",
        "calling": [
            "FUN_08007110",
            "FUN_08007710"
        ],
        "current_name": "set_flags_based_on_param_080074e0"
    },
    "FUN_080073c0": {
        "renaming": {
            "FUN_080073c0": "execute_code_at_address_080073c0",
            "PTR_DAT_080073d0": "address_pointer",
            "PTR_DAT_080073d4": "argument_pointer",
            "code": "code_pointer"
        },
        "code": "void execute_code_at_address_080073c0(void)\n{\n  code *address = *(code **)PTR_DAT_080073d0;\n  if (address != NULL) {\n    address(*(undefined4 *)PTR_DAT_080073d4);\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080073c0",
        "calling": [
            "FUN_08005cb4"
        ],
        "current_name": "execute_code_at_address_080073c0"
    },
    "FUN_080084b0": {
        "renaming": {
            "FUN_080084b0": "process_parameter_080084b0",
            "PTR_DAT_080084f0": "parameter_key_list",
            "PTR_DAT_080084f4": "parameter_value_list",
            "PTR_DAT_080084f8": "value_list",
            "PTR_DAT_080084fc": "data_pointer_list",
            "cVar1": "parameter_key",
            "iVar4": "parameter_value",
            "uVar5": "parameter_value2",
            "uVar3": "found_value",
            "puVar2": "data_pointer"
        },
        "code": "void process_parameter_080084b0(void)\n{\n  char parameter_key = PTR_DAT_080084f0[1];\n  int parameter_value = get_parameter_value(parameter_key, PTR_DAT_080084f4);\n  if (parameter_value != 0) {\n    int parameter_value2 = get_parameter_value(parameter_key, PTR_DAT_080084f4);\n    int found_value = find_value_if_key_not_null(parameter_value2, PTR_DAT_080084f8);\n    undefined *data_pointer = PTR_DAT_080084fc;\n    PTR_DAT_080084fc[0x59] = found_value;\n    data_pointer[0x58] = parameter_key;\n    *(undefined4 *)(data_pointer + 0x48) = 0x2580;\n    *(undefined4 *)(data_pointer + 0x54) = 0;\n    *(undefined4 *)(data_pointer + 0x4c) = 0;\n    *(undefined4 *)(data_pointer + 0x50) = 0;\n    execute_function(data_pointer);\n  }\n  return;\n}",
        "called": [
            "FUN_0800734a",
            "FUN_08008078",
            "FUN_08007320"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080084b0",
        "calling": [
            "FUN_08008500"
        ],
        "current_name": "process_parameter_080084b0"
    },
    "FUN_08004050": {
        "renaming": {
            "FUN_08004050": "get_value_from_pointer_08004050",
            "param_1": "pointer_to_pointer",
            "uVar1": "value",
            "puVar2": "pointer",
            "DAT_080040e0": "address_of_DAT_080040e0",
            "DAT_080040e4": "address_of_DAT_080040e4"
        },
        "code": "uint32_t get_value_from_pointer_08004050(uint32_t **pointer_to_pointer)\\n{\\n  uint32_t value = **pointer_to_pointer;\\n  if (*(char *)((int)pointer_to_pointer + 0x21) != '\\x02') {\\n    pointer_to_pointer[0xe] = (uint32_t *)0x4;\\n    return 1;\\n  }\\n  value &= 0xfffffff1;\\n  value &= 0xfffffffe;\\n  uint32_t *pointer = *pointer_to_pointer;\\n  if (pointer == DAT_080040e0) {\\n    value = 1;\\n  }\\n  else if (pointer == DAT_080040e0 + 5) {\\n    value = 0x10;\\n  }\\n  else if (pointer == DAT_080040e0 + 10) {\\n    value = 0x100;\\n  }\\n  else if (pointer == DAT_080040e0 + 0xf) {\\n    value = 0x1000;\\n  }\\n  else if (pointer == DAT_080040e0 + 0x14) {\\n    value = 0x10000;\\n  }\\n  else if (pointer == DAT_080040e0 + 0x19) {\\n    value = 0x100000;\\n  }\\n  else {\\n    value = 0x1000000;\\n  }\\n  *(uint32_t *)(DAT_080040e4 + 4) = value;\\n  *(char *)((int)pointer_to_pointer + 0x21) = 1;\\n  *(uint32_t *)(pointer_to_pointer + 8) = 0;\\n  if (pointer_to_pointer[0xd] != (uint32_t *)0x0) {\\n    (*(void (*)())pointer_to_pointer[0xd])();\\n    return 0;\\n  }\\n  return 0;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004050",
        "calling": [
            "FUN_08004f3c",
            "FUN_080069ec"
        ],
        "current_name": "get_value_from_pointer_08004050"
    },
    "FUN_08008e14": {
        "renaming": {
            "FUN_08008e14": "set_memory_data_if_valid_08008e14",
            "param_1": "input_value_1",
            "param_2": "input_value_2",
            "PTR_DAT_08008e3c": "PTR_DAT_08008e3c",
            "set_data_in_memory_08008df8": "set_data_in_memory_08008df8"
        },
        "code": "void set_memory_data_if_valid_08008e14(int input_value_1, int input_value_2)\n{\n  const int VALID_VALUE_1 = 1;\n  const int VALID_VALUE_2 = 0xffff;\n\n  if ((input_value_1 == VALID_VALUE_1) && (input_value_2 == VALID_VALUE_2)) {\n    set_data_in_memory_08008df8(PTR_DAT_08008e3c, 0, 0, 0, 0);\n  }\n  return;\n}",
        "called": [
            "FUN_08008df8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008e14",
        "calling": [],
        "current_name": "set_memory_data_if_valid_08008e14"
    },
    "FUN_08005a28": {
        "renaming": {
            "FUN_08005a28": "get_shifted_value_from_pointer_08005a28",
            "uVar1": "shifted_value",
            "get_value_from_pointer_08005a1c": "get_value_from_pointer",
            "PTR_DAT_08005a44": "shift_array",
            "DAT_08005a40": "data_pointer"
        },
        "code": "uint get_shifted_value_from_pointer_08005a28(void)\n{\n  uint shifted_value = get_value_from_pointer_08005a1c();\n  uint index = (*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d;\n  uint shift_amount = PTR_DAT_08005a44[index];\n  uint result = shifted_value >> shift_amount;\n  return result;\n}",
        "called": [
            "FUN_08005a1c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005a28",
        "calling": [
            "FUN_080075dc",
            "FUN_080045c0",
            "FUN_08006538"
        ],
        "current_name": "get_shifted_value_from_pointer_08005a28"
    },
    "FUN_080095a8": {
        "renaming": {
            "FUN_080095a8": "get_length_of_data_to_write_080095a8",
            "param_1": "data_info",
            "param_2": "data_pointer",
            "param_3": "write_function",
            "param_4": "padding",
            "param_5": "write_single_byte",
            "iVar1": "result",
            "uVar2": "max_length",
            "uVar3": "data_length",
            "bVar4": "is_data_type_not_4",
            "data_type": "data_type",
            "length": "length",
            "padding_length": "padding_length",
            "remaining_length": "remaining_length"
        },
        "code": "uint get_length_of_data_to_write_080095a8(uint data_info[], uint *data_pointer, uint (*write_function)(uint, uint, void *, uint))\\n{\\n  uint max_length = data_info[2];\\n  if (data_info[4] < max_length) {\\n    max_length = data_info[4];\\n  }\\n  uint length = max_length;\\n  if (*(char *)((int)data_info + 0x43) != '\\0') {\\n    length++;\\n  }\\n  if ((int)(*data_info << 0x1a) < 0) {\\n    length += 2;\\n    *(undefined *)((int)data_info + length - 2) = 0x30;\\n    *(undefined *)((int)data_info + length - 1) = *(undefined *)((int)data_info + 0x45);\\n  }\\n  uint data_type = *data_info & 6;\\n  if (data_type == 0) {\\n    for (; (int)data_type < (int)(data_info[3] - length); data_type++) {\\n      uint result = write_function(data_info[1], 1, (void *)((int)data_info + 0x19), 1);\\n      if (result == -1) {\\n        return 0xffffffff;\\n      }\\n    }\\n  }\\n  uint data_length = (uint)*(byte *)((int)data_info + 0x43);\\n  if (data_length != 0) {\\n    data_length = 1;\\n  }\\n  uint padding_length = data_length;\\n  if ((int)(*data_info << 0x1a) < 0) {\\n    padding_length += 2;\\n  }\\n  uint remaining_length = 0;\\n  if (data_type != 4) {\\n    remaining_length = data_info[3] - length;\\n  }\\n  if (remaining_length < 0) {\\n    remaining_length = 0;\\n  }\\n  if (data_info[4] < data_info[2]) {\\n    remaining_length += data_info[2] - data_info[4];\\n  }\\n  uint result = write_function(data_info[1], padding_length, (void *)((int)data_info + 0x43), data_length);\\n  if (result == -1) {\\n    return 0xffffffff;\\n  }\\n  return remaining_length;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080095a8",
        "calling": [
            "FUN_08009698"
        ],
        "current_name": "get_length_of_data_to_write_080095a8"
    },
    "FUN_08003002": {
        "renaming": {
            "FUN_08003002": "write_data_to_device_08003002",
            "param_1": "device_address",
            "is_device_busy": "is_device_busy"
        },
        "code": "void write_data_to_device_08003002(int device_address)\\n{\\n  bool is_device_busy = (*(char *)(device_address + 0x1f8) != '\\0');\\n  \\n  if (is_device_busy) {\\n    return;\\n  }\\n  \\n  process_bits(0xd, 1);\\n  write_bits_to_device(device_address, 0xd, 2, 0x28, 0xd2);\\n  delay_execution(0xfa);\\n  write_bits_to_device(device_address, 0xd, 5, 0x28, 0xd2);\\n  delay_execution(0x7d);\\n  return;\\n}",
        "called": [
            "FUN_08008ac4",
            "FUN_08002fca",
            "FUN_08008990"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003002",
        "calling": [
            "FUN_08003048"
        ],
        "current_name": "write_data_to_device_08003002"
    },
    "FUN_08008ac4": {
        "renaming": {
            "FUN_08008ac4": "do_nothing_08008ac4"
        },
        "code": "void do_nothing_08008ac4(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008ac4",
        "calling": [
            "FUN_08003002",
            "FUN_08002fca"
        ],
        "current_name": "do_nothing_08008ac4"
    },
    "FUN_08003bd8": {
        "renaming": {
            "FUN_08003bd8": "checkAndUpdatePointer_08003bd8",
            "param_1": "pointer",
            "iVar1": "isPointerValid",
            "uVar2": "flag",
            "set_flag_and_update_08006ca8": "setFlagAndUpdate",
            "check_if_pointer_is_valid_08003b8c": "checkPointerValidity",
            "DAT_08003ce0": "mask1",
            "DAT_08003ce4": "mask2"
        },
        "code": "int checkAndUpdatePointer_08003bd8(int *pointer)\n{\n  if (pointer == NULL) {\n    return 1;\n  }\n  if (pointer[10] == 0) {\n    pointer[11] = 0;\n    pointer[9] = 0;\n    set_flag_and_update_08006ca8();\n  }\n  int isPointerValid = check_if_pointer_is_valid_08003b8c(pointer);\n  uint flag = pointer[10] & 0x10;\n  if ((flag == 0) && (isPointerValid == 0)) {\n    pointer[10] = pointer[10] & 0xffffeefdU | 2;\n    uint mask = pointer[1] | pointer[7] | pointer[3] << 1;\n    if (pointer[2] == 0x100 || pointer[2] == 1) {\n      mask |= 0x100;\n    }\n    if (pointer[5] == 1) {\n      if (pointer[3] == 0) {\n        mask |= (pointer[6] - 1) * 0x2000 | 0x800;\n      }\n      else {\n        pointer[10] |= 0x20;\n        pointer[11] |= 1;\n      }\n    }\n    *(uint *)(*pointer + 4) = mask | *(uint *)(*pointer + 4) & 0xffff16ff;\n    *(uint *)(*pointer + 8) = DAT_08003ce0 & *(uint *)(*pointer + 8) | mask;\n    uint shift = (pointer[2] == 0x100 || pointer[2] == 1) ? (pointer[4] - 1) * 0x100000 : 0;\n    *(uint *)(*pointer + 0x2c) = shift | *(uint *)(*pointer + 0x2c) & 0xff0fffff;\n    if (mask != (DAT_08003ce4 & *(uint *)(*pointer + 8))) {\n      pointer[10] = pointer[10] & 0xffffffedU | 0x10;\n      pointer[11] |= 1;\n      return 1;\n    }\n    pointer[11] = 0;\n    pointer[10] = pointer[10] & 0xfffffffcU | 1;\n    return 0;\n  }\n  pointer[10] |= 0x10;\n  return 1;\n}",
        "called": [
            "FUN_08003b8c",
            "FUN_08006ca8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003bd8",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "checkAndUpdatePointer_08003bd8"
    },
    "FUN_08009d50": {
        "renaming": {
            "FUN_08009d50": "initialize_blocks_08009d50",
            "param_1": "block_ptr",
            "uVar1": "block",
            "iVar2": "iVar",
            "bVar3": "is_same"
        },
        "code": "void initialize_blocks_08009d50(int block_ptr)\n{\n    undefined4 block1 = 0;\n    undefined4 block2 = 0;\n    undefined4 block3 = 0;\n    if (*(int *)(block_ptr + 0x18) == 0)\n    {\n        *(undefined4 *)(block_ptr + 0x48) = 0;\n        *(undefined4 *)(block_ptr + 0x4c) = 0;\n        *(undefined4 *)(block_ptr + 0x50) = 0;\n        int iVar = *(int *)PTR_PTR_DAT_08009da8;\n        *(undefined **)(block_ptr + 0x28) = PTR_LAB_08009cd0_1_08009dac;\n        bool is_same = block_ptr == iVar;\n        if (is_same)\n        {\n            iVar = 1;\n        }\n        if (is_same)\n        {\n            *(int *)(block_ptr + 0x18) = iVar;\n        }\n        block1 = allocate_and_initialize_block_08009db0();\n        block2 = allocate_and_initialize_block_08009db0(block_ptr);\n        block3 = allocate_and_initialize_block_08009db0(block_ptr);\n        initializeData_08009cdc(block1, 4, 0);\n        initializeData_08009cdc(block2, 9, 1);\n        initializeData_08009cdc(block3, 0x12, 2);\n        *(int *)(block_ptr + 0x18) = 1;\n    }\n    return;\n}",
        "called": [
            "FUN_08009db0",
            "FUN_08009cdc"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009d50",
        "calling": [
            "FUN_08009c7c",
            "FUN_08009db0",
            "FUN_0800932c",
            "FUN_08009a80",
            "FUN_080098d8",
            "FUN_0800937c"
        ],
        "current_name": "initialize_blocks_08009d50"
    },
    "FUN_08003366": {
        "renaming": {
            "FUN_08003366": "set_values_if_param2_equals_113_08003366",
            "param_1": "ptr_object",
            "param_2": "param2",
            "param_3": "value1",
            "param_4": "value2"
        },
        "code": "void set_values_if_param2_equals_113_08003366(int ptr_object, int param2, int value1, int value2)\n{\n  if (param2 == 0x71) {\n    *(int *)(ptr_object + 0x68) = value1;\n    *(int *)(ptr_object + 0x40) = value2;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003366",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "set_values_if_param2_equals_113_08003366"
    },
    "FUN_080091b0": {
        "renaming": {
            "FUN_080091b0": "copy_data_to_buffer_080091b0",
            "param_1": "dest_address",
            "param_2": "source_data",
            "param_3": "data_length",
            "puVar1": "source_buffer_end",
            "puVar2": "destination_buffer"
        },
        "code": "void copy_data_to_buffer_080091b0(int dest_address, const char *source_data, int data_length)\n{\n  char *destination_buffer = (char *)(dest_address - 1);\n  const char *source_buffer_end = source_data + data_length;\n  for (; source_data != source_buffer_end; source_data++) {\n    destination_buffer++;\n    *destination_buffer = *source_data;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080091b0",
        "calling": [
            "FUN_08009908",
            "FUN_080027f0"
        ],
        "current_name": "copy_data_to_buffer_080091b0"
    },
    "FUN_08009108": {
        "renaming": {
            "FUN_08009108": "combine_values_08009108",
            "param_1": "value1",
            "param_2": "value2",
            "CONCAT44": "combine_64_bits",
            "DAT_08009120": "data_exists"
        },
        "code": "uint64_t combine_values_08009108(uint32_t value1, uint32_t value2)\n{\n  if (DAT_08009120 != 0) {\n    return ((uint64_t)value1 << 32) | 2;\n  }\n  return ((uint64_t)value2 << 32);\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009108",
        "calling": [
            "FUN_080090c2"
        ],
        "current_name": "combine_values_08009108"
    },
    "FUN_0800a18c": {
        "renaming": {
            "FUN_0800a18c": "update_pointers_and_call_0800a18c",
            "UNRECOVERED_JUMPTABLE": "jump_table",
            "PTR_DAT_0800a228": "pointer_1",
            "PTR_DAT_0800a22c": "pointer_2",
            "PTR_DAT_0800a230": "pointer_3",
            "PTR_DAT_0800a234": "pointer_4",
            "PTR_DAT_0800a238": "pointer_5",
            "PTR_DAT_0800a23c": "pointer_6",
            "PTR_DAT_0800a240": "pointer_7",
            "PTR_DAT_0800a244": "pointer_8",
            "PTR_DAT_0800a248": "pointer_9",
            "PTR_DAT_0800a24c": "pointer_10",
            "PTR_DAT_0800a250": "pointer_11",
            "PTR_DAT_0800a254": "pointer_12",
            "update_pointers_and_call": "update_pointers_and_call",
            "jump_table": "jump_table",
            "update_pointer": "update_pointer",
            "pointer": "pointer",
            "call_jump_table": "call_jump_table"
        },
        "code": "void update_pointers_and_call_0800a18c(void)\n{\n  code *jump_table = update_pointers_and_call_0800a18c;\n  update_pointer(PTR_DAT_0800a228);\n  update_pointer(PTR_DAT_0800a22c);\n  update_pointer(PTR_DAT_0800a230);\n  update_pointer(PTR_DAT_0800a234);\n  update_pointer(PTR_DAT_0800a238);\n  update_pointer(PTR_DAT_0800a23c);\n  update_pointer(PTR_DAT_0800a240);\n  update_pointer(PTR_DAT_0800a244);\n  update_pointer(PTR_DAT_0800a248);\n  update_pointer(PTR_DAT_0800a24c);\n  update_pointer(PTR_DAT_0800a250);\n  update_pointer(PTR_DAT_0800a254);\n  call_jump_table(jump_table);\n  return;\n}\n\nvoid update_pointer(int *pointer)\n{\n  if (*pointer < 0)\n  {\n    *pointer = 1;\n  }\n}\n\nvoid call_jump_table(code *jump_table)\n{\n  /* WARNING: Could not recover jumptable at 0x0800a224. Too many branches */\n  /* WARNING: Treating indirect jump as call */\n  (*jump_table)();\n  return;\n}",
        "called": [
            "FUN_08009b5c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a18c",
        "calling": [
            "FUN_08009084"
        ],
        "current_name": "update_pointers_and_call_0800a18c"
    },
    "FUN_08009908": {
        "renaming": {
            "FUN_08009908": "allocate_and_copy_data_08009908",
            "param_1": "input_data",
            "param_2": "size",
            "uVar1": "allocated_size",
            "uVar2": "result",
            "uVar3": "calculated_size",
            "add_to_linked_list_080091d8": "add_to_linked_list",
            "calculate_value_0800a154": "calculate_size",
            "allocate_memory_block_08009270": "allocate_memory_block",
            "copy_data_to_buffer_080091b0": "copy_data_to_buffer"
        },
        "code": "uint allocate_and_copy_data_08009908(uint input_data, uint size)\n{\n  uint result;\n  uint allocated_size = *(uint *)PTR_PTR_DAT_08009914;\n\n  if (input_data != 0) {\n    if (size == 0) {\n      add_to_linked_list_080091d8();\n      result = size;\n    }\n    else {\n      uint calculated_size = calculate_value_0800a154();\n      result = input_data;\n      if ((calculated_size < size) && (result = allocate_memory_block(allocated_size, size), result != 0)) {\n        copy_data_to_buffer_080091b0(result, input_data, size);\n        add_to_linked_list_080091d8(allocated_size, input_data);\n      }\n    }\n    return result;\n  }\n  result = allocate_memory_block(allocated_size, size);\n  return result;\n}",
        "called": [
            "FUN_080091b0",
            "FUN_08009270",
            "FUN_0800a154",
            "FUN_080091d8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009908",
        "calling": [
            "FUN_080027f0",
            "FUN_08002acc",
            "FUN_0800288c"
        ],
        "current_name": "allocate_and_copy_data_08009908"
    },
    "FUN_08008a24": {
        "renaming": {
            "FUN_08008a24": "readBitAndSetValue_08008a24",
            "param_1": "bitIndex",
            "param_2": "value",
            "param_3": "parameter",
            "param_4": "data",
            "iVar1": "bitMask",
            "uVar2": "dataValue",
            "puVar3": "dataPtr",
            "uVar4": "bitValue",
            "PTR_DAT_08008a64": "bitArray",
            "PTR_DAT_08008a68": "bitMaskArray",
            "read_bit_at_position_08006b28": "readBitAtPosition",
            "get_data_by_index_08006b7c": "getIndexedData",
            "set_parameter_value_based_on_condition_080072d8": "setParameterBasedOnCondition"
        },
        "code": "void readBitAndSetValue_08008a24(uint bitIndex, uint value, uint parameter, void* data)\n{\n  uint bitValue;\n  if (bitIndex < 0x3c) {\n    bitValue = (uint)(char)PTR_DAT_08008a64[bitIndex];\n    data = PTR_DAT_08008a64;\n  }\n  else {\n    bitValue = 0xffffffff;\n  }\n  if ((bitValue != 0xffffffff) && (read_bit_at_position_08006b28(bitValue, PTR_DAT_08008a68, parameter, data, data) != 0)) {\n    uint dataIndex = (bitValue << 0x18) >> 0x1c;\n    uint bitMask = 1 << (bitValue & 0xf) & 0xffff;\n    uint dataValue = get_data_by_index_08006b7c(dataIndex);\n    set_parameter_value_based_on_condition_080072d8(dataValue, bitMask, value, parameter);\n  }\n}\n",
        "called": [
            "FUN_08006b28",
            "FUN_080072d8",
            "FUN_08006b7c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008a24",
        "calling": [
            "FUN_080005f8",
            "FUN_080088e0",
            "FUN_08002fca"
        ],
        "current_name": "readBitAndSetValue_08008a24"
    },
    "FUN_08008abc": {
        "renaming": {
            "FUN_08008abc": "get_pointer_value_and_return_08008abc",
            "PTR_0800723c": "pointer_value"
        },
        "code": "void get_pointer_value_and_return_08008abc(void)\n{\n  get_pointer_value_and_return_08008abc_0800723c();\n  return;\n}",
        "called": [
            "FUN_0800723c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008abc",
        "calling": [
            "FUN_080022f8"
        ],
        "current_name": "get_pointer_value_and_return_08008abc"
    },
    "FUN_08002b68": {
        "renaming": {
            "FUN_08002b68": "process_data_08002b68",
            "param_1": "data",
            "param_2": "data_len",
            "param_3": "data_id",
            "param_4": "message_id",
            "param_5": "message_type",
            "uVar2": "message_type",
            "uVar3": "message_id",
            "iVar1": "result"
        },
        "code": "int process_data_08002b68(uint8_t *data, uint32_t data_len, uint32_t data_id, uint32_t message_id, uint8_t message_type)\n{\n  int result = 0;\n  uint8_t message_data[128];\n  \n  if (data[data_id + 0x11] == 0) {\n    return result;\n  }\n  \n  allocate_and_update_data(data[data_id + 0x1c]);\n  \n  if (*PTR_DAT_08002bf4 != 0) {\n    if (message_type != 0) {\n      initialize_data(data, data_len);\n      if (message_type > 3) {\n        message_type = 3;\n      }\n      while (message_type > 0) {\n        (*(void (**)(uint8_t *, uint8_t))data)(data, data_id >> ((message_type - 1) * 8) & 0xff);\n        message_type--;\n      }\n      check_and_update_value(data, 0);\n    }\n    \n    result = check_message(data + 5, (data_len & 0x7f) << 1, *(int *)PTR_DAT_08002bf4, data[data_id + 0x1c], message_id);\n    if (result != 0) {\n      data[data_id + 0x1c] = 0;\n    }\n    *PTR_DAT_08002bf8 = 0;\n    *PTR_DAT_08002bfc = (char)data[data_id + 0x1c];\n  }\n  else {\n    data[data_id + 4] = 1;\n  }\n  return result;\n}",
        "called": [
            "FUN_08002a58",
            "FUN_08002acc",
            "FUN_08007f0e",
            "FUN_08002a30"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002b68",
        "calling": [
            "FUN_08002c00"
        ],
        "current_name": "process_data_08002b68"
    },
    "FUN_080005e0": {
        "renaming": {
            "FUN_080005e0": "clear_memory_080005e0",
            "PTR_DAT_080005f0": "memory_location_1",
            "PTR_DAT_080005f4": "memory_location_2"
        },
        "code": "void clear_memory_080005e0(void)\n{\n  *PTR_DAT_080005f0 = 0;\n  *PTR_DAT_080005f4 = 0xff;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080005e0",
        "calling": [
            "FUN_080005f8",
            "FUN_08000aec"
        ],
        "current_name": "clear_memory_080005e0"
    },
    "FUN_08008020": {
        "renaming": {
            "FUN_08008020": "check_and_set_values_for_input_08008020",
            "param_1": "input",
            "iVar1": "input_offset",
            "subtract_four_from_input_08007f78": "subtract_four_from_input",
            "set_and_update_values_080049e0": "set_and_update_values"
        },
        "code": "void check_and_set_values_for_input_08008020(void* input)\\n{\\n  int input_offset = subtract_four_from_input_08007f78();\\n  if (*(char *)(input_offset + 0x5d) == '\\0') {\\n    set_and_update_values_080049e0(input);\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08007f78",
            "FUN_080049e0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008020",
        "calling": [
            "FUN_08004f3c"
        ],
        "current_name": "check_and_set_values_for_input_08008020"
    },
    "FUN_0800674c": {
        "renaming": {
            "FUN_0800674c": "do_nothing_0800674c"
        },
        "code": "void do_nothing_0800674c(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800674c",
        "calling": [
            "FUN_0800674e"
        ],
        "current_name": "do_nothing_0800674c"
    },
    "FUN_08005dac": {
        "renaming": {
            "FUN_08005dac": "update_flags_08005dac",
            "param_1": "flag_address",
            "param_2": "data",
            "uVar1": "flag_value",
            "iVar2": "value1",
            "iVar3": "value2"
        },
        "code": "void update_flags_08005dac(int flag_address, int *data)\n{\n  uint flag_value = *(uint *)(flag_address + 0x4);\n  int value1 = *data;\n  int value2 = data[2];\n\n  *(uint *)(flag_address + 0x20) &= 0xffffefff;\n  if (flag_address == DAT_08005df0) {\n    flag_value = (flag_value & 0xffffbfff) | (data[5] << 6);\n  }\n  *(uint *)(flag_address + 0x4) = flag_value;\n  *(uint *)(flag_address + 0x1c) = (*(uint *)(flag_address + 0x1c) & 0xffff8cff) | (value1 << 8);\n  *(int *)(flag_address + 0x40) = data[1];\n  *(uint *)(flag_address + 0x20) = (*(uint *)(flag_address + 0x20) & 0xffffdfff) | (value2 << 0xc);\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005dac",
        "calling": [
            "FUN_08006186",
            "FUN_08006128"
        ],
        "current_name": "update_flags_08005dac"
    },
    "FUN_0800674e": {
        "renaming": {
            "FUN_0800674e": "check_and_set_value_0800674e",
            "param_1": "input_ptr",
            "do_nothing_0800674c": "do_nothing",
            "calculate_new_value_for_ptr_08006538": "calculate_new_value"
        },
        "code": "int check_and_set_value_0800674e(int *input_ptr)\\n{\\n  if (input_ptr != NULL) {\\n    if (*(char *)((int)input_ptr + 0x39) == '\\0') {\\n      *(undefined *)((int)input_ptr + 0xe) = 0;\\n      do_nothing_0800674c();\\n    }\\n    *(undefined *)((int)input_ptr + 0x39) = 0x24;\\n    *(uint *)(*input_ptr + 0xc) &= 0xffffdfff;\\n    calculate_new_value(input_ptr);\\n    *(uint *)(*input_ptr + 0x10) &= 0xffffb7ff;\\n    *(uint *)(*input_ptr + 0x14) &= 0xffffffd5;\\n    *(uint *)(*input_ptr + 0xc) |= 0x2000;\\n    input_ptr[0xf] = 0;\\n    *(undefined *)((int)input_ptr + 0x39) = 0x20;\\n    *(undefined *)((int)input_ptr + 0x3a) = 0x20;\\n    return 0;\\n  }\\n  return 1;\\n}",
        "called": [
            "FUN_0800674c",
            "FUN_08006538"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800674e",
        "calling": [
            "FUN_08008078"
        ],
        "current_name": "check_and_set_value_0800674e"
    },
    "FUN_0800771c": {
        "renaming": {
            "FUN_0800771c": "execute_callback_if_flag_set_0800771c",
            "param_1": "flag_address",
            "iVar1": "callback_ptr"
        },
        "code": "void execute_callback_if_flag_set_0800771c(int flag_address)\\n{\\n  int callback_ptr = subtract_four_08007718();\\n  if ((*(code **)(callback_ptr + 0x4c) != (code *)0x0) && (*(char *)(flag_address + 0x1c) == '\\x01')) {\\n    (**(code **)(callback_ptr + 0x4c))(callback_ptr,0);\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08007718"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800771c",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "execute_callback_if_flag_set_0800771c"
    },
    "FUN_080066e8": {
        "renaming": {
            "FUN_080066e8": "check_flags_and_values_080066e8",
            "param_1": "flags",
            "param_2": "flag_values",
            "param_3": "expected_result",
            "param_4": "ptr",
            "param_5": "max_distance",
            "iVar1": "pointer_value"
        },
        "code": "int check_flags_and_values_080066e8(uint **flags, uint flag_values, bool expected_result, int ptr, uint max_distance)\n{\n  int pointer_value;\n  while (((flag_values & ~**flags) == 0) != expected_result) {\n    return 0;\n  }\n  if ((max_distance != 0xffffffff) && ((max_distance != 0) && ((pointer_value = get_pointer_value_08003760(), (uint)(pointer_value - ptr) > max_distance)))) {\n    return 0;\n  }\n  (*flags)[3] &= 0xfffffe5f;\n  (*flags)[5] &= 0xfffffffe;\n  *(undefined *)((int)flags + 0x39) = 0x20;\n  *(undefined *)((int)flags + 0x3a) = 0x20;\n  *(undefined *)(flags + 0xe) = 0;\n  return 3;\n}",
        "called": [
            "FUN_08003760"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080066e8",
        "calling": [
            "FUN_080067ac"
        ],
        "current_name": "check_flags_and_values_080066e8"
    },
    "FUN_08009358": {
        "renaming": {
            "FUN_08009358": "process_data_08009358",
            "param_1": "data_start_address",
            "param_2": "data_end_address",
            "param_3": "data",
            "param_4": "current_index",
            "iVar1": "processed_bytes_count",
            "puVar2": "current_byte_address",
            "iVar3": "byte_count"
        },
        "code": "int process_data_08009358(int data_start_address, int data_end_address, char *data, int current_index)\n{\n  int processed_bytes_count = 0;\n  char *current_byte_address = data + current_index;\n  \n  while (current_index != 0)\n  {\n    if (current_byte_address == data_end_address)\n    {\n      return 0;\n    }\n    \n    processed_bytes_count = process_byte(data_start_address, *current_byte_address, data_end_address, current_index, processed_bytes_count);\n    current_index = processed_bytes_count + 1;\n    current_byte_address = current_byte_address + 1;\n  }\n  \n  return processed_bytes_count;\n}",
        "called": [
            "FUN_0800932c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009358",
        "calling": [
            "FUN_0800937c"
        ],
        "current_name": "process_data_08009358"
    },
    "FUN_0800270c": {
        "renaming": {
            "FUN_0800270c": "calculate_difference_between_two_bytes_0800270c",
            "*PTR_DAT_08002718": "*first_byte",
            "*PTR_DAT_0800271c": "*second_byte"
        },
        "code": "int calculate_difference_between_two_bytes_0800270c(void)\\n{\\n  uint first_byte = (uint)(byte)*PTR_DAT_08002718;\\n  uint second_byte = (uint)(byte)*PTR_DAT_0800271c;\\n  int difference = first_byte - second_byte;\\n  return difference;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800270c",
        "calling": [
            "FUN_08001c18"
        ],
        "current_name": "calculate_difference_between_two_bytes_0800270c"
    },
    "FUN_08003370": {
        "renaming": {
            "FUN_08003370": "set_values_in_struct_08003370",
            "param_1": "struct_address",
            "param_2": "value1",
            "param_3": "value2"
        },
        "code": "void set_values_in_struct_08003370(int struct_address, int value1, int value2)\\n{\\n  *(int *)(struct_address + 0x6c) = value1;\\n  *(int *)(struct_address + 0x44) = value2;\\n  return;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003370",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "set_values_in_struct_08003370"
    },
    "FUN_08007fa0": {
        "renaming": {
            "FUN_08007fa0": "process_input_08007fa0",
            "param_1": "input_address",
            "param_2": "is_valid",
            "param_3": "is_processing_needed",
            "param_4": "processing_parameter",
            "iVar1": "result"
        },
        "code": "void process_input_08007fa0(int input_address, int is_valid, int is_processing_needed, undefined4 processing_parameter)\n{\n  int result = subtract_four_from_input();\n  if (is_valid == *(int *)(input_address + 0xc)) {\n    if (is_processing_needed == 0) {\n      *(undefined *)(result + 0x88) = 0;\n      *(undefined *)(result + 0x5c) = 0;\n      if (*(code **)(result + 100) != (code *)0x0) {\n        (**(code **)(result + 100))();\n      }\n      validate_input(input_address,result + 0x68,*(undefined *)(result + 0x88),8);\n      return;\n    }\n    *(undefined *)(result + 0x5c) = 1;\n    process_input_08007fa0_08004954(input_address,result + 0x68,0x20,8,processing_parameter);\n  }\n  return;\n}",
        "called": [
            "FUN_08004954",
            "FUN_08007f78",
            "FUN_080048c8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007fa0",
        "calling": [
            "FUN_08004ac2"
        ],
        "current_name": "process_input_08007fa0"
    },
    "FUN_08003376": {
        "renaming": {
            "FUN_08003376": "process_input_08003376",
            "param_1": "input_data",
            "param_2": "input_byte",
            "param_3": "input_length",
            "bVar1": "is_input_valid"
        },
        "code": "void process_input_08003376(undefined *input_data, undefined input_byte, uint input_length)\n{\n  bool is_input_valid;\n  if (input_length < *(uint *)(input_data + 8)) {\n    is_input_valid = false;\n  }\n  else {\n    is_input_valid = true;\n    if (*(code **)(input_data + 100) != (code *)0x0) {\n      *input_data = 1;\n      (**(code **)(input_data + 100))(*(undefined4 *)(input_data + 0x3c));\n      if (input_length < *(uint *)(input_data + 8)) {\n        is_input_valid = false;\n      }\n      else {\n        is_input_valid = true;\n      }\n    }\n  }\n  if (!is_input_valid) {\n    *(undefined *)(*(int *)(input_data + 4) + input_length) = input_byte;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003376",
        "calling": [
            "FUN_08003474",
            "FUN_080033cc"
        ],
        "current_name": "process_input_08003376"
    },
    "FUN_08008bf4": {
        "renaming": {
            "FUN_08008bf4": "calculate_shift_if_needed_08008bf4",
            "DAT_08008c18": "is_shift_needed",
            "PTR_DAT_08008c1c": "shift_amount_data"
        },
        "code": "void calculate_shift_if_needed_08008bf4(void)\n{\n  bool DAT_08008c18 = (DAT_08008c18 != 0);\n  if (DAT_08008c18) {\n    calculate_shift_amount(PTR_DAT_08008c1c);\n  }\n  return;\n}",
        "called": [
            "FUN_08008afa"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008bf4",
        "calling": [
            "FUN_08008f1c"
        ],
        "current_name": "calculate_shift_if_needed_08008bf4"
    },
    "FUN_08005430": {
        "renaming": {
            "FUN_08005430": "get_value_from_offset_08005430",
            "param_1": "base_address"
        },
        "code": "undefined4 get_value_from_offset_08005430(int base_address)\\n{\\n  int value_offset = 0x40;\\n  return *(undefined4 *)(base_address + value_offset);\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005430",
        "calling": [
            "FUN_08007e74",
            "FUN_08007f0e"
        ],
        "current_name": "get_value_from_offset_08005430"
    },
    "FUN_08002720": {
        "renaming": {
            "FUN_08002720": "get_next_byte_08002720",
            "bVar1": "current_byte_index",
            "bVar2": "byte_offset"
        },
        "code": "uint get_next_byte_08002720()\\n{\\n  uint current_byte_index = *PTR_DAT_08002740;\\n  uint max_byte_index = (uint)(byte)*PTR_DAT_08002744;\\n  if (current_byte_index < max_byte_index) {\\n    uint byte_offset = *(uint *)(*PTR_DAT_08002748 + current_byte_index);\\n    *PTR_DAT_08002740 = current_byte_index + 1;\\n    return byte_offset;\\n  }\\n  return 0xffffffff;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002720",
        "calling": [
            "FUN_08001c08"
        ],
        "current_name": "get_next_byte_08002720"
    },
    "FUN_080031ce": {
        "renaming": {
            "FUN_080031ce": "encode_data_080031ce",
            "param_1": "data_ptr",
            "param_2": "param_2",
            "param_3": "param_3",
            "param_4": "param_4",
            "param_5": "param_5",
            "puVar1": "function_ptr",
            "uVar2": "i"
        },
        "code": "void encode_data_080031ce(uint32_t *data_ptr, uint32_t data_size, uint32_t param_3, uint32_t param_4, int param_5)\\n{\\n  uint32_t *function_ptr = (uint32_t *)*data_ptr;\\n  if (function_ptr != NULL) {\\n    void (*function_call)(uint32_t *, uint32_t, uint32_t, void *, uint32_t) = (void (*)(uint32_t *, uint32_t, uint32_t, void *, uint32_t))(*function_ptr);\\n    function_call(data_ptr, 0xf0, param_3, (void *)*function_ptr, param_4);\\n    void (*second_function_call)(uint32_t *) = (void (*)(uint32_t *))(**(uint32_t ***)(uint32_t *)*data_ptr);\\n    second_function_call((uint32_t *)*data_ptr);\\n    second_function_call((uint32_t *)*data_ptr, param_2);\\n    second_function_call((uint32_t *)*data_ptr, param_3);\\n    for (uint32_t i = 0; i < data_size; i++) {\\n      encode_data_080031ce_0800307a(data_ptr, 1, param_5 + i, 0);\\n    }\\n    second_function_call((uint32_t *)*data_ptr, 0xf7);\\n  }\\n  return;\\n}",
        "called": [
            "FUN_0800307a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080031ce",
        "calling": [
            "FUN_08002df6"
        ],
        "current_name": "encode_data_080031ce"
    },
    "FUN_08009918": {
        "renaming": {
            "FUN_08009918": "check_and_set_offset_08009918",
            "param_1": "result",
            "param_2": "input",
            "puVar1": "ptr",
            "iVar2": "offset"
        },
        "code": "void check_and_set_offset_08009918(int *result, undefined4 input)\\n{\\n  undefined *ptr = PTR_DAT_08009934;\\n  *(undefined4 *)ptr = 0;\\n  int offset = calculate_offset(input);\\n  if ((offset == -1) && (*(int *)ptr != 0)) {\\n    *result = *(int *)ptr;\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08008804"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009918",
        "calling": [
            "FUN_08009270"
        ],
        "current_name": "check_and_set_offset_08009918"
    },
    "FUN_08005434": {
        "renaming": {
            "FUN_08005434": "count_down_08005434",
            "param_1": "input",
            "local_4": "count",
            "bVar1": "is_not_zero"
        },
        "code": "void count_down_08005434(int input)\n{\n  bool is_not_zero;\n  int count = input * (uint)((ulonglong)DAT_0800545c * (ulonglong)*(uint *)PTR_DAT_08005458 >> 0x29);\n  do {\n    is_not_zero = count != 0;\n    count--;\n  } while (is_not_zero);\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005434",
        "calling": [
            "FUN_08005460"
        ],
        "current_name": "count_down_08005434"
    },
    "FUN_08005e2e": {
        "renaming": {
            "FUN_08005e2e": "clearFlagsIfConditionsMet_08005e2e",
            "param_1": "paramArray",
            "puVar1": "paramPtr",
            "iVar1": "condition1",
            "iVar2": "condition2",
            "iVar3": "flagMask",
            "puVar4": "flagPtr",
            "puVar5": "flag2Ptr",
            "set_flags_based_on_parameter_08007110": "setFlagsBasedOnParameter"
        },
        "code": "void clearFlagsIfConditionsMet_08005e2e(uint **paramArray)\n{\n  uint *paramPtr = *paramArray;\n  uint condition1 = 0x1111;\n  uint condition2 = 0x444;\n  uint flagMask = 0xfffffffe;\n  uint *flagPtr = (uint *)((int)paramArray + 0x3d);\n  uint *flag2Ptr = (uint *)(paramArray + 0xf);\n  *flagPtr = 2;\n  if ((paramPtr[8] & condition1) == 0) {\n    if ((paramPtr[8] & condition2) == 0) {\n      *paramPtr = *paramPtr & flagMask;\n    }\n  }\n  set_flags_based_on_parameter_08007110(paramArray);\n  *flagPtr = 0;\n  *flag2Ptr = 0;\n  return;\n}",
        "called": [
            "FUN_08007110"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005e2e",
        "calling": [
            "FUN_080071e4"
        ],
        "current_name": "clearFlagsIfConditionsMet_08005e2e"
    },
    "FUN_08007736": {
        "renaming": {
            "FUN_08007736": "execute_subtract_four_result_08007736",
            "iVar1": "subtracted_value"
        },
        "code": "void execute_subtract_four_result_08007736(void)\n{\n  int subtracted_value = subtract_four_result();\n  if (*(code **)(subtracted_value + 0x48) != (code *)0x0) {\n    (**(code **)(subtracted_value + 0x48))();\n  }\n  return;\n}",
        "called": [
            "FUN_08007718"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007736",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "execute_subtract_four_result_08007736"
    },
    "FUN_08002968": {
        "renaming": {
            "FUN_08002968": "clear_and_initialize_data_08002968",
            "param_1": "data_pointer",
            "param_2": "input_value",
            "iVar1": "memory_size",
            "iVar2": "index_offset",
            "is_special_case": "is_special_case",
            "PTR_DAT_080029ec": "flag_pointer",
            "PTR_DAT_080029f0": "reset_flag_pointer",
            "*(int *)PTR_DAT_080029f4": "memory_pointer",
            "memory_value": "memory_value",
            "PTR_DAT_080029f8": "memory_size_pointer",
            "PTR_DAT_080029fc": "flag_pointer_2",
            "PTR_DAT_08002a00": "reset_flag_pointer_2",
            "*(int *)PTR_DAT_08002a04": "memory_pointer_2",
            "PTR_DAT_08002a08": "memory_size_pointer_2",
            "PTR_DAT_08002a0c": "flag_pointer_3",
            "index_offset_value": "index_offset_value",
            "*(char *)(param_1 + 0x10)": "index_offset",
            "*(undefined *)(param_1 + 0x11)": "special_case_flag",
            "FUNC_080077b0": "fill_memory_with_value_080091c6",
            "DAT_08002a10": "memory_value",
            "PTR_LAB_08002774_1_08002a14": "param_value",
            "PTR_LAB_08002b00_1_08002a18": "param_2_value"
        },
        "code": "void clear_and_initialize_data_08002968(int data_pointer, uint8_t input_value)\n{\n  int memory_size;\n  int index_offset;\n  int param_1 = data_pointer;\n  uint8_t is_special_case = 0;\n  uint8_t *PTR_DAT_080029ec = PTR_DAT_080029ec;\n  uint8_t *PTR_DAT_080029f0 = PTR_DAT_080029f0;\n  int **(int *)PTR_DAT_080029f4 = *(int **)PTR_DAT_080029f4;\n  uint8_t DAT_08002a10 = 0;\n  uint8_t *PTR_DAT_080029f8 = PTR_DAT_080029f8;\n  uint8_t *PTR_DAT_080029fc = PTR_DAT_080029fc;\n  uint8_t *PTR_DAT_08002a00 = PTR_DAT_08002a00;\n  int **(int *)PTR_DAT_08002a04 = *(int **)PTR_DAT_08002a04;\n  uint8_t *PTR_DAT_08002a08 = PTR_DAT_08002a08;\n  uint8_t *PTR_DAT_08002a0c = PTR_DAT_08002a0c;\n  uint8_t param_2 = input_value & 0x7f;\n  uint8_t index_offset_value = param_2 << 1;\n  *(char *)(param_1 + 0x10) = index_offset_value;\n  if (input_value == 0x33) {\n    *(undefined *)(param_1 + 0x11) = 1;\n  }\n  else {\n    *(undefined *)(param_1 + 0x11) = 0;\n  }\n  index_offset = param_1 + 0x14;\n  memory_size = 0x4000;\n  if (*(char *)(param_1 + 0x11) == 0) {\n    is_special_case = 1;\n  }\n  *PTR_DAT_080029ec = 0;\n  *PTR_DAT_080029f0 = 0;\n  if (**(int *)PTR_DAT_080029f4 != 0) {\n    fill_memory_with_value_080091c6(**(int *)PTR_DAT_080029f4, DAT_08002a10, *PTR_DAT_080029f8);\n  }\n  *PTR_DAT_080029fc = 0;\n  *PTR_DAT_08002a00 = 0;\n  if (**(int *)PTR_DAT_08002a04 != 0) {\n    fill_memory_with_value_080091c6(**(int *)PTR_DAT_08002a04, DAT_08002a10, *PTR_DAT_08002a08);\n  }\n  *PTR_DAT_08002a0c = 0;\n  FUNC_080077b0(index_offset, DAT_08002a10, memory_size, index_offset_value, *(undefined *)(param_1 + 0x11));\n  if (is_special_case == 0) {\n    set_PTR_LAB_08002774_1_08002a14_if_not_null_08007f8e(index_offset, PTR_LAB_08002774_1_08002a14);\n    update_param_2_if_param_1_not_null_08007f7c(index_offset, PTR_LAB_08002b00_1_08002a18);\n  }\n}\n",
        "called": [
            "FUN_08007f8e",
            "FUN_08007f7c",
            "FUN_080091c6",
            "FUN_080077b0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002968",
        "calling": [
            "FUN_08002a1c"
        ],
        "current_name": "clear_and_initialize_data_08002968"
    },
    "FUN_08004ccc": {
        "renaming": {
            "FUN_08004ccc": "execute_command_08004ccc",
            "param_1": "command",
            "puVar1": "command_ptr"
        },
        "code": "void execute_command_08004ccc(uint **command)\n{\n  uint *command_ptr = command[0xb];\n  if (*(char *)((int)command + 0x3d) == '!') {\n    if (*(short *)((int)command + 0x2a) == 0) {\n      if (((command_ptr == (uint *)0x4) || (command_ptr == (uint *)0x8)) || (command_ptr == (uint *)0xffff0000)) {\n        (*command)[1] = (*command)[1] & 0xfffff8ff;\n        **command = **command | 0x200;\n        command[0xc] = (uint *)0x0;\n        *(undefined *)((int)command + 0x3d) = 0x20;\n        if (*(char *)((int)command + 0x3e) == '@') {\n          *(undefined *)((int)command + 0x3e) = 0;\n          do_nothing_1();\n        }\n        else {\n          *(undefined *)((int)command + 0x3e) = 0;\n          do_nothing_2();\n        }\n      }\n      else {\n        (*command)[1] = (*command)[1] & 0xfffff8ff;\n        command[0xc] = (uint *)0x11;\n        *(undefined *)((int)command + 0x3e) = 0;\n        *(undefined *)((int)command + 0x3d) = 0x20;\n        do_nothing_2();\n      }\n    }\n    else {\n      command_ptr = command[9];\n      command[9] = (uint *)((int)command_ptr + 1);\n      (*command)[4] = (uint)*(byte *)command_ptr;\n      *(short *)((int)command + 0x2a) = *(short *)((int)command + 0x2a) + -1;\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_08004a1e",
            "FUN_08004b80"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004ccc",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "execute_command_08004ccc"
    },
    "FUN_080042d4": {
        "renaming": {
            "FUN_080042d4": "check_bit_080042d4",
            "param_1": "bit_array",
            "param_2": "bit_mask"
        },
        "code": "int check_bit_080042d4(uint *bit_array, uint bit_mask)\n{\n  if ((bit_mask & *bit_array) == 0) {\n    return 0;\n  }\n  return 1;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080042d4",
        "calling": [
            "FUN_080072f0"
        ],
        "current_name": "check_bit_080042d4"
    },
    "FUN_0800542a": {
        "renaming": {
            "FUN_0800542a": "get_character_at_offset_0800542a",
            "param_1": "character_offset"
        },
        "code": "undefined get_character_at_offset_0800542a(int character_offset)\n{\n  return *(undefined *)(character_offset + 0x3d);\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800542a",
        "calling": [
            "FUN_08007e74",
            "FUN_08007f0e"
        ],
        "current_name": "get_character_at_offset_0800542a"
    },
    "FUN_0800457c": {
        "renaming": {
            "FUN_0800457c": "extract_byte_from_data_0800457c",
            "param_1": "data",
            "pbVar1": "byte_data",
            "PTR_00000009": "byte_data_offset",
            "*(short *)((int)param_1 + 0x2a)": "*(data_offset)",
            "*(uint *)(*param_1 + 0x10)": "*(destination)"
        },
        "code": "void extract_byte_from_data_0800457c(int *data)\n{\n  short *data_offset = (short *)((int)data + 0x2a);\n  if (*data_offset != 0)\n  {\n    byte *byte_data = (byte *)data[9];\n    data[9] = (int)(byte_data + 1);\n    uint *destination = (uint *)(*data + 0x10);\n    *destination = (uint)*byte_data;\n    *data_offset = *data_offset - 1;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800457c",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "extract_byte_from_data_0800457c"
    },
    "FUN_080091c6": {
        "renaming": {
            "FUN_080091c6": "fill_memory_with_value_080091c6",
            "param_1": "memory_start",
            "param_2": "value",
            "param_3": "num_bytes",
            "puVar1": "memory_end"
        },
        "code": "void fill_memory_with_value_080091c6(char *memory_start, char value, int num_bytes)\n{\n  char *memory_end = memory_start + num_bytes;\n  for (; memory_start != memory_end; memory_start++) {\n    *memory_start = value;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080091c6",
        "calling": [
            "FUN_08009db0",
            "FUN_08006d80",
            "FUN_08007118",
            "FUN_08002968",
            "FUN_08002a58",
            "FUN_08009d24",
            "FUN_08009cdc"
        ],
        "current_name": "fill_memory_with_value_080091c6"
    },
    "FUN_0800a07a": {
        "renaming": {
            "FUN_0800a07a": "assignValueAndCheckStatus_0800a07a",
            "param_1": "value",
            "param_2": "data",
            "iVar1": "assignedValue",
            "bVar3": "isAssignSuccessful",
            "uVar2": "flags",
            "check_and_assign_value_0800a130": "checkAndAssignValue"
        },
        "code": "void assignValueAndCheckStatus_0800a07a(int value, int* data)\n{\n  int assignedValue = check_and_assign_value_0800a130(value, *(short *)(data + 0xe));\n  bool isAssignSuccessful = assignedValue != -1;\n  ushort flags = *(ushort *)(data + 0xc);\n  if (!isAssignSuccessful) {\n    flags &= 0xefff;\n  }\n  else {\n    *(int *)(data + 0x54) = assignedValue;\n    flags |= 0x1000;\n  }\n  *(ushort *)(data + 0xc) = flags;\n  return;\n}",
        "called": [
            "FUN_0800a130"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a07a",
        "calling": [],
        "current_name": "assignValueAndCheckStatus_0800a07a"
    },
    "FUN_08003a20": {
        "renaming": {
            "FUN_08003a20": "activate_device_08003a20",
            "param_1": "device_info",
            "param_2": "device_id",
            "iVar1": "current_ptr_value",
            "uVar2": "return_value",
            "iVar3": "device_ptr",
            "local_14": "i",
            "PTR_DAT_08003a98": "device_multiplier",
            "DAT_08003a9c": "device_timeout",
            "get_pointer_value_08003760": "get_pointer_value"
        },
        "code": "int activate_device_08003a20(int *device_info, int device_id)\\n{\\n  int device_ptr = *device_info;\\n  if ((*(uint *)(device_ptr + 8) & 1) == 0) {\\n    *(uint *)(device_ptr + 8) = *(uint *)(device_ptr + 8) | 1;\\n    for (uint i = (uint)((ulonglong)DAT_08003a9c * (ulonglong)*(uint *)PTR_DAT_08003a98 >> 0x32); i != 0; i--) {\\n    }\\n    int initial_ptr_value = get_pointer_value_08003760(device_info, device_id, (int)((ulonglong)DAT_08003a9c * (ulonglong)*(uint *)PTR_DAT_08003a98));\\n    do {\\n      if ((*(uint *)(*device_info + 8) & 1) != 0) {\\n        return 0;\\n      }\\n      int current_ptr_value = get_pointer_value_08003760(device_info);\\n    } while ((uint)(current_ptr_value - initial_ptr_value) < 3);\\n    device_info[10] = device_info[10] | 0x10;\\n    device_info[0xb] = device_info[0xb] | 1;\\n    *(undefined *)(device_info + 9) = 0;\\n    return 1;\\n  }\\n  else {\\n    return 0;\\n  }\\n}",
        "called": [
            "FUN_08003760"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003a20",
        "calling": [
            "FUN_08003aa0",
            "FUN_08003e20"
        ],
        "current_name": "activate_device_08003a20"
    },
    "FUN_080064b0": {
        "renaming": {
            "FUN_080064b0": "clear_flags_080064b0",
            "param_1": "device_info",
            "PTR_08003a98": "device_multiplier",
            "DAT_08003a9c": "device_timeout"
        },
        "code": "void clear_flags_080064b0(int *device_info)\n{\n  int *device_ptr = device_info;\n  *(uint *)(device_ptr[3] + 0xc) &= 0xfffffedf;\n  *(uint *)(device_ptr[3] + 0x14) &= 0xfffffffe;\n  *(undefined *)((int)device_info + 0x3a) = 0x20;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080064b0",
        "calling": [
            "FUN_080069ec"
        ],
        "current_name": "clear_flags_080064b0"
    },
    "FUN_08009cdc": {
        "renaming": {
            "FUN_08009cdc": "initializeData_08009cdc",
            "param_1": "data",
            "param_2": "value1",
            "param_3": "value2",
            "fill_memory_with_value_080091c6": "fillMemoryWithZeros"
        },
        "code": "void initializeData_08009cdc(undefined4 *data, undefined2 value1, undefined2 value2)\n{\n  data[0] = 0;\n  data[1] = 0;\n  data[2] = 0;\n  *(undefined2 *)(data + 3) = value1;\n  data[0x19] = 0;\n  *(undefined2 *)((int)data + 0xe) = value2;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  fill_memory_with_value_080091c6(data + 0x17, 8);\n  data[8] = data;\n  data[9] = DAT_08009d14;\n  data[10] = PTR_assign_value_if_condition_met_0800a042_1_08009d18;\n  data[0xb] = PTR_assignValueAndCheckStatus_0800a07a_1_08009d1c;\n  data[0xc] = PTR_LAB_0800a09e_1_08009d20;\n  return;\n}",
        "called": [
            "FUN_080091c6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009cdc",
        "calling": [
            "FUN_08009d50"
        ],
        "current_name": "initializeData_08009cdc"
    },
    "FUN_08002a58": {
        "renaming": {
            "FUN_08002a58": "checkAndUpdateValue_08002a58",
            "param_1": "value",
            "iVar1": "updatedValue",
            "uVar2": "result",
            "check_and_update_value_08007e74": "updateValue",
            "PTR_DAT_08002ab0": "ptr1",
            "PTR_DAT_08002aac": "ptr2",
            "PTR_DAT_08002aa8": "ptr3",
            "PTR_DAT_08002ab4": "ptr4",
            "PTR_DAT_08002ab8": "ptr5",
            "PTR_DAT_08002abc": "ptr6",
            "fill_memory_with_value_080091c6": "fillMemoryWithZeroes"
        },
        "code": "int checkAndUpdateValue_08002a58(int value)\n{\n  int result;\n  if (value == 0) {\n    result = 4;\n  }\n  else {\n    int updatedValue = check_and_update_value_08007e74(value);\n    if (updatedValue == 0) {\n      result = 0;\n    }\n    else if (updatedValue == 1) {\n      result = 1;\n    }\n    else {\n      result = 4;\n    }\n    if (*(int *)PTR_DAT_08002aac != 0) {\n      fill_memory_with_value_080091c6(*(int *)PTR_DAT_08002aac, *PTR_DAT_08002ab4);\n    }\n    *PTR_DAT_08002ab8 = 0;\n    *PTR_DAT_08002aa8 = 0;\n    *PTR_DAT_08002abc = 0;\n  }\n  return result;\n}",
        "called": [
            "FUN_08007e74",
            "FUN_080091c6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002a58",
        "calling": [
            "FUN_08001c18",
            "FUN_08002b68",
            "FUN_08002ac0"
        ],
        "current_name": "checkAndUpdateValue_08002a58"
    },
    "FUN_080026b0": {
        "renaming": {
            "FUN_080026b0": "set_value_based_on_conditions_080026b0",
            "param_1": "device_info",
            "param_2": "new_value",
            "calculate_new_value_08008ef4": "calculate_new_value",
            "set_value_based_on_conditions_0800267c": "write_value_to_device"
        },
        "code": "void set_value_based_on_conditions_080026b0(int *device_info, int new_value)\n{\n  int value = new_value;\n  if (new_value < 0)\n  {\n    value = 0;\n  }\n  else if (new_value > 180)\n  {\n    value = 180;\n  }\n  int device_multiplier = calculate_device_multiplier(device_info);\n  int device_timeout = calculate_device_timeout(device_info);\n  value = calculate_new_value_08008ef4(value, 0, 180, (device_multiplier - *(char *)(device_info + 1)) * 4,\n                 (device_timeout - *(char *)(device_info + 2)) * 4);\n  set_value_based_on_conditions_080026b0_0800267c(device_info, value);\n  return;\n}",
        "called": [
            "FUN_08008ef4",
            "FUN_0800267c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080026b0",
        "calling": [
            "FUN_0800021a"
        ],
        "current_name": "set_value_based_on_conditions_080026b0"
    },
    "FUN_08006092": {
        "renaming": {
            "FUN_08006092": "check_and_update_registers_08006092",
            "param_1": "input_ptr",
            "FUNC_08006e68": "do_nothing",
            "update_registers_08005fe8": "update_registers"
        },
        "code": "int check_and_update_registers_08006092(int *input_ptr)\\n{\\n  if (input_ptr != NULL) {\\n    if (*(char *)((int)input_ptr + 0x3d) == '\\0') {\\n      *(undefined *)((int)input_ptr + 0x3c) = 0;\\n      do_nothing();\\n    }\\n    *(undefined *)((int)input_ptr + 0x3d) = 2;\\n    update_registers_08005fe8(*input_ptr, input_ptr + 1);\\n    *(undefined *)((int)input_ptr + 0x3d) = 1;\\n    return 0;\\n  }\\n  return 1;\\n}",
        "called": [
            "FUN_08006e68",
            "FUN_08005fe8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006092",
        "calling": [
            "FUN_08007118"
        ],
        "current_name": "check_and_update_registers_08006092"
    },
    "FUN_08008d8c": {
        "renaming": {
            "FUN_08008d8c": "initialize_data_structure_if_flag_set_08008d8c",
            "param_1": "flag",
            "param_2": "value",
            "PTR_DAT_08008dac": "ptr1",
            "DAT_08008da8": "dat1",
            "param_3": "param3",
            "param_4": "param4",
            "initialize_data_structure_and_set_defaults_08008d30": "initialize_data_structure_and_set_defaults"
        },
        "code": "void initialize_data_structure_if_flag_set_08008d8c(int flag, int value, undefined4 param_3, undefined4 param_4) {\n  if (flag != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    initialize_data_structure_and_set_defaults_08008d30(PTR_DAT_08008dac, DAT_08008da8, param_3, 0xffff, param_4);\n  }\n  return;\n}",
        "called": [
            "FUN_08008d30"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008d8c",
        "calling": [],
        "current_name": "initialize_data_structure_if_flag_set_08008d8c"
    },
    "FUN_080004d4": {
        "renaming": {
            "FUN_080004d4": "increment_counters_if_flag_set_080004d4",
            "param_1": "flag",
            "param_2": "counter",
            "iVar1": "i",
            "puVar2": "counter_ptr"
        },
        "code": "void increment_counters_if_flag_set_080004d4(int flag, int counter)\n{\n  if (flag != 1)\n  {\n    return;\n  }\n  if (counter == 0xffff)\n  {\n    unsigned char *counter_ptr = PTR_DAT_080004fc;\n    for (int i = 0; i < 11; i++)\n    {\n      increment_and_set_08002580(counter_ptr);\n      counter_ptr += 3;\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_08002580"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080004d4",
        "calling": [],
        "current_name": "increment_counters_if_flag_set_080004d4"
    },
    "FUN_080005f8": {
        "renaming": {
            "FUN_080005f8": "FUNC_080005f8"
        },
        "code": "\nvoid FUNC_080005f8(uint param_1,int param_2)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  char cVar3;\n  bool bVar4;\n  uint uVar5;\n  \n  iVar2 = get_value_at_offset_08002fa0(PTR_DAT_08000874,param_1);\n  if (iVar2 != 0x7f) {\n    iVar2 = get_value_at_offset_08002fa0(PTR_DAT_08000874,param_1);\n    if (iVar2 == 6) {\n      cVar3 = *PTR_DAT_0800087c;\n      if (cVar3 == '\\0') {\n        cVar3 = '\\0';\n      }\n      else if (param_2 == 6) {\n        cVar3 = '\\0';\n      }\n    }\n    else {\n      cVar3 = '\\0';\n    }\n    if (cVar3 != '\\0') {\n      clear_memory_080005e0();\n    }\n    if (param_1 < 0x3c) {\n      if (PTR_DAT_08000878[param_1] == -1) {\n        bVar4 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac();\n        if (iVar2 == 0) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000878[param_1]);\n          if (iVar2 == 1) {\n            bVar4 = false;\n          }\n          else if (param_2 == 4) {\n            bVar4 = false;\n          }\n          else {\n            bVar4 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar4 = false;\n    }\n    if (bVar4) {\n      if ((byte)PTR_DAT_08000880[param_1] < 0xc) {\n        iVar2 = calculate_index_from_input_080026f8(PTR_DAT_08000884 + (uint)(byte)PTR_DAT_08000880[param_1] * 3);\n      }\n      else {\n        iVar2 = 0;\n      }\n      if (iVar2 != 0) {\n        process_input_and_update_state_08000588(param_1);\n      }\n    }\n    uVar5 = param_1 - 0x2e & 0xff;\n    if (uVar5 < 0xe) {\n      if (param_1 < 0x3c) {\n        iVar2 = (int)(char)PTR_DAT_08000878[param_1];\n      }\n      else {\n        iVar2 = -1;\n      }\n      iVar2 = find_char_index_080036ac(iVar2);\n      if (iVar2 == 0) {\n        bVar4 = false;\n      }\n      else {\n        if (param_1 < 0x3c) {\n          iVar2 = (int)(char)PTR_DAT_08000878[param_1];\n        }\n        else {\n          iVar2 = -1;\n        }\n        iVar2 = find_char_index_080036ac(iVar2);\n        if (iVar2 == 1) {\n          bVar4 = false;\n        }\n        else {\n          bVar4 = true;\n        }\n      }\n    }\n    else {\n      bVar4 = false;\n    }\n    if (bVar4) {\n      set_device_parameter_08000488(uVar5,param_2 == 2);\n    }\n    if (param_1 < 0x3c) {\n      if (PTR_DAT_08000878[param_1] == -1) {\n        bVar4 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac();\n        if (iVar2 == 0) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000878[param_1]);\n          if (iVar2 == 1) {\n            bVar4 = false;\n          }\n          else {\n            bVar4 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar4 = false;\n    }\n    if (bVar4) {\n      if ((param_2 == 0) || (param_2 == 0xb)) {\n        PTR_DAT_08000888[param_1 >> 3] = PTR_DAT_08000888[param_1 >> 3] | (byte)(1 << (param_1 & 7))\n        ;\n      }\n      else {\n        PTR_DAT_08000888[param_1 >> 3] =\n             PTR_DAT_08000888[param_1 >> 3] & ~(byte)(1 << (param_1 & 7));\n      }\n    }\n    set_value_at_index_08002fc2(PTR_DAT_08000874,param_1,0);\n    switch(param_2) {\n    case 0:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000878[param_1] == -1) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            bVar4 = false;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000878[param_1]);\n            if (iVar2 == 1) {\n              bVar4 = false;\n            }\n            else {\n              bVar4 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar4 = false;\n      }\n      if (bVar4) {\n        process_bit_08008990(param_1,0);\n        set_byte_at_offset_08002fa8(PTR_DAT_08000874,param_1,0);\n        return;\n      }\n      break;\n    case 1:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000a48[param_1] == -1) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            bVar4 = false;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000a48[param_1]);\n            if (iVar2 == 1) {\n              bVar4 = false;\n            }\n            else {\n              bVar4 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar4 = false;\n      }\n      if (bVar4) {\n        iVar2 = get_value_at_offset_08002fa0(PTR_DAT_08000a44,param_1);\n        if (iVar2 == 3) {\n          readBitAndSetValue_08008a24(param_1,0);\n        }\n        process_bit_08008990(param_1,1);\n        set_byte_at_offset_08002fa8(PTR_DAT_08000a44,param_1,1);\n        return;\n      }\n      break;\n    case 2:\n      if (uVar5 < 0xe) {\n        if (param_1 < 0x3c) {\n          iVar2 = (int)(char)PTR_DAT_08000878[param_1];\n        }\n        else {\n          iVar2 = -1;\n        }\n        iVar2 = find_char_index_080036ac(iVar2);\n        if (iVar2 == 0) {\n          bVar4 = false;\n        }\n        else {\n          if (param_1 < 0x3c) {\n            iVar2 = (int)(char)PTR_DAT_08000878[param_1];\n          }\n          else {\n            iVar2 = -1;\n          }\n          iVar2 = find_char_index_080036ac(iVar2);\n          if (iVar2 == 1) {\n            bVar4 = false;\n          }\n          else {\n            bVar4 = true;\n          }\n        }\n      }\n      else {\n        bVar4 = false;\n      }\n      if (bVar4) {\n        if (param_1 < 0x3c) {\n          if (PTR_DAT_08000878[param_1] == -1) {\n            bVar4 = false;\n          }\n          else {\n            iVar2 = find_char_index_080036ac();\n            if (iVar2 == 0) {\n              bVar4 = false;\n            }\n            else {\n              iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000878[param_1]);\n              if (iVar2 == 1) {\n                bVar4 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar4 = false;\n        }\n        if (bVar4) {\n          process_bit_08008990(param_1,0);\n        }\n        set_byte_at_offset_08002fa8(PTR_DAT_08000874,param_1,2);\n        return;\n      }\n      break;\n    case 3:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000a48[param_1] == -1) {\n          iVar2 = 0;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            iVar2 = 0;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000a48[param_1]);\n            if (iVar2 == 1) {\n              iVar2 = 0;\n            }\n            else {\n              iVar2 = compare_values_0800738a((int)(char)PTR_DAT_08000a48[param_1],PTR_DAT_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        iVar2 = 0;\n      }\n      if (iVar2 != 0) {\n        process_bit_08008990(param_1,1);\n        process_bit_080088e0(param_1,0);\n        set_byte_at_offset_08002fa8(PTR_DAT_08000a44,param_1,3);\n        return;\n      }\n      break;\n    case 4:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000a48[param_1] == -1) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            bVar4 = false;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000a48[param_1]);\n            if (iVar2 == 1) {\n              bVar4 = false;\n            }\n            else {\n              bVar4 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar4 = false;\n      }\n      if (bVar4) {\n        set_byte_at_offset_08002fa8(PTR_DAT_08000a44,param_1,4);\n        if (((byte)PTR_DAT_08000a50[param_1] != 0xff) &&\n           (iVar2 = calculate_index_from_input_080026f8(PTR_DAT_08000a54 + (uint)(byte)PTR_DAT_08000a50[param_1] * 3),\n           iVar2 != 0)) {\n          bVar4 = false;\n        }\n        if (bVar4) {\n          process_servo_data_08000500(param_1,0xffffffff);\n          return;\n        }\n      }\n      break;\n    default:\n      process_data_and_return_result_08002f14(PTR_DAT_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000a48[param_1] == -1) {\n          iVar2 = 0;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            iVar2 = 0;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000a48[param_1]);\n            if (iVar2 == 1) {\n              iVar2 = 0;\n            }\n            else {\n              iVar2 = compare_values_0800738a((int)(char)PTR_DAT_08000a48[param_1],PTR_DAT_08000a58);\n              if (iVar2 == 0) {\n                iVar2 = compare_values_0800738a((int)(char)PTR_DAT_08000a48[param_1],PTR_DAT_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        iVar2 = 0;\n      }\n      if (iVar2 != 0) {\n        set_byte_at_offset_08002fa8(PTR_DAT_08000a44,param_1,6);\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (param_1 < 0x3c) {\n        if (PTR_DAT_08000878[param_1] == -1) {\n          bVar4 = false;\n        }\n        else {\n          iVar2 = find_char_index_080036ac();\n          if (iVar2 == 0) {\n            bVar4 = false;\n          }\n          else {\n            iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08000878[param_1]);\n            if (iVar2 == 1) {\n              bVar4 = false;\n            }\n            else {\n              bVar4 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar4 = false;\n      }\n      if (bVar4) {\n        process_bit_08008990(param_1,2);\n        puVar1 = PTR_DAT_08000a44;\n        set_byte_at_offset_08002fa8(PTR_DAT_08000a44,param_1,0xb);\n        set_value_at_index_08002fc2(puVar1,param_1,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_08000488",
            "FUN_08000500",
            "FUN_08002fc2",
            "FUN_080036ac",
            "FUN_08002f14",
            "FUN_080026f8",
            "FUN_08002fa8",
            "FUN_0800738a",
            "FUN_080005e0",
            "FUN_08000588",
            "FUN_08002fa0",
            "FUN_08008a24",
            "FUN_080088e0",
            "FUN_08008990"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x080005f8",
        "calling": [
            "FUN_08001cd0",
            "FUN_08000a64",
            "FUN_08000aec"
        ],
        "current_name": "FUNC_080005f8"
    },
    "FUN_08009124": {
        "renaming": {
            "FUN_08009124": "process_data_08009124",
            "param_1": "data_size",
            "param_2": "data_offset",
            "param_3": "data_ptr",
            "param_4": "output_ptr",
            "uStack_8": "current_data_size",
            "uStack_4": "current_data_offset",
            "PTR_PTR_DAT_08009144": "PTR_PTR_DATA",
            "FUNC_0800937c": "process_helper"
        },
        "code": "void process_data_08009124(int data_size, int data_offset, int* data_ptr, int* output_ptr)\n{\n  int current_data_size = data_size;\n  int current_data_offset = data_offset;\n  int* current_data_ptr = data_ptr;\n  int* current_output_ptr = output_ptr;\n  process_helper(*(int*)PTR_PTR_DAT_08009144, data_size, data_offset, &current_data_size, data_ptr, &current_data_ptr);\n  return;\n}",
        "called": [
            "FUN_0800937c"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009124",
        "calling": [
            "FUN_080090cc"
        ],
        "current_name": "process_data_08009124"
    },
    "FUN_08002fa0": {
        "renaming": {
            "FUN_08002fa0": "get_value_at_offset_08002fa0",
            "param_1": "offset",
            "param_2": "address",
            "undefined": "unsigned char",
            "*(undefined *)": "unsigned char*",
            "value": "value_ptr"
        },
        "code": "unsigned char get_value_at_offset_08002fa0(int offset, int address)\n{\n  unsigned char* value_ptr = (unsigned char*)(address + offset + 0xcc);\n  return *value_ptr;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002fa0",
        "calling": [
            "FUN_080022f8",
            "FUN_080005f8",
            "FUN_08001cd0",
            "FUN_0800021a"
        ],
        "current_name": "get_value_at_offset_08002fa0"
    },
    "FUN_080064ae": {
        "renaming": {
            "FUN_080064ae": "do_nothing_080064ae"
        },
        "code": "void do_nothing_080064ae(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080064ae",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "do_nothing_080064ae"
    },
    "FUN_0800a424": {
        "renaming": {
            "FUN_0800a424": "do_nothing_0800a424"
        },
        "code": "void do_nothing_0800a424(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a424",
        "calling": [
            "FUN_08009148",
            "FUN_0800010c"
        ],
        "current_name": "do_nothing_0800a424"
    },
    "FUN_08003a1c": {
        "renaming": {
            "FUN_08003a1c": "get_value_from_pointer_08003a1c",
            "param_1": "pointer_offset"
        },
        "code": "undefined4 get_value_from_pointer_08003a1c(int pointer_offset)\n{\n  return *(undefined4 *)(pointer_offset + 0x28);\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003a1c",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "get_value_from_pointer_08003a1c"
    },
    "FUN_080064ac": {
        "renaming": {
            "FUN_080064ac": "do_nothing_080064ac"
        },
        "code": "void do_nothing_080064ac(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080064ac",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "do_nothing_080064ac"
    },
    "FUN_08005cb4": {
        "renaming": {
            "FUN_08005cb4": "execute_code_if_flag_set_08005cb4",
            "param_1": "flag_ptr",
            "DAT_08005ce8": "data",
            "**param_1": "flag_value",
            "(*param_1)[1]": "second_flag_value",
            "both_flags_set": "both_flags_set",
            "execute_code_at_address_080073c0": "execute_code_at_address",
            "(*param_1)[1] = 0xfffffffd": "(*flag_ptr)[1] = 0xfffffffd",
            "uint": "uint",
            "data_ptr": "data_ptr",
            "bool_value": "bool_value",
            "bool_ptr": "bool_ptr"
        },
        "code": "void execute_code_if_flag_set_08005cb4(uint **flag_ptr) {\n  uint flag_value = **flag_ptr;\n  uint second_flag_value = (*flag_ptr)[1];\n  bool both_flags_set = (flag_value & 2) && (second_flag_value & 2);\n  if (both_flags_set) {\n    execute_code_at_address_080073c0();\n    (*flag_ptr)[1] = 0xfffffffd;\n  }\n  uint* DAT_08005ce8_ptr = (uint*) (DAT_08005ce8 + 0x14);\n  *DAT_08005ce8_ptr = 0x20000;\n  bool bool_value = true;\n  char* bool_ptr = (char*) (flag_ptr + 0x11);\n  *bool_ptr = bool_value;\n}",
        "called": [
            "FUN_080073c0"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005cb4",
        "calling": [],
        "current_name": "execute_code_if_flag_set_08005cb4"
    },
    "FUN_08007744": {
        "renaming": {
            "FUN_08007744": "get_value_from_struct_08007744",
            "param_1": "struct_address",
            "PTR_": "ptr_to_",
            "DAT_": "data_"
        },
        "code": "undefined4 get_value_from_struct_08007744(int struct_address)\n{\n  int* PTR_value = *(int *)(struct_address + 4);\n  int offset_to_value = 0x24;\n  return *(undefined4 *)(PTR_value + offset_to_value);\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007744",
        "calling": [],
        "current_name": "get_value_from_struct_08007744"
    },
    "FUN_08006538": {
        "renaming": {
            "FUN_08006538": "calculate_new_value_for_ptr_08006538",
            "param_1": "param_ptr",
            "*param_1": "ptr",
            "param_1[3]": "value_1",
            "param_1[2]": "value_2",
            "param_1[4]": "value_3",
            "param_1[5]": "value_4",
            "param_1[6]": "value_5",
            "DAT_080066e0": "PTR_080066e0",
            "get_shifted_value_from_pointer_08005a28()": "value_12",
            "param_1[1]": "value_11",
            "PTR_080066e4": "DAT_080066e4",
            "ptr[4]": "ptr_value_1",
            "ptr[2]": "ptr_value_2"
        },
        "code": "void calculate_new_value_for_ptr_08006538(int *param_ptr) {\n  uint *ptr = (uint *) (*param_ptr);\n  uint value_1 = param_ptr[3];\n  uint value_2 = param_ptr[2] | param_ptr[4] | param_ptr[5];\n  ptr[4] = (ptr[4] & 0xfffffcff) | param_ptr[6];\n  if (*ptr != DAT_080066e0) {\n    uint uVar1 = PTR_080066e4;\n    uint value_3 = param_ptr[1];\n    uint value_4 = get_shifted_value_from_pointer_08005a28();\n    uint value_5 = param_ptr[1];\n    uint value_6 = get_shifted_value_from_pointer_08005a28();\n    uint value_7 = param_ptr[1];\n    uint value_8 = get_shifted_value_from_pointer_08005a28();\n    uint value_9 = param_ptr[1];\n    uint value_10 = get_shifted_value_from_pointer_08005a28();\n    uint value_11 = param_ptr[1];\n    uint value_12 = get_shifted_value_from_pointer_08005a28();\n    ptr[2] = ((uVar1 * ((value_4 * 0x19 / (value_5 << 2)) + (uVar1 * ((value_6 * 0x19 / (value_7 << 2)) >> 0x25) * -100) * 0x10 + 0x32) >> 0x20) << 0x17 >> 0x1c) + ((uVar1 * ((value_8 * 0x19 / (value_9 << 2)) + (uVar1 * ((value_10 * 0x19 / (value_11 << 2)) >> 0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf0) + (PTR_080066e4 * ((value_3 * 0x19 / (ptr[3] << 2))) >> 0x25) * 0x10;\n  } else {\n    uint uVar1 = PTR_080066e4;\n    uint value_3 = param_ptr[1];\n    uint value_4 = get_shifted_value_from_pointer_08005a48();\n    uint value_5 = param_ptr[1];\n    uint value_6 = get_shifted_value_from_pointer_08005a48();\n    uint value_7 = param_ptr[1];\n    uint value_8 = get_shifted_value_from_pointer_08005a48();\n    uint value_9 = param_ptr[1];\n    uint value_10 = get_shifted_value_from_pointer_08005a48();\n    uint value_11 = param_ptr[1];\n    uint value_12 = get_shifted_value_from_pointer_08005a48();\n    ptr[2] = ((uVar1 * ((value_4 * 0x19 / (value_5 << 2)) + (uVar1 * ((value_6 * 0x19 / (value_7 << 2)) >> 0x25) * -100) * 0x10 + 0x32) >> 0x20) << 0x17 >> 0x1c) + ((uVar1 * ((value_8 * 0x19 / (value_9 << 2)) + (uVar1 * ((value_10 * 0x19 / (value_11 << 2)) >> 0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf0) + (PTR_080066e4 * ((value_3 * 0x19 / (ptr[3] << 2))) >> 0x25) * 0x10;\n  }\n}",
        "called": [
            "FUN_08005a48",
            "FUN_08005a28"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006538",
        "calling": [
            "FUN_0800674e"
        ],
        "current_name": "calculate_new_value_for_ptr_08006538"
    },
    "FUN_080042e2": {
        "renaming": {
            "FUN_080042e2": "set_parameter_value_080042e2",
            "param_1": "struct_address",
            "param_2": "value",
            "param_3": "shift_left",
            "PTR_": "ptr_to_",
            "DAT_": "data_"
        },
        "code": "void set_parameter_value_080042e2(int struct_address, int value, bool shift_left)\n{\n  int* PTR_parameter = *(int *)(struct_address + 0x10);\n  if (shift_left) {\n    *(PTR_parameter) = value << 0x10;\n  } else {\n    *(PTR_parameter) = value;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080042e2",
        "calling": [
            "FUN_080072d8"
        ],
        "current_name": "set_parameter_value_080042e2"
    },
    "FUN_08002fa8": {
        "renaming": {
            "FUN_08002fa8": "set_byte_at_offset_08002fa8",
            "param_1": "struct_address",
            "param_2": "offset",
            "param_3": "value",
            "PTR_": "ptr_to_",
            "DAT_": "data_"
        },
        "code": "void set_byte_at_offset_08002fa8(int struct_address, int offset, uint8_t value)\n{\n  uint8_t* PTR_byte = *(uint8_t **)(struct_address + 0xcc + offset);\n  if (*PTR_byte != 0x7f) {\n    *PTR_byte = value;\n  }\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002fa8",
        "calling": [
            "FUN_080005f8"
        ],
        "current_name": "set_byte_at_offset_08002fa8"
    },
    "FUN_0800325a": {
        "renaming": {
            "FUN_0800325a": "process_data_0800325a",
            "param_1": "struct_address",
            "param_2": "data_type",
            "param_3": "data_size",
            "param_4": "data",
            "puVar1": "ptr_to_function",
            "uVar2": "i",
            "encode_data_0800307a": "encode_data"
        },
        "code": "void process_data_0800325a(uint8_t *struct_address, int offset, uint8_t data, uint data_size)\n{\n  uint8_t *ptr_to_data = *(uint8_t **)(struct_address + 0xcc + offset);\n  if (*ptr_to_data != 0x0) {\n    for (uint i = 0; i < data_size; i++) {\n      encode_data_0800307a(struct_address, 1, data + i, 0);\n    }\n  }\n}\n\nvoid process_data_0800325a(uint8_t *struct_address, uint8_t param_2, uint data_size, int param_4)\n{\n  uint8_t *ptr_to_function = *(uint8_t **)struct_address;\n  if (ptr_to_function != NULL) {\n    (**(void (**)(void *, uint8_t))(*ptr_to_function))((void *)ptr_to_function, 0xf0);\n    (***(void (***)(void *, uint8_t))(*(uint8_t **)struct_address))((void *)*(uint8_t **)struct_address, param_2);\n    for (uint i = 0; i < data_size; i++) {\n      process_data_0800325a(struct_address, i, param_4, 1);\n    }\n    (***(void (***)(void *, uint8_t))(*(uint8_t **)struct_address))((void *)*(uint8_t **)struct_address, 0xf7);\n  }\n}\n",
        "called": [
            "FUN_0800307a"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800325a",
        "calling": [
            "FUN_08002f0a",
            "FUN_080032a2"
        ],
        "current_name": "process_data_0800325a"
    },
    "FUN_080091d8": {
        "renaming": {
            "FUN_080091d8": "add_to_linked_list_080091d8",
            "param_1": "head",
            "param_2": "data",
            "param_3": "unused1",
            "param_4": "unused2",
            "puVar1": "ptr_to_head",
            "extraout_r1": "next",
            "ppiVar2": "prev",
            "piVar4": "prev_data",
            "ppiVar3": "next",
            "ppiVar5": "current",
            "ppiVar6": "ptr_to_node",
            "ppiVar7": "next_data"
        },
        "code": "void add_to_linked_list_080091d8(undefined4 *head, int data, undefined4 unused1, undefined4 unused2)\n{\n  int **current = (int **)(data - 4);\n  if (data == 0) {\n    return;\n  }\n  do_nothing_08009f48();\n  int **ptr_to_head = *(int ***)(PTR_DAT_0800926c);\n  if (ptr_to_head == NULL) {\n    current[1] = NULL;\n    *(int ***)PTR_DAT_0800926c = current;\n  }\n  else if (current < ptr_to_head) {\n    int **next = (int **)*current;\n    int **prev = (int **)((int)current + (int)next);\n    if (ptr_to_head == prev) {\n      int *prev_data = *ptr_to_head;\n      ptr_to_head = (int **)ptr_to_head[1];\n      prev = (int **)((int)prev_data + (int)next);\n      *current = prev;\n    }\n    current[1] = ptr_to_head;\n    *(int ***)PTR_DAT_0800926c = current;\n  }\n  else {\n    int **ptr_to_node = ptr_to_head;\n    while (ptr_to_node[1] != NULL && ptr_to_node[1] <= current) {\n      ptr_to_node = ptr_to_node[1];\n    }\n    int **next = (int **)ptr_to_node[1];\n    if ((int **)((int)ptr_to_node + (int)next) == current) {\n      next = (int **)((int)next + (int)*current);\n      *ptr_to_node = next;\n      if (ptr_to_node[1] == (int **)((int)ptr_to_node + (int)next)) {\n        int *next_data = *ptr_to_node[1];\n        next = (int **)ptr_to_node[1][1];\n        next = (int **)((int)next_data + (int)next);\n        *ptr_to_node[1] = next;\n        ptr_to_node[1][1] = (int *)next;\n      }\n    }\n    else if (current < (int **)((int)ptr_to_node + (int)next)) {\n      *head = 0xc;\n    }\n    else {\n      next = (int **)((int)current + (int)*current);\n      if (ptr_to_node[1] == next) {\n        int *next_data = ptr_to_node[1][1];\n        next = (int **)((int)next_data + (int)*current);\n        *current = next;\n      }\n      current[1] = ptr_to_node[1];\n      ptr_to_node[1] = current;\n    }\n  }\n  do_nothing_08009f4a(head, current, current[1], unused2);\n  return;\n}",
        "called": [
            "FUN_08009f4a",
            "FUN_08009f48"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080091d8",
        "calling": [
            "FUN_08009b5c",
            "FUN_08009a80",
            "FUN_08009908",
            "FUN_080091a0"
        ],
        "current_name": "add_to_linked_list_080091d8"
    },
    "FUN_0800688e": {
        "renaming": {
            "FUN_0800688e": "set_data_0800688e",
            "param_1": "data_struct",
            "param_2": "param_2",
            "param_3": "param_3",
            "flag": "flag",
            "*param_1": "*data_struct"
        },
        "code": "int set_data_0800688e(int *data_struct, int param_2, int param_3)\\n{\\n  char *flag = (char *)(data_struct + 0x39);\\n  if (*flag != ' ') {\\n    return 2;\\n  }\\n  if (param_2 == 0 || param_3 == 0) {\\n    return 1;\\n  }\\n  if (*(char *)(data_struct + 0xe) != '\\x01') {\\n    data_struct[8] = param_2;\\n    data_struct[9] = (short)param_3;\\n    data_struct[0xf] = 0;\\n    *(short *)((int)data_struct + 0x26) = (short)param_3;\\n    *flag = 0x21;\\n    *(char *)(data_struct + 0xe) = 0;\\n    *(uint *)(*data_struct + 0xc) |= 0x80;\\n    return 0;\\n  }\\n  return 2;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800688e",
        "calling": [
            "FUN_08008694",
            "FUN_08008730"
        ],
        "current_name": "set_data_0800688e"
    },
    "FUN_080088e0": {
        "renaming": {
            "FUN_080088e0": "process_bit_080088e0",
            "param_1": "bit_position",
            "param_2": "value",
            "iVar1": "result",
            "uVar2": "shift_amount",
            "iVar3": "index",
            "PTR_DAT_0800897c": "bit_index_array",
            "PTR_DAT_08008980": "comparison_value",
            "process_bit_08008990": "set_bit_at_index",
            "read_bit_at_position_08006b28": "read_bit_at_position",
            "set_bit_at_index_08006b3e": "set_bit_at_index",
            "PTR_DAT_08008984": "bit_array",
            "update_flags_and_registers_08007118": "update_flags_and_registers",
            "DAT_0800898c": "register_value"
        },
        "code": "void process_bit_080088e0(uint bit_position, uint value)\n{\n  int index = -1;\n  if (bit_position < 0x3c) {\n    index = (int)(char)PTR_DAT_0800897c[bit_position];\n  }\n  if (index != -1) {\n    int result = compare_values(index, PTR_DAT_08008980);\n    if (result == 0) {\n      process_bit_080088e0_08008990(bit_position, 1);\n      uint shift_amount = *(uint *)PTR_DAT_08008988;\n      if (shift_amount != 8) {\n        if (shift_amount < 9) {\n          value = value << (8 - shift_amount & 0xff);\n        }\n        else {\n          value = value >> (shift_amount - 8 & 0xff);\n        }\n      }\n      if (value < 0x80) {\n        set_bit_at_index_08006b3e(index, PTR_DAT_08008984, 0);\n      }\n      else {\n        set_bit_at_index_08006b3e(index, PTR_DAT_08008984, 1);\n      }\n    }\n    else {\n      int bit_value = read_bit_at_position_08006b28(index, PTR_DAT_08008984);\n      if (bit_value == 0) {\n        set_bit_at_index_08006b3e(index, PTR_DAT_08008984, 1);\n      }\n      uint shift_amount = *(uint *)PTR_DAT_08008988;\n      if (shift_amount != 8) {\n        if (shift_amount < 9) {\n          value = value << (8 - shift_amount & 0xff);\n        }\n        else {\n          value = value >> (shift_amount - 8 & 0xff);\n        }\n      }\n      update_flags_and_registers(index, DAT_0800898c, 0xff, value, bit_value == 0);\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_08006b28",
            "FUN_08007118",
            "FUN_08008a24",
            "FUN_08006b3e",
            "FUN_0800738a",
            "FUN_08008990"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080088e0",
        "calling": [
            "FUN_080005f8",
            "FUN_0800021a"
        ],
        "current_name": "process_bit_080088e0"
    },
    "FUN_08008b66": {
        "renaming": {
            "FUN_08008b66": "process_combination_and_update_08008b66",
            "param_1": "combination_ptr",
            "iVar1": "process_result",
            "uVar2": "new_index",
            "local_9": "local_byte"
        },
        "code": "void process_combination_and_update_08008b66(int combination_ptr)\n{\n  int process_result;\n  ushort new_index;\n  undefined local_byte;\n  \n  process_result = process_combination_08008600(combination_ptr,&local_byte);\n  if ((process_result == 0) &&\n     (new_index = *(ushort *)(combination_ptr + 0x60) + 1U & 0x3f, new_index != *(ushort *)(combination_ptr + 0x62))) {\n    *(undefined *)(*(int *)(combination_ptr + 0x5c) + (uint)*(ushort *)(combination_ptr + 0x60)) = local_byte;\n    *(ushort *)(combination_ptr + 0x60) = new_index;\n  }\n  return;\n}",
        "called": [
            "FUN_08008600"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008b66",
        "calling": [],
        "current_name": "process_combination_and_update_08008b66"
    },
    "FUN_0800870c": {
        "renaming": {
            "FUN_0800870c": "execute_operation_0800870c",
            "uVar1": "operation_index",
            "find_number_080086e8": "find_operation_index",
            "PTR_DAT_08008728": "operation_functions",
            "PTR_DAT_0800872c": "operation_params"
        },
        "code": "void execute_operation_0800870c(void)\n{\n  uint operation_index = find_number_080086e8();\n  if (operation_index < 5) {\n    PTR_DAT_08008728[operation_index](PTR_DAT_0800872c[operation_index]);\n  }\n  return;\n}",
        "called": [
            "FUN_080086e8"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800870c",
        "calling": [
            "FUN_0800694c"
        ],
        "current_name": "execute_operation_0800870c"
    },
    "FUN_08008840": {
        "renaming": {
            "FUN_08008840": "get_error_code_08008840",
            "undefined4": "uint32_t"
        },
        "code": "uint32_t get_error_code_08008840(void)\\n{\\n  uint32_t error_code = 0xffffffff;\\n  return error_code;\\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008840",
        "calling": [],
        "current_name": "get_error_code_08008840"
    },
    "FUN_08008600": {
        "renaming": {
            "FUN_08008600": "process_combination_08008600",
            "param_1": "combination_index",
            "param_2": "output",
            "param_3": "param_3",
            "param_4": "param_4",
            "iVar1": "is_valid_combination",
            "check_combination_080085b8()": "check_combination()",
            "*param_2": "*output",
            "PTR_DAT_08008638": "PTR_DAT_08008638",
            "*(undefined *)(param_1 + 0x45)": "*(undefined *)(combination_index + 0x45)",
            "set_params_080068d6()": "set_params()",
            "*(undefined4 *)(PTR_DAT_08008638 + (uint)*(byte *)(param_1 + 0x44) * 4)": "*(undefined4 *)(PTR_DAT_08008638 + (uint)*(byte *)(combination_index + 0x44) * 4)",
            "param_1 + 0x45": "combination_index + 0x45",
            "0xffffffff": "0",
            "return 0xffffffff;": "return 0;",
            "return 0xffffffff;\\n  }": "return 0;\\n  }"
        },
        "code": "undefined4 process_combination_08008600(int combination_index, undefined* output, undefined4 param_3, undefined4 param_4) {\n  if (combination_index == 0) {\n    return 0xffffffff;\n  }\n  int is_valid_combination = check_combination(combination_index);\n  if (is_valid_combination == 0) {\n    *output = *(undefined *)(combination_index + 0x45);\n    set_params(*(undefined4 *)(PTR_DAT_08008638 + (uint)*(byte *)(param_1 + 0x44) * 4), combination_index + 0x45, 1, PTR_DAT_08008638, param_4);\n    return 0;\n  }\n  return 0xffffffff;\n}",
        "called": [
            "FUN_080085b8",
            "FUN_080068d6"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008600",
        "calling": [
            "FUN_08008b66"
        ],
        "current_name": "process_combination_08008600"
    },
    "FUN_08003154": {
        "renaming": {
            "FUN_08003154": "copy_value_to_pointer_08003154",
            "param_1": "destination",
            "param_2": "value"
        },
        "code": "void copy_value_to_pointer_08003154(uint32_t *destination, uint32_t value)\n{\n  *destination = value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003154",
        "calling": [
            "FUN_08002e26"
        ],
        "current_name": "copy_value_to_pointer_08003154"
    },
    "FUN_08006420": {
        "renaming": {
            "FUN_08006420": "set_bit_in_uint_at_index_08006420",
            "param_1": "data",
            "param_2": "index",
            "param_3": "bit_value"
        },
        "code": "void set_bit_in_uint_at_index_08006420(uint32_t* data, uint8_t index, uint8_t bit_value)\n{\n  uint32_t bit_mask = 1u << index;\n  *data &= ~bit_mask;\n  *data |= bit_value << index;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08006420",
        "calling": [
            "FUN_0800643c",
            "FUN_08006460"
        ],
        "current_name": "set_bit_in_uint_at_index_08006420"
    },
    "FUN_08007750": {
        "renaming": {
            "FUN_08007750": "set_value_in_array_at_index_08007750",
            "param_1": "array",
            "param_2": "index",
            "param_3": "value",
            "PTR_": "ptr_",
            "DAT_": "dat_"
        },
        "code": "void set_value_in_array_at_index_08007750(int* array, int index, int value)\n{\n  int* array_ptr = *(int**)(array + 4);\n  int* element_ptr = array_ptr + 0x34 + index * 4;\n  *element_ptr = value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007750",
        "calling": [],
        "current_name": "set_value_in_array_at_index_08007750"
    },
    "FUN_08009938": {
        "renaming": {
            "FUN_08009938": "find_character_in_string_08009938",
            "param_1": "str",
            "param_2": "ch",
            "pcVar1": "curr_char_ptr"
        },
        "code": "char* find_character_in_string_08009938(char* str, char ch)\n{\n  char* curr_char_ptr = str;\n  while(*curr_char_ptr != '\\0')\n  {\n    if(*curr_char_ptr == ch)\n    {\n      return curr_char_ptr;\n    }\n    curr_char_ptr++;\n  }\n  if(ch == '\\0')\n  {\n    return curr_char_ptr;\n  }\n  return (char*)0x0;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08009938",
        "calling": [
            "FUN_0800997e"
        ],
        "current_name": "find_character_in_string_08009938"
    },
    "FUN_08007f0e": {
        "renaming": {
            "FUN_08007f0e": "check_message_08007f0e",
            "param_1": "message_offset",
            "param_2": "message_length",
            "param_3": "message_id",
            "param_4": "message_flags",
            "iVar1": "pointer_start",
            "get_pointer_value_08003760()": "get_pointer_value()",
            "uVar3": "offset_diff",
            "iVar4": "result",
            "iVar2": "send_result",
            "iVar5": "message_address",
            "send_message_080047f4()": "send_message()",
            "get_character_at_offset_0800542a()": "get_character_at_offset()",
            "character_value": "character_value",
            "get_value_from_offset_08005430()": "get_value_from_offset()",
            "value_at_offset": "value_at_offset",
            "0x20": "0x20",
            "0x65": "0x65",
            "return iVar4;": "return result;"
        },
        "code": "int check_message_08007f0e(int message_offset, undefined4 message_length, undefined4 message_id, undefined4 message_flags) {\n  int pointer_start = get_pointer_value();\n  uint offset_diff = 0;\n  int result = 2;\n  do {\n    int message_address = message_offset + 4;\n    int send_result = send_message(message_address, message_length, message_id, message_flags, message_flags);\n    if (send_result == 0) {\n      result = 0;\n      int character_value = 0;\n      while ((character_value = get_character_at_offset(message_address), character_value != 0x20 && (result == 0))) {\n        int pointer_end = get_pointer_value();\n        offset_diff = pointer_end - pointer_start;\n        if (offset_diff < 0x65) {\n          int value_at_offset = get_value_from_offset(message_address);\n          if (value_at_offset != 0) {\n            result = 2;\n          }\n        }\n        else {\n          result = 1;\n        }\n      }\n    }\n    int value_at_offset = get_value_from_offset(message_address);\n  } while ((value_at_offset == 4) && (offset_diff < 100));\n  return result;\n}",
        "called": [
            "FUN_080047f4",
            "FUN_08003760",
            "FUN_0800542a",
            "FUN_08005430"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08007f0e",
        "calling": [
            "FUN_08002b68"
        ],
        "current_name": "check_message_08007f0e"
    },
    "FUN_08004004": {
        "renaming": {
            "FUN_08004004": "set_bit_in_array_08004004",
            "param_1": "bit_index",
            "DAT_08004020": "array_start_address",
            "PTR_08004024": "array_end_address",
            "PTR_08004028": "array_size",
            "PTR_0800402c": "array_element_size"
        },
        "code": "void set_bit_in_array_08004004(uint bit_index)\n{\n  if (-1 < (int)bit_index) {\n    uint array_index = (bit_index >> 5) + 0x60;\n    uint* array_ptr = (uint*)(DAT_08004020 + array_index * 4);\n    uint bit_position = bit_index & 0x1f;\n    uint bit_value = 1 << bit_position;\n    *array_ptr = bit_value;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08004004",
        "calling": [],
        "current_name": "set_bit_in_array_08004004"
    },
    "FUN_08003158": {
        "renaming": {
            "FUN_08003158": "send_encoded_data_if_possible_08003158",
            "param_1": "message_buffer",
            "param_2": "message_length",
            "param_3": "message_flags",
            "puVar1": "message_address",
            "local_a": "encoded_data",
            "0x0": "0x0",
            "0x10": "0x10",
            "0x4000": "0x4000",
            "encode_data_0800307a()": "encode_data()",
            "encode_and_send_data_08003106()": "encode_and_send_data()"
        },
        "code": "void send_encoded_data_if_possible_08003158(undefined4 *message_buffer, uint message_length, ushort message_flags) {\n  undefined4 *message_address = (undefined4 *)*message_buffer;\n  if (message_address != (undefined4 *)0x0) {\n    ushort encoded_data = message_flags;\n    if (((int)message_length < 0x10) && (message_flags < 0x4000)) {\n      (**(code **)*message_address)(message_address, message_length | 0xe0);\n      encode_data(message_buffer, 2, &encoded_data);\n    }\n    else {\n      encode_and_send_data(message_buffer, message_length, 2, &encoded_data);\n    }\n  }\n  return;\n}",
        "called": [
            "FUN_0800307a",
            "FUN_08003106"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08003158",
        "calling": [
            "FUN_08002ef2"
        ],
        "current_name": "send_encoded_data_if_possible_08003158"
    },
    "FUN_080090c2": {
        "renaming": {
            "FUN_080090c2": "combine_values_080090c2",
            "param_1": "value1",
            "param_2": "value2",
            "combine_values_08009108": "combine_values_08009108"
        },
        "code": "void combine_values_080090c2(void* value1, void* value2) {\n  combine_values_080090c2_08009108(value2, value1);\n  return;\n}",
        "called": [
            "FUN_08009108"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080090c2",
        "calling": [
            "FUN_08008f78"
        ],
        "current_name": "combine_values_080090c2"
    },
    "FUN_08000ef8": {
        "renaming": {
            "FUN_08000ef8": "FUNC_08000ef8"
        },
        "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  bool bVar3;\n  byte bVar4;\n  \n  if (*PTR_DAT_08001188 != '\\0') {\n    bVar1 = *PTR_DAT_0800118c;\n    if (*PTR_DAT_08001190 == -1) {\n      bVar4 = 0;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar4 = 0;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)*PTR_DAT_08001190);\n        if (iVar2 == 1) {\n          bVar4 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar4 = 0;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0);\n          if (iVar2 == 0) {\n            bVar4 = 0;\n          }\n          else {\n            bVar4 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_DAT_08001190[1] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[1]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(1);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 2;\n    }\n    if (PTR_DAT_08001190[2] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[2]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(2);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 4;\n    }\n    if (PTR_DAT_08001190[3] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[3]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(3);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 8;\n    }\n    if (PTR_DAT_08001190[4] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[4]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(4);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x10;\n    }\n    if (PTR_DAT_08001190[5] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[5]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(5);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x20;\n    }\n    if (PTR_DAT_08001190[6] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[6]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(6);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x40;\n    }\n    if (PTR_DAT_08001190[7] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001190[7]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(7);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x80;\n    }\n    execute_function_08000be8(0,bVar4);\n  }\n  if (PTR_DAT_08001188[1] != '\\0') {\n    bVar1 = PTR_DAT_0800118c[1];\n    if (PTR_DAT_08001190[8] == -1) {\n      bVar4 = 0;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar4 = 0;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[8]);\n        if (iVar2 == 1) {\n          bVar4 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar4 = 0;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(8);\n          if (iVar2 == 0) {\n            bVar4 = 0;\n          }\n          else {\n            bVar4 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_DAT_08001424[9] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[9]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(9);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 2;\n    }\n    if (PTR_DAT_08001424[10] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[10]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(10);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 4;\n    }\n    if (PTR_DAT_08001424[0xb] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0xb]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0xb);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 8;\n    }\n    if (PTR_DAT_08001424[0xc] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0xc]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0xc);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x10;\n    }\n    if (PTR_DAT_08001424[0xd] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0xd]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0xd);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x20;\n    }\n    if (PTR_DAT_08001424[0xe] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0xe]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0xe);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x40;\n    }\n    if (PTR_DAT_08001424[0xf] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0xf]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0xf);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x80;\n    }\n    execute_function_08000be8(1,bVar4,0);\n  }\n  if (PTR_DAT_08001428[2] != '\\0') {\n    bVar1 = PTR_DAT_0800142c[2];\n    if (PTR_DAT_08001424[0x10] == -1) {\n      bVar4 = 0;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar4 = 0;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001424[0x10]);\n        if (iVar2 == 1) {\n          bVar4 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar4 = 0;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x10);\n          if (iVar2 == 0) {\n            bVar4 = 0;\n          }\n          else {\n            bVar4 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_DAT_080016c4[0x11] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x11]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x11);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 2;\n    }\n    if (PTR_DAT_080016c4[0x12] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x12]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x12);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 4;\n    }\n    if (PTR_DAT_080016c4[0x13] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x13]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x13);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 8;\n    }\n    if (PTR_DAT_080016c4[0x14] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x14]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x14);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x10;\n    }\n    if (PTR_DAT_080016c4[0x15] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x15]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x15);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x20;\n    }\n    if (PTR_DAT_080016c4[0x16] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x16]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x16);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x40;\n    }\n    if (PTR_DAT_080016c4[0x17] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x17]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x17);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x80;\n    }\n    execute_function_08000be8(2,bVar4,0);\n  }\n  if (PTR_DAT_080016c8[3] != '\\0') {\n    bVar1 = PTR_DAT_080016cc[3];\n    if (PTR_DAT_080016c4[0x18] == -1) {\n      bVar4 = 0;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar4 = 0;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_080016c4[0x18]);\n        if (iVar2 == 1) {\n          bVar4 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar4 = 0;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x18);\n          if (iVar2 == 0) {\n            bVar4 = 0;\n          }\n          else {\n            bVar4 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_DAT_080016c4[0x19] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x19]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x19);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 2;\n    }\n    if (PTR_DAT_08001960[0x1a] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1a]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1a);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 4;\n    }\n    if (PTR_DAT_08001960[0x1b] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1b]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1b);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 8;\n    }\n    if (PTR_DAT_08001960[0x1c] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1c]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1c);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x10;\n    }\n    if (PTR_DAT_08001960[0x1d] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1d]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1d);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x20;\n    }\n    if (PTR_DAT_08001960[0x1e] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1e]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1e);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x40;\n    }\n    if (PTR_DAT_08001960[0x1f] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x1f]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x1f);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x80;\n    }\n    execute_function_08000be8(3,bVar4,0);\n  }\n  if (PTR_DAT_08001964[4] != '\\0') {\n    bVar1 = PTR_DAT_08001968[4];\n    if (PTR_DAT_08001960[0x20] == -1) {\n      bVar4 = 0;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar4 = 0;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x20]);\n        if (iVar2 == 1) {\n          bVar4 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar4 = 0;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x20);\n          if (iVar2 == 0) {\n            bVar4 = 0;\n          }\n          else {\n            bVar4 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_DAT_08001960[0x21] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001960[0x21]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x21);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 2;\n    }\n    if (PTR_DAT_08001b44[0x22] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x22]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x22);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 4;\n    }\n    if (PTR_DAT_08001b44[0x23] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x23]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x23);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 8;\n    }\n    if (PTR_DAT_08001b44[0x24] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x24]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x24);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x10;\n    }\n    if (PTR_DAT_08001b44[0x25] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x25]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x25);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x20;\n    }\n    if (PTR_DAT_08001b44[0x26] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x26]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x26);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x40;\n    }\n    if (PTR_DAT_08001b44[0x27] == -1) {\n      bVar3 = false;\n    }\n    else {\n      iVar2 = find_char_index_080036ac();\n      if (iVar2 == 0) {\n        bVar3 = false;\n      }\n      else {\n        iVar2 = find_char_index_080036ac((int)(char)PTR_DAT_08001b44[0x27]);\n        if (iVar2 == 1) {\n          bVar3 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar3 = false;\n        }\n        else {\n          iVar2 = check_bit_and_return_if_set_08008a6c(0x27);\n          if (iVar2 == 0) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    if (bVar3) {\n      bVar4 = bVar4 | 0x80;\n    }\n    execute_function_08000be8(4,bVar4,0);\n  }\n  return;\n}\n\n",
        "called": [
            "FUN_080036ac",
            "FUN_08000be8",
            "FUN_08008a6c"
        ],
        "skipped": true,
        "improved": false,
        "entrypoint": "0x08000ef8",
        "calling": [
            "FUN_080022f8"
        ],
        "current_name": "FUNC_08000ef8"
    },
    "FUN_08008846": {
        "renaming": {
            "FUN_08008846": "set_memory_permissions_08008846",
            "param_1": "process_id",
            "param_2": "memory_address"
        },
        "code": "void set_memory_permissions_08008846(int process_id, int memory_address)\n{\n  int permissions = 0x2000;\n  int* process_handle_ptr = (int*)memory_address;\n  *process_handle_ptr = permissions;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08008846",
        "calling": [
            "FUN_0800a0ec"
        ],
        "current_name": "set_memory_permissions_08008846"
    },
    "FUN_0800a430": {
        "renaming": {
            "FUN_0800a430": "print_hello_world_0800a430"
        },
        "code": "void print_hello_world_0800a430(void)\n{\n  printf(\"Hello World!\\n\");\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800a430",
        "calling": [],
        "current_name": "print_hello_world_0800a430"
    },
    "FUN_0800459c": {
        "renaming": {
            "FUN_0800459c": "process_data_0800459c",
            "param_1": "data",
            "puVar1": "buffer",
            "PTR_0800a430": "counter"
        },
        "code": "void process_data_0800459c(int *data)\n{\n  short *PTR_0800a430 = (short *)((int)data + 0x2a);\n  if (*PTR_0800a430 != 0) {\n    char *buffer = (char *)data[9];\n    data[9] = (int)(buffer + 1);\n    *buffer = (char)*(int *)(*data + 0x10);\n    *PTR_0800a430 = *PTR_0800a430 - 1;\n  }\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800459c",
        "calling": [
            "FUN_08005188"
        ],
        "current_name": "process_data_0800459c"
    },
    "FUN_0800774a": {
        "renaming": {
            "FUN_0800774a": "set_param_value_0800774a",
            "param_1": "param_struct",
            "param_2": "new_value",
            "PTR_0800a430": "param_data",
            "DAT_0804a024": "9"
        },
        "code": "void set_param_value_0800774a(int *param_struct, int new_value)\n{\n  int *PTR_0800a430 = (int *)param_struct[1];\n  PTR_0800a430[DAT_0804a024] = new_value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800774a",
        "calling": [],
        "current_name": "set_param_value_0800774a"
    },
    "FUN_080042f0": {
        "renaming": {
            "FUN_080042f0": "update_and_execute_if_bit_set_080042f0",
            "param_1": "bit_mask",
            "DAT_08004308": "data_ptr"
        },
        "code": "void update_and_execute_if_bit_set_080042f0(uint bit_mask) {\\n  uint* DAT_08004308 = (uint*)(DAT_08004308 + 0x14);\\n  if ((*DAT_08004308 & bit_mask) != 0) {\\n    *DAT_08004308 = bit_mask;\\n    execute_if_bit_set_08009094();\\n  }\\n  return;\\n}",
        "called": [
            "FUN_08009094"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080042f0",
        "calling": [],
        "current_name": "update_and_execute_if_bit_set_080042f0"
    },
    "FUN_080027f0": {
        "renaming": {
            "FUN_080027f0": "copy_data_to_buffer_080027f0",
            "param_1": "buffer_address",
            "param_2": "data",
            "param_3": "data_size",
            "puVar2": "buffer_pointer",
            "iVar3": "result",
            "uVar4": "buffer_size",
            "uVar5": "buffer_used_size",
            "cVar1": "buffer_status"
        },
        "code": "uint copy_data_to_buffer_080027f0(int buffer_address, undefined4 data, uint data_size)\n{\n  char buffer_status;\n  undefined *buffer_pointer;\n  int result;\n  char buffer_used_size;\n  char buffer_size;\n  \n  buffer_pointer = PTR_DATA_BUFFER_POINTER;\n  buffer_status = *PTR_DATA_BUFFER_STATUS;\n  if (buffer_status == 0) {\n    result = copy_data_to_buffer_080027f0(buffer_address + 0x14, &data, data_size & 0xffff);\n    if (result != 0) {\n      return data_size;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    buffer_size = (char)*PTR_DATA_BUFFER_SIZE + 1;\n    buffer_used_size = (char)*PTR_DATA_BUFFER_USED_SIZE;\n    if (buffer_used_size < buffer_size + data_size) {\n      if (buffer_size + data_size < 0x20) {\n        buffer_size = 0x20;\n      }\n      else {\n        buffer_size = buffer_size + data_size;\n      }\n      result = allocate_and_copy_data(PTR_DATA_BUFFER_ADDRESS, buffer_size);\n      *PTR_DATA_BUFFER_POINTER = result;\n      if (result == 0) {\n        return 0;\n      }\n      else {\n        *PTR_DATA_BUFFER_USED_SIZE = buffer_size;\n      }\n    }\n    buffer_pointer = PTR_DATA_BUFFER_POINTER_2;\n    if (*PTR_DATA_BUFFER_ADDRESS == 0) {\n      *(undefined4 *)(buffer_address + 4) = 1;\n      return 0;\n    }\n    else {\n      copy_data_to_buffer_080027f0((uint)buffer_pointer + *(int *)PTR_DATA_BUFFER_ADDRESS, &data, data_size);\n      buffer_used_size = buffer_used_size + (char)data_size;\n      *buffer_pointer = buffer_used_size;\n      *PTR_DATA_BUFFER_USED_SIZE = buffer_used_size;\n      return data_size;\n    }\n  }\n}",
        "called": [
            "FUN_080091b0",
            "FUN_08009908",
            "FUN_08007ede"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080027f0",
        "calling": [],
        "current_name": "copy_data_to_buffer_080027f0"
    },
    "FUN_0800314e": {
        "renaming": {
            "FUN_0800314e": "set_param_value_0800314e",
            "param_1": "new_value"
        },
        "code": "void set_param_value_0800314e(undefined4 *param_struct, undefined4 new_value)\n{\n  *param_struct = new_value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x0800314e",
        "calling": [
            "FUN_08002ce0"
        ],
        "current_name": "set_param_value_0800314e"
    },
    "FUN_080076e0": {
        "renaming": {
            "FUN_080076e0": "update_timer_status_080076e0",
            "param_1": "timer_data",
            "cVar1": "timer_type",
            "determine_timer_type_08007544": "determine_timer_type",
            "set_bit_in_array_08003fb0": "set_bit_in_timer_array",
            "iVar2": "flags_updated",
            "set_flags_and_clear_flag_if_appropriate_08005df4": "update_flags_and_clear_flag_if_appropriate",
            "set_bits_and_clear_flags_080062f4": "set_bits_and_clear_flags"
        },
        "code": "void update_timer_status_080076e0(undefined4 *timer_data)\n{\n  char timer_type = determine_timer_type(*timer_data);\n  set_bit_in_array_08003fb0((int)timer_type);\n  int flags_updated = set_flags_and_clear_flag_if_appropriate_08005df4(timer_data + 1);\n  if (flags_updated == 0) {\n    set_bits_and_clear_flags_080062f4(timer_data + 1, 0);\n  }\n  return;\n}",
        "called": [
            "FUN_080062f4",
            "FUN_08005df4",
            "FUN_08003fb0",
            "FUN_08007544"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080076e0",
        "calling": [
            "FUN_08002578"
        ],
        "current_name": "update_timer_status_080076e0"
    },
    "FUN_08002f14": {
        "renaming": {
            "FUN_08002f14": "process_data_and_return_result_08002f14",
            "param_1": "data",
            "process_string_data_if_not_empty_080032a2": "process_string_data_if_not_empty_080032a2"
        },
        "code": "void process_data_and_return_result_08002f14(void* data) {\\n  void* string_data = data + 0x40;\\n  process_string_data_if_not_empty_080032a2(string_data);\\n  return;\\n}",
        "called": [
            "FUN_080032a2"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08002f14",
        "calling": [
            "FUN_08000500",
            "FUN_080005f8",
            "FUN_08001cd0",
            "FUN_08001c18"
        ],
        "current_name": "process_data_and_return_result_08002f14"
    },
    "FUN_080036a2": {
        "renaming": {
            "FUN_080036a2": "initialize_device_and_validate_input_080036a2"
        },
        "code": "void initialize_device_and_validate_input_080036a2()\n{\n  validate_input();\n  return;\n}",
        "called": [
            "FUN_080072fa"
        ],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080036a2",
        "calling": [
            "FUN_08008f0e"
        ],
        "current_name": "initialize_device_and_validate_input_080036a2"
    },
    "FUN_080038e4": {
        "renaming": {
            "FUN_080038e4": "set_param_value_080038e4",
            "param_1": "param_struct",
            "param_2": "param_value",
            "uVar1": "return_value",
            "uVar2": "shift_amount",
            "iVar3": "struct_ptr",
            "local_c": "loop_counter"
        },
        "code": "void set_param_value_080038e4(int *param_struct, uint new_value)\n{\n  *param_struct = new_value;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x080038e4",
        "calling": [
            "FUN_08006d80"
        ],
        "current_name": "set_param_value_080038e4"
    },
    "FUN_08005e68": {
        "renaming": {
            "FUN_08005e68": "do_nothing_08005e68"
        },
        "code": "void do_nothing_08005e68(void)\n{\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005e68",
        "calling": [
            "FUN_08005e6e"
        ],
        "current_name": "do_nothing_08005e68"
    },
    "FUN_08005d48": {
        "renaming": {
            "FUN_08005d48": "clear_bit_08005d48",
            "param_1": "base_address",
            "param_2": "data",
            "uVar1": "mask1",
            "uVar2": "reg2",
            "uVar3": "reg3",
            "DAT_08005da8": "MASK",
            "mask1": "mask1",
            "mask2": "mask2",
            "mask3": "mask3",
            "mask4": "mask4",
            "reg1": "reg1",
            "reg2": "reg2",
            "reg3": "reg3",
            "reg4": "reg4",
            "reg5": "reg5"
        },
        "code": "void clear_bit_08005d48(uint32_t base_address, uint32_t *data)\n{\n  uint32_t mask1 = 0xfffffeff;\n  uint32_t mask2 = 0xfffffdff;\n  uint32_t mask3 = 0xfffff7ff;\n  uint32_t mask4 = 0xfffffbff;\n  uint32_t reg1 = *(uint32_t *)(base_address + 0x20);\n  uint32_t reg2 = *(uint32_t *)(base_address + 4);\n  uint32_t reg3 = *data;\n  uint32_t reg4 = param_2[1];\n  uint32_t reg5 = param_2[2] << 8;\n  if (base_address == DAT_08005da8) {\n    reg5 = (reg5 & mask3 | param_2[3] << 8) & mask4;\n    reg2 = reg2 & 0xffffcfff | param_2[5] << 4 | param_2[6] << 4;\n  }\n  *(uint32_t *)(base_address + 4) = reg2;\n  *(uint32_t *)(base_address + 0x1c) = *(uint32_t *)(base_address + 0x1c) & 0xffffff8c | reg3;\n  *(uint32_t *)(base_address + 0x3c) = reg4;\n  *(uint32_t *)(base_address + 0x20) = reg1 & mask1 | reg5;\n  return;\n}",
        "called": [],
        "skipped": false,
        "improved": true,
        "entrypoint": "0x08005d48",
        "calling": [
            "FUN_08006186",
            "FUN_08006128"
        ],
        "current_name": "clear_bit_08005d48"
    }
}