ida_hexrays (module)
    array used for translating cexpr_t->op type to their names. 

ida_hexrays.ACFL_BLKOPT (variable)
    perform interblock transformations

ida_hexrays.ACFL_GLBDEL (variable)
    perform dead code eliminition

ida_hexrays.ACFL_GLBPROP (variable)
    perform global propagation

ida_hexrays.ACFL_GUESS (variable)
    may guess calling conventions

ida_hexrays.ACFL_LOCOPT (variable)
    perform local propagation (requires ACFL_BLKOPT)

ida_hexrays.ALLOW_UNUSED_LABELS (variable)
    Unused labels are permitted.

ida_hexrays.ANCHOR_BLKCMT (variable)
    block comment (for ctree items)

ida_hexrays.ANCHOR_CITEM (variable)
    c-tree item

ida_hexrays.ANCHOR_ITP (variable)
    item type preciser

ida_hexrays.ANCHOR_LVAR (variable)
    declaration of local variable

ida_hexrays.ANY_FPSIZE (variable)
    any size of floating operand is permitted

ida_hexrays.ANY_REGSIZE (variable)
    any register size is permitted

ida_hexrays.BLT_0WAY (variable)
    does not have successors (tail is a noret function)

ida_hexrays.BLT_1WAY (variable)
    passes execution to one block (regular or goto block)

ida_hexrays.BLT_2WAY (variable)
    passes execution to two blocks (conditional jump)

ida_hexrays.BLT_NONE (variable)
    unknown block type

ida_hexrays.BLT_NWAY (variable)
    passes execution to many blocks (switch idiom)

ida_hexrays.BLT_STOP (variable)
    stops execution regularly (must be the last block)

ida_hexrays.BLT_XTRN (variable)
    external block (out of function address)

ida_hexrays.CALC_CURLY_BRACES (variable)
    print curly braces if necessary

ida_hexrays.CFL_FINAL (variable)
    call type is final, should not be changed

ida_hexrays.CFL_HELPER (variable)
    created from a decompiler helper function

ida_hexrays.CFL_NORET (variable)
    call does not return

ida_hexrays.CFS_BOUNDS (variable)
    'eamap' and 'boundaries' are ready

ida_hexrays.CFS_LOCKED (variable)
    cfunc is temporarily locked

ida_hexrays.CFS_LVARS_HIDDEN (variable)
    local variable definitions are collapsed

ida_hexrays.CFS_TEXT (variable)
    'sv' is ready (and hdrlines)

ida_hexrays.CHF_FAKE (variable)
    fake chain created by widen_chains()

ida_hexrays.CHF_INITED (variable)
    is chain initialized? (valid only after lvar allocation)

ida_hexrays.CHF_OVER (variable)
    overlapped chain

ida_hexrays.CHF_PASSTHRU (variable)
    pass-thru chain, must use the input variable to the block

ida_hexrays.CHF_REPLACED (variable)
    chain operands have been replaced?

ida_hexrays.CHF_TERM (variable)
    terminating chain; the variable does not survive across the block

ida_hexrays.CIT_COLLAPSED (variable)
    display ctree item in collapsed form

ida_hexrays.CMAT_BUILT (variable)
    just generated

ida_hexrays.CMAT_CASTED (variable)
    added necessary casts

ida_hexrays.CMAT_CPA (variable)
    corrected pointer arithmetic

ida_hexrays.CMAT_FINAL (variable)
    ready-to-use

ida_hexrays.CMAT_NICE (variable)
    nicefied expressions

ida_hexrays.CMAT_TRANS1 (variable)
    applied first wave of transformations

ida_hexrays.CMAT_TRANS2 (variable)
    applied second wave of transformations

ida_hexrays.CMAT_TRANS3 (variable)
    applied third wave of transformations

ida_hexrays.CMAT_ZERO (variable)
    does not exist

ida_hexrays.CMT_ALL (variable)
    All comments.

ida_hexrays.CMT_BLOCK1 (variable)
    Anterioir block comment.

ida_hexrays.CMT_BLOCK2 (variable)
    Posterior block comment.

ida_hexrays.CMT_FUNC (variable)
    Function comment.

ida_hexrays.CMT_LVAR (variable)
    Local variable comment.

ida_hexrays.CMT_NONE (variable)
    No comment is possible.

ida_hexrays.CMT_TAIL (variable)
    Indented comment.

ida_hexrays.CPBLK_FAST (variable)
    do not update minbstkref and minbargref

ida_hexrays.CPBLK_MINREF (variable)
    update minbstkref and minbargref

ida_hexrays.CPBLK_OPTJMP (variable)
    del the jump insn at the end of the block if it becomes useless

ida_hexrays.CV_FAST (variable)
    do not maintain parent information

ida_hexrays.CV_INSNS (variable)
    visit only statements, prune all expressions do not use before the final ctree
    maturity because expressions may contain statements at intermediate stages (see
    cot_insn). Otherwise you risk missing statements embedded into expressions.

ida_hexrays.CV_PARENTS (variable)
    maintain parent information

ida_hexrays.CV_POST (variable)
    call the leave...() functions

ida_hexrays.CV_PRUNE (variable)
    this bit is set by visit...() to prune the walk

ida_hexrays.CV_RESTART (variable)
    restart enumeration at the top expr (apply_to_exprs)

ida_hexrays.DECOMP_ALL_BLKS (variable)
    generate microcode for unreachable blocks

ida_hexrays.DECOMP_GXREFS_DEFLT (variable)
    the default behavior: do not update the global xrefs cache upon decompile()
    call, but when the pseudocode text is generated (e.g., through
    cfunc_t.get_pseudocode())

ida_hexrays.DECOMP_GXREFS_FORCE (variable)
    update the global xrefs cache immediately

ida_hexrays.DECOMP_GXREFS_NOUPD (variable)
    do not update the global xrefs cache

ida_hexrays.DECOMP_NO_CACHE (variable)
    do not use decompilation cache (snippets are never cached)

ida_hexrays.DECOMP_NO_FRAME (variable)
    do not use function frame info (only snippet mode)

ida_hexrays.DECOMP_NO_HIDE (variable)
    do not close display waitbox. see close_hexrays_waitboxes()

ida_hexrays.DECOMP_NO_WAIT (variable)
    do not display waitbox

ida_hexrays.DECOMP_NO_XREFS (variable)
    Obsolete. Use DECOMP_GXREFS_NOUPD.

ida_hexrays.DECOMP_VOID_MBA (variable)
    return empty mba object (to be used with gen_microcode)

ida_hexrays.DECOMP_WARNINGS (variable)
    display warnings in the output window

ida_hexrays.DecompilationFailure (class)

ida_hexrays.EQ_CMPDEST (variable)
    compare instruction destinations

ida_hexrays.EQ_IGNCODE (variable)
    ignore instruction opcodes

ida_hexrays.EQ_IGNSIZE (variable)
    ignore source operand sizes

ida_hexrays.EQ_OPTINSN (variable)
    optimize mop_d operands

ida_hexrays.EXFL_ALL (variable)
    all currently defined bits

ida_hexrays.EXFL_ALONE (variable)
    standalone helper

ida_hexrays.EXFL_CPADONE (variable)
    pointer arithmetic correction done

ida_hexrays.EXFL_CSTR (variable)
    string literal

ida_hexrays.EXFL_FPOP (variable)
    floating point operation

ida_hexrays.EXFL_JUMPOUT (variable)
    jump out-of-function

ida_hexrays.EXFL_LVALUE (variable)
    expression is lvalue even if it doesn't look like it

ida_hexrays.EXFL_PARTIAL (variable)
    type of the expression is considered partial

ida_hexrays.EXFL_UNDEF (variable)
    expression uses undefined value

ida_hexrays.EXFL_VFTABLE (variable)
    is ptr to vftable (used for cot_memptr, cot_memref)

ida_hexrays.FCI_DEAD (variable)
    some return registers were determined dead

ida_hexrays.FCI_EXPLOCS (variable)
    all arglocs are specified explicitly

ida_hexrays.FCI_FINAL (variable)
    call type is final, should not be changed

ida_hexrays.FCI_HASCALL (variable)
    A function is an synthetic helper combined from several instructions and at
    least one of them was a call to a real functions

ida_hexrays.FCI_HASFMT (variable)
    A variadic function with recognized printf- or scanf-style format string

ida_hexrays.FCI_NORET (variable)
    call does not return

ida_hexrays.FCI_NOSIDE (variable)
    call does not have side effects

ida_hexrays.FCI_PROP (variable)
    call has been propagated

ida_hexrays.FCI_PURE (variable)
    pure function

ida_hexrays.FCI_SPLOK (variable)
    spoiled/visible_memory lists have been optimized. for some functions we can
    reduce them as soon as information about the arguments becomes available. in
    order not to try optimize them again we use this bit.

ida_hexrays.FD_BACKWARD (variable)
    search direction

ida_hexrays.FD_DEF (variable)
    look for definition

ida_hexrays.FD_DIRTY (variable)
    ignore possible implicit definitions by function calls and indirect memory
    access

ida_hexrays.FD_FORWARD (variable)
    search direction

ida_hexrays.FD_USE (variable)
    look for use

ida_hexrays.FORBID_UNUSED_LABELS (variable)
    Unused labels cause interr.

ida_hexrays.GCA_ALLOC (variable)
    enumerate only allocated chains

ida_hexrays.GCA_EMPTY (variable)
    include empty chains

ida_hexrays.GCA_NALLOC (variable)
    enumerate only non-allocated chains

ida_hexrays.GCA_OFIRST (variable)
    consider only chains of the first block

ida_hexrays.GCA_OLAST (variable)
    consider only chains of the last block

ida_hexrays.GCA_SPEC (variable)
    include chains for special registers

ida_hexrays.GCO_DEF (variable)
    is destination operand?

ida_hexrays.GCO_REG (variable)
    is register? otherwise a stack variable

ida_hexrays.GCO_STK (variable)
    a stack variable

ida_hexrays.GCO_USE (variable)
    is source operand?

ida_hexrays.GC_ASR (variable)
    all the above and assertions

ida_hexrays.GC_DIRTY_ALL (variable)
    bitmask to represent all chains

ida_hexrays.GC_END (variable)
    number of chain types

ida_hexrays.GC_REGS_AND_STKVARS (variable)
    registers and stkvars (restricted memory only)

ida_hexrays.GC_XDSU (variable)
    only registers calculated with FULL_XDSU

ida_hexrays.GLN_ALL (variable)
    get both

ida_hexrays.GLN_CURRENT (variable)
    get label of the current item

ida_hexrays.GLN_GOTO_TARGET (variable)
    get goto target

ida_hexrays.Hexrays_Hooks (class)
    Proxy of C++ Hexrays_Hooks class.

ida_hexrays.Hexrays_Hooks.__disown__ (method)

ida_hexrays.Hexrays_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> Hexrays_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_hexrays.Hexrays_Hooks.build_callinfo (method)
    build_callinfo(self, blk, type) -> PyObject *
    Analyzing a call instruction.
    
    @param blk: (mblock_t *) blk->tail is the call.
    @param type: (tinfo_t *) buffer for the output type.

ida_hexrays.Hexrays_Hooks.callinfo_built (method)
    callinfo_built(self, blk) -> int
    A call instruction has been anallyzed.
    
    @param blk: (mblock_t *) blk->tail is the call.

ida_hexrays.Hexrays_Hooks.calls_done (method)
    calls_done(self, mba) -> int
    All calls have been analyzed.
    
    @param mba: (mba_t *) This event is generated immediately after analyzing all
                calls, before any optimizitions, call unmerging and block merging.

ida_hexrays.Hexrays_Hooks.close_pseudocode (method)
    close_pseudocode(self, vu) -> int
    Pseudocode view is being closed.
    
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.cmt_changed (method)
    cmt_changed(self, cfunc, loc, cmt) -> int
    Comment got changed.
    
    @param cfunc: (cfunc_t *)
    @param loc: (const treeloc_t *)
    @param cmt: (const char *)

ida_hexrays.Hexrays_Hooks.combine (method)
    combine(self, blk, insn) -> int
    Trying to combine instructions of basic block.
    
    @param blk: (mblock_t *)
    @param insn: (minsn_t *) Should return: 1 if combined the current instruction
                 with a preceding one -1 if the instruction should not be combined 0
                 else

ida_hexrays.Hexrays_Hooks.create_hint (method)
    create_hint(self, vu) -> PyObject *
    Create a hint for the current item.
    @see: ui_get_custom_viewer_hint
    
    @param vu: (vdui_t *)
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

ida_hexrays.Hexrays_Hooks.curpos (method)
    curpos(self, vu) -> int
    Current cursor position has been changed. (for example, by left-clicking or
    using keyboard)
    
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.double_click (method)
    double_click(self, vu, shift_state) -> int
    Mouse double click.
    
    @param vu: (vdui_t *)
    @param shift_state: (int) Should return: 1 if the event has been handled

ida_hexrays.Hexrays_Hooks.flowchart (method)
    flowchart(self, fc) -> int
    Flowchart has been generated.
    
    @param fc: (qflow_chart_t *)

ida_hexrays.Hexrays_Hooks.func_printed (method)
    func_printed(self, cfunc) -> int
    Function text has been generated. Plugins may modify the text in cfunc_t::sv.
    The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store
    pointers to ctree items.
    
    @param cfunc: (cfunc_t *)

ida_hexrays.Hexrays_Hooks.glbopt (method)
    glbopt(self, mba) -> int
    Global optimization has been finished. If microcode is modified, MERR_LOOP must
    be returned. It will cause a complete restart of the optimization.
    
    @param mba: (mba_t *) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.hook (method)
    hook(self) -> bool

ida_hexrays.Hexrays_Hooks.interr (method)
    interr(self, errcode) -> int
    Internal error has occurred.
    
    @param errcode: (int )

ida_hexrays.Hexrays_Hooks.keyboard (method)
    keyboard(self, vu, key_code, shift_state) -> int
    Keyboard has been hit.
    
    @param vu: (vdui_t *)
    @param key_code: (int) VK_...
    @param shift_state: (int) Should return: 1 if the event has been handled

ida_hexrays.Hexrays_Hooks.locopt (method)
    locopt(self, mba) -> int
    Basic block level optimization has been finished.
    
    @param mba: (mba_t *) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.lvar_cmt_changed (method)
    lvar_cmt_changed(self, vu, v, cmt) -> int
    Local variable comment got changed.
    
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param cmt: (const char *) Please note that it is possible to read/write user
                settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_mapping_changed (method)
    lvar_mapping_changed(self, vu, frm, to) -> int
    Local variable mapping got changed.
    
    @param vu: (vdui_t *)
    @param from: lvar_t *
    @param to: (lvar_t *) Please note that it is possible to read/write user
               settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_name_changed (method)
    lvar_name_changed(self, vu, v, name, is_user_name) -> int
    Local variable got renamed.
    
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param name: (const char *)
    @param is_user_name: (bool) Please note that it is possible to read/write user
                         settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_type_changed (method)
    lvar_type_changed(self, vu, v, tinfo) -> int
    Local variable type got changed.
    
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param tinfo: (const tinfo_t *) Please note that it is possible to read/write
                  user settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.maturity (method)
    maturity(self, cfunc, new_maturity) -> int
    Ctree maturity level is being changed.
    
    @param cfunc: (cfunc_t *)
    @param new_maturity: (ctree_maturity_t)

ida_hexrays.Hexrays_Hooks.microcode (method)
    microcode(self, mba) -> int
    Microcode has been generated.
    
    @param mba: (mba_t *) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.open_pseudocode (method)
    open_pseudocode(self, vu) -> int
    New pseudocode view has been opened.
    
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.populating_popup (method)
    populating_popup(self, widget, popup_handle, vu) -> int
    Populating popup menu. We can add menu items now.
    
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.prealloc (method)
    prealloc(self, mba) -> int
    Local variables: preallocation step begins.
    
    @param mba: (mba_t *) This event may occur several times. Should return: 1 if
                modified microcode Negative values are Microcode error codes error
                codes

ida_hexrays.Hexrays_Hooks.preoptimized (method)
    preoptimized(self, mba) -> int
    Microcode has been preoptimized.
    
    @param mba: (mba_t *) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.print_func (method)
    print_func(self, cfunc, vp) -> int
    Printing ctree and generating text.
    
    @param cfunc: (cfunc_t *)
    @param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin
               It is forbidden to modify ctree at this event.

ida_hexrays.Hexrays_Hooks.prolog (method)
    prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
    Prolog analysis has been finished.
    
    @param mba: (mba_t *)
    @param fc: (qflow_chart_t *)
    @param reachable_blocks: (bitset_t *)
    @param decomp_flags: (int) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.refresh_pseudocode (method)
    refresh_pseudocode(self, vu) -> int
    Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is
    forbidden in this event.
    
    @param vu: (vdui_t *) See also hxe_text_ready, which happens earlier

ida_hexrays.Hexrays_Hooks.resolve_stkaddrs (method)
    resolve_stkaddrs(self, mba) -> int
    The optimizer is about to resolve stack addresses.
    
    @param mba: (mba_t *)

ida_hexrays.Hexrays_Hooks.right_click (method)
    right_click(self, vu) -> int
    Mouse right click. Use hxe_populating_popup instead, in case you want to add
    items in the popup menu.
    
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.stkpnts (method)
    stkpnts(self, mba, _sps) -> int
    SP change points have been calculated.
    
    @param mba: (mba_t *)
    @param stkpnts: (stkpnts_t *) return Microcode error codes code

ida_hexrays.Hexrays_Hooks.structural (method)
    structural(self, ct) -> int
    Structural analysis has been finished.
    
    @param ct: (control_graph_t *)

ida_hexrays.Hexrays_Hooks.switch_pseudocode (method)
    switch_pseudocode(self, vu) -> int
    Existing pseudocode view has been reloaded with a new function. Its text has not
    been refreshed yet, only cfunc and mba pointers are ready.
    
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.text_ready (method)
    text_ready(self, vu) -> int
    Decompiled text is ready.
    
    @param vu: (vdui_t *) This event can be used to modify the output text (sv).
               Obsolete. Please use hxe_func_printed instead.

ida_hexrays.Hexrays_Hooks.unhook (method)
    unhook(self) -> bool

ida_hexrays.IPROP_CLNPOP (variable)
    the purpose of the instruction is to clean stack (e.g. "pop ecx" is often used
    for that)

ida_hexrays.IPROP_COMBINED (variable)
    insn has been modified because of a partial reference

ida_hexrays.IPROP_DONT_COMB (variable)
    may not combine this instruction with others

ida_hexrays.IPROP_DONT_PROP (variable)
    may not propagate

ida_hexrays.IPROP_EXTSTX (variable)
    this is m_ext propagated into m_stx

ida_hexrays.IPROP_FARCALL (variable)
    call of a far function using push cs/call sequence

ida_hexrays.IPROP_FPINSN (variable)
    floating point insn

ida_hexrays.IPROP_IGNLOWSRC (variable)
    low part of the instruction source operand has been created artificially (this
    bit is used only for 'and x, 80...')

ida_hexrays.IPROP_INV_JX (variable)
    inverted conditional jump

ida_hexrays.IPROP_MBARRIER (variable)
    this instruction acts as a memory barrier (instructions accessing memory may not
    be reordered past it)

ida_hexrays.IPROP_MULTI_MOV (variable)
    bits that can be set by plugins:
    
    the minsn was generated as part of insn that moves multiple registers (example:
    STM on ARM may transfer multiple registers)

ida_hexrays.IPROP_OPTIONAL (variable)
    optional instruction

ida_hexrays.IPROP_PERSIST (variable)
    persistent insn; they are not destroyed

ida_hexrays.IPROP_SPLIT (variable)
    the instruction has been split:

ida_hexrays.IPROP_SPLIT1 (variable)
    into 1 byte

ida_hexrays.IPROP_SPLIT2 (variable)
    into 2 bytes

ida_hexrays.IPROP_SPLIT4 (variable)
    into 4 bytes

ida_hexrays.IPROP_SPLIT8 (variable)
    into 8 bytes

ida_hexrays.IPROP_TAILCALL (variable)
    tail call

ida_hexrays.IPROP_UNMERGED (variable)
    'goto' instruction was transformed info 'call'

ida_hexrays.IPROP_WAS_NORET (variable)
    was noret icall

ida_hexrays.IPROP_WILDMATCH (variable)
    match multiple insns

ida_hexrays.ITP_ARG1 (variable)
    , (64 entries are reserved for 64 call arguments)

ida_hexrays.ITP_ASM (variable)
    __asm-line

ida_hexrays.ITP_BLOCK1 (variable)
    opening block comment. this comment is printed before the item (other comments
    are indented and printed after the item)

ida_hexrays.ITP_BLOCK2 (variable)
    closing block comment.

ida_hexrays.ITP_BRACE2 (variable)
    )

ida_hexrays.ITP_CASE (variable)
    bit for switch cases

ida_hexrays.ITP_COLON (variable)
    : (label)

ida_hexrays.ITP_CURLY1 (variable)
    {

ida_hexrays.ITP_CURLY2 (variable)
    }

ida_hexrays.ITP_DO (variable)
    do-line

ida_hexrays.ITP_ELSE (variable)
    else-line

ida_hexrays.ITP_EMPTY (variable)
    nothing

ida_hexrays.ITP_SEMI (variable)
    semicolon

ida_hexrays.ITP_SIGN (variable)
    if this bit is set too, then we have a negative case value

ida_hexrays.LOCOPT_ALL (variable)
    redo optimization for all blocks. if this bit is not set, only dirty blocks will
    be optimized

ida_hexrays.LOCOPT_REFINE (variable)
    refine return type, ok to fail

ida_hexrays.LOCOPT_REFINE2 (variable)
    refine return type, try harder

ida_hexrays.LVINF_KEEP (variable)
    preserve saved user settings regardless of vars for example, if a var loses all
    its user-defined attributes or even gets destroyed, keep its lvar_saved_info_t.
    this is used for ephemeral variables that get destroyed by macro recognition.

ida_hexrays.LVINF_NOMAP (variable)
    forbid automatic mapping of the variable

ida_hexrays.LVINF_NOPTR (variable)
    variable type should not be a pointer

ida_hexrays.LVINF_SPLIT (variable)
    split allocation of a new variable. forces the decompiler to create a new
    variable at ll.defea

ida_hexrays.LVINF_UNUSED (variable)
    unused argument, corresponds to CVAR_UNUSED

ida_hexrays.MBA2_ARGIDX_OK (variable)
    may verify input argument list?

ida_hexrays.MBA2_ARGIDX_SORTED (variable)
    args finally sorted according to ABI (e.g. reverse stkarg order in Borland)

ida_hexrays.MBA2_CODE16_BIT (variable)
    the code16 bit removed

ida_hexrays.MBA2_DONT_VERIFY (variable)
    Do not verify microcode. This flag is recomended to be set only when debugging
    decompiler plugins

ida_hexrays.MBA2_HAS_OUTLINES (variable)
    calls to outlined code have been inlined

ida_hexrays.MBA2_IS_CTR (variable)
    is constructor?

ida_hexrays.MBA2_IS_DTR (variable)
    is destructor?

ida_hexrays.MBA2_LVARNAMES_OK (variable)
    may verify lvar_names?

ida_hexrays.MBA2_LVARS_RENAMED (variable)
    accept empty names now?

ida_hexrays.MBA2_NO_DUP_CALLS (variable)
    forbid multiple calls with the same ea

ida_hexrays.MBA2_NO_DUP_LVARS (variable)
    forbid multiple lvars with the same ea

ida_hexrays.MBA2_NO_FRAME (variable)
    do not use function frame info (only snippet mode)

ida_hexrays.MBA2_OVER_CHAINS (variable)
    has overlapped chains?

ida_hexrays.MBA2_PROP_COMPLEX (variable)
    allow propagation of more complex variable definitions

ida_hexrays.MBA2_STACK_RETVAL (variable)
    the return value is on the stack

ida_hexrays.MBA2_UNDEF_RETVAR (variable)
    return value is undefined

ida_hexrays.MBA2_VALRNG_DONE (variable)
    calculated valranges?

ida_hexrays.MBA_ASRPROP (variable)
    assertion have been propagated

ida_hexrays.MBA_ASRTOK (variable)
    assertions have been generated

ida_hexrays.MBA_CALLS (variable)
    callinfo has been built

ida_hexrays.MBA_CHVARS (variable)
    can verify chain varnums

ida_hexrays.MBA_CMBBLK (variable)
    request to combine blocks

ida_hexrays.MBA_CMNSTK (variable)
    stkvars+stkargs should be considered as one area

ida_hexrays.MBA_COLGDL (variable)
    display graph after each reduction

ida_hexrays.MBA_DELPAIRS (variable)
    pairs have been deleted once

ida_hexrays.MBA_GLBOPT (variable)
    microcode has been optimized globally

ida_hexrays.MBA_INSGDL (variable)
    display instruction in graphs

ida_hexrays.MBA_LOADED (variable)
    loaded gdl, no instructions (debugging)

ida_hexrays.MBA_LVARS0 (variable)
    lvar pre-allocation has been performed

ida_hexrays.MBA_LVARS1 (variable)
    lvar real allocation has been performed

ida_hexrays.MBA_NICE (variable)
    apply transformations to c code

ida_hexrays.MBA_NOFUNC (variable)
    function is not present, addresses might be wrong

ida_hexrays.MBA_NUMADDR (variable)
    display definition addresses for numbers

ida_hexrays.MBA_PASSREGS (variable)
    has mcallinfo_t::pass_regs

ida_hexrays.MBA_PATTERN (variable)
    microcode pattern, callinfo is present

ida_hexrays.MBA_PRCDEFS (variable)
    use precise defeas for chain-allocated lvars

ida_hexrays.MBA_PREOPT (variable)
    preoptimization stage complete

ida_hexrays.MBA_REFINE (variable)
    may refine return value size

ida_hexrays.MBA_RETFP (variable)
    function returns floating point value

ida_hexrays.MBA_RETREF (variable)
    return type has been refined

ida_hexrays.MBA_SAVRST (variable)
    save-restore analysis has been performed

ida_hexrays.MBA_SHORT (variable)
    use short display

ida_hexrays.MBA_SPLINFO (variable)
    (final_type ? idb_spoiled : spoiled_regs) is valid

ida_hexrays.MBA_THUNK (variable)
    thunk function

ida_hexrays.MBA_VALNUM (variable)
    display value numbers

ida_hexrays.MBA_WINGR32 (variable)
    use wingraph32

ida_hexrays.MBL_BACKPROP (variable)
    performed backprop_cc

ida_hexrays.MBL_CALL (variable)
    call information has been built

ida_hexrays.MBL_COMB (variable)
    needs "combine" pass

ida_hexrays.MBL_DEAD (variable)
    needs "eliminate deads" pass

ida_hexrays.MBL_DMT64 (variable)
    needs "demote 64bits"

ida_hexrays.MBL_DSLOT (variable)
    block for delay slot

ida_hexrays.MBL_FAKE (variable)
    fake block

ida_hexrays.MBL_GOTO (variable)
    this block is a goto target

ida_hexrays.MBL_INCONST (variable)
    inconsistent lists: we are building them

ida_hexrays.MBL_KEEP (variable)
    do not remove even if unreachable

ida_hexrays.MBL_LIST (variable)
    use/def lists are ready (not dirty)

ida_hexrays.MBL_NONFAKE (variable)
    regular block

ida_hexrays.MBL_NORET (variable)
    dead end block: doesn't return execution control

ida_hexrays.MBL_PRIV (variable)
    private block - no instructions except the specified are accepted (used in
    patterns)

ida_hexrays.MBL_PROP (variable)
    needs 'propagation' pass

ida_hexrays.MBL_PUSH (variable)
    needs "convert push/pop instructions"

ida_hexrays.MBL_TCAL (variable)
    aritifical call block for tail calls

ida_hexrays.MBL_VALRANGES (variable)
    should optimize using value ranges

ida_hexrays.MERR_BADARCH (variable)
    current architecture is not supported

ida_hexrays.MERR_BADBLK (variable)
    bad block found

ida_hexrays.MERR_BADCALL (variable)
    could not determine call arguments

ida_hexrays.MERR_BADFRAME (variable)
    function frame is wrong

ida_hexrays.MERR_BADIDB (variable)
    inconsistent database information

ida_hexrays.MERR_BADRANGES (variable)
    bad input ranges

ida_hexrays.MERR_BADSP (variable)
    positive sp value has been found

ida_hexrays.MERR_BITNESS (variable)
    16-bit functions cannot be decompiled

ida_hexrays.MERR_BLOCK (variable)
    no error, switch to new block

ida_hexrays.MERR_BUSY (variable)
    already decompiling a function

ida_hexrays.MERR_CANCELED (variable)
    decompilation has been cancelled

ida_hexrays.MERR_COMPLEX (variable)
    too complex function

ida_hexrays.MERR_DSLOT (variable)
    bad instruction in the delay slot

ida_hexrays.MERR_EXCEPTION (variable)
    exception analysis failed

ida_hexrays.MERR_EXTERN (variable)
    special segments cannot be decompiled

ida_hexrays.MERR_FARPTR (variable)
    far memory model is supported only for pc

ida_hexrays.MERR_FUNCSIZE (variable)
    too big function

ida_hexrays.MERR_HUGESTACK (variable)
    stack frame is too big

ida_hexrays.MERR_INSN (variable)
    cannot convert to microcode

ida_hexrays.MERR_INTERR (variable)
    internal error

ida_hexrays.MERR_LICENSE (variable)
    no license available

ida_hexrays.MERR_LOOP (variable)
    internal code: redo last loop (never reported)

ida_hexrays.MERR_LVARS (variable)
    local variable allocation failed

ida_hexrays.MERR_MEM (variable)
    not enough memory

ida_hexrays.MERR_OK (variable)
    ok

ida_hexrays.MERR_ONLY32 (variable)
    only 32-bit functions can be decompiled for the current database

ida_hexrays.MERR_ONLY64 (variable)
    only 64-bit functions can be decompiled for the current database

ida_hexrays.MERR_OVERLAP (variable)
    variables would overlap: s

ida_hexrays.MERR_PARTINIT (variable)
    partially initialized variable s

ida_hexrays.MERR_PROLOG (variable)
    prolog analysis failed

ida_hexrays.MERR_RECDEPTH (variable)
    max recursion depth reached during lvar allocation

ida_hexrays.MERR_REDO (variable)
    redecompilation has been requested

ida_hexrays.MERR_SIZEOF (variable)
    wrong basic type sizes in compiler settings

ida_hexrays.MERR_STOP (variable)
    no error, stop the analysis

ida_hexrays.MERR_SWITCH (variable)
    wrong switch idiom

ida_hexrays.MERR_UNKTYPE (variable)
    undefined type s (currently unused error code)

ida_hexrays.MLI_CLR_FLAGS (variable)
    clear LVINF_... bits

ida_hexrays.MLI_CMT (variable)
    apply lvar comment

ida_hexrays.MLI_NAME (variable)
    apply lvar name

ida_hexrays.MLI_SET_FLAGS (variable)
    set LVINF_... bits

ida_hexrays.MLI_TYPE (variable)
    apply lvar type

ida_hexrays.MMAT_CALLS (variable)
    detected call arguments. see also hxe_calls_done

ida_hexrays.MMAT_GENERATED (variable)
    generated microcode

ida_hexrays.MMAT_GLBOPT1 (variable)
    performed the first pass of global optimization

ida_hexrays.MMAT_GLBOPT2 (variable)
    most global optimization passes are done

ida_hexrays.MMAT_GLBOPT3 (variable)
    completed all global optimization. microcode is fixed now.

ida_hexrays.MMAT_LOCOPT (variable)
    local optimization of each basic block is complete. control flow graph is ready
    too.

ida_hexrays.MMAT_LVARS (variable)
    allocated local variables

ida_hexrays.MMAT_PREOPTIMIZED (variable)
    preoptimized pass is complete

ida_hexrays.MMAT_ZERO (variable)
    microcode does not exist

ida_hexrays.MMIDX_GLBHIGH (variable)
    global memory: high part

ida_hexrays.MMIDX_GLBLOW (variable)
    global memory: low part

ida_hexrays.NALT_VD (variable)
    this index is not used by ida

ida_hexrays.NF_BINVDONE (variable)
    temporary internal bit: inverting bits is done

ida_hexrays.NF_BITNOT (variable)
    The user asked to invert bits of the constant.

ida_hexrays.NF_FIXED (variable)
    number format has been defined by the user

ida_hexrays.NF_NEGATE (variable)
    The user asked to negate the constant.

ida_hexrays.NF_NEGDONE (variable)
    temporary internal bit: negation has been performed

ida_hexrays.NF_VALID (variable)
    internal bit: stroff or enum is valid for enums: this bit is set immediately for
    stroffs: this bit is set at the end of decompilation

ida_hexrays.NOSIZE (variable)
    wrong or unexisting operand size

ida_hexrays.NO_CURLY_BRACES (variable)
    don't print curly braces

ida_hexrays.NO_SIDEFF (variable)
    change operand size but ignore side effects if you decide to keep the changed
    operand, handle_new_size() must be called

ida_hexrays.ONLY_SIDEFF (variable)
    only handle side effects

ida_hexrays.OPF_NEW_WINDOW (variable)
    open new window

ida_hexrays.OPF_NO_WAIT (variable)
    do not display waitbox if decompilation happens

ida_hexrays.OPF_REUSE (variable)
    reuse existing window

ida_hexrays.OPF_REUSE_ACTIVE (variable)
    reuse existing window, only if the currently active widget is a pseudocode view

ida_hexrays.OPROP_FLOAT (variable)
    possibly floating value

ida_hexrays.OPROP_IMPDONE (variable)
    imported operand (a pointer) has been dereferenced

ida_hexrays.OPROP_LOWADDR (variable)
    a low address offset

ida_hexrays.OPROP_UDEFVAL (variable)
    uses undefined value

ida_hexrays.OPROP_UDT (variable)
    a struct or union

ida_hexrays.OPTI_ADDREXPRS (variable)
    optimize all address expressions (&x+N; &x-&y)

ida_hexrays.OPTI_COMBINSNS (variable)
    may combine insns (only for optimize_insn)

ida_hexrays.OPTI_MINSTKREF (variable)
    may update minstkref

ida_hexrays.OPTI_NO_LDXOPT (variable)
    the function is called after the propagation attempt, we do not optimize
    low/high(ldx) in this case

ida_hexrays.RETRIEVE_ALWAYS (variable)
    Retrieve comment even if it has been used.

ida_hexrays.RETRIEVE_ONCE (variable)
    Retrieve comment if it has not been used yet.

ida_hexrays.ROLE_3WAYCMP0 (variable)
    3-way compare helper, returns -1/0/1

ida_hexrays.ROLE_3WAYCMP1 (variable)
    3-way compare helper, returns 0/1/2

ida_hexrays.ROLE_ABS (variable)
    integer absolute value

ida_hexrays.ROLE_ALLOCA (variable)
    alloca() function

ida_hexrays.ROLE_BITTEST (variable)
    [lock] bt

ida_hexrays.ROLE_BITTESTANDCOMPLEMENT (variable)
    [lock] btc

ida_hexrays.ROLE_BITTESTANDRESET (variable)
    [lock] btr

ida_hexrays.ROLE_BITTESTANDSET (variable)
    [lock] bts

ida_hexrays.ROLE_BSWAP (variable)
    bswap() function (any size)

ida_hexrays.ROLE_BUG (variable)
    BUG() helper macro: never returns, causes exception.

ida_hexrays.ROLE_CFSUB3 (variable)
    carry flag after subtract with carry

ida_hexrays.ROLE_CONTAINING_RECORD (variable)
    CONTAINING_RECORD() macro.

ida_hexrays.ROLE_EMPTY (variable)
    empty, does not do anything (maybe spoils regs)

ida_hexrays.ROLE_FASTFAIL (variable)
    __fastfail()

ida_hexrays.ROLE_IS_MUL_OK (variable)
    is_mul_ok

ida_hexrays.ROLE_MEMCPY (variable)
    memcpy(void *dst, const void *src, size_t count);

ida_hexrays.ROLE_MEMSET (variable)
    memset(void *dst, uchar value, size_t count);

ida_hexrays.ROLE_MEMSET32 (variable)
    memset32(void *dst, uint32 value, size_t count);

ida_hexrays.ROLE_MEMSET64 (variable)
    memset64(void *dst, uint64 value, size_t count);

ida_hexrays.ROLE_OFSUB3 (variable)
    overflow flag after subtract with carry

ida_hexrays.ROLE_PRESENT (variable)
    present() function (used in patterns)

ida_hexrays.ROLE_READFLAGS (variable)
    __readeflags, __readcallersflags

ida_hexrays.ROLE_ROL (variable)
    rotate left

ida_hexrays.ROLE_ROR (variable)
    rotate right

ida_hexrays.ROLE_SATURATED_MUL (variable)
    saturated_mul

ida_hexrays.ROLE_SSE_CMP4 (variable)
    e.g. _mm_cmpgt_ss

ida_hexrays.ROLE_SSE_CMP8 (variable)
    e.g. _mm_cmpgt_sd

ida_hexrays.ROLE_STRCAT (variable)
    strcat(char *dst, const char *src);

ida_hexrays.ROLE_STRCPY (variable)
    strcpy(char *dst, const char *src);

ida_hexrays.ROLE_STRLEN (variable)
    strlen(const char *src);

ida_hexrays.ROLE_TAIL (variable)
    char *tail(const char *str);

ida_hexrays.ROLE_UNK (variable)
    unknown function role

ida_hexrays.ROLE_VA_ARG (variable)
    va_arg() macro

ida_hexrays.ROLE_VA_COPY (variable)
    va_copy() function

ida_hexrays.ROLE_VA_END (variable)
    va_end() function

ida_hexrays.ROLE_VA_START (variable)
    va_start() function

ida_hexrays.ROLE_WCSCAT (variable)
    wchar_t *wcscat(wchar_t *dst, const wchar_t *src)

ida_hexrays.ROLE_WCSCPY (variable)
    wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);

ida_hexrays.ROLE_WCSLEN (variable)
    size_t wcslen(const wchar_t *s)

ida_hexrays.ROLE_WMEMCPY (variable)
    wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, size_t n)

ida_hexrays.ROLE_WMEMSET (variable)
    wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)

ida_hexrays.SHINS_LDXEA (variable)
    display address of ldx expressions (not used)

ida_hexrays.SHINS_NUMADDR (variable)
    display definition addresses for numbers

ida_hexrays.SHINS_SHORT (variable)
    do not display use-def chains and other attrs

ida_hexrays.SHINS_VALNUM (variable)
    display value numbers

ida_hexrays.ULV_PRECISE_DEFEA (variable)
    Use precise defea's for lvar locations.

ida_hexrays.USE_CURLY_BRACES (variable)
    print curly braces without any checks

ida_hexrays.USE_KEYBOARD (variable)
    Keyboard.

ida_hexrays.USE_MOUSE (variable)
    Mouse.

ida_hexrays.VDI_EXPR (variable)
    c-tree item

ida_hexrays.VDI_FUNC (variable)
    the function itself (the very first line with the function prototype)

ida_hexrays.VDI_LVAR (variable)
    declaration of local variable

ida_hexrays.VDI_NONE (variable)
    undefined

ida_hexrays.VDI_TAIL (variable)
    cursor is at (beyond) the line end (commentable line)

ida_hexrays.VDRUN_APPEND (variable)
    Create a new file or append to existing file.

ida_hexrays.VDRUN_CMDLINE (variable)
    Called from ida's command line.

ida_hexrays.VDRUN_LUMINA (variable)
    Use lumina server.

ida_hexrays.VDRUN_MAYSTOP (variable)
    The user can cancel decompilation.

ida_hexrays.VDRUN_NEWFILE (variable)
    Create a new file or overwrite existing file.

ida_hexrays.VDRUN_ONLYNEW (variable)
    Fail if output file already exists.

ida_hexrays.VDRUN_SENDIDB (variable)
    Send problematic databases to hex-rays.com.

ida_hexrays.VDRUN_SILENT (variable)
    Silent decompilation.

ida_hexrays.VDRUN_STATS (variable)
    Print statistics into vd_stats.txt.

ida_hexrays.VDUI_VALID (variable)
    is valid?

ida_hexrays.VDUI_VISIBLE (variable)
    is visible?

ida_hexrays.VR_AT_END (variable)
    get value ranges after the instruction or at the block end, just after the last
    instruction (if M is nullptr)

ida_hexrays.VR_AT_START (variable)
    get value ranges before the instruction or at the block start (if M is nullptr)

ida_hexrays.VR_EXACT (variable)
    find exact match. if not set, the returned valrng size will be >= vivl.size

ida_hexrays.WARN_ADDR_OUTARGS (variable)
    6 cannot handle address arithmetics in outgoing argument area of stack frame -
    unused

ida_hexrays.WARN_ARRAY_INARG (variable)
    21 array has been used for an input argument

ida_hexrays.WARN_BAD_CALL_SP (variable)
    38 bad sp value at call

ida_hexrays.WARN_BAD_FIELD_TYPE (variable)
    23 incorrect structure member type for s::s, ignored

ida_hexrays.WARN_BAD_INSN (variable)
    49 bad instruction

ida_hexrays.WARN_BAD_MAPDST (variable)
    48 too short map destination 's' for variable 's'

ida_hexrays.WARN_BAD_PURGED (variable)
    12 inconsistent function type and number of purged bytes

ida_hexrays.WARN_BAD_RETVAR (variable)
    25 wrong return variable

ida_hexrays.WARN_BAD_SHADOW (variable)
    45 ignored the value written to the shadow area of the succeeding call

ida_hexrays.WARN_BAD_SP (variable)
    40 positive sp value a has been found

ida_hexrays.WARN_BAD_STD_TYPE (variable)
    37 corrupted or unexisting local type 's'

ida_hexrays.WARN_BAD_STKPNT (variable)
    41 wrong sp change point

ida_hexrays.WARN_BAD_STROFF (variable)
    33 user specified stroff has not been processed: s

ida_hexrays.WARN_BAD_VALRNG (variable)
    44 values range analysis failed

ida_hexrays.WARN_BAD_VARSIZE (variable)
    34 inconsistent variable size for 's'

ida_hexrays.WARN_CBUILD_LOOPS (variable)
    13 too many cbuild loops

ida_hexrays.WARN_CR_BADOFF (variable)
    32 CONTAINING_RECORD: too small offset d for struct 's'

ida_hexrays.WARN_CR_NOFIELD (variable)
    31 CONTAINING_RECORD: no field 's' in struct 's' at d

ida_hexrays.WARN_DEP_UNK_CALLS (variable)
    7 found interdependent unknown calls

ida_hexrays.WARN_EXP_LINVAR (variable)
    10 failed to expand a linear variable

ida_hexrays.WARN_FIXED_MACRO (variable)
    29 fixed broken macro-insn

ida_hexrays.WARN_FRAG_LVAR (variable)
    26 fragmented variable at s may be wrong

ida_hexrays.WARN_GUESSED_TYPE (variable)
    9 using guessed type s;

ida_hexrays.WARN_HUGE_STKOFF (variable)
    27 exceedingly huge offset into the stack frame

ida_hexrays.WARN_ILL_ELLIPSIS (variable)
    8 erroneously detected ellipsis type has been ignored

ida_hexrays.WARN_ILL_FPU_STACK (variable)
    18 inconsistent fpu stack

ida_hexrays.WARN_ILL_FUNCTYPE (variable)
    2 invalid function type 's' has been ignored

ida_hexrays.WARN_ILL_PURGED (variable)
    1 odd caller purged bytes d, correcting

ida_hexrays.WARN_JUMPOUT (variable)
    43 control flows out of bounds

ida_hexrays.WARN_MAX (variable)
    may be used in notes as a placeholder when the warning id is not available

ida_hexrays.WARN_MAX_ARGS (variable)
    22 too many input arguments, some ignored

ida_hexrays.WARN_MISSED_SWITCH (variable)
    39 wrong markup of switch jump, skipped it

ida_hexrays.WARN_MUST_RET_FP (variable)
    17 function return type is incorrect (must be floating point)

ida_hexrays.WARN_NO_SAVE_REST (variable)
    14 could not find valid save-restore pair for s

ida_hexrays.WARN_ODD_ABI (variable)
    50 encountered odd instruction for the current ABI

ida_hexrays.WARN_ODD_ADDR_USE (variable)
    16 odd use of a variable address

ida_hexrays.WARN_ODD_INPUT_REG (variable)
    15 odd input register s

ida_hexrays.WARN_OPT_USELESS_JCND (variable)
    54 simplified comparisons for 's': s became s

ida_hexrays.WARN_OPT_VALRNG (variable)
    46 conditional instruction was optimized away because s

ida_hexrays.WARN_OPT_VALRNG2 (variable)
    52 mask 0xX is shortened because s <= 0xX"

ida_hexrays.WARN_OPT_VALRNG3 (variable)
    53 masking with 0XX was optimized away because s <= 0xX

ida_hexrays.WARN_RET_LOCREF (variable)
    47 returning address of temporary local variable 's'

ida_hexrays.WARN_SELFREF_PROP (variable)
    19 self-referencing variable has been detected

ida_hexrays.WARN_UNALIGNED_ARG (variable)
    36 unaligned function argument 's'

ida_hexrays.WARN_UNBALANCED_STACK (variable)
    51 unbalanced stack, ignored a potential tail call

ida_hexrays.WARN_UNDEF_LVAR (variable)
    42 variable 's' is possibly undefined

ida_hexrays.WARN_UNINITED_REG (variable)
    28 reference to an uninitialized register has been removed: s

ida_hexrays.WARN_UNSUPP_REG (variable)
    35 unsupported processor register 's'

ida_hexrays.WARN_VARARG_MANY (variable)
    5 too many varargs, some ignored

ida_hexrays.WARN_VARARG_NOSTK (variable)
    4 call vararg without local stack

ida_hexrays.WARN_VARARG_REGS (variable)
    0 cannot handle register arguments in vararg function, discarded them

ida_hexrays.WARN_VARARG_TCAL (variable)
    3 cannot handle tail call to vararg

ida_hexrays.WARN_WIDEN_CHAINS (variable)
    11 failed to widen chains

ida_hexrays.WARN_WOULD_OVERLAP (variable)
    20 variables would overlap: s

ida_hexrays.WARN_WRITE_CONST (variable)
    24 write access to const memory at a has been detected

ida_hexrays.WARN_WRONG_VA_OFF (variable)
    30 wrong offset of va_list variable

ida_hexrays.WITH_SIDEFF (variable)
    change operand size and handle side effects

ida_hexrays.__cbhooks_t (class)

ida_hexrays.__cbhooks_t.__init__ (method)

ida_hexrays.__cbhooks_t.close_pseudocode (method)

ida_hexrays.__cbhooks_t.create_hint (method)

ida_hexrays.__cbhooks_t.curpos (method)

ida_hexrays.__cbhooks_t.double_click (method)

ida_hexrays.__cbhooks_t.func_printed (method)

ida_hexrays.__cbhooks_t.interr (method)

ida_hexrays.__cbhooks_t.keyboard (method)

ida_hexrays.__cbhooks_t.maturity (method)

ida_hexrays.__cbhooks_t.open_pseudocode (method)

ida_hexrays.__cbhooks_t.populating_popup (method)

ida_hexrays.__cbhooks_t.print_func (method)

ida_hexrays.__cbhooks_t.refresh_pseudocode (method)

ida_hexrays.__cbhooks_t.right_click (method)

ida_hexrays.__cbhooks_t.switch_pseudocode (method)

ida_hexrays.__cbhooks_t.text_ready (method)

ida_hexrays._call_with_transferrable_ownership (function)

ida_hexrays._kludge_force_declare_TPopupMenu (function)
    _kludge_force_declare_TPopupMenu(arg1)
    
    Parameters
    ----------
    arg1: TPopupMenu const *

ida_hexrays._ll_call_helper (function)
    _ll_call_helper(rettype, args, format) -> cexpr_t
    
    Parameters
    ----------
    rettype: tinfo_t const &
    args: carglist_t *
    format: char const *

ida_hexrays._ll_create_helper (function)
    _ll_create_helper(standalone, type, format) -> cexpr_t
    
    Parameters
    ----------
    standalone: bool
    type: tinfo_t const &
    format: char const *

ida_hexrays._ll_dereference (function)
    _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *
    ptrsize: int
    is_flt: bool

ida_hexrays._ll_lnot (function)
    _ll_lnot(e) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *

ida_hexrays._ll_make_num (function)
    _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t
    
    Parameters
    ----------
    n: uint64
    func: cfunc_t *
    ea: ea_t
    opnum: int
    sign: type_sign_t
    size: int

ida_hexrays._ll_make_ref (function)
    _ll_make_ref(e) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *

ida_hexrays._ll_new_block (function)
    _ll_new_block() -> cinsn_t

ida_hexrays._map_as_dict (function)

ida_hexrays._map_as_dict._map___contains__ (function)
    Returns true if the specified key exists in the . 

ida_hexrays._map_as_dict._map___delitem__ (function)
    Removes the value associated with the provided key. 

ida_hexrays._map_as_dict._map___getitem__ (function)
    Returns the value associated with the provided key. 

ida_hexrays._map_as_dict._map___iter__ (function)
    Iterate over dictionary keys. 

ida_hexrays._map_as_dict._map___setitem__ (function)
    Returns the value associated with the provided key. 

ida_hexrays._map_as_dict._map_clear (function)

ida_hexrays._map_as_dict._map_copy (function)

ida_hexrays._map_as_dict._map_get (function)

ida_hexrays._map_as_dict._map_has_key (function)

ida_hexrays._map_as_dict._map_items (function)

ida_hexrays._map_as_dict._map_iteritems (function)

ida_hexrays._map_as_dict._map_iterkeys (function)

ida_hexrays._map_as_dict._map_itervalues (function)

ida_hexrays._map_as_dict._map_keys (function)

ida_hexrays._map_as_dict._map_pop (function)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_popitem (function)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_setdefault (function)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_values (function)

ida_hexrays.accepts_small_udts (function)
    accepts_small_udts(op) -> bool
    Is the operator allowed on small structure or union?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.accepts_udts (function)
    accepts_udts(op) -> bool
    
    @param op: enum ctype_t

ida_hexrays.arglocs_overlap (function)
    arglocs_overlap(loc1, w1, loc2, w2) -> bool
    Do two arglocs overlap?
    
    @param loc1: (C++: const vdloc_t &) vdloc_t const &
    @param w1: (C++: size_t)
    @param loc2: (C++: const vdloc_t &) vdloc_t const &
    @param w2: (C++: size_t)

ida_hexrays.array_of_bitsets (class)
    Proxy of C++ qvector< bitset_t > class.

ida_hexrays.array_of_bitsets.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< bitset_t > const &

ida_hexrays.array_of_bitsets.__getitem__ (method)
    __getitem__(self, i) -> bitset_t
    
    @param i: size_t

ida_hexrays.array_of_bitsets.__init__ (method)
    __init__(self) -> array_of_bitsets
    __init__(self, x) -> array_of_bitsets
    
    @param x: qvector< bitset_t > const &

ida_hexrays.array_of_bitsets.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.array_of_bitsets.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< bitset_t > const &

ida_hexrays.array_of_bitsets.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: bitset_t const &

ida_hexrays.array_of_bitsets._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: bitset_t const &

ida_hexrays.array_of_bitsets.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: bitset_t const &

ida_hexrays.array_of_bitsets.at (method)
    at(self, _idx) -> bitset_t
    
    @param _idx: size_t

ida_hexrays.array_of_bitsets.begin (method)
    begin(self) -> bitset_t

ida_hexrays.array_of_bitsets.capacity (method)
    capacity(self) -> size_t

ida_hexrays.array_of_bitsets.clear (method)
    clear(self)

ida_hexrays.array_of_bitsets.empty (method)
    empty(self) -> bool

ida_hexrays.array_of_bitsets.end (method)
    end(self) -> bitset_t

ida_hexrays.array_of_bitsets.erase (method)
    erase(self, it) -> bitset_t
    
    @param it: qvector< bitset_t >::iterator
    
    erase(self, first, last) -> bitset_t
    
    @param first: qvector< bitset_t >::iterator
    @param last: qvector< bitset_t >::iterator

ida_hexrays.array_of_bitsets.extract (method)
    extract(self) -> bitset_t

ida_hexrays.array_of_bitsets.find (method)
    find(self, x) -> bitset_t
    
    @param x: bitset_t const &

ida_hexrays.array_of_bitsets.grow (method)
    grow(self, x=bitset_t())
    
    @param x: bitset_t const &

ida_hexrays.array_of_bitsets.has (method)
    has(self, x) -> bool
    
    @param x: bitset_t const &

ida_hexrays.array_of_bitsets.inject (method)
    inject(self, s, len)
    
    @param s: bitset_t *
    @param len: size_t

ida_hexrays.array_of_bitsets.insert (method)
    insert(self, it, x) -> bitset_t
    
    @param it: qvector< bitset_t >::iterator
    @param x: bitset_t const &

ida_hexrays.array_of_bitsets.pop_back (method)
    pop_back(self)

ida_hexrays.array_of_bitsets.push_back (method)
    push_back(self, x)
    
    @param x: bitset_t const &
    
    push_back(self) -> bitset_t

ida_hexrays.array_of_bitsets.qclear (method)
    qclear(self)

ida_hexrays.array_of_bitsets.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.array_of_bitsets.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: bitset_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.array_of_bitsets.size (method)
    size(self) -> size_t

ida_hexrays.array_of_bitsets.swap (method)
    swap(self, r)
    
    @param r: qvector< bitset_t > &

ida_hexrays.array_of_bitsets.truncate (method)
    truncate(self)

ida_hexrays.array_of_ivlsets (class)
    Proxy of C++ qvector< ivlset_t > class.

ida_hexrays.array_of_ivlsets.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< ivlset_t > const &

ida_hexrays.array_of_ivlsets.__getitem__ (method)
    __getitem__(self, i) -> ivlset_t
    
    @param i: size_t

ida_hexrays.array_of_ivlsets.__init__ (method)
    __init__(self) -> array_of_ivlsets
    __init__(self, x) -> array_of_ivlsets
    
    @param x: qvector< ivlset_t > const &

ida_hexrays.array_of_ivlsets.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.array_of_ivlsets.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< ivlset_t > const &

ida_hexrays.array_of_ivlsets.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: ivlset_t const &

ida_hexrays.array_of_ivlsets._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: ivlset_t const &

ida_hexrays.array_of_ivlsets.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: ivlset_t const &

ida_hexrays.array_of_ivlsets.at (method)
    at(self, _idx) -> ivlset_t
    
    @param _idx: size_t

ida_hexrays.array_of_ivlsets.begin (method)
    begin(self) -> ivlset_t

ida_hexrays.array_of_ivlsets.capacity (method)
    capacity(self) -> size_t

ida_hexrays.array_of_ivlsets.clear (method)
    clear(self)

ida_hexrays.array_of_ivlsets.empty (method)
    empty(self) -> bool

ida_hexrays.array_of_ivlsets.end (method)
    end(self) -> ivlset_t

ida_hexrays.array_of_ivlsets.erase (method)
    erase(self, it) -> ivlset_t
    
    @param it: qvector< ivlset_t >::iterator
    
    erase(self, first, last) -> ivlset_t
    
    @param first: qvector< ivlset_t >::iterator
    @param last: qvector< ivlset_t >::iterator

ida_hexrays.array_of_ivlsets.extract (method)
    extract(self) -> ivlset_t

ida_hexrays.array_of_ivlsets.find (method)
    find(self, x) -> ivlset_t
    
    @param x: ivlset_t const &

ida_hexrays.array_of_ivlsets.grow (method)
    grow(self, x=ivlset_t())
    
    @param x: ivlset_t const &

ida_hexrays.array_of_ivlsets.has (method)
    has(self, x) -> bool
    
    @param x: ivlset_t const &

ida_hexrays.array_of_ivlsets.inject (method)
    inject(self, s, len)
    
    @param s: ivlset_t *
    @param len: size_t

ida_hexrays.array_of_ivlsets.insert (method)
    insert(self, it, x) -> ivlset_t
    
    @param it: qvector< ivlset_t >::iterator
    @param x: ivlset_t const &

ida_hexrays.array_of_ivlsets.pop_back (method)
    pop_back(self)

ida_hexrays.array_of_ivlsets.push_back (method)
    push_back(self, x)
    
    @param x: ivlset_t const &
    
    push_back(self) -> ivlset_t

ida_hexrays.array_of_ivlsets.qclear (method)
    qclear(self)

ida_hexrays.array_of_ivlsets.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.array_of_ivlsets.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: ivlset_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.array_of_ivlsets.size (method)
    size(self) -> size_t

ida_hexrays.array_of_ivlsets.swap (method)
    swap(self, r)
    
    @param r: qvector< ivlset_t > &

ida_hexrays.array_of_ivlsets.truncate (method)
    truncate(self)

ida_hexrays.asgop (function)
    asgop(cop) -> ctype_t
    Convert plain operator into assignment operator. For example, cot_add returns
    cot_asgadd.
    
    @param cop: (C++: ctype_t) enum ctype_t

ida_hexrays.asgop_revert (function)
    asgop_revert(cop) -> ctype_t
    Convert assignment operator into plain operator. For example, cot_asgadd returns
    cot_add
    
    @param cop: (C++: ctype_t) enum ctype_t
    @return: cot_empty is the input operator is not an assignment operator.

ida_hexrays.bit_bound_t (class)
    Proxy of C++ bit_bound_t class.

ida_hexrays.bit_bound_t.__init__ (method)
    __init__(self, n=0, s=0) -> bit_bound_t
    
    @param n: int
    @param s: int

ida_hexrays.bitset_t (class)
    Proxy of C++ bitset_t class.

ida_hexrays.bitset_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.__init__ (method)
    __init__(self) -> bitset_t
    __init__(self, m) -> bitset_t
    
    @param m: bitset_t const &

ida_hexrays.bitset_t.__iter__ (method)

ida_hexrays.bitset_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.add (method)
    add(self, bit) -> bool
    
    @param bit: int
    
    add(self, bit, width) -> bool
    
    @param bit: int
    @param width: int
    
    add(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.back (method)
    back(self) -> int

ida_hexrays.bitset_t.begin (method)
    begin(self) -> iterator

ida_hexrays.bitset_t.clear (method)
    clear(self)

ida_hexrays.bitset_t.compare (method)
    compare(self, r) -> int
    
    @param r: bitset_t const &

ida_hexrays.bitset_t.copy (method)
    copy(self, m) -> bitset_t
    
    @param m: bitset_t const &

ida_hexrays.bitset_t.count (method)
    count(self) -> int
    count(self, bit) -> int
    
    @param bit: int

ida_hexrays.bitset_t.cut_at (method)
    cut_at(self, maxbit) -> bool
    
    @param maxbit: int

ida_hexrays.bitset_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.bitset_t.empty (method)
    empty(self) -> bool

ida_hexrays.bitset_t.end (method)
    end(self) -> iterator

ida_hexrays.bitset_t.fill_with_ones (method)
    fill_with_ones(self, maxbit)
    
    @param maxbit: int

ida_hexrays.bitset_t.front (method)
    front(self) -> int

ida_hexrays.bitset_t.has (method)
    has(self, bit) -> bool
    
    @param bit: int

ida_hexrays.bitset_t.has_all (method)
    has_all(self, bit, width) -> bool
    
    @param bit: int
    @param width: int

ida_hexrays.bitset_t.has_any (method)
    has_any(self, bit, width) -> bool
    
    @param bit: int
    @param width: int

ida_hexrays.bitset_t.has_common (method)
    has_common(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.inc (method)
    inc(self, p, n=1)
    
    @param p: bitset_t::iterator &
    @param n: int

ida_hexrays.bitset_t.includes (method)
    includes(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.intersect (method)
    intersect(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.is_subset_of (method)
    is_subset_of(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.itat (method)
    itat(self, n) -> iterator
    
    @param n: int

ida_hexrays.bitset_t.itv (method)
    itv(self, it) -> int
    
    @param it: bitset_t::const_iterator

ida_hexrays.bitset_t.last (method)
    last(self) -> int

ida_hexrays.bitset_t.shift_down (method)
    shift_down(self, shift)
    
    @param shift: int

ida_hexrays.bitset_t.sub (method)
    sub(self, bit) -> bool
    
    @param bit: int
    
    sub(self, bit, width) -> bool
    
    @param bit: int
    @param width: int
    
    sub(self, ml) -> bool
    
    @param ml: bitset_t const &

ida_hexrays.bitset_t.swap (method)
    swap(self, r)
    
    @param r: bitset_t &

ida_hexrays.block_chains_begin (function)
    block_chains_begin(set) -> block_chains_iterator_t
    Get iterator pointing to the beginning of block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *

ida_hexrays.block_chains_clear (function)
    block_chains_clear(set)
    Clear block_chains_t.
    
    @param set: (C++: block_chains_t *)

ida_hexrays.block_chains_end (function)
    block_chains_end(set) -> block_chains_iterator_t
    Get iterator pointing to the end of block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *

ida_hexrays.block_chains_erase (function)
    block_chains_erase(set, p)
    Erase current element from block_chains_t.
    
    @param set: (C++: block_chains_t *)
    @param p: (C++: block_chains_iterator_t)

ida_hexrays.block_chains_find (function)
    block_chains_find(set, val) -> block_chains_iterator_t
    Find the specified key in set block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *
    @param val: (C++: const chain_t &) chain_t const &

ida_hexrays.block_chains_free (function)
    block_chains_free(set)
    Delete block_chains_t instance.
    
    @param set: (C++: block_chains_t *)

ida_hexrays.block_chains_get (function)
    block_chains_get(p) -> chain_t
    Get reference to the current set value.
    
    @param p: (C++: block_chains_iterator_t)

ida_hexrays.block_chains_insert (function)
    block_chains_insert(set, val) -> block_chains_iterator_t
    Insert new (chain_t) into set block_chains_t.
    
    @param set: (C++: block_chains_t *)
    @param val: (C++: const chain_t &) chain_t const &

ida_hexrays.block_chains_iterator_t (class)
    Proxy of C++ block_chains_iterator_t class.

ida_hexrays.block_chains_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: block_chains_iterator_t const &

ida_hexrays.block_chains_iterator_t.__init__ (method)
    __init__(self) -> block_chains_iterator_t

ida_hexrays.block_chains_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: block_chains_iterator_t const &

ida_hexrays.block_chains_new (function)
    block_chains_new() -> block_chains_t
    Create a new block_chains_t instance.

ida_hexrays.block_chains_next (function)
    block_chains_next(p) -> block_chains_iterator_t
    Move to the next element.
    
    @param p: (C++: block_chains_iterator_t)

ida_hexrays.block_chains_prev (function)
    block_chains_prev(p) -> block_chains_iterator_t
    Move to the previous element.
    
    @param p: (C++: block_chains_iterator_t)

ida_hexrays.block_chains_size (function)
    block_chains_size(set) -> size_t
    Get size of block_chains_t.
    
    @param set: (C++: block_chains_t *)

ida_hexrays.block_chains_t (class)
    Proxy of C++ block_chains_t class.

ida_hexrays.block_chains_t.__init__ (method)
    __init__(self) -> block_chains_t

ida_hexrays.block_chains_t._print (method)
    _print(self)

ida_hexrays.block_chains_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.block_chains_t.get_chain (method)
    get_chain(self, k, width=1) -> chain_t
    
    @param k: voff_t const &
    @param width: int
    
    get_chain(self, ch) -> chain_t
    
    @param ch: chain_t const &

ida_hexrays.block_chains_t.get_reg_chain (method)
    get_reg_chain(self, reg, width=1) -> chain_t
    
    @param reg: mreg_t
    @param width: int

ida_hexrays.block_chains_t.get_stk_chain (method)
    get_stk_chain(self, off, width=1) -> chain_t
    
    @param off: sval_t
    @param width: int

ida_hexrays.block_chains_vec_t (class)
    Proxy of C++ qvector< block_chains_t > class.

ida_hexrays.block_chains_vec_t.__getitem__ (method)
    __getitem__(self, i) -> block_chains_t
    
    @param i: size_t

ida_hexrays.block_chains_vec_t.__init__ (method)
    __init__(self) -> block_chains_vec_t
    __init__(self, x) -> block_chains_vec_t
    
    @param x: qvector< block_chains_t > const &

ida_hexrays.block_chains_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.block_chains_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: block_chains_t const &

ida_hexrays.block_chains_vec_t.at (method)
    at(self, _idx) -> block_chains_t
    
    @param _idx: size_t

ida_hexrays.block_chains_vec_t.begin (method)
    begin(self) -> block_chains_t

ida_hexrays.block_chains_vec_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.block_chains_vec_t.clear (method)
    clear(self)

ida_hexrays.block_chains_vec_t.empty (method)
    empty(self) -> bool

ida_hexrays.block_chains_vec_t.end (method)
    end(self) -> block_chains_t

ida_hexrays.block_chains_vec_t.erase (method)
    erase(self, it) -> block_chains_t
    
    @param it: qvector< block_chains_t >::iterator
    
    erase(self, first, last) -> block_chains_t
    
    @param first: qvector< block_chains_t >::iterator
    @param last: qvector< block_chains_t >::iterator

ida_hexrays.block_chains_vec_t.extract (method)
    extract(self) -> block_chains_t

ida_hexrays.block_chains_vec_t.grow (method)
    grow(self, x=block_chains_t())
    
    @param x: block_chains_t const &

ida_hexrays.block_chains_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: block_chains_t *
    @param len: size_t

ida_hexrays.block_chains_vec_t.insert (method)
    insert(self, it, x) -> block_chains_t
    
    @param it: qvector< block_chains_t >::iterator
    @param x: block_chains_t const &

ida_hexrays.block_chains_vec_t.pop_back (method)
    pop_back(self)

ida_hexrays.block_chains_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: block_chains_t const &
    
    push_back(self) -> block_chains_t

ida_hexrays.block_chains_vec_t.qclear (method)
    qclear(self)

ida_hexrays.block_chains_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.block_chains_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: block_chains_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.block_chains_vec_t.size (method)
    size(self) -> size_t

ida_hexrays.block_chains_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< block_chains_t > &

ida_hexrays.block_chains_vec_t.truncate (method)
    truncate(self)

ida_hexrays.boundaries_begin (function)
    boundaries_begin(map) -> boundaries_iterator_t
    Get iterator pointing to the beginning of boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *

ida_hexrays.boundaries_clear (function)
    boundaries_clear(map)
    Clear boundaries_t.
    
    @param map: (C++: boundaries_t *)

ida_hexrays.boundaries_end (function)
    boundaries_end(map) -> boundaries_iterator_t
    Get iterator pointing to the end of boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *

ida_hexrays.boundaries_erase (function)
    boundaries_erase(map, p)
    Erase current element from boundaries_t.
    
    @param map: (C++: boundaries_t *)
    @param p: (C++: boundaries_iterator_t)

ida_hexrays.boundaries_find (function)
    boundaries_find(map, key) -> boundaries_iterator_t
    Find the specified key in boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *
    @param key: (C++: const cinsn_t *&) cinsn_t const *

ida_hexrays.boundaries_first (function)
    boundaries_first(p) -> cinsn_t
    Get reference to the current map key.
    
    @param p: (C++: boundaries_iterator_t)

ida_hexrays.boundaries_free (function)
    boundaries_free(map)
    Delete boundaries_t instance.
    
    @param map: (C++: boundaries_t *)

ida_hexrays.boundaries_insert (function)
    boundaries_insert(map, key, val) -> boundaries_iterator_t
    Insert new (cinsn_t *, rangeset_t) pair into boundaries_t.
    
    @param map: (C++: boundaries_t *)
    @param key: (C++: const cinsn_t *&) cinsn_t const *
    @param val: (C++: const rangeset_t &) rangeset_t const &

ida_hexrays.boundaries_iterator_t (class)
    Proxy of C++ boundaries_iterator_t class.

ida_hexrays.boundaries_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: boundaries_iterator_t const &

ida_hexrays.boundaries_iterator_t.__init__ (method)
    __init__(self) -> boundaries_iterator_t

ida_hexrays.boundaries_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: boundaries_iterator_t const &

ida_hexrays.boundaries_new (function)
    boundaries_new() -> boundaries_t
    Create a new boundaries_t instance.

ida_hexrays.boundaries_next (function)
    boundaries_next(p) -> boundaries_iterator_t
    Move to the next element.
    
    @param p: (C++: boundaries_iterator_t)

ida_hexrays.boundaries_prev (function)
    boundaries_prev(p) -> boundaries_iterator_t
    Move to the previous element.
    
    @param p: (C++: boundaries_iterator_t)

ida_hexrays.boundaries_second (function)
    boundaries_second(p) -> rangeset_t
    Get reference to the current map value.
    
    @param p: (C++: boundaries_iterator_t)

ida_hexrays.boundaries_size (function)
    boundaries_size(map) -> size_t
    Get size of boundaries_t.
    
    @param map: (C++: boundaries_t *)

ida_hexrays.boundaries_t (class)
    Proxy of C++ std::map< cinsn_t *,rangeset_t > class.

ida_hexrays.boundaries_t.__init__ (method)
    __init__(self) -> boundaries_t

ida_hexrays.boundaries_t.at (method)
    at(self, _Keyval) -> rangeset_t
    
    @param _Keyval: cinsn_t *const &

ida_hexrays.boundaries_t.size (method)
    size(self) -> size_t

ida_hexrays.call_helper (function)
    Create a helper call.

ida_hexrays.carg_t (class)
    Proxy of C++ carg_t class.

ida_hexrays.carg_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.__init__ (method)
    __init__(self) -> carg_t

ida_hexrays.carg_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: carg_t const &

ida_hexrays.carg_t.compare (method)
    compare(self, r) -> int
    
    @param r: carg_t const &

ida_hexrays.carg_t.consume_cexpr (method)
    consume_cexpr(self, e)
    
    @param e: cexpr_t *

ida_hexrays.carg_t.formal_type (variable)
    formal parameter type (if known)

ida_hexrays.carg_t.is_vararg (variable)
    is a vararg (matches ...)

ida_hexrays.carglist_t (class)
    Proxy of C++ carglist_t class.

ida_hexrays.carglist_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.__init__ (method)
    __init__(self) -> carglist_t
    __init__(self, ftype, fl=0) -> carglist_t
    
    @param ftype: tinfo_t const &
    @param fl: int

ida_hexrays.carglist_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.compare (method)
    compare(self, r) -> int
    
    @param r: carglist_t const &

ida_hexrays.carglist_t.flags (variable)
    call flags

ida_hexrays.carglist_t.functype (variable)
    function object type

ida_hexrays.casm_t (class)
    Proxy of C++ casm_t class.

ida_hexrays.casm_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.__init__ (method)
    __init__(self, ea) -> casm_t
    
    @param ea: ea_t
    
    __init__(self, r) -> casm_t
    
    @param r: casm_t const &

ida_hexrays.casm_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: casm_t const &

ida_hexrays.casm_t.compare (method)
    compare(self, r) -> int
    
    @param r: casm_t const &

ida_hexrays.casm_t.one_insn (method)
    one_insn(self) -> bool

ida_hexrays.cblock_t (class)
    Proxy of C++ cblock_t class.

ida_hexrays.cblock_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t.__init__ (method)
    __init__(self) -> cblock_t

ida_hexrays.cblock_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cblock_t const &

ida_hexrays.cblock_t._deregister (method)
    _deregister(self)

ida_hexrays.cblock_t.compare (method)
    compare(self, r) -> int
    
    @param r: cblock_t const &

ida_hexrays.ccase_t (class)
    Proxy of C++ ccase_t class.

ida_hexrays.ccase_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.__init__ (method)
    __init__(self) -> ccase_t

ida_hexrays.ccase_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.compare (method)
    compare(self, r) -> int
    
    @param r: ccase_t const &

ida_hexrays.ccase_t.size (method)
    size(self) -> size_t

ida_hexrays.ccase_t.value (method)
    value(self, i) -> uint64 const &
    
    @param i: int

ida_hexrays.ccase_t.values (variable)
    List of case values. if empty, then 'default' case

ida_hexrays.ccases_t (class)
    Proxy of C++ ccases_t class.

ida_hexrays.ccases_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.__init__ (method)
    __init__(self) -> ccases_t

ida_hexrays.ccases_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ccases_t const &

ida_hexrays.ccases_t.compare (method)
    compare(self, r) -> int
    
    @param r: ccases_t const &

ida_hexrays.cdg_insn_iterator_t (class)
    Proxy of C++ cdg_insn_iterator_t class.

ida_hexrays.cdg_insn_iterator_t.__init__ (method)
    __init__(self, mba_) -> cdg_insn_iterator_t
    
    @param mba_: mba_t const *
    
    __init__(self, r) -> cdg_insn_iterator_t
    
    @param r: cdg_insn_iterator_t const &

ida_hexrays.cdg_insn_iterator_t.dslot_with_xrefs (method)
    dslot_with_xrefs(self) -> bool

ida_hexrays.cdg_insn_iterator_t.has_dslot (method)
    has_dslot(self) -> bool

ida_hexrays.cdg_insn_iterator_t.is_severed_dslot (method)
    is_severed_dslot(self) -> bool

ida_hexrays.cdg_insn_iterator_t.next (method)
    next(self, ins) -> merror_t
    
    @param ins: insn_t *

ida_hexrays.cdg_insn_iterator_t.ok (method)
    ok(self) -> bool

ida_hexrays.cdg_insn_iterator_t.start (method)
    start(self, rng)
    
    @param rng: range_t const &

ida_hexrays.cdo_t (class)
    Proxy of C++ cdo_t class.

ida_hexrays.cdo_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.__init__ (method)
    __init__(self) -> cdo_t

ida_hexrays.cdo_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cdo_t const &

ida_hexrays.cdo_t.compare (method)
    compare(self, r) -> int
    
    @param r: cdo_t const &

ida_hexrays.ceinsn_t (class)
    Proxy of C++ ceinsn_t class.

ida_hexrays.ceinsn_t.__init__ (method)
    __init__(self) -> ceinsn_t

ida_hexrays.ceinsn_t.expr (variable)
    Expression of the statement.

ida_hexrays.cexpr_operands (function)
    return a dictionary with the operands of a cexpr_t. 

ida_hexrays.cexpr_t (class)
    Proxy of C++ cexpr_t class.

ida_hexrays.cexpr_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__init__ (method)
    __init__(self) -> cexpr_t
    __init__(self, cexpr_op, _x, _y=None, _z=None) -> cexpr_t
    
    @param cexpr_op: enum ctype_t
    @param _x: cexpr_t *
    @param _y: cexpr_t *
    @param _z: cexpr_t *
    
    __init__(self, r) -> cexpr_t
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t._deregister (method)
    _deregister(self)

ida_hexrays.cexpr_t._get_a (method)
    _get_a(self) -> carglist_t

ida_hexrays.cexpr_t._get_fpc (method)
    _get_fpc(self) -> fnumber_t

ida_hexrays.cexpr_t._get_helper (method)
    _get_helper(self) -> char const *

ida_hexrays.cexpr_t._get_insn (method)
    _get_insn(self) -> cinsn_t

ida_hexrays.cexpr_t._get_m (method)
    _get_m(self) -> int

ida_hexrays.cexpr_t._get_n (method)
    _get_n(self) -> cnumber_t

ida_hexrays.cexpr_t._get_obj_ea (method)
    _get_obj_ea(self) -> ea_t

ida_hexrays.cexpr_t._get_ptrsize (method)
    _get_ptrsize(self) -> int

ida_hexrays.cexpr_t._get_refwidth (method)
    _get_refwidth(self) -> int

ida_hexrays.cexpr_t._get_string (method)
    _get_string(self) -> char const *

ida_hexrays.cexpr_t._get_x (method)
    _get_x(self) -> cexpr_t

ida_hexrays.cexpr_t._get_y (method)
    _get_y(self) -> cexpr_t

ida_hexrays.cexpr_t._get_z (method)
    _get_z(self) -> cexpr_t

ida_hexrays.cexpr_t._register (method)
    _register(self)

ida_hexrays.cexpr_t._replace_by (method)
    _replace_by(self, r)
    
    Parameters
    ----------
    r: cexpr_t *

ida_hexrays.cexpr_t._set_a (method)
    _set_a(self, _v)
    
    Parameters
    ----------
    _v: carglist_t *

ida_hexrays.cexpr_t._set_fpc (method)
    _set_fpc(self, _v)
    
    Parameters
    ----------
    _v: fnumber_t *

ida_hexrays.cexpr_t._set_helper (method)
    _set_helper(self, _v)
    
    Parameters
    ----------
    _v: char const *

ida_hexrays.cexpr_t._set_insn (method)
    _set_insn(self, _v)
    
    Parameters
    ----------
    _v: cinsn_t *

ida_hexrays.cexpr_t._set_m (method)
    _set_m(self, _v)
    
    Parameters
    ----------
    _v: int

ida_hexrays.cexpr_t._set_n (method)
    _set_n(self, _v)
    
    Parameters
    ----------
    _v: cnumber_t *

ida_hexrays.cexpr_t._set_obj_ea (method)
    _set_obj_ea(self, _v)
    
    Parameters
    ----------
    _v: ea_t

ida_hexrays.cexpr_t._set_ptrsize (method)
    _set_ptrsize(self, _v)
    
    Parameters
    ----------
    _v: int

ida_hexrays.cexpr_t._set_refwidth (method)
    _set_refwidth(self, _v)
    
    Parameters
    ----------
    _v: int

ida_hexrays.cexpr_t._set_string (method)
    _set_string(self, _v)
    
    Parameters
    ----------
    _v: char const *

ida_hexrays.cexpr_t._set_x (method)
    _set_x(self, _v)
    
    Parameters
    ----------
    _v: cexpr_t *

ida_hexrays.cexpr_t._set_y (method)
    _set_y(self, _v)
    
    Parameters
    ----------
    _v: cexpr_t *

ida_hexrays.cexpr_t._set_z (method)
    _set_z(self, _v)
    
    Parameters
    ----------
    _v: cexpr_t *

ida_hexrays.cexpr_t.a (variable)
    argument list (used for cot_call)

ida_hexrays.cexpr_t.assign (method)
    assign(self, r) -> cexpr_t
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.calc_type (method)
    calc_type(self, recursive)
    Calculate the type of the expression. Use this function to calculate the
    expression type when a new expression is built
    
    @param recursive: (C++: bool) if true, types of all children expression will be calculated
                      before calculating our type

ida_hexrays.cexpr_t.cleanup (method)
    cleanup(self)
    Cleanup the expression. This function properly deletes all children and sets the
    item type to cot_empty.

ida_hexrays.cexpr_t.compare (method)
    compare(self, r) -> int
    
    @param r: cexpr_t const &

ida_hexrays.cexpr_t.contains_comma (method)
    contains_comma(self, times=1) -> bool
    Does the expression contain a comma operator?
    
    @param times: (C++: int)

ida_hexrays.cexpr_t.contains_comma_or_insn_or_label (method)
    contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
    Does the expression contain a comma operator or an embedded statement operator
    or a label?
    
    @param maxcommas: (C++: int)

ida_hexrays.cexpr_t.contains_insn (method)
    contains_insn(self, times=1) -> bool
    Does the expression contain an embedded statement operator?
    
    @param times: (C++: int)

ida_hexrays.cexpr_t.contains_insn_or_label (method)
    contains_insn_or_label(self) -> bool
    Does the expression contain an embedded statement operator or a label?

ida_hexrays.cexpr_t.contains_operator (method)
    contains_operator(self, needed_op, times=1) -> bool
    Check if the expression contains the specified operator.
    
    @param needed_op: (C++: ctype_t) operator code to search for
    @param times: (C++: int) how many times the operator code should be present
    @return: true if the expression has at least TIMES children with NEEDED_OP

ida_hexrays.cexpr_t.cpadone (method)
    cpadone(self) -> bool
    Pointer arithmetic correction done for this expression?

ida_hexrays.cexpr_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.cexpr_t.equal_effect (method)
    equal_effect(self, r) -> bool
    Compare two expressions. This function tries to compare two expressions in an
    'intelligent' manner. For example, it knows about commutitive operators and can
    ignore useless casts.
    
    @param r: (C++: const cexpr_t &) the expression to compare against the current expression
    @return: true expressions can be considered equal

ida_hexrays.cexpr_t.exflags (variable)
    Expression attributes

ida_hexrays.cexpr_t.find_num_op (method)
    find_num_op(self) -> cexpr_t

ida_hexrays.cexpr_t.find_op (method)
    find_op(self, _op) -> cexpr_t
    
    @param _op: enum ctype_t

ida_hexrays.cexpr_t.fpc (variable)
    used for cot_fnum

ida_hexrays.cexpr_t.get_1num_op (method)
    get_1num_op(self, o1, o2) -> bool
    
    @param o1: cexpr_t **
    @param o2: cexpr_t **

ida_hexrays.cexpr_t.get_const_value (method)
    get_const_value(self) -> bool
    Get expression value.
    
    @return: true if the expression is a number.

ida_hexrays.cexpr_t.get_high_nbit_bound (method)
    get_high_nbit_bound(self) -> bit_bound_t
    Get max number of bits that can really be used by the expression. For example, x
    % 16 can yield only 4 non-zero bits, higher bits are zero

ida_hexrays.cexpr_t.get_low_nbit_bound (method)
    get_low_nbit_bound(self) -> int
    Get min number of bits that are certainly required to represent the expression.
    For example, constant 16 always uses 5 bits: 10000.

ida_hexrays.cexpr_t.get_ptr_or_array (method)
    get_ptr_or_array(self) -> cexpr_t
    Find pointer or array child.

ida_hexrays.cexpr_t.get_type_sign (method)
    get_type_sign(self) -> type_sign_t
    Get expression sign.

ida_hexrays.cexpr_t.get_v (method)
    get_v(self) -> var_ref_t

ida_hexrays.cexpr_t.has_side_effects (method)
    has_side_effects(self) -> bool
    Check if the expression has side effects. Calls, pre/post inc/dec, and
    assignments have side effects.

ida_hexrays.cexpr_t.helper (variable)
    helper name (used for cot_helper)

ida_hexrays.cexpr_t.insn (variable)
    an embedded statement, they are prohibited at the final maturity stage
    (CMAT_FINAL)

ida_hexrays.cexpr_t.is_call_arg_of (method)
    is_call_arg_of(self, parent) -> bool
    Is call argument?
    
    @param parent: (C++: const citem_t *) citem_t const *
    @return: true if our expression is a call argument of the specified parent
             expression.

ida_hexrays.cexpr_t.is_call_object_of (method)
    is_call_object_of(self, parent) -> bool
    Is call object?
    
    @param parent: (C++: const citem_t *) citem_t const *
    @return: true if our expression is the call object of the specified parent
             expression.

ida_hexrays.cexpr_t.is_child_of (method)
    is_child_of(self, parent) -> bool
    Verify if the specified item is our parent.
    
    @param parent: (C++: const citem_t *) possible parent item
    @return: true if the specified item is our parent

ida_hexrays.cexpr_t.is_const_value (method)
    is_const_value(self, _v) -> bool
    Check if the expression is a number with the specified value.
    
    @param _v: (C++: uint64)

ida_hexrays.cexpr_t.is_cstr (method)
    is_cstr(self) -> bool

ida_hexrays.cexpr_t.is_fpop (method)
    is_fpop(self) -> bool

ida_hexrays.cexpr_t.is_jumpout (method)
    is_jumpout(self) -> bool

ida_hexrays.cexpr_t.is_negative_const (method)
    is_negative_const(self) -> bool
    Check if the expression is a negative number.

ida_hexrays.cexpr_t.is_nice_cond (method)
    is_nice_cond(self) -> bool
    Is nice condition?. Nice condition is a nice expression of the boolean type.

ida_hexrays.cexpr_t.is_nice_expr (method)
    is_nice_expr(self) -> bool
    Is nice expression? Nice expressions do not contain comma operators, embedded
    statements, or labels.

ida_hexrays.cexpr_t.is_non_negative_const (method)
    is_non_negative_const(self) -> bool
    Check if the expression is a non-negative number.

ida_hexrays.cexpr_t.is_non_zero_const (method)
    is_non_zero_const(self) -> bool
    Check if the expression is a non-zero number.

ida_hexrays.cexpr_t.is_odd_lvalue (method)
    is_odd_lvalue(self) -> bool

ida_hexrays.cexpr_t.is_type_signed (method)
    is_type_signed(self) -> bool
    Is expression signed?

ida_hexrays.cexpr_t.is_type_unsigned (method)
    is_type_unsigned(self) -> bool
    Is expression unsigned?

ida_hexrays.cexpr_t.is_undef_val (method)
    is_undef_val(self) -> bool

ida_hexrays.cexpr_t.is_vftable (method)
    is_vftable(self) -> bool

ida_hexrays.cexpr_t.is_zero_const (method)
    is_zero_const(self) -> bool
    Check if the expression is a zero.

ida_hexrays.cexpr_t.m (variable)
    member offset (used for cot_memptr, cot_memref) for unions, the member number

ida_hexrays.cexpr_t.maybe_ptr (method)
    maybe_ptr(self) -> bool
    May the expression be a pointer?

ida_hexrays.cexpr_t.n (variable)
    used for cot_num

ida_hexrays.cexpr_t.numval (method)
    numval(self) -> uint64
    Get numeric value of the expression. This function can be called only on cot_num
    expressions!

ida_hexrays.cexpr_t.obj_ea (variable)
    used for cot_obj

ida_hexrays.cexpr_t.print1 (method)
    print1(self, func)
    Print expression into one line.
    
    @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
                 variable names.

ida_hexrays.cexpr_t.ptrsize (variable)
    memory access size (used for cot_ptr, cot_memptr)

ida_hexrays.cexpr_t.put_number (method)
    put_number(self, func, value, nbytes, sign=no_sign)
    Assign a number to the expression.
    
    @param func: (C++: cfunc_t *) current function
    @param value: (C++: uint64) number value
    @param nbytes: (C++: int) size of the number in bytes
    @param sign: (C++: type_sign_t) number sign

ida_hexrays.cexpr_t.refwidth (variable)
    how many bytes are accessed? (-1: none)

ida_hexrays.cexpr_t.requires_lvalue (method)
    requires_lvalue(self, child) -> bool
    Check if the expression requires an lvalue.
    
    @param child: (C++: const cexpr_t *) The function will check if this child of our expression must be an
                  lvalue.
    @return: true if child must be an lvalue.

ida_hexrays.cexpr_t.set_cpadone (method)
    set_cpadone(self)

ida_hexrays.cexpr_t.set_v (method)
    set_v(self, v)
    
    @param v: var_ref_t const *

ida_hexrays.cexpr_t.set_vftable (method)
    set_vftable(self)

ida_hexrays.cexpr_t.string (variable)
    utf8 string constant, user representation (used for cot_str)

ida_hexrays.cexpr_t.swap (method)
    swap(self, r)
    
    @param r: cexpr_t &

ida_hexrays.cexpr_t.theother (method)
    theother(self, what) -> cexpr_t
    
    @param what: cexpr_t const *

ida_hexrays.cexpr_t.type (variable)
    expression type. must be carefully maintained

ida_hexrays.cexpr_t.v (variable)
    used for cot_var

ida_hexrays.cexpr_t.x (variable)
    the first operand of the expression

ida_hexrays.cexpr_t.y (variable)
    the second operand of the expression

ida_hexrays.cexpr_t.z (variable)
    the third operand of the expression

ida_hexrays.cfor_t (class)
    Proxy of C++ cfor_t class.

ida_hexrays.cfor_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.__init__ (method)
    __init__(self) -> cfor_t

ida_hexrays.cfor_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.compare (method)
    compare(self, r) -> int
    
    @param r: cfor_t const &

ida_hexrays.cfor_t.init (variable)
    Initialization expression.

ida_hexrays.cfor_t.step (variable)
    Step expression.

ida_hexrays.cfunc_parentee_t (class)
    Proxy of C++ cfunc_parentee_t class.

ida_hexrays.cfunc_parentee_t.__disown__ (method)

ida_hexrays.cfunc_parentee_t.__init__ (method)
    __init__(self, f, post=False) -> cfunc_parentee_t
    
    @param f: cfunc_t *
    @param post: bool

ida_hexrays.cfunc_parentee_t.calc_rvalue_type (method)
    calc_rvalue_type(self, target, e) -> bool
    Calculate rvalue type. This function tries to determine the type of the
    specified item based on its context. For example, if the current expression is
    the right side of an assignment operator, the type of its left side will be
    returned. This function can be used to determine the 'best' type of the
    specified expression.
    
    @param target: (C++: tinfo_t *) 'best' type of the expression will be returned here
    @param e: (C++: const cexpr_t *) expression to determine the desired type
    @return: false if failed

ida_hexrays.cfunc_parentee_t.func (variable)
    Pointer to current function.

ida_hexrays.cfunc_t (class)
    Proxy of C++ cfunc_t class.

ida_hexrays.cfunc_t.__init__ (method)

ida_hexrays.cfunc_t.__str__ (method)
    __str__(self) -> qstring

ida_hexrays.cfunc_t.argidx (variable)
    list of arguments (indexes into vars)

ida_hexrays.cfunc_t.body (variable)
    function body, must be a block

ida_hexrays.cfunc_t.build_c_tree (method)
    build_c_tree(self)
    Generate the function body. This function (re)generates the function body from
    the underlying microcode.

ida_hexrays.cfunc_t.del_orphan_cmts (method)
    del_orphan_cmts(self) -> int
    Delete all orphan comments. The save_user_cmts() function must be called after
    this call.

ida_hexrays.cfunc_t.entry_ea (variable)
    function entry address

ida_hexrays.cfunc_t.find_item_coords (method)
    find_item_coords(self, item, px, py) -> bool
    
    @param item: citem_t const *
    @param px: int *
    @param py: int *
    
    find_item_coords(self, item) -> PyObject *
    
    @param item: citem_t const *

ida_hexrays.cfunc_t.find_label (method)
    find_label(self, label) -> citem_t
    Find the label.
    
    @param label: (C++: int)
    @return: pointer to the ctree item with the specified label number.

ida_hexrays.cfunc_t.gather_derefs (method)
    gather_derefs(self, ci, udm=None) -> bool
    
    @param ci: ctree_item_t const &
    @param udm: udt_type_data_t *

ida_hexrays.cfunc_t.get_boundaries (method)
    get_boundaries(self) -> boundaries_t
    Get pointer to map of instruction boundaries. This function initializes the
    boundary map if not done yet.

ida_hexrays.cfunc_t.get_eamap (method)
    get_eamap(self) -> eamap_t
    Get pointer to ea->insn map. This function initializes eamap if not done yet.

ida_hexrays.cfunc_t.get_func_type (method)
    get_func_type(self, type) -> bool
    Get the function type.
    
    @param type: (C++: tinfo_t *) variable where the function type is returned
    @return: false if failure

ida_hexrays.cfunc_t.get_line_item (method)
    get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
    Get ctree item for the specified cursor position.
    
    @param line: (C++: const char *) line of decompilation text (element of sv)
    @param x: (C++: int) x cursor coordinate in the line
    @param is_ctree_line: (C++: bool) does the line belong to statement area? (if not, it is
                          assumed to belong to the declaration area)
    @param phead: (C++: ctree_item_t *) ptr to the first item on the line (used to attach block comments).
                  May be nullptr
    @param pitem: (C++: ctree_item_t *) ptr to the current item. May be nullptr
    @param ptail: (C++: ctree_item_t *) ptr to the last item on the line (used to attach indented
                  comments). May be nullptr
    @see: vdui_t::get_current_item()
    @return: false if failed to get the current item

ida_hexrays.cfunc_t.get_lvars (method)
    get_lvars(self) -> lvars_t
    Get vector of local variables.
    
    @return: pointer to the vector of local variables. If you modify this vector,
             the ctree must be regenerated in order to have correct cast operators.
             Use build_c_tree() for that. Removing lvars should be done carefully:
             all references in ctree and microcode must be corrected after that.

ida_hexrays.cfunc_t.get_pseudocode (method)
    get_pseudocode(self) -> strvec_t
    Get pointer to decompilation output: the pseudocode. This function generates
    pseudocode if not done yet.

ida_hexrays.cfunc_t.get_stkoff_delta (method)
    get_stkoff_delta(self) -> sval_t
    Get stack offset delta. The local variable stack offsets retrieved by
    v.location.stkoff() should be adjusted before being used as stack frame offsets
    in IDA.
    
    @return: the delta to apply. example: ida_stkoff = v.location.stkoff() -
             f->get_stkoff_delta()

ida_hexrays.cfunc_t.get_user_cmt (method)
    get_user_cmt(self, loc, rt) -> char const *
    Retrieve a user defined comment.
    
    @param loc: (C++: const treeloc_t &) ctree location
    @param rt: (C++: cmt_retrieval_type_t) should already retrieved comments retrieved again?
    @return: pointer to the comment string or nullptr

ida_hexrays.cfunc_t.get_user_iflags (method)
    get_user_iflags(self, loc) -> int32
    Retrieve citem iflags.
    
    @param loc: (C++: const citem_locator_t &) citem locator
    @return: ctree item iflags bits or 0

ida_hexrays.cfunc_t.get_user_union_selection (method)
    get_user_union_selection(self, ea, path) -> bool
    Retrieve a user defined union field selection.
    
    @param ea: (C++: ea_t) address
    @param path: (C++: intvec_t *) out: path describing the union selection.
    @return: pointer to the path or nullptr

ida_hexrays.cfunc_t.get_warnings (method)
    get_warnings(self) -> hexwarns_t
    Get information about decompilation warnings.
    
    @return: reference to the vector of warnings

ida_hexrays.cfunc_t.has_orphan_cmts (method)
    has_orphan_cmts(self) -> bool
    Check if there are orphan comments.

ida_hexrays.cfunc_t.hdrlines (variable)
    number of lines in the declaration area

ida_hexrays.cfunc_t.locked (method)
    locked(self) -> bool

ida_hexrays.cfunc_t.maturity (variable)
    maturity level

ida_hexrays.cfunc_t.mba (variable)
    underlying microcode

ida_hexrays.cfunc_t.numforms (variable)
    user-defined number formats.

ida_hexrays.cfunc_t.print_dcl (method)
    print_dcl(self)
    Print function prototype.

ida_hexrays.cfunc_t.print_func (method)
    print_func(self, vp)
    Print function text.
    
    @param vp: (C++: vc_printer_t &) printer helper class to receive the generated text.

ida_hexrays.cfunc_t.refcnt (variable)
    reference count to this object. use cfuncptr_t

ida_hexrays.cfunc_t.refresh_func_ctext (method)
    refresh_func_ctext(self)
    Refresh ctext after a ctree modification. This function informs the decompiler
    that ctree (body) have been modified and ctext (sv) does not correspond to it
    anymore. It also refreshes the pseudocode windows if there is any.

ida_hexrays.cfunc_t.release (method)
    release(self)

ida_hexrays.cfunc_t.remove_unused_labels (method)
    remove_unused_labels(self)
    Remove unused labels. This function checks what labels are really used by the
    function and removes the unused ones. You must call it after deleting a goto
    statement.

ida_hexrays.cfunc_t.save_user_cmts (method)
    save_user_cmts(self)
    Save user-defined comments into the database.

ida_hexrays.cfunc_t.save_user_iflags (method)
    save_user_iflags(self)
    Save user-defined iflags into the database.

ida_hexrays.cfunc_t.save_user_labels (method)
    save_user_labels(self)
    Save user-defined labels into the database.

ida_hexrays.cfunc_t.save_user_numforms (method)
    save_user_numforms(self)
    Save user-defined number formats into the database.

ida_hexrays.cfunc_t.save_user_unions (method)
    save_user_unions(self)
    Save user-defined union field selections into the database.

ida_hexrays.cfunc_t.set_user_cmt (method)
    set_user_cmt(self, loc, cmt)
    Set a user defined comment. This function stores the specified comment in the
    cfunc_t structure. The save_user_cmts() function must be called after it.
    
    @param loc: (C++: const treeloc_t &) ctree location
    @param cmt: (C++: const char *) new comment. if empty or nullptr, then an existing comment is
                deleted.

ida_hexrays.cfunc_t.set_user_iflags (method)
    set_user_iflags(self, loc, iflags)
    Set citem iflags.
    
    @param loc: (C++: const citem_locator_t &) citem locator
    @param iflags: (C++: int32) new iflags

ida_hexrays.cfunc_t.set_user_union_selection (method)
    set_user_union_selection(self, ea, path)
    Set a union field selection. The save_user_unions() function must be called
    after calling this function.
    
    @param ea: (C++: ea_t) address
    @param path: (C++: const intvec_t &) in: path describing the union selection.

ida_hexrays.cfunc_t.statebits (variable)
    current cfunc_t state. see cfunc state bits

ida_hexrays.cfunc_t.treeitems (variable)
    vector of ctree items

ida_hexrays.cfunc_t.user_cmts (variable)
    user-defined comments.

ida_hexrays.cfunc_t.user_iflags (variable)
    user-defined item flags ctree item iflags bits

ida_hexrays.cfunc_t.user_labels (variable)
    user-defined labels.

ida_hexrays.cfunc_t.user_unions (variable)
    user-defined union field selections.

ida_hexrays.cfunc_t.verify (method)
    verify(self, aul, even_without_debugger)
    Verify the ctree. This function verifies the ctree. If the ctree is malformed,
    an internal error is generated. Use it to verify the ctree after your
    modifications.
    
    @param aul: (C++: allow_unused_labels_t) Are unused labels acceptable?
    @param even_without_debugger: (C++: bool) if false and there is no debugger, the
                                  verification will be skipped

ida_hexrays.cfunc_type (function)
    Get the function's return type tinfo_t object. 

ida_hexrays.cfuncptr_t (class)
    Proxy of C++ qrefcnt_t< cfunc_t > class.

ida_hexrays.cfuncptr_t.__deref__ (method)
    __deref__(self) -> cfunc_t

ida_hexrays.cfuncptr_t.__init__ (method)
    __init__(self, p) -> cfuncptr_t
    
    @param p: cfunc_t *
    
    __init__(self, r) -> cfuncptr_t
    
    @param r: qrefcnt_t< cfunc_t > const &

ida_hexrays.cfuncptr_t.__ptrval__ (method)
    __ptrval__(self) -> size_t

ida_hexrays.cfuncptr_t.__ref__ (method)
    __ref__(self) -> cfunc_t

ida_hexrays.cfuncptr_t.__str__ (method)
    __str__(self) -> qstring

ida_hexrays.cfuncptr_t.build_c_tree (method)
    build_c_tree(self)

ida_hexrays.cfuncptr_t.del_orphan_cmts (method)
    del_orphan_cmts(self) -> int

ida_hexrays.cfuncptr_t.find_item_coords (method)
    find_item_coords(self, item, px, py) -> bool
    
    @param item: citem_t const *
    @param px: int *
    @param py: int *
    
    find_item_coords(self, item) -> (int, int), bool
    
    @param item: citem_t const *

ida_hexrays.cfuncptr_t.find_label (method)
    find_label(self, label) -> citem_t
    
    @param label: int

ida_hexrays.cfuncptr_t.gather_derefs (method)
    gather_derefs(self, ci, udm=None) -> bool
    
    @param ci: ctree_item_t const &
    @param udm: udt_type_data_t *

ida_hexrays.cfuncptr_t.get_boundaries (method)
    get_boundaries(self) -> boundaries_t

ida_hexrays.cfuncptr_t.get_eamap (method)
    get_eamap(self) -> eamap_t

ida_hexrays.cfuncptr_t.get_func_type (method)
    get_func_type(self, type) -> bool
    
    @param type: tinfo_t *

ida_hexrays.cfuncptr_t.get_line_item (method)
    get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
    
    @param line: char const *
    @param x: int
    @param is_ctree_line: bool
    @param phead: ctree_item_t *
    @param pitem: ctree_item_t *
    @param ptail: ctree_item_t *

ida_hexrays.cfuncptr_t.get_lvars (method)
    get_lvars(self) -> lvars_t

ida_hexrays.cfuncptr_t.get_pseudocode (method)
    get_pseudocode(self) -> strvec_t

ida_hexrays.cfuncptr_t.get_stkoff_delta (method)
    get_stkoff_delta(self) -> sval_t

ida_hexrays.cfuncptr_t.get_user_cmt (method)
    get_user_cmt(self, loc, rt) -> char const *
    
    @param loc: treeloc_t const &
    @param rt: enum cmt_retrieval_type_t

ida_hexrays.cfuncptr_t.get_user_iflags (method)
    get_user_iflags(self, loc) -> int32
    
    @param loc: citem_locator_t const &

ida_hexrays.cfuncptr_t.get_user_union_selection (method)
    get_user_union_selection(self, ea, path) -> bool
    
    @param ea: ea_t
    @param path: intvec_t *

ida_hexrays.cfuncptr_t.get_warnings (method)
    get_warnings(self) -> hexwarns_t

ida_hexrays.cfuncptr_t.has_orphan_cmts (method)
    has_orphan_cmts(self) -> bool

ida_hexrays.cfuncptr_t.locked (method)
    locked(self) -> bool

ida_hexrays.cfuncptr_t.print_dcl (method)
    print_dcl(self)

ida_hexrays.cfuncptr_t.print_func (method)
    print_func(self, vp)
    
    @param vp: vc_printer_t &

ida_hexrays.cfuncptr_t.refresh_func_ctext (method)
    refresh_func_ctext(self)

ida_hexrays.cfuncptr_t.release (method)
    release(self)

ida_hexrays.cfuncptr_t.remove_unused_labels (method)
    remove_unused_labels(self)

ida_hexrays.cfuncptr_t.reset (method)
    reset(self)

ida_hexrays.cfuncptr_t.save_user_cmts (method)
    save_user_cmts(self)

ida_hexrays.cfuncptr_t.save_user_iflags (method)
    save_user_iflags(self)

ida_hexrays.cfuncptr_t.save_user_labels (method)
    save_user_labels(self)

ida_hexrays.cfuncptr_t.save_user_numforms (method)
    save_user_numforms(self)

ida_hexrays.cfuncptr_t.save_user_unions (method)
    save_user_unions(self)

ida_hexrays.cfuncptr_t.set_user_cmt (method)
    set_user_cmt(self, loc, cmt)
    
    @param loc: treeloc_t const &
    @param cmt: char const *

ida_hexrays.cfuncptr_t.set_user_iflags (method)
    set_user_iflags(self, loc, iflags)
    
    @param loc: citem_locator_t const &
    @param iflags: int32

ida_hexrays.cfuncptr_t.set_user_union_selection (method)
    set_user_union_selection(self, ea, path)
    
    @param ea: ea_t
    @param path: intvec_t const &

ida_hexrays.cfuncptr_t.verify (method)
    verify(self, aul, even_without_debugger)
    
    @param aul: enum allow_unused_labels_t
    @param even_without_debugger: bool

ida_hexrays.cgoto_t (class)
    Proxy of C++ cgoto_t class.

ida_hexrays.cgoto_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.__init__ (method)
    __init__(self) -> cgoto_t

ida_hexrays.cgoto_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.compare (method)
    compare(self, r) -> int
    
    @param r: cgoto_t const &

ida_hexrays.cgoto_t.label_num (variable)
    Target label number.

ida_hexrays.chain_keeper_t (class)
    Proxy of C++ chain_keeper_t class.

ida_hexrays.chain_keeper_t.__init__ (method)
    __init__(self, _gc) -> chain_keeper_t
    
    @param _gc: graph_chains_t *

ida_hexrays.chain_keeper_t.back (method)
    back(self) -> block_chains_t

ida_hexrays.chain_keeper_t.for_all_chains (method)
    for_all_chains(self, cv, gca) -> int
    
    @param cv: chain_visitor_t &
    @param gca: int

ida_hexrays.chain_keeper_t.front (method)
    front(self) -> block_chains_t

ida_hexrays.chain_t (class)
    Proxy of C++ chain_t class.

ida_hexrays.chain_t.__init__ (method)
    __init__(self) -> chain_t
    __init__(self, t, off, w=1, v=-1) -> chain_t
    
    @param t: mopt_t
    @param off: sval_t
    @param w: int
    @param v: int
    
    __init__(self, _k, w=1) -> chain_t
    
    @param _k: voff_t const &
    @param w: int

ida_hexrays.chain_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: chain_t const &

ida_hexrays.chain_t._print (method)
    _print(self)

ida_hexrays.chain_t.append_list (method)
    append_list(self, mba, list)
    Append the contents of the chain to the specified list of locations.
    
    @param mba: (C++: const mba_t *) mba_t const *
    @param list: (C++: mlist_t *)

ida_hexrays.chain_t.clear_varnum (method)
    clear_varnum(self)

ida_hexrays.chain_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.chain_t.endoff (method)
    endoff(self) -> voff_t

ida_hexrays.chain_t.flags (variable)
    combination Chain properties bits

ida_hexrays.chain_t.get_reg (method)
    get_reg(self) -> mreg_t

ida_hexrays.chain_t.get_stkoff (method)
    get_stkoff(self) -> sval_t

ida_hexrays.chain_t.includes (method)
    includes(self, r) -> bool
    
    @param r: chain_t const &

ida_hexrays.chain_t.is_fake (method)
    is_fake(self) -> bool

ida_hexrays.chain_t.is_inited (method)
    is_inited(self) -> bool

ida_hexrays.chain_t.is_overlapped (method)
    is_overlapped(self) -> bool

ida_hexrays.chain_t.is_passreg (method)
    is_passreg(self) -> bool

ida_hexrays.chain_t.is_reg (method)
    is_reg(self) -> bool

ida_hexrays.chain_t.is_replaced (method)
    is_replaced(self) -> bool

ida_hexrays.chain_t.is_stkoff (method)
    is_stkoff(self) -> bool

ida_hexrays.chain_t.is_term (method)
    is_term(self) -> bool

ida_hexrays.chain_t.key (method)
    key(self) -> voff_t

ida_hexrays.chain_t.overlap (method)
    overlap(self, r) -> bool
    
    @param r: chain_t const &

ida_hexrays.chain_t.set_inited (method)
    set_inited(self, b)
    
    @param b: bool

ida_hexrays.chain_t.set_overlapped (method)
    set_overlapped(self, b)
    
    @param b: bool

ida_hexrays.chain_t.set_replaced (method)
    set_replaced(self, b)
    
    @param b: bool

ida_hexrays.chain_t.set_term (method)
    set_term(self, b)
    
    @param b: bool

ida_hexrays.chain_t.set_value (method)
    set_value(self, r)
    
    @param r: chain_t const &

ida_hexrays.chain_t.varnum (variable)
    allocated variable index (-1 - not allocated yet)

ida_hexrays.chain_t.width (variable)
    size of the value in bytes

ida_hexrays.chain_visitor_t (class)
    Proxy of C++ chain_visitor_t class.

ida_hexrays.chain_visitor_t.__disown__ (method)

ida_hexrays.chain_visitor_t.__init__ (method)
    __init__(self) -> chain_visitor_t
    
    @param self: PyObject *

ida_hexrays.chain_visitor_t.parent (variable)
    parent of the current chain

ida_hexrays.chain_visitor_t.visit_chain (method)
    visit_chain(self, nblock, ch) -> int
    
    @param nblock: int
    @param ch: chain_t &

ida_hexrays.change_hexrays_config (function)
    change_hexrays_config(directive) -> bool
    Parse DIRECTIVE and update the current configuration variables. For the syntax
    see hexrays.cfg
    
    @param directive: (C++: const char *) char const *

ida_hexrays.checkout_hexrays_license (function)
    checkout_hexrays_license(silent) -> bool
    Check out a floating decompiler license. This function will display a dialog box
    if the license is not available. For non-floating licenses this function is
    effectively no-op. It is not necessary to call this function before decompiling.
    If the license was not checked out, the decompiler will automatically do it.
    This function can be used to check out a license in advance and ensure that a
    license is available.
    
    @param silent: (C++: bool) silently fail if the license cannot be checked out.
    @return: false if failed

ida_hexrays.cif_t (class)
    Proxy of C++ cif_t class.

ida_hexrays.cif_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.__init__ (method)
    __init__(self) -> cif_t
    __init__(self, r) -> cif_t
    
    @param r: cif_t const &

ida_hexrays.cif_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cif_t const &

ida_hexrays.cif_t.assign (method)
    assign(self, r) -> cif_t
    
    @param r: cif_t const &

ida_hexrays.cif_t.cleanup (method)
    cleanup(self)

ida_hexrays.cif_t.compare (method)
    compare(self, r) -> int
    
    @param r: cif_t const &

ida_hexrays.cif_t.ielse (variable)
    Else-branch of the if-statement. May be nullptr.

ida_hexrays.cif_t.ithen (variable)
    Then-branch of the if-statement.

ida_hexrays.cinsn_details (function)
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.

ida_hexrays.cinsn_list_t (class)
    Proxy of C++ qlist< cinsn_t > class.

ida_hexrays.cinsn_list_t.__eq__ (method)
    __eq__(self, x) -> bool
    
    @param x: qlist< cinsn_t > const &

ida_hexrays.cinsn_list_t.__getitem__ (method)
    __getitem__(self, i) -> cinsn_t
    
    @param i: size_t

ida_hexrays.cinsn_list_t.__init__ (method)
    __init__(self) -> cinsn_list_t
    __init__(self, x) -> cinsn_list_t
    
    @param x: qlist< cinsn_t > const &

ida_hexrays.cinsn_list_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.cinsn_list_t.__ne__ (method)
    __ne__(self, x) -> bool
    
    @param x: qlist< cinsn_t > const &

ida_hexrays.cinsn_list_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: cinsn_t const &

ida_hexrays.cinsn_list_t.at (method)

ida_hexrays.cinsn_list_t.back (method)
    back(self) -> cinsn_t

ida_hexrays.cinsn_list_t.begin (method)
    begin(self) -> cinsn_list_t_iterator

ida_hexrays.cinsn_list_t.clear (method)
    clear(self)

ida_hexrays.cinsn_list_t.empty (method)
    empty(self) -> bool

ida_hexrays.cinsn_list_t.end (method)
    end(self) -> cinsn_list_t_iterator

ida_hexrays.cinsn_list_t.erase (method)
    erase(self, p)
    
    @param p: cinsn_list_t_iterator

ida_hexrays.cinsn_list_t.find (method)

ida_hexrays.cinsn_list_t.front (method)
    front(self) -> cinsn_t

ida_hexrays.cinsn_list_t.index (method)

ida_hexrays.cinsn_list_t.insert (method)
    insert(self, i, v)
    
    @param i: size_t
    @param v: cinsn_t const &
    
    insert(self, p, x) -> cinsn_list_t_iterator
    
    @param p: cinsn_list_t_iterator
    @param x: cinsn_t const &

ida_hexrays.cinsn_list_t.pop_back (method)
    pop_back(self)

ida_hexrays.cinsn_list_t.pop_front (method)
    pop_front(self)

ida_hexrays.cinsn_list_t.push_back (method)
    push_back(self, x)
    
    @param x: cinsn_t const &
    
    push_back(self) -> cinsn_t

ida_hexrays.cinsn_list_t.push_front (method)
    push_front(self, x)
    
    @param x: cinsn_t const &

ida_hexrays.cinsn_list_t.rbegin (method)
    rbegin(self) -> qlist< cinsn_t >::reverse_iterator
    rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator

ida_hexrays.cinsn_list_t.remove (method)
    remove(self, v) -> bool
    
    @param v: cinsn_t const &

ida_hexrays.cinsn_list_t.rend (method)
    rend(self) -> qlist< cinsn_t >::reverse_iterator
    rend(self) -> qlist< cinsn_t >::const_reverse_iterator

ida_hexrays.cinsn_list_t.size (method)
    size(self) -> size_t

ida_hexrays.cinsn_list_t.swap (method)
    swap(self, x)
    
    @param x: qlist< cinsn_t > &

ida_hexrays.cinsn_list_t_iterator (class)
    Proxy of C++ cinsn_list_t_iterator class.

ida_hexrays.cinsn_list_t_iterator.__eq__ (method)
    __eq__(self, x) -> bool
    
    @param x: cinsn_list_t_iterator const *

ida_hexrays.cinsn_list_t_iterator.__init__ (method)
    __init__(self) -> cinsn_list_t_iterator

ida_hexrays.cinsn_list_t_iterator.__ne__ (method)
    __ne__(self, x) -> bool
    
    @param x: cinsn_list_t_iterator const *

ida_hexrays.cinsn_list_t_iterator.__next__ (method)
    __next__(self)

ida_hexrays.cinsn_t (class)
    Proxy of C++ cinsn_t class.

ida_hexrays.cinsn_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__init__ (method)
    __init__(self) -> cinsn_t
    __init__(self, r) -> cinsn_t
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t._deregister (method)
    _deregister(self)

ida_hexrays.cinsn_t._get_casm (method)
    _get_casm(self) -> casm_t

ida_hexrays.cinsn_t._get_cblock (method)
    _get_cblock(self) -> cblock_t

ida_hexrays.cinsn_t._get_cdo (method)
    _get_cdo(self) -> cdo_t

ida_hexrays.cinsn_t._get_cexpr (method)
    _get_cexpr(self) -> cexpr_t

ida_hexrays.cinsn_t._get_cfor (method)
    _get_cfor(self) -> cfor_t

ida_hexrays.cinsn_t._get_cgoto (method)
    _get_cgoto(self) -> cgoto_t

ida_hexrays.cinsn_t._get_cif (method)
    _get_cif(self) -> cif_t

ida_hexrays.cinsn_t._get_creturn (method)
    _get_creturn(self) -> creturn_t

ida_hexrays.cinsn_t._get_cswitch (method)
    _get_cswitch(self) -> cswitch_t

ida_hexrays.cinsn_t._get_cwhile (method)
    _get_cwhile(self) -> cwhile_t

ida_hexrays.cinsn_t._print (method)
    _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
    
    Parameters
    ----------
    indent: int
    vp: vc_printer_t &
    use_curly: enum use_curly_t

ida_hexrays.cinsn_t._register (method)
    _register(self)

ida_hexrays.cinsn_t._replace_by (method)
    _replace_by(self, r)
    
    Parameters
    ----------
    r: cinsn_t *

ida_hexrays.cinsn_t._set_casm (method)
    _set_casm(self, _v)
    
    Parameters
    ----------
    _v: casm_t *

ida_hexrays.cinsn_t._set_cblock (method)
    _set_cblock(self, _v)
    
    Parameters
    ----------
    _v: cblock_t *

ida_hexrays.cinsn_t._set_cdo (method)
    _set_cdo(self, _v)
    
    Parameters
    ----------
    _v: cdo_t *

ida_hexrays.cinsn_t._set_cexpr (method)
    _set_cexpr(self, _v)
    
    Parameters
    ----------
    _v: cexpr_t *

ida_hexrays.cinsn_t._set_cfor (method)
    _set_cfor(self, _v)
    
    Parameters
    ----------
    _v: cfor_t *

ida_hexrays.cinsn_t._set_cgoto (method)
    _set_cgoto(self, _v)
    
    Parameters
    ----------
    _v: cgoto_t *

ida_hexrays.cinsn_t._set_cif (method)
    _set_cif(self, _v)
    
    Parameters
    ----------
    _v: cif_t *

ida_hexrays.cinsn_t._set_creturn (method)
    _set_creturn(self, _v)
    
    Parameters
    ----------
    _v: creturn_t *

ida_hexrays.cinsn_t._set_cswitch (method)
    _set_cswitch(self, _v)
    
    Parameters
    ----------
    _v: cswitch_t *

ida_hexrays.cinsn_t._set_cwhile (method)
    _set_cwhile(self, _v)
    
    Parameters
    ----------
    _v: cwhile_t *

ida_hexrays.cinsn_t.assign (method)
    assign(self, r) -> cinsn_t
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.casm (variable)
    details of asm-statement

ida_hexrays.cinsn_t.cblock (variable)
    details of block-statement

ida_hexrays.cinsn_t.cdo (variable)
    details of do-statement

ida_hexrays.cinsn_t.cexpr (variable)
    details of expression-statement

ida_hexrays.cinsn_t.cfor (variable)
    details of for-statement

ida_hexrays.cinsn_t.cgoto (variable)
    details of goto-statement

ida_hexrays.cinsn_t.cif (variable)
    details of if-statement

ida_hexrays.cinsn_t.cleanup (method)
    cleanup(self)
    Cleanup the statement. This function properly deletes all children and sets the
    item type to cit_empty.

ida_hexrays.cinsn_t.collect_free_breaks (method)
    collect_free_breaks(self, breaks) -> bool
    Collect free break statements. This function finds all free break statements
    within the current statement. A break statement is free if it does not have a
    loop or switch parent that that is also within the current statement.
    
    @param breaks: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free break
                   statements is returned. This argument can be nullptr.
    @return: true if some free break statements have been found

ida_hexrays.cinsn_t.collect_free_continues (method)
    collect_free_continues(self, continues) -> bool
    Collect free continue statements. This function finds all free continue
    statements within the current statement. A continue statement is free if it does
    not have a loop parent that that is also within the current statement.
    
    @param continues: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free
                      continue statements is returned. This argument can be nullptr.
    @return: true if some free continue statements have been found

ida_hexrays.cinsn_t.compare (method)
    compare(self, r) -> int
    
    @param r: cinsn_t const &

ida_hexrays.cinsn_t.contains_free_break (method)
    contains_free_break(self) -> bool
    Check if the statement has free break statements.

ida_hexrays.cinsn_t.contains_free_continue (method)
    contains_free_continue(self) -> bool
    Check if the statement has free continue statements.

ida_hexrays.cinsn_t.contains_insn (method)
    contains_insn(self, type, times=1) -> bool
    Check if the statement contains a statement of the specified type.
    
    @param type: (C++: ctype_t) statement opcode to look for
    @param times: (C++: int) how many times TYPE should be present
    @return: true if the statement has at least TIMES children with opcode == TYPE

ida_hexrays.cinsn_t.create_if (method)
    create_if(self, cnd) -> cif_t
    Create a new if-statement. The current statement must be a block. The new
    statement will be appended to it.
    
    @param cnd: (C++: cexpr_t *) if condition. It will be deleted after being copied.

ida_hexrays.cinsn_t.creturn (variable)
    details of return-statement

ida_hexrays.cinsn_t.cswitch (variable)
    details of switch-statement

ida_hexrays.cinsn_t.cwhile (variable)
    details of while-statement

ida_hexrays.cinsn_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.cinsn_t.insn_is_epilog (method)
    insn_is_epilog(insn) -> bool
    
    @param insn: cinsn_t const *

ida_hexrays.cinsn_t.is_epilog (method)

ida_hexrays.cinsn_t.is_ordinary_flow (method)
    is_ordinary_flow(self) -> bool
    Check if the statement passes execution to the next statement.
    
    @return: false if the statement breaks the control flow (like goto, return, etc)

ida_hexrays.cinsn_t.new_insn (method)
    new_insn(self, insn_ea) -> cinsn_t
    Create a new statement. The current statement must be a block. The new statement
    will be appended to it.
    
    @param insn_ea: (C++: ea_t) statement address

ida_hexrays.cinsn_t.print1 (method)
    print1(self, func)
    Print the statement into one line. Currently this function is not available.
    
    @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
                 variable names.

ida_hexrays.cinsn_t.swap (method)
    swap(self, r)
    
    @param r: cinsn_t &

ida_hexrays.cinsn_t.zero (method)
    zero(self)
    Overwrite with zeroes without cleaning memory or deleting children.

ida_hexrays.cinsn_t_insn_is_epilog (function)
    cinsn_t_insn_is_epilog(insn) -> bool
    
    @param insn: cinsn_t const *

ida_hexrays.cinsnptrvec_t (class)
    Proxy of C++ qvector< cinsn_t * > class.

ida_hexrays.cinsnptrvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< cinsn_t * > const &

ida_hexrays.cinsnptrvec_t.__getitem__ (method)
    __getitem__(self, i) -> cinsn_t
    
    @param i: size_t

ida_hexrays.cinsnptrvec_t.__init__ (method)
    __init__(self) -> cinsnptrvec_t
    __init__(self, x) -> cinsnptrvec_t
    
    @param x: qvector< cinsn_t * > const &

ida_hexrays.cinsnptrvec_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.cinsnptrvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< cinsn_t * > const &

ida_hexrays.cinsnptrvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: cinsn_t *const &

ida_hexrays.cinsnptrvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: cinsn_t *const &

ida_hexrays.cinsnptrvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: cinsn_t *const &

ida_hexrays.cinsnptrvec_t.at (method)
    at(self, _idx) -> cinsn_t
    
    @param _idx: size_t

ida_hexrays.cinsnptrvec_t.begin (method)
    begin(self) -> qvector< cinsn_t * >::iterator
    begin(self) -> qvector< cinsn_t * >::const_iterator

ida_hexrays.cinsnptrvec_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.cinsnptrvec_t.clear (method)
    clear(self)

ida_hexrays.cinsnptrvec_t.empty (method)
    empty(self) -> bool

ida_hexrays.cinsnptrvec_t.end (method)
    end(self) -> qvector< cinsn_t * >::iterator
    end(self) -> qvector< cinsn_t * >::const_iterator

ida_hexrays.cinsnptrvec_t.erase (method)
    erase(self, it) -> qvector< cinsn_t * >::iterator
    
    @param it: qvector< cinsn_t * >::iterator
    
    erase(self, first, last) -> qvector< cinsn_t * >::iterator
    
    @param first: qvector< cinsn_t * >::iterator
    @param last: qvector< cinsn_t * >::iterator

ida_hexrays.cinsnptrvec_t.extract (method)
    extract(self) -> cinsn_t **

ida_hexrays.cinsnptrvec_t.find (method)
    find(self, x) -> qvector< cinsn_t * >::iterator
    
    @param x: cinsn_t *const &
    
    find(self, x) -> qvector< cinsn_t * >::const_iterator
    
    @param x: cinsn_t *const &

ida_hexrays.cinsnptrvec_t.has (method)
    has(self, x) -> bool
    
    @param x: cinsn_t *const &

ida_hexrays.cinsnptrvec_t.inject (method)
    inject(self, s, len)
    
    @param s: cinsn_t **
    @param len: size_t

ida_hexrays.cinsnptrvec_t.insert (method)
    insert(self, it, x) -> qvector< cinsn_t * >::iterator
    
    @param it: qvector< cinsn_t * >::iterator
    @param x: cinsn_t *const &

ida_hexrays.cinsnptrvec_t.pop_back (method)
    pop_back(self)

ida_hexrays.cinsnptrvec_t.push_back (method)
    push_back(self, x)
    
    @param x: cinsn_t *const &
    
    push_back(self) -> cinsn_t *&

ida_hexrays.cinsnptrvec_t.qclear (method)
    qclear(self)

ida_hexrays.cinsnptrvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.cinsnptrvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: cinsn_t *const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.cinsnptrvec_t.size (method)
    size(self) -> size_t

ida_hexrays.cinsnptrvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< cinsn_t * > &

ida_hexrays.cinsnptrvec_t.truncate (method)
    truncate(self)

ida_hexrays.cit_asm (variable)
    asm-statement

ida_hexrays.cit_block (variable)
    block-statement: { ... }

ida_hexrays.cit_break (variable)
    break-statement

ida_hexrays.cit_continue (variable)
    continue-statement

ida_hexrays.cit_do (variable)
    do-statement

ida_hexrays.cit_empty (variable)
    instruction types start here

ida_hexrays.cit_expr (variable)
    expression-statement: expr;

ida_hexrays.cit_for (variable)
    for-statement

ida_hexrays.cit_goto (variable)
    goto-statement

ida_hexrays.cit_if (variable)
    if-statement

ida_hexrays.cit_return (variable)
    return-statement

ida_hexrays.cit_switch (variable)
    switch-statement

ida_hexrays.cit_while (variable)
    while-statement

ida_hexrays.citem_cmt_t (class)
    Proxy of C++ citem_cmt_t class.

ida_hexrays.citem_cmt_t.__init__ (method)
    __init__(self) -> citem_cmt_t
    __init__(self, s) -> citem_cmt_t
    
    @param s: char const *

ida_hexrays.citem_cmt_t.__str__ (method)
    __str__(self) -> char const *

ida_hexrays.citem_cmt_t.c_str (method)
    c_str(self) -> char const *

ida_hexrays.citem_cmt_t.used (variable)
    the comment has been retrieved?

ida_hexrays.citem_locator_t (class)
    Proxy of C++ citem_locator_t class.

ida_hexrays.citem_locator_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.__init__ (method)
    __init__(self, _ea, _op) -> citem_locator_t
    
    @param _ea: ea_t
    @param _op: enum ctype_t
    
    __init__(self, i) -> citem_locator_t
    
    @param i: citem_t const *

ida_hexrays.citem_locator_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.compare (method)
    compare(self, r) -> int
    
    @param r: citem_locator_t const &

ida_hexrays.citem_locator_t.ea (variable)
    citem address

ida_hexrays.citem_locator_t.op (variable)
    citem operation

ida_hexrays.citem_t (class)
    Proxy of C++ citem_t class.

ida_hexrays.citem_t.__dbg_get_meminfo (method)
    __dbg_get_meminfo(self) -> qstring

ida_hexrays.citem_t.__dbg_get_registered_kind (method)
    __dbg_get_registered_kind(self) -> int

ida_hexrays.citem_t.__init__ (method)
    __init__(self, o=cot_empty) -> citem_t
    
    @param o: enum ctype_t

ida_hexrays.citem_t._acquire_ownership (method)

ida_hexrays.citem_t._ensure_cond (method)

ida_hexrays.citem_t._ensure_no_obj (method)

ida_hexrays.citem_t._ensure_no_op (method)

ida_hexrays.citem_t._ensure_ownership_transferrable (method)

ida_hexrays.citem_t._get_op (method)
    _get_op(self) -> ctype_t

ida_hexrays.citem_t._maybe_disown_and_deregister (method)

ida_hexrays.citem_t._meminfo (method)

ida_hexrays.citem_t._obj_id (method)
    _obj_id(self) -> PyObject *

ida_hexrays.citem_t._own_and_register (method)

ida_hexrays.citem_t._set_op (method)
    _set_op(self, v)
    
    Parameters
    ----------
    v: enum ctype_t

ida_hexrays.citem_t.contains_expr (method)
    contains_expr(self, e) -> bool
    Does the item contain an expression?
    
    @param e: (C++: const cexpr_t *) cexpr_t const *

ida_hexrays.citem_t.contains_label (method)
    contains_label(self) -> bool
    Does the item contain a label?

ida_hexrays.citem_t.ea (variable)
    address that corresponds to the item. may be BADADDR

ida_hexrays.citem_t.find_closest_addr (method)
    find_closest_addr(self, _ea) -> citem_t
    
    @param _ea: ea_t

ida_hexrays.citem_t.find_parent_of (method)
    find_parent_of(self, sitem) -> citem_t
    
    @param sitem: citem_t const *
    
    find_parent_of(self, item) -> citem_t
    
    @param item: citem_t const *

ida_hexrays.citem_t.index (variable)
    an index in cfunc_t::treeitems. meaningful only after print_func()

ida_hexrays.citem_t.is_expr (method)
    is_expr(self) -> bool
    Is an expression?

ida_hexrays.citem_t.label_num (variable)
    label number. -1 means no label. items of the expression types (cot_...) should
    not have labels at the final maturity level, but at the intermediate levels any
    ctree item may have a label. Labels must be unique. Usually they correspond to
    the basic block numbers.

ida_hexrays.citem_t.op (variable)
    item type

ida_hexrays.citem_t.print1 (method)
    print1(self, func)
    Print item into one line.
    
    @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
                 variable names.
    @return: length of the generated text.

ida_hexrays.citem_t.replace_by (method)

ida_hexrays.citem_t.swap (method)
    swap(self, r)
    Swap two citem_t.
    
    @param r: (C++: citem_t &)

ida_hexrays.citem_to_specific_type (function)
    cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 

ida_hexrays.clear_cached_cfuncs (function)
    clear_cached_cfuncs()
    Flush all cached decompilation results.

ida_hexrays.cloop_t (class)
    Proxy of C++ cloop_t class.

ida_hexrays.cloop_t.__init__ (method)
    __init__(self, b=None) -> cloop_t
    
    @param b: cinsn_t *
    
    __init__(self, r) -> cloop_t
    
    @param r: cloop_t const &

ida_hexrays.cloop_t.assign (method)
    assign(self, r) -> cloop_t
    
    @param r: cloop_t const &

ida_hexrays.cloop_t.cleanup (method)
    cleanup(self)

ida_hexrays.close_hexrays_waitbox (function)
    close_hexrays_waitbox()
    Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_HIDE was used
    during decompilation.

ida_hexrays.close_pseudocode (function)
    close_pseudocode(f) -> bool
    Close pseudocode window.
    
    @param f: (C++: TWidget *) pointer to window
    @return: false if failed

ida_hexrays.cnumber_t (class)
    Proxy of C++ cnumber_t class.

ida_hexrays.cnumber_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.__init__ (method)
    __init__(self, _opnum=0) -> cnumber_t
    
    @param _opnum: int

ida_hexrays.cnumber_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t._print (method)
    _print(self, type, parent=None, nice_stroff=None)
    
    Parameters
    ----------
    type: tinfo_t const &
    parent: citem_t const *
    nice_stroff: bool *

ida_hexrays.cnumber_t._value (variable)
    its value

ida_hexrays.cnumber_t.assign (method)
    assign(self, v, nbytes, sign)
    Assign new value
    
    @param v: (C++: uint64) new value
    @param nbytes: (C++: int) size of the new value in bytes
    @param sign: (C++: type_sign_t) sign of the value

ida_hexrays.cnumber_t.compare (method)
    compare(self, r) -> int
    
    @param r: cnumber_t const &

ida_hexrays.cnumber_t.nf (variable)
    how to represent it

ida_hexrays.cnumber_t.value (method)
    value(self, type) -> uint64
    Get value. This function will properly extend the number sign to 64bits
    depending on the type sign.
    
    @param type: (C++: const tinfo_t &) tinfo_t const &

ida_hexrays.codegen_t (class)
    Proxy of C++ codegen_t class.

ida_hexrays.codegen_t.__init__ (method)

ida_hexrays.codegen_t.analyze_prolog (method)
    analyze_prolog(self, fc, reachable) -> merror_t
    Analyze prolog/epilog of the function to decompile. If prolog is found, allocate
    and fill 'mba->pi' structure.
    
    @param fc: (C++: const class qflow_chart_t &) flow chart
    @param reachable: (C++: const class bitset_t &) bitmap of reachable blocks
    @return: error code

ida_hexrays.codegen_t.emit (method)
    emit(self, code, width, l, r, d, offsize) -> minsn_t
    Emit one microinstruction. This variant accepts pointers to operands. It is more
    difficult to use but permits to create virtually any instruction. Operands may
    be nullptr when it makes sense.
    
    @param code: (C++: mcode_t) enum mcode_t
    @param width: int
    @param l: (C++: const mop_t *) uval_t
    @param r: (C++: const mop_t *) uval_t
    @param d: (C++: const mop_t *) uval_t
    @param offsize: int
    
    emit(self, code, l, r, d) -> minsn_t
    
    @param code: enum mcode_t
    @param l: mop_t const *
    @param r: mop_t const *
    @param d: mop_t const *

ida_hexrays.codegen_t.emit_micro_mvm (method)
    emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t
    Emit one microinstruction. This variant takes a data type not a size.
    
    @param code: (C++: mcode_t) enum mcode_t
    @param dtype: (C++: op_dtype_t)
    @param l: (C++: uval_t)
    @param r: (C++: uval_t)
    @param d: (C++: uval_t)
    @param offsize: (C++: int)

ida_hexrays.codegen_t.gen_micro (method)
    gen_micro(self) -> merror_t
    Generate microcode for one instruction. The instruction is in INSN
    
    @return: MERR_OK - all ok MERR_BLOCK - all ok, need to switch to new block
             MERR_BADBLK - delete current block and continue other error codes are
             fatal

ida_hexrays.codegen_t.load_effective_address (method)
    load_effective_address(self, n, flags=0) -> mreg_t
    Generate microcode to calculate the address of a memory operand.
    
    @param n: (C++: int) - number of INSN operand
    @param flags: (C++: int) - reserved for future use
    @return: register containing the operand address. mr_none - failed (not a memory
             operand)

ida_hexrays.codegen_t.load_operand (method)
    load_operand(self, opnum, flags=0) -> mreg_t
    Generate microcode to load one operand.
    
    @param opnum: (C++: int) number of INSN operand
    @param flags: (C++: int) reserved for future use
    @return: register containing the operand.

ida_hexrays.codegen_t.microgen_completed (method)
    microgen_completed(self)
    This method is called when the microcode generation is done.

ida_hexrays.codegen_t.prepare_gen_micro (method)
    prepare_gen_micro(self) -> merror_t
    Setup internal data to handle new instruction. This method should be called
    before calling gen_micro(). Usually gen_micro() is called by the decompiler. You
    have to call this function explicitly only if you yourself call gen_micro(). The
    instruction is in INSN
    
    @return: MERR_OK - all ok other error codes are fatal

ida_hexrays.codegen_t.store_operand (method)
    store_operand(self, n, mop, flags=0, outins=None) -> bool
    Generate microcode to store an operand. In case of success an arbitrary number
    of instructions can be generated (and even no instruction if the source and
    target are the same)
    
    @param n: (C++: int) - number of target INSN operand
    @param mop: (C++: const mop_t &) - operand to be stored
    @param flags: (C++: int) - reserved for future use
    @param outins: (C++: minsn_t **) - (OUT) the last generated instruction
    @return: success

ida_hexrays.convert_to_user_call (function)
    convert_to_user_call(udc, cdg) -> merror_t
    try to generate user-defined call for an instruction
    
    @param udc: (C++: const udcall_t &) udcall_t const &
    @param cdg: (C++: codegen_t &)
    @return: Microcode error codes code: MERR_OK - user-defined call generated else
             - error (MERR_INSN == inacceptable udc.tif)

ida_hexrays.cot_add (variable)
    x + y

ida_hexrays.cot_asg (variable)
    x = y

ida_hexrays.cot_asgadd (variable)
    x += y

ida_hexrays.cot_asgband (variable)
    x &= y

ida_hexrays.cot_asgbor (variable)
    x |= y

ida_hexrays.cot_asgmul (variable)
    x *= y

ida_hexrays.cot_asgsdiv (variable)
    x /= y signed

ida_hexrays.cot_asgshl (variable)
    x <<= y

ida_hexrays.cot_asgsmod (variable)
    x %= y signed

ida_hexrays.cot_asgsshr (variable)
    x >>= y signed

ida_hexrays.cot_asgsub (variable)
    x -= y

ida_hexrays.cot_asgudiv (variable)
    x /= y unsigned

ida_hexrays.cot_asgumod (variable)
    x %= y unsigned

ida_hexrays.cot_asgushr (variable)
    x >>= y unsigned

ida_hexrays.cot_asgxor (variable)
    x ^= y

ida_hexrays.cot_band (variable)
    x & y

ida_hexrays.cot_bnot (variable)
    ~x

ida_hexrays.cot_bor (variable)
    x | y

ida_hexrays.cot_call (variable)
    x(...)

ida_hexrays.cot_cast (variable)
    (type)x

ida_hexrays.cot_comma (variable)
    x, y

ida_hexrays.cot_eq (variable)
    x == y int or fpu (see EXFL_FPOP)

ida_hexrays.cot_fadd (variable)
    x + y fp

ida_hexrays.cot_fdiv (variable)
    x / y fp

ida_hexrays.cot_fmul (variable)
    x * y fp

ida_hexrays.cot_fneg (variable)
    -x fp

ida_hexrays.cot_fnum (variable)
    fpc

ida_hexrays.cot_fsub (variable)
    x - y fp

ida_hexrays.cot_helper (variable)
    arbitrary name

ida_hexrays.cot_idx (variable)
    x[y]

ida_hexrays.cot_insn (variable)
    instruction in expression, internal representation only

ida_hexrays.cot_land (variable)
    x && y

ida_hexrays.cot_lnot (variable)
    !x

ida_hexrays.cot_lor (variable)
    x || y

ida_hexrays.cot_memptr (variable)
    x->m, access size in 'ptrsize'

ida_hexrays.cot_memref (variable)
    x.m

ida_hexrays.cot_mul (variable)
    x * y

ida_hexrays.cot_ne (variable)
    x != y int or fpu (see EXFL_FPOP)

ida_hexrays.cot_neg (variable)
    -x

ida_hexrays.cot_num (variable)
    n

ida_hexrays.cot_obj (variable)
    obj_ea

ida_hexrays.cot_postdec (variable)
    x-

ida_hexrays.cot_postinc (variable)
    x++

ida_hexrays.cot_predec (variable)
    -x

ida_hexrays.cot_preinc (variable)
    ++x

ida_hexrays.cot_ptr (variable)
    *x, access size in 'ptrsize'

ida_hexrays.cot_ref (variable)
    &x

ida_hexrays.cot_sdiv (variable)
    x / y signed

ida_hexrays.cot_sge (variable)
    x >= y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_sgt (variable)
    x > y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_shl (variable)
    x << y

ida_hexrays.cot_sizeof (variable)
    sizeof(x)

ida_hexrays.cot_sle (variable)
    x <= y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_slt (variable)
    x < y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_smod (variable)
    x % y signed

ida_hexrays.cot_sshr (variable)
    x >> y signed

ida_hexrays.cot_str (variable)
    string constant (user representation)

ida_hexrays.cot_sub (variable)
    x - y

ida_hexrays.cot_tern (variable)
    x ? y : z

ida_hexrays.cot_type (variable)
    arbitrary type

ida_hexrays.cot_udiv (variable)
    x / y unsigned

ida_hexrays.cot_uge (variable)
    x >= y unsigned

ida_hexrays.cot_ugt (variable)
    x > y unsigned

ida_hexrays.cot_ule (variable)
    x <= y unsigned

ida_hexrays.cot_ult (variable)
    x < y unsigned

ida_hexrays.cot_umod (variable)
    x % y unsigned

ida_hexrays.cot_ushr (variable)
    x >> y unsigned

ida_hexrays.cot_var (variable)
    v

ida_hexrays.cot_xor (variable)
    x ^ y

ida_hexrays.create_cfunc (function)
    create_cfunc(mba) -> cfuncptr_t
    Create a new cfunc_t object.
    
    @param mba: (C++: mba_t *) microcode object. After creating the cfunc object it takes the
                ownership of MBA.

ida_hexrays.create_empty_mba (function)
    create_empty_mba(mbr, hf=None) -> mba_t
    Create an empty microcode object.
    
    @param mbr: (C++: const mba_ranges_t &) mba_ranges_t const &
    @param hf: (C++: hexrays_failure_t *)

ida_hexrays.create_field_name (function)
    create_field_name(type, offset=BADADDR) -> qstring
    
    @param type: tinfo_t const &
    @param offset: uval_t

ida_hexrays.create_helper (function)
    Create a helper object..

ida_hexrays.create_typedef (function)
    create_typedef(name) -> tinfo_t
    Create a reference to an ordinal type.
    
    @param name: char const *
    
    @return: type which refers to the specified ordinal. For example, if n is 1, the
             type info which refers to ordinal type 1 is created.
    create_typedef(n) -> tinfo_t
    
    @param n: int

ida_hexrays.creturn_t (class)
    Proxy of C++ creturn_t class.

ida_hexrays.creturn_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.__init__ (method)
    __init__(self) -> creturn_t

ida_hexrays.creturn_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: creturn_t const &

ida_hexrays.creturn_t.compare (method)
    compare(self, r) -> int
    
    @param r: creturn_t const &

ida_hexrays.cswitch_t (class)
    Proxy of C++ cswitch_t class.

ida_hexrays.cswitch_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.__init__ (method)
    __init__(self) -> cswitch_t

ida_hexrays.cswitch_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.cases (variable)
    Switch cases: values and instructions.

ida_hexrays.cswitch_t.compare (method)
    compare(self, r) -> int
    
    @param r: cswitch_t const &

ida_hexrays.cswitch_t.mvnf (variable)
    Maximal switch value and number format.

ida_hexrays.ctext_position_t (class)
    Proxy of C++ ctext_position_t class.

ida_hexrays.ctext_position_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.__init__ (method)
    __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
    
    @param _lnnum: int
    @param _x: int
    @param _y: int

ida_hexrays.ctext_position_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.compare (method)
    compare(self, r) -> int
    
    @param r: ctext_position_t const &

ida_hexrays.ctext_position_t.in_ctree (method)
    in_ctree(self, hdrlines) -> bool
    Is the cursor in the variable/type declaration area?
    
    @param hdrlines: (C++: int) Number of lines of the declaration area

ida_hexrays.ctext_position_t.lnnum (variable)
    Line number.

ida_hexrays.ctext_position_t.x (variable)
    x coordinate of the cursor within the window

ida_hexrays.ctext_position_t.y (variable)
    y coordinate of the cursor within the window

ida_hexrays.ctree_anchor_t (class)
    Proxy of C++ ctree_anchor_t class.

ida_hexrays.ctree_anchor_t.__init__ (method)
    __init__(self) -> ctree_anchor_t

ida_hexrays.ctree_anchor_t.get_index (method)
    get_index(self) -> int

ida_hexrays.ctree_anchor_t.get_itp (method)
    get_itp(self) -> item_preciser_t

ida_hexrays.ctree_anchor_t.is_blkcmt_anchor (method)
    is_blkcmt_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_citem_anchor (method)
    is_citem_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_itp_anchor (method)
    is_itp_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_lvar_anchor (method)
    is_lvar_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_valid_anchor (method)
    is_valid_anchor(self) -> bool

ida_hexrays.ctree_item_t (class)
    Proxy of C++ ctree_item_t class.

ida_hexrays.ctree_item_t.__init__ (method)
    __init__(self) -> ctree_item_t

ida_hexrays.ctree_item_t._get_e (method)
    _get_e(self) -> cexpr_t

ida_hexrays.ctree_item_t._get_f (method)
    _get_f(self) -> cfunc_t

ida_hexrays.ctree_item_t._get_i (method)
    _get_i(self) -> cinsn_t

ida_hexrays.ctree_item_t._get_it (method)
    _get_it(self) -> citem_t

ida_hexrays.ctree_item_t._get_l (method)
    _get_l(self) -> lvar_t

ida_hexrays.ctree_item_t._print (method)
    _print(self)

ida_hexrays.ctree_item_t.citype (variable)
    Item type.

ida_hexrays.ctree_item_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.ctree_item_t.get_ea (method)
    get_ea(self) -> ea_t
    Get address of the current item. Each ctree item has an address.
    
    @return: BADADDR if failed

ida_hexrays.ctree_item_t.get_edm (method)
    get_edm(self, parent) -> int
    Get type of an enum member. If the current item is a symbolic constant, this
    function will return information about it.
    
    @param parent: (C++: tinfo_t *) pointer to buffer for the enum type.
    @return: member index or -1 if failed

ida_hexrays.ctree_item_t.get_label_num (method)
    get_label_num(self, gln_flags) -> int
    Get label number of the current item.
    
    @param gln_flags: (C++: int) Combination of get_label_num control bits
    @return: -1 if failed or no label

ida_hexrays.ctree_item_t.get_lvar (method)
    get_lvar(self) -> lvar_t
    Get pointer to local variable. If the current item is a local variable, this
    function will return pointer to its definition.
    
    @return: nullptr if failed

ida_hexrays.ctree_item_t.get_memptr (method)
    get_memptr(self, p_sptr=None) -> member_t *
    Get pointer to structure member. If the current item is a structure field, this
    function will return pointer to its definition.
    
    @param p_sptr: (C++: struc_t **) pointer to the variable where the pointer to the parent structure
                   is returned. This parameter can be nullptr.
    @return: nullptr if failed OBSOLETE FUNCTION, do not use!

ida_hexrays.ctree_item_t.get_udm (method)
    get_udm(self, udm=None, parent=None, p_offset=None) -> int
    Get type of a structure field. If the current item is a structure/union field,
    this function will return information about it.
    
    @param udm: (C++: udm_t *) pointer to buffer for the udt member info.
    @param parent: (C++: tinfo_t *) pointer to buffer for the struct/union type.
    @param p_offset: (C++: uint64 *) pointer to the offset in bits inside udt.
    @return: member index or -1 if failed Both output parameters can be nullptr.

ida_hexrays.ctree_item_t.is_citem (method)
    is_citem(self) -> bool
    Is the current item is a ctree item?

ida_hexrays.ctree_items_t (class)
    Proxy of C++ qvector< citem_t * > class.

ida_hexrays.ctree_items_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< citem_t * > const &

ida_hexrays.ctree_items_t.__getitem__ (method)
    __getitem__(self, i) -> citem_t
    
    @param i: size_t

ida_hexrays.ctree_items_t.__init__ (method)
    __init__(self) -> ctree_items_t
    __init__(self, x) -> ctree_items_t
    
    @param x: qvector< citem_t * > const &

ida_hexrays.ctree_items_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.ctree_items_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< citem_t * > const &

ida_hexrays.ctree_items_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: citem_t *const &

ida_hexrays.ctree_items_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: citem_t *const &

ida_hexrays.ctree_items_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: citem_t *const &

ida_hexrays.ctree_items_t.at (method)
    at(self, _idx) -> citem_t
    
    @param _idx: size_t

ida_hexrays.ctree_items_t.begin (method)
    begin(self) -> qvector< citem_t * >::iterator
    begin(self) -> qvector< citem_t * >::const_iterator

ida_hexrays.ctree_items_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.ctree_items_t.clear (method)
    clear(self)

ida_hexrays.ctree_items_t.empty (method)
    empty(self) -> bool

ida_hexrays.ctree_items_t.end (method)
    end(self) -> qvector< citem_t * >::iterator
    end(self) -> qvector< citem_t * >::const_iterator

ida_hexrays.ctree_items_t.erase (method)
    erase(self, it) -> qvector< citem_t * >::iterator
    
    @param it: qvector< citem_t * >::iterator
    
    erase(self, first, last) -> qvector< citem_t * >::iterator
    
    @param first: qvector< citem_t * >::iterator
    @param last: qvector< citem_t * >::iterator

ida_hexrays.ctree_items_t.extract (method)
    extract(self) -> citem_t **

ida_hexrays.ctree_items_t.find (method)
    find(self, x) -> qvector< citem_t * >::iterator
    
    @param x: citem_t *const &
    
    find(self, x) -> qvector< citem_t * >::const_iterator
    
    @param x: citem_t *const &

ida_hexrays.ctree_items_t.has (method)
    has(self, x) -> bool
    
    @param x: citem_t *const &

ida_hexrays.ctree_items_t.inject (method)
    inject(self, s, len)
    
    @param s: citem_t **
    @param len: size_t

ida_hexrays.ctree_items_t.insert (method)
    insert(self, it, x) -> qvector< citem_t * >::iterator
    
    @param it: qvector< citem_t * >::iterator
    @param x: citem_t *const &

ida_hexrays.ctree_items_t.pop_back (method)
    pop_back(self)

ida_hexrays.ctree_items_t.push_back (method)
    push_back(self, x)
    
    @param x: citem_t *const &
    
    push_back(self) -> citem_t *&

ida_hexrays.ctree_items_t.qclear (method)
    qclear(self)

ida_hexrays.ctree_items_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.ctree_items_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: citem_t *const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.ctree_items_t.size (method)
    size(self) -> size_t

ida_hexrays.ctree_items_t.swap (method)
    swap(self, r)
    
    @param r: qvector< citem_t * > &

ida_hexrays.ctree_items_t.truncate (method)
    truncate(self)

ida_hexrays.ctree_parentee_t (class)
    Proxy of C++ ctree_parentee_t class.

ida_hexrays.ctree_parentee_t.__disown__ (method)

ida_hexrays.ctree_parentee_t.__init__ (method)
    __init__(self, post=False) -> ctree_parentee_t
    
    @param post: bool

ida_hexrays.ctree_parentee_t.get_block (method)
    get_block(self) -> cblock_t
    Get pointer to the parent block of the currently visited item. This function
    should be called only when the parent is a block.

ida_hexrays.ctree_parentee_t.recalc_parent_types (method)
    recalc_parent_types(self) -> bool
    Recalculate type of parent nodes. If a node type has been changed, the visitor
    must recalculate all parent types, otherwise the ctree becomes inconsistent. If
    during this recalculation a parent node is added/deleted, this function returns
    true. In this case the traversal must be stopped because the information about
    parent nodes is stale.
    
    @return: false-ok to continue the traversal, true-must stop.

ida_hexrays.ctree_visitor_t (class)
    Proxy of C++ ctree_visitor_t class.

ida_hexrays.ctree_visitor_t.__disown__ (method)

ida_hexrays.ctree_visitor_t.__init__ (method)
    __init__(self, _flags) -> ctree_visitor_t
    
    @param _flags: int

ida_hexrays.ctree_visitor_t.apply_to (method)
    apply_to(self, item, parent) -> int
    Traverse ctree. The traversal will start at the specified item and continue
    until of one the visit_...() functions return a non-zero value.
    
    @param item: (C++: citem_t *) root of the ctree to traverse
    @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
    @return: 0 or a non-zero value returned by a visit_...() function

ida_hexrays.ctree_visitor_t.apply_to_exprs (method)
    apply_to_exprs(self, item, parent) -> int
    Traverse only expressions. The traversal will start at the specified item and
    continue until of one the visit_...() functions return a non-zero value.
    
    @param item: (C++: citem_t *) root of the ctree to traverse
    @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
    @return: 0 or a non-zero value returned by a visit_...() function

ida_hexrays.ctree_visitor_t.clr_prune (method)
    clr_prune(self)
    Do not prune children. This is an internal function, no need to call it.

ida_hexrays.ctree_visitor_t.clr_restart (method)
    clr_restart(self)
    Do not restart. This is an internal function, no need to call it.

ida_hexrays.ctree_visitor_t.cv_flags (variable)
    Ctree visitor property bits

ida_hexrays.ctree_visitor_t.is_postorder (method)
    is_postorder(self) -> bool
    Should the leave...() functions be called?

ida_hexrays.ctree_visitor_t.leave_expr (method)
    leave_expr(self, arg0) -> int
    Visit an expression after having visited its children. This is a visitor
    function which should be overridden by a derived class to do some useful work.
    This visitor performs post-order traserval, i.e. an item is visited after its
    children.
    
    @param arg0: cexpr_t *
    @return: 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.leave_insn (method)
    leave_insn(self, arg0) -> int
    Visit a statement after having visited its children. This is a visitor function
    which should be overridden by a derived class to do some useful work. This
    visitor performs post-order traserval, i.e. an item is visited after its
    children.
    
    @param arg0: cinsn_t *
    @return: 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.maintain_parents (method)
    maintain_parents(self) -> bool
    Should the parent information by maintained?

ida_hexrays.ctree_visitor_t.must_prune (method)
    must_prune(self) -> bool
    Should the traversal skip the children of the current item?

ida_hexrays.ctree_visitor_t.must_restart (method)
    must_restart(self) -> bool
    Should the traversal restart?

ida_hexrays.ctree_visitor_t.only_insns (method)
    only_insns(self) -> bool
    Should all expressions be automatically pruned?

ida_hexrays.ctree_visitor_t.parent_expr (method)
    parent_expr(self) -> cexpr_t
    Get parent of the current item as an expression.

ida_hexrays.ctree_visitor_t.parent_insn (method)
    parent_insn(self) -> cinsn_t
    Get parent of the current item as a statement.

ida_hexrays.ctree_visitor_t.parents (variable)
    Vector of parents of the current item.

ida_hexrays.ctree_visitor_t.prune_now (method)
    prune_now(self)
    Prune children. This function may be called by a visitor() to skip all children
    of the current item.

ida_hexrays.ctree_visitor_t.set_restart (method)
    set_restart(self)
    Restart the travesal. Meaningful only in apply_to_exprs()

ida_hexrays.ctree_visitor_t.visit_expr (method)
    visit_expr(self, arg0) -> int
    Visit an expression. This is a visitor function which should be overridden by a
    derived class to do some useful work. This visitor performs pre-order traserval,
    i.e. an item is visited before its children.
    
    @param arg0: cexpr_t *
    @return: 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.visit_insn (method)
    visit_insn(self, arg0) -> int
    Visit a statement. This is a visitor function which should be overridden by a
    derived class to do some useful work. This visitor performs pre-order traserval,
    i.e. an item is visited before its children.
    
    @param arg0: cinsn_t *
    @return: 0 to continue the traversal, nonzero to stop.

ida_hexrays.cwhile_t (class)
    Proxy of C++ cwhile_t class.

ida_hexrays.cwhile_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.__init__ (method)
    __init__(self) -> cwhile_t

ida_hexrays.cwhile_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: cwhile_t const &

ida_hexrays.cwhile_t.compare (method)
    compare(self, r) -> int
    
    @param r: cwhile_t const &

ida_hexrays.debug_hexrays_ctree (function)
    debug_hexrays_ctree(level, msg)
    
    @param level: int
    @param msg: char const *

ida_hexrays.decompile (function)
    decompile(mbr, hf=None, decomp_flags=0) -> cfuncptr_t
    Decompile a snippet or a function.
    
    @param mbr: (C++: const mba_ranges_t &) what to decompile
    @param hf: (C++: hexrays_failure_t *) extended error information (if failed)
    @param decomp_flags: (C++: int) bitwise combination of decompile() flags... bits
    @return: pointer to the decompilation result (a reference counted pointer).
             nullptr if failed.

ida_hexrays.decompile (function)
    Decompile a function.
    
    @param ea an address belonging to the function, or an ida_funcs.func_t object
    @param hf extended error information (if failed)
    @param flags decomp_flags bitwise combination of `DECOMP_...` bits
    @return the decompilation result (a `ida_hexrays.cfunc_t` wrapper), or None

ida_hexrays.decompile_func (function)
    decompile_func(pfn, hf=None, decomp_flags=0) -> cfuncptr_t
    Decompile a function. Multiple decompilations of the same function return the
    same object.
    
    @param pfn: (C++: func_t *) pointer to function to decompile
    @param hf: (C++: hexrays_failure_t *) extended error information (if failed)
    @param decomp_flags: (C++: int) bitwise combination of decompile() flags... bits
    @return: pointer to the decompilation result (a reference counted pointer).
             nullptr if failed.

ida_hexrays.decompile_many (function)
    decompile_many(outfile, funcaddrs, flags) -> bool
    Batch decompilation. Decompile all or the specified functions
    
    @param outfile: (C++: const char *) name of the output file
    @param funcaddrs: (C++: const eavec_t *) list of functions to decompile. If nullptr or empty, then
                      decompile all nonlib functions
    @param flags: (C++: int) Batch decompilation bits
    @return: true if no internal error occurred and the user has not cancelled
             decompilation

ida_hexrays.dereference (function)
    Dereference a pointer. This function dereferences a pointer expression. It
    performs the following conversion: "ptr" => "*ptr" It can handle discrepancies
    in the pointer type and the access size.
    
    @return: dereferenced expression

ida_hexrays.dstr (function)
    dstr(tif) -> char const *
    Print the specified type info. This function can be used from a debugger by
    typing "tif->dstr()"
    
    @param tif: (C++: const tinfo_t *) tinfo_t const *

ida_hexrays.dummy_ptrtype (function)
    dummy_ptrtype(ptrsize, isfp) -> tinfo_t
    Generate a dummy pointer type
    
    @param ptrsize: (C++: int) size of pointed object
    @param isfp: (C++: bool) is floating point object?

ida_hexrays.eamap_begin (function)
    eamap_begin(map) -> eamap_iterator_t
    Get iterator pointing to the beginning of eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *

ida_hexrays.eamap_clear (function)
    eamap_clear(map)
    Clear eamap_t.
    
    @param map: (C++: eamap_t *)

ida_hexrays.eamap_end (function)
    eamap_end(map) -> eamap_iterator_t
    Get iterator pointing to the end of eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *

ida_hexrays.eamap_erase (function)
    eamap_erase(map, p)
    Erase current element from eamap_t.
    
    @param map: (C++: eamap_t *)
    @param p: (C++: eamap_iterator_t)

ida_hexrays.eamap_find (function)
    eamap_find(map, key) -> eamap_iterator_t
    Find the specified key in eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *
    @param key: (C++: const ea_t &) ea_t const &

ida_hexrays.eamap_first (function)
    eamap_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: eamap_iterator_t)

ida_hexrays.eamap_free (function)
    eamap_free(map)
    Delete eamap_t instance.
    
    @param map: (C++: eamap_t *)

ida_hexrays.eamap_insert (function)
    eamap_insert(map, key, val) -> eamap_iterator_t
    Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
    
    @param map: (C++: eamap_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const cinsnptrvec_t &) cinsnptrvec_t const &

ida_hexrays.eamap_iterator_t (class)
    Proxy of C++ eamap_iterator_t class.

ida_hexrays.eamap_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: eamap_iterator_t const &

ida_hexrays.eamap_iterator_t.__init__ (method)
    __init__(self) -> eamap_iterator_t

ida_hexrays.eamap_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: eamap_iterator_t const &

ida_hexrays.eamap_new (function)
    eamap_new() -> eamap_t
    Create a new eamap_t instance.

ida_hexrays.eamap_next (function)
    eamap_next(p) -> eamap_iterator_t
    Move to the next element.
    
    @param p: (C++: eamap_iterator_t)

ida_hexrays.eamap_prev (function)
    eamap_prev(p) -> eamap_iterator_t
    Move to the previous element.
    
    @param p: (C++: eamap_iterator_t)

ida_hexrays.eamap_second (function)
    eamap_second(p) -> cinsnptrvec_t
    Get reference to the current map value.
    
    @param p: (C++: eamap_iterator_t)

ida_hexrays.eamap_size (function)
    eamap_size(map) -> size_t
    Get size of eamap_t.
    
    @param map: (C++: eamap_t *)

ida_hexrays.eamap_t (class)
    Proxy of C++ std::map< ea_t,cinsnptrvec_t > class.

ida_hexrays.eamap_t.__init__ (method)
    __init__(self) -> eamap_t

ida_hexrays.eamap_t.at (method)
    at(self, _Keyval) -> cinsnptrvec_t
    
    @param _Keyval: unsigned-ea-like-numeric-type const &

ida_hexrays.eamap_t.size (method)
    size(self) -> size_t

ida_hexrays.fnumber_t (class)
    Proxy of C++ fnumber_t class.

ida_hexrays.fnumber_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.__init__ (method)
    __init__(self) -> fnumber_t

ida_hexrays.fnumber_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t._print (method)
    _print(self)

ida_hexrays.fnumber_t.compare (method)
    compare(self, r) -> int
    
    @param r: fnumber_t const &

ida_hexrays.fnumber_t.dereference_const_uint16 (method)
    dereference_const_uint16(self) -> uint16 const *

ida_hexrays.fnumber_t.dereference_uint16 (method)
    dereference_uint16(self) -> uint16 *

ida_hexrays.fnumber_t.fnum (variable)
    Internal representation of the number.

ida_hexrays.fnumber_t.nbytes (variable)
    Original size of the constant in bytes.

ida_hexrays.gco_info_t (class)
    Proxy of C++ gco_info_t class.

ida_hexrays.gco_info_t.__init__ (method)
    __init__(self) -> gco_info_t

ida_hexrays.gco_info_t.append_to_list (method)
    append_to_list(self, list, mba) -> bool
    Append operand info to LIST. This function converts IDA register number or stack
    offset to a decompiler list.
    
    @param list: (C++: mlist_t *) list to append to
    @param mba: (C++: const mba_t *) microcode object

ida_hexrays.gco_info_t.cvt_to_ivl (method)
    cvt_to_ivl(self) -> vivl_t
    Convert operand info to VIVL. The returned VIVL can be used, for example, in a
    call of get_valranges().

ida_hexrays.gco_info_t.is_def (method)
    is_def(self) -> bool

ida_hexrays.gco_info_t.is_reg (method)
    is_reg(self) -> bool

ida_hexrays.gco_info_t.is_use (method)
    is_use(self) -> bool

ida_hexrays.gco_info_t.name (variable)
    register or stkvar name

ida_hexrays.gco_info_t.regnum (variable)
    if register, the register id

ida_hexrays.gco_info_t.size (variable)
    operand size

ida_hexrays.gco_info_t.stkoff (variable)
    if stkvar, stack offset

ida_hexrays.gen_microcode (function)
    gen_microcode(mbr, hf=None, retlist=None, decomp_flags=0, reqmat=MMAT_GLBOPT3) -> mba_t
    Generate microcode of an arbitrary code snippet
    
    @param mbr: (C++: const mba_ranges_t &) snippet ranges
    @param hf: (C++: hexrays_failure_t *) extended error information (if failed)
    @param retlist: (C++: const mlist_t *) list of registers the snippet returns
    @param decomp_flags: (C++: int) bitwise combination of decompile() flags... bits
    @param reqmat: (C++: mba_maturity_t) required microcode maturity
    @return: pointer to the microcode, nullptr if failed.

ida_hexrays.get_ctype_name (function)
    get_ctype_name(op) -> char const *
    
    @param op: enum ctype_t

ida_hexrays.get_current_operand (function)
    get_current_operand(out) -> bool
    Get the instruction operand under the cursor. This function determines the
    operand that is under the cursor in the active disassembly listing. If the
    operand refers to a register or stack variable, it returns true.
    
    @param out: (C++: gco_info_t *) [out]: output buffer

ida_hexrays.get_float_type (function)
    get_float_type(width) -> tinfo_t
    Get a type of a floating point value with the specified width
    
    @param width: (C++: int) width of the desired type
    @return: type info object

ida_hexrays.get_hexrays_version (function)
    get_hexrays_version() -> char const *
    Get decompiler version. The returned string is of the form
    <major>.<minor>.<revision>.<build-date>
    
    @return: pointer to version string. For example: "2.0.0.140605"

ida_hexrays.get_int_type_by_width_and_sign (function)
    get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t
    Create a type info by width and sign. Returns a simple type (examples: int,
    short) with the given width and sign.
    
    @param srcwidth: (C++: int) size of the type in bytes
    @param sign: (C++: type_sign_t) sign of the type

ida_hexrays.get_member_type (function)
    get_member_type(mptr, type) -> bool
    Get type of a structure field. This function performs validity checks of the
    field type. Wrong types are rejected.
    
    @param mptr: (C++: const member_t *) structure field
    @param type: (C++: tinfo_t *) pointer to the variable where the type is returned. This parameter
                 can be nullptr.
    @return: false if failed

ida_hexrays.get_merror_desc (function)
    get_merror_desc(code, mba) -> str
    Get textual description of an error code
    
    @param code: (C++: merror_t) Microcode error codes
    @param mba: (C++: mba_t *) the microcode array
    @return: the error address

ida_hexrays.get_mreg_name (function)
    get_mreg_name(reg, width, ud=None) -> str
    Get the microregister name.
    
    @param reg: (C++: mreg_t) microregister number
    @param width: (C++: int) size of microregister in bytes. may be bigger than the real
                  register size.
    @param ud: (C++: void *) reserved, must be nullptr
    @return: width of the printed register. this value may be less than the WIDTH
             argument.

ida_hexrays.get_op_signness (function)
    get_op_signness(op) -> type_sign_t
    Get operator sign. Meaningful for sign-dependent operators, like cot_sdiv.
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.get_signed_mcode (function)
    get_signed_mcode(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.get_temp_regs (function)
    get_temp_regs() -> mlist_t
    Get list of temporary registers. Tempregs are temporary registers that are used
    during code generation. They do not map to regular processor registers. They are
    used only to store temporary values during execution of one instruction.
    Tempregs may not be used to pass a value from one block to another. In other
    words, at the end of a block all tempregs must be dead.

ida_hexrays.get_type (function)
    get_type(id, tif, guess) -> bool
    Get a global type. Global types are types of addressable objects and
    struct/union/enum types
    
    @param id: (C++: uval_t) address or id of the object
    @param tif: (C++: tinfo_t *) buffer for the answer
    @param guess: (C++: type_source_t) what kind of types to consider
    @return: success

ida_hexrays.get_unk_type (function)
    get_unk_type(size) -> tinfo_t
    Create a partial type info by width. Returns a partially defined type (examples:
    _DWORD, _BYTE) with the given width.
    
    @param size: (C++: int) size of the type in bytes

ida_hexrays.get_unsigned_mcode (function)
    get_unsigned_mcode(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.get_widget_vdui (function)
    get_widget_vdui(f) -> vdui_t
    Get the vdui_t instance associated to the TWidget
    
    @param f: (C++: TWidget *) pointer to window
    @return: a vdui_t *, or nullptr

ida_hexrays.getb_reginsn (function)
    getb_reginsn(ins) -> minsn_t
    
    @param ins: minsn_t *

ida_hexrays.getf_reginsn (function)
    getf_reginsn(ins) -> minsn_t
    
    @param ins: minsn_t *

ida_hexrays.graph_chains_t (class)
    Proxy of C++ graph_chains_t class.

ida_hexrays.graph_chains_t.__init__ (method)
    __init__(self) -> graph_chains_t

ida_hexrays.graph_chains_t.acquire (method)
    acquire(self)
    Lock the chains.

ida_hexrays.graph_chains_t.for_all_chains (method)
    for_all_chains(self, cv, gca_flags) -> int
    Visit all chains
    
    @param cv: (C++: chain_visitor_t &) chain visitor
    @param gca_flags: (C++: int) combination of GCA_ bits

ida_hexrays.graph_chains_t.is_locked (method)
    is_locked(self) -> bool
    Are the chains locked? It is a good idea to lock the chains before using them.
    This ensures that they won't be recalculated and reallocated during the use. See
    the chain_keeper_t class for that.

ida_hexrays.graph_chains_t.release (method)
    release(self)
    Unlock the chains.

ida_hexrays.graph_chains_t.swap (method)
    swap(self, r)
    
    @param r: graph_chains_t &

ida_hexrays.has_cached_cfunc (function)
    has_cached_cfunc(ea) -> bool
    Do we have a cached decompilation result for 'ea'?
    
    @param ea: (C++: ea_t)

ida_hexrays.has_mcode_seloff (function)
    has_mcode_seloff(op) -> bool
    
    @param op: enum mcode_t

ida_hexrays.hexrays_alloc (function)
    hexrays_alloc(size) -> void *
    
    @param size: size_t

ida_hexrays.hexrays_failure_t (class)
    Proxy of C++ hexrays_failure_t class.

ida_hexrays.hexrays_failure_t.__init__ (method)
    __init__(self) -> hexrays_failure_t
    __init__(self, c, ea, buf=None) -> hexrays_failure_t
    
    @param c: enum merror_t
    @param ea: ea_t
    @param buf: char const *
    
    __init__(self, c, ea, buf) -> hexrays_failure_t
    
    @param c: enum merror_t
    @param ea: ea_t
    @param buf: qstring const &

ida_hexrays.hexrays_failure_t.code (variable)
    Microcode error codes

ida_hexrays.hexrays_failure_t.desc (method)
    desc(self) -> qstring

ida_hexrays.hexrays_failure_t.errea (variable)
    associated address

ida_hexrays.hexrays_failure_t.str (variable)
    string information

ida_hexrays.hexrays_free (function)
    hexrays_free(ptr)
    
    @param ptr: void *

ida_hexrays.hexwarn_t (class)
    Proxy of C++ hexwarn_t class.

ida_hexrays.hexwarn_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.__init__ (method)
    __init__(self) -> hexwarn_t

ida_hexrays.hexwarn_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.compare (method)
    compare(self, r) -> int
    
    @param r: hexwarn_t const &

ida_hexrays.hexwarn_t.ea (variable)
    Address where the warning occurred.

ida_hexrays.hexwarn_t.id (variable)
    Warning id.

ida_hexrays.hexwarn_t.text (variable)
    Fully formatted text of the warning.

ida_hexrays.hexwarns_t (class)
    Proxy of C++ qvector< hexwarn_t > class.

ida_hexrays.hexwarns_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< hexwarn_t > const &

ida_hexrays.hexwarns_t.__getitem__ (method)
    __getitem__(self, i) -> hexwarn_t
    
    @param i: size_t

ida_hexrays.hexwarns_t.__init__ (method)
    __init__(self) -> hexwarns_t
    __init__(self, x) -> hexwarns_t
    
    @param x: qvector< hexwarn_t > const &

ida_hexrays.hexwarns_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.hexwarns_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< hexwarn_t > const &

ida_hexrays.hexwarns_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: hexwarn_t const &

ida_hexrays.hexwarns_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: hexwarn_t const &

ida_hexrays.hexwarns_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: hexwarn_t const &

ida_hexrays.hexwarns_t.at (method)
    at(self, _idx) -> hexwarn_t
    
    @param _idx: size_t

ida_hexrays.hexwarns_t.begin (method)
    begin(self) -> hexwarn_t

ida_hexrays.hexwarns_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.hexwarns_t.clear (method)
    clear(self)

ida_hexrays.hexwarns_t.empty (method)
    empty(self) -> bool

ida_hexrays.hexwarns_t.end (method)
    end(self) -> hexwarn_t

ida_hexrays.hexwarns_t.erase (method)
    erase(self, it) -> hexwarn_t
    
    @param it: qvector< hexwarn_t >::iterator
    
    erase(self, first, last) -> hexwarn_t
    
    @param first: qvector< hexwarn_t >::iterator
    @param last: qvector< hexwarn_t >::iterator

ida_hexrays.hexwarns_t.extract (method)
    extract(self) -> hexwarn_t

ida_hexrays.hexwarns_t.find (method)
    find(self, x) -> hexwarn_t
    
    @param x: hexwarn_t const &

ida_hexrays.hexwarns_t.grow (method)
    grow(self, x=hexwarn_t())
    
    @param x: hexwarn_t const &

ida_hexrays.hexwarns_t.has (method)
    has(self, x) -> bool
    
    @param x: hexwarn_t const &

ida_hexrays.hexwarns_t.inject (method)
    inject(self, s, len)
    
    @param s: hexwarn_t *
    @param len: size_t

ida_hexrays.hexwarns_t.insert (method)
    insert(self, it, x) -> hexwarn_t
    
    @param it: qvector< hexwarn_t >::iterator
    @param x: hexwarn_t const &

ida_hexrays.hexwarns_t.pop_back (method)
    pop_back(self)

ida_hexrays.hexwarns_t.push_back (method)
    push_back(self, x)
    
    @param x: hexwarn_t const &
    
    push_back(self) -> hexwarn_t

ida_hexrays.hexwarns_t.qclear (method)
    qclear(self)

ida_hexrays.hexwarns_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.hexwarns_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: hexwarn_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.hexwarns_t.size (method)
    size(self) -> size_t

ida_hexrays.hexwarns_t.swap (method)
    swap(self, r)
    
    @param r: qvector< hexwarn_t > &

ida_hexrays.hexwarns_t.truncate (method)
    truncate(self)

ida_hexrays.history_item_t (class)
    Proxy of C++ history_item_t class.

ida_hexrays.history_item_t.__init__ (method)
    __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
    
    @param _ea: ea_t
    @param _lnnum: int
    @param _x: int
    @param _y: int
    
    __init__(self, _ea, p) -> history_item_t
    
    @param _ea: ea_t
    @param p: ctext_position_t const &

ida_hexrays.history_item_t.ea (variable)
    The entry address of the decompiled function.

ida_hexrays.history_item_t.end (variable)
    BADADDR-decompile function; otherwise end of the range.

ida_hexrays.history_t (class)
    Proxy of C++ qstack< history_item_t > class.

ida_hexrays.history_t.__init__ (method)
    __init__(self) -> history_t

ida_hexrays.history_t.pop (method)
    pop(self) -> history_item_t

ida_hexrays.history_t.push (method)
    push(self, v)
    
    @param v: history_item_t const &

ida_hexrays.history_t.top (method)
    top(self) -> history_item_t

ida_hexrays.hxe_build_callinfo (variable)
    Analyzing a call instruction.

ida_hexrays.hxe_callinfo_built (variable)
    A call instruction has been anallyzed.

ida_hexrays.hxe_calls_done (variable)
    All calls have been analyzed.

ida_hexrays.hxe_close_pseudocode (variable)
    Pseudocode view is being closed.

ida_hexrays.hxe_cmt_changed (variable)
    Comment got changed.

ida_hexrays.hxe_combine (variable)
    Trying to combine instructions of basic block.

ida_hexrays.hxe_create_hint (variable)
    Create a hint for the current item.
    @see: ui_get_custom_viewer_hint
    
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

ida_hexrays.hxe_curpos (variable)
    Current cursor position has been changed. (for example, by left-clicking or
    using keyboard)

ida_hexrays.hxe_double_click (variable)
    Mouse double click.

ida_hexrays.hxe_flowchart (variable)
    Flowchart has been generated.

ida_hexrays.hxe_func_printed (variable)
    Function text has been generated. Plugins may modify the text in cfunc_t::sv.
    The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store
    pointers to ctree items.

ida_hexrays.hxe_glbopt (variable)
    Global optimization has been finished. If microcode is modified, MERR_LOOP must
    be returned. It will cause a complete restart of the optimization.

ida_hexrays.hxe_interr (variable)
    Internal error has occurred.

ida_hexrays.hxe_keyboard (variable)
    Keyboard has been hit.

ida_hexrays.hxe_locopt (variable)
    Basic block level optimization has been finished.

ida_hexrays.hxe_maturity (variable)
    Ctree maturity level is being changed.

ida_hexrays.hxe_microcode (variable)
    Microcode has been generated.

ida_hexrays.hxe_open_pseudocode (variable)
    New pseudocode view has been opened.

ida_hexrays.hxe_populating_popup (variable)
    Populating popup menu. We can add menu items now.

ida_hexrays.hxe_prealloc (variable)
    Local variables: preallocation step begins.

ida_hexrays.hxe_preoptimized (variable)
    Microcode has been preoptimized.

ida_hexrays.hxe_print_func (variable)
    Printing ctree and generating text.

ida_hexrays.hxe_prolog (variable)
    Prolog analysis has been finished.

ida_hexrays.hxe_refresh_pseudocode (variable)
    Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is
    forbidden in this event.

ida_hexrays.hxe_resolve_stkaddrs (variable)
    The optimizer is about to resolve stack addresses.

ida_hexrays.hxe_right_click (variable)
    Mouse right click. Use hxe_populating_popup instead, in case you want to add
    items in the popup menu.

ida_hexrays.hxe_stkpnts (variable)
    SP change points have been calculated.

ida_hexrays.hxe_structural (variable)
    Structural analysis has been finished.

ida_hexrays.hxe_switch_pseudocode (variable)
    Existing pseudocode view has been reloaded with a new function. Its text has not
    been refreshed yet, only cfunc and mba pointers are ready.

ida_hexrays.hxe_text_ready (variable)
    Decompiled text is ready.

ida_hexrays.init_hexrays_plugin (function)
    init_hexrays_plugin(flags=0) -> bool
    Check that your plugin is compatible with hex-rays decompiler. This function
    must be called before calling any other decompiler function.
    
    @param flags: (C++: int) reserved, must be 0
    @return: true if the decompiler exists and is compatible with your plugin

ida_hexrays.install_hexrays_callback (function)
    Deprecated. Please use Hexrays_Hooks instead
    Install handler for decompiler events.
    
    @return: false if failed

ida_hexrays.install_microcode_filter (function)
    install_microcode_filter(filter, install=True) -> bool
    register/unregister non-standard microcode generator
    
    @param filter: (C++: microcode_filter_t *) - microcode generator object
    @param install: (C++: bool) - TRUE - register the object, FALSE - unregister
    @return: success

ida_hexrays.is_additive (function)
    is_additive(op) -> bool
    Is additive operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_assignment (function)
    is_assignment(op) -> bool
    Is assignment operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_binary (function)
    is_binary(op) -> bool
    Is binary operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_bitop (function)
    is_bitop(op) -> bool
    Is bit related operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_bool_type (function)
    is_bool_type(type) -> bool
    Is a boolean type?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a boolean type

ida_hexrays.is_break_consumer (function)
    is_break_consumer(op) -> bool
    Does a break statement influence the specified statement code?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_commutative (function)
    is_commutative(op) -> bool
    Is commutative operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_inplace_def (function)
    is_inplace_def(type) -> bool
    Is struct/union/enum definition (not declaration)?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &

ida_hexrays.is_kreg (function)
    is_kreg(r) -> bool
    Is a kernel register? Kernel registers are temporary registers that can be used
    freely. They may be used to store values that cross instruction or basic block
    boundaries. Kernel registers do not map to regular processor registers. See also
    mba_t::alloc_kreg()
    
    @param r: (C++: mreg_t)

ida_hexrays.is_logical (function)
    is_logical(op) -> bool
    Is logical operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_loop (function)
    is_loop(op) -> bool
    Is loop statement code?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_lvalue (function)
    is_lvalue(op) -> bool
    Is Lvalue operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_may_access (function)
    is_may_access(maymust) -> bool
    
    @param maymust: maymust_t

ida_hexrays.is_mcode_addsub (function)
    is_mcode_addsub(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_call (function)
    is_mcode_call(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_commutative (function)
    is_mcode_commutative(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_convertible_to_jmp (function)
    is_mcode_convertible_to_jmp(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_convertible_to_set (function)
    is_mcode_convertible_to_set(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_divmod (function)
    is_mcode_divmod(op) -> bool
    
    @param op: enum mcode_t

ida_hexrays.is_mcode_fpu (function)
    is_mcode_fpu(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_j1 (function)
    is_mcode_j1(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_jcond (function)
    is_mcode_jcond(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_propagatable (function)
    is_mcode_propagatable(mcode) -> bool
    May opcode be propagated? Such opcodes can be used in sub-instructions (nested
    instructions) There is a handful of non-propagatable opcodes, like jumps, ret,
    nop, etc All other regular opcodes are propagatable and may appear in a nested
    instruction.
    
    @param mcode: (C++: mcode_t) enum mcode_t

ida_hexrays.is_mcode_set (function)
    is_mcode_set(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_set1 (function)
    is_mcode_set1(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_shift (function)
    is_mcode_shift(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_mcode_xdsu (function)
    is_mcode_xdsu(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.is_multiplicative (function)
    is_multiplicative(op) -> bool
    Is multiplicative operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_nonbool_type (function)
    is_nonbool_type(type) -> bool
    Is definitely a non-boolean type?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a non-boolean type (non bool and well defined)

ida_hexrays.is_paf (function)
    is_paf(t) -> bool
    Is a pointer, array, or function type?
    
    @param t: (C++: type_t)

ida_hexrays.is_prepost (function)
    is_prepost(op) -> bool
    Is pre/post increment/decrement operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_ptr_or_array (function)
    is_ptr_or_array(t) -> bool
    Is a pointer or array type?
    
    @param t: (C++: type_t)

ida_hexrays.is_relational (function)
    is_relational(op) -> bool
    Is comparison operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_signed_mcode (function)
    is_signed_mcode(code) -> bool
    
    @param code: enum mcode_t

ida_hexrays.is_small_udt (function)
    is_small_udt(tif) -> bool
    Is a small structure or union?
    
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a small UDT (user defined type). Small UDTs fit
             into a register (or pair or registers) as a rule.

ida_hexrays.is_type_correct (function)
    is_type_correct(ptr) -> bool
    Verify a type string.
    
    @param ptr: (C++: const type_t *) type_t const *
    @return: true if type string is correct

ida_hexrays.is_unary (function)
    is_unary(op) -> bool
    Is unary operator?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.is_unsigned_mcode (function)
    is_unsigned_mcode(code) -> bool
    
    @param code: enum mcode_t

ida_hexrays.iterator (class)
    Proxy of C++ bitset_t::iterator class.

ida_hexrays.iterator.__eq__ (method)
    __eq__(self, n) -> bool
    
    @param n: bitset_t::iterator const &

ida_hexrays.iterator.__init__ (method)
    __init__(self, n=-1) -> iterator
    
    @param n: int

ida_hexrays.iterator.__ne__ (method)
    __ne__(self, n) -> bool
    
    @param n: bitset_t::iterator const &

ida_hexrays.iterator.__ref__ (method)
    __ref__(self) -> int

ida_hexrays.ivl_t (class)
    Proxy of C++ ivl_t class.

ida_hexrays.ivl_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.__init__ (method)
    __init__(self, _off=0, _size=0) -> ivl_t
    
    @param _off: uval_t
    @param _size: uval_t

ida_hexrays.ivl_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.clear (method)
    clear(self)

ida_hexrays.ivl_t.compare (method)
    compare(self, r) -> int
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.contains (method)
    contains(self, off2) -> bool
    
    @param off2: uval_t

ida_hexrays.ivl_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.ivl_t.empty (method)
    empty(self) -> bool

ida_hexrays.ivl_t.extend_to_cover (method)
    extend_to_cover(self, r) -> bool
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.includes (method)
    includes(self, ivl) -> bool
    
    @param ivl: ivl_t const &

ida_hexrays.ivl_t.intersect (method)
    intersect(self, r)
    
    @param r: ivl_t const &

ida_hexrays.ivl_t.overlap (method)
    overlap(self, ivl) -> bool
    
    @param ivl: ivl_t const &

ida_hexrays.ivl_with_name_t (class)
    Proxy of C++ ivl_with_name_t class.

ida_hexrays.ivl_with_name_t.__init__ (method)
    __init__(self) -> ivl_with_name_t

ida_hexrays.ivlset_t (class)
    Proxy of C++ ivlset_t class.

ida_hexrays.ivlset_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.__init__ (method)
    __init__(self) -> ivlset_t
    __init__(self, ivl) -> ivlset_t
    
    @param ivl: ivl_t const &

ida_hexrays.ivlset_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t._print (method)
    _print(self)

ida_hexrays.ivlset_t.add (method)
    add(self, ivl) -> bool
    
    @param ivl: ivl_t const &
    
    add(self, ea, size) -> bool
    
    @param ea: ea_t
    @param size: asize_t
    
    add(self, ivs) -> bool
    
    @param ivs: ivlset_t const &

ida_hexrays.ivlset_t.addmasked (method)
    addmasked(self, ivs, mask) -> bool
    
    @param ivs: ivlset_t const &
    @param mask: ivl_t const &

ida_hexrays.ivlset_t.compare (method)
    compare(self, r) -> int
    
    @param r: ivlset_t const &

ida_hexrays.ivlset_t.contains (method)
    contains(self, off) -> bool
    
    @param off: uval_t

ida_hexrays.ivlset_t.count (method)
    count(self) -> asize_t

ida_hexrays.ivlset_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.ivlset_t.has_common (method)
    has_common(self, ivl, strict=False) -> bool
    
    @param ivl: ivl_t const &
    @param strict: bool
    
    has_common(self, ivs) -> bool
    
    @param ivs: ivlset_t const &

ida_hexrays.ivlset_t.includes (method)
    includes(self, ivs) -> bool
    
    @param ivs: ivlset_t const &

ida_hexrays.ivlset_t.intersect (method)
    intersect(self, ivs) -> bool
    
    @param ivs: ivlset_t const &

ida_hexrays.ivlset_t.sub (method)
    sub(self, ivl) -> bool
    
    @param ivl: ivl_t const &
    
    sub(self, ea, size) -> bool
    
    @param ea: ea_t
    @param size: asize_t
    
    sub(self, ivs) -> bool
    
    @param ivs: ivlset_t const &

ida_hexrays.jcnd2set (function)
    jcnd2set(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.lexcompare (function)
    lexcompare(a, b) -> int
    
    @param a: mop_t const &
    @param b: mop_t const &

ida_hexrays.lnot (function)
    Logically negate the specified expression. The specified expression will be
    logically negated. For example, "x == y" is converted into "x != y" by this
    function.
    
    @return: logically negated expression.

ida_hexrays.locate_lvar (function)
    locate_lvar(out, func_ea, varname) -> bool
    Find a variable by name.
    
    @param out: (C++: lvar_locator_t *) output buffer for the variable locator
    @param func_ea: (C++: ea_t) function start address
    @param varname: (C++: const char *) variable name
    @return: success Since VARNAME is not always enough to find the variable, it may
             decompile the function.

ida_hexrays.lvar_locator_t (class)
    Proxy of C++ lvar_locator_t class.

ida_hexrays.lvar_locator_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.__init__ (method)
    __init__(self) -> lvar_locator_t
    __init__(self, loc, ea) -> lvar_locator_t
    
    @param loc: vdloc_t const &
    @param ea: ea_t

ida_hexrays.lvar_locator_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.compare (method)
    compare(self, r) -> int
    
    @param r: lvar_locator_t const &

ida_hexrays.lvar_locator_t.defea (variable)
    Definition address. Usually, this is the address of the instruction that
    initializes the variable. In some cases it can be a fictional address.

ida_hexrays.lvar_locator_t.get_reg1 (method)
    get_reg1(self) -> mreg_t
    Get the register number of the variable.

ida_hexrays.lvar_locator_t.get_reg2 (method)
    get_reg2(self) -> mreg_t
    Get the number of the second register (works only for ALOC_REG2 lvars)

ida_hexrays.lvar_locator_t.get_scattered (method)
    get_scattered(self) -> scattered_aloc_t

ida_hexrays.lvar_locator_t.get_stkoff (method)
    get_stkoff(self) -> sval_t
    Get offset of the varialbe in the stack frame.
    
    @return: a non-negative value for stack variables. The value is an offset from
             the bottom of the stack frame in terms of vd-offsets. negative values
             mean error (not a stack variable)

ida_hexrays.lvar_locator_t.is_reg1 (method)
    is_reg1(self) -> bool
    Is variable located on one register?

ida_hexrays.lvar_locator_t.is_reg2 (method)
    is_reg2(self) -> bool
    Is variable located on two registers?

ida_hexrays.lvar_locator_t.is_reg_var (method)
    is_reg_var(self) -> bool
    Is variable located on register(s)?

ida_hexrays.lvar_locator_t.is_scattered (method)
    is_scattered(self) -> bool
    Is variable scattered?

ida_hexrays.lvar_locator_t.is_stk_var (method)
    is_stk_var(self) -> bool
    Is variable located on the stack?

ida_hexrays.lvar_locator_t.location (variable)
    Variable location.

ida_hexrays.lvar_mapping_begin (function)
    lvar_mapping_begin(map) -> lvar_mapping_iterator_t
    Get iterator pointing to the beginning of lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *

ida_hexrays.lvar_mapping_clear (function)
    lvar_mapping_clear(map)
    Clear lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)

ida_hexrays.lvar_mapping_end (function)
    lvar_mapping_end(map) -> lvar_mapping_iterator_t
    Get iterator pointing to the end of lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *

ida_hexrays.lvar_mapping_erase (function)
    lvar_mapping_erase(map, p)
    Erase current element from lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)
    @param p: (C++: lvar_mapping_iterator_t)

ida_hexrays.lvar_mapping_find (function)
    lvar_mapping_find(map, key) -> lvar_mapping_iterator_t
    Find the specified key in lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *
    @param key: (C++: const lvar_locator_t &) lvar_locator_t const &

ida_hexrays.lvar_mapping_first (function)
    lvar_mapping_first(p) -> lvar_locator_t
    Get reference to the current map key.
    
    @param p: (C++: lvar_mapping_iterator_t)

ida_hexrays.lvar_mapping_free (function)
    lvar_mapping_free(map)
    Delete lvar_mapping_t instance.
    
    @param map: (C++: lvar_mapping_t *)

ida_hexrays.lvar_mapping_insert (function)
    lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t
    Insert new (lvar_locator_t, lvar_locator_t) pair into lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)
    @param key: (C++: const lvar_locator_t &) lvar_locator_t const &
    @param val: (C++: const lvar_locator_t &) lvar_locator_t const &

ida_hexrays.lvar_mapping_iterator_t (class)
    Proxy of C++ lvar_mapping_iterator_t class.

ida_hexrays.lvar_mapping_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: lvar_mapping_iterator_t const &

ida_hexrays.lvar_mapping_iterator_t.__init__ (method)
    __init__(self) -> lvar_mapping_iterator_t

ida_hexrays.lvar_mapping_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: lvar_mapping_iterator_t const &

ida_hexrays.lvar_mapping_new (function)
    lvar_mapping_new() -> lvar_mapping_t
    Create a new lvar_mapping_t instance.

ida_hexrays.lvar_mapping_next (function)
    lvar_mapping_next(p) -> lvar_mapping_iterator_t
    Move to the next element.
    
    @param p: (C++: lvar_mapping_iterator_t)

ida_hexrays.lvar_mapping_prev (function)
    lvar_mapping_prev(p) -> lvar_mapping_iterator_t
    Move to the previous element.
    
    @param p: (C++: lvar_mapping_iterator_t)

ida_hexrays.lvar_mapping_second (function)
    lvar_mapping_second(p) -> lvar_locator_t
    Get reference to the current map value.
    
    @param p: (C++: lvar_mapping_iterator_t)

ida_hexrays.lvar_mapping_size (function)
    lvar_mapping_size(map) -> size_t
    Get size of lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)

ida_hexrays.lvar_mapping_t (class)
    Proxy of C++ std::map< lvar_locator_t,lvar_locator_t > class.

ida_hexrays.lvar_mapping_t.__init__ (method)
    __init__(self) -> lvar_mapping_t

ida_hexrays.lvar_mapping_t.at (method)
    at(self, _Keyval) -> lvar_locator_t
    
    @param _Keyval: lvar_locator_t const &

ida_hexrays.lvar_mapping_t.size (method)
    size(self) -> size_t

ida_hexrays.lvar_ref_t (class)
    Proxy of C++ lvar_ref_t class.

ida_hexrays.lvar_ref_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__init__ (method)
    __init__(self, m, i, o=0) -> lvar_ref_t
    
    @param m: mba_t *
    @param i: int
    @param o: sval_t
    
    __init__(self, r) -> lvar_ref_t
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.compare (method)
    compare(self, r) -> int
    
    @param r: lvar_ref_t const &

ida_hexrays.lvar_ref_t.idx (variable)
    index into mba->vars

ida_hexrays.lvar_ref_t.mba (variable)
    Pointer to the parent mba_t object. Since we need to access the 'mba->vars'
    array in order to retrieve the referenced variable, we keep a pointer to mba_t
    here. Note: this means this class and consequently mop_t, minsn_t, mblock_t are
    specific to a mba_t object and cannot migrate between them. fortunately this is
    not something we need to do. second, lvar_ref_t's appear only after MMAT_LVARS.

ida_hexrays.lvar_ref_t.off (variable)
    offset from the beginning of the variable

ida_hexrays.lvar_ref_t.swap (method)
    swap(self, r)
    
    @param r: lvar_ref_t &

ida_hexrays.lvar_ref_t.var (method)
    var(self) -> lvar_t
    Retrieve the referenced variable.

ida_hexrays.lvar_saved_info_t (class)
    Proxy of C++ lvar_saved_info_t class.

ida_hexrays.lvar_saved_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: lvar_saved_info_t const &

ida_hexrays.lvar_saved_info_t.__init__ (method)
    __init__(self) -> lvar_saved_info_t

ida_hexrays.lvar_saved_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: lvar_saved_info_t const &

ida_hexrays.lvar_saved_info_t.clear_keep (method)
    clear_keep(self)

ida_hexrays.lvar_saved_info_t.clr_nomap_lvar (method)
    clr_nomap_lvar(self)

ida_hexrays.lvar_saved_info_t.clr_noptr_lvar (method)
    clr_noptr_lvar(self)

ida_hexrays.lvar_saved_info_t.clr_split_lvar (method)
    clr_split_lvar(self)

ida_hexrays.lvar_saved_info_t.clr_unused_lvar (method)
    clr_unused_lvar(self)

ida_hexrays.lvar_saved_info_t.cmt (variable)
    Comment.

ida_hexrays.lvar_saved_info_t.flags (variable)
    saved user lvar info property bits

ida_hexrays.lvar_saved_info_t.has_info (method)
    has_info(self) -> bool

ida_hexrays.lvar_saved_info_t.is_kept (method)
    is_kept(self) -> bool

ida_hexrays.lvar_saved_info_t.is_nomap_lvar (method)
    is_nomap_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_noptr_lvar (method)
    is_noptr_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_split_lvar (method)
    is_split_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_unused_lvar (method)
    is_unused_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.ll (variable)
    Variable locator.

ida_hexrays.lvar_saved_info_t.name (variable)
    Name.

ida_hexrays.lvar_saved_info_t.set_keep (method)
    set_keep(self)

ida_hexrays.lvar_saved_info_t.set_nomap_lvar (method)
    set_nomap_lvar(self)

ida_hexrays.lvar_saved_info_t.set_noptr_lvar (method)
    set_noptr_lvar(self)

ida_hexrays.lvar_saved_info_t.set_split_lvar (method)
    set_split_lvar(self)

ida_hexrays.lvar_saved_info_t.set_unused_lvar (method)
    set_unused_lvar(self)

ida_hexrays.lvar_saved_info_t.size (variable)
    Type size (if not initialized then -1)

ida_hexrays.lvar_saved_info_t.type (variable)
    Type.

ida_hexrays.lvar_saved_infos_t (class)
    Proxy of C++ qvector< lvar_saved_info_t > class.

ida_hexrays.lvar_saved_infos_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< lvar_saved_info_t > const &

ida_hexrays.lvar_saved_infos_t.__getitem__ (method)
    __getitem__(self, i) -> lvar_saved_info_t
    
    @param i: size_t

ida_hexrays.lvar_saved_infos_t.__init__ (method)
    __init__(self) -> lvar_saved_infos_t
    __init__(self, x) -> lvar_saved_infos_t
    
    @param x: qvector< lvar_saved_info_t > const &

ida_hexrays.lvar_saved_infos_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.lvar_saved_infos_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< lvar_saved_info_t > const &

ida_hexrays.lvar_saved_infos_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.at (method)
    at(self, _idx) -> lvar_saved_info_t
    
    @param _idx: size_t

ida_hexrays.lvar_saved_infos_t.begin (method)
    begin(self) -> lvar_saved_info_t

ida_hexrays.lvar_saved_infos_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.lvar_saved_infos_t.clear (method)
    clear(self)

ida_hexrays.lvar_saved_infos_t.empty (method)
    empty(self) -> bool

ida_hexrays.lvar_saved_infos_t.end (method)
    end(self) -> lvar_saved_info_t

ida_hexrays.lvar_saved_infos_t.erase (method)
    erase(self, it) -> lvar_saved_info_t
    
    @param it: qvector< lvar_saved_info_t >::iterator
    
    erase(self, first, last) -> lvar_saved_info_t
    
    @param first: qvector< lvar_saved_info_t >::iterator
    @param last: qvector< lvar_saved_info_t >::iterator

ida_hexrays.lvar_saved_infos_t.extract (method)
    extract(self) -> lvar_saved_info_t

ida_hexrays.lvar_saved_infos_t.find (method)
    find(self, x) -> lvar_saved_info_t
    
    @param x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.grow (method)
    grow(self, x=lvar_saved_info_t())
    
    @param x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.has (method)
    has(self, x) -> bool
    
    @param x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.inject (method)
    inject(self, s, len)
    
    @param s: lvar_saved_info_t *
    @param len: size_t

ida_hexrays.lvar_saved_infos_t.insert (method)
    insert(self, it, x) -> lvar_saved_info_t
    
    @param it: qvector< lvar_saved_info_t >::iterator
    @param x: lvar_saved_info_t const &

ida_hexrays.lvar_saved_infos_t.pop_back (method)
    pop_back(self)

ida_hexrays.lvar_saved_infos_t.push_back (method)
    push_back(self, x)
    
    @param x: lvar_saved_info_t const &
    
    push_back(self) -> lvar_saved_info_t

ida_hexrays.lvar_saved_infos_t.qclear (method)
    qclear(self)

ida_hexrays.lvar_saved_infos_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.lvar_saved_infos_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: lvar_saved_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.lvar_saved_infos_t.size (method)
    size(self) -> size_t

ida_hexrays.lvar_saved_infos_t.swap (method)
    swap(self, r)
    
    @param r: qvector< lvar_saved_info_t > &

ida_hexrays.lvar_saved_infos_t.truncate (method)
    truncate(self)

ida_hexrays.lvar_t (class)
    Proxy of C++ lvar_t class.

ida_hexrays.lvar_t.__init__ (method)

ida_hexrays.lvar_t.accepts_type (method)
    accepts_type(self, t, may_change_thisarg=False) -> bool
    Check if the variable accept the specified type. Some types are forbidden (void,
    function types, wrong arrays, etc)
    
    @param t: (C++: const tinfo_t &) tinfo_t const &
    @param may_change_thisarg: (C++: bool)

ida_hexrays.lvar_t.append_list (method)
    append_list(self, mba, lst, pad_if_scattered=False)
    Append local variable to mlist.
    
    @param mba: (C++: const mba_t *) ptr to the current mba_t
    @param lst: (C++: mlist_t *) list to append to
    @param pad_if_scattered: (C++: bool) if true, append padding bytes in case of scattered lvar

ida_hexrays.lvar_t.clear_used (method)
    clear_used(self)

ida_hexrays.lvar_t.clr_arg_var (method)
    clr_arg_var(self)

ida_hexrays.lvar_t.clr_automapped (method)
    clr_automapped(self)

ida_hexrays.lvar_t.clr_decl_unused (method)
    clr_decl_unused(self)

ida_hexrays.lvar_t.clr_dummy_arg (method)
    clr_dummy_arg(self)

ida_hexrays.lvar_t.clr_fake_var (method)
    clr_fake_var(self)

ida_hexrays.lvar_t.clr_floating_var (method)
    clr_floating_var(self)

ida_hexrays.lvar_t.clr_mapdst_var (method)
    clr_mapdst_var(self)

ida_hexrays.lvar_t.clr_mreg_done (method)
    clr_mreg_done(self)

ida_hexrays.lvar_t.clr_noptr_var (method)
    clr_noptr_var(self)

ida_hexrays.lvar_t.clr_notarg (method)
    clr_notarg(self)

ida_hexrays.lvar_t.clr_overlapped_var (method)
    clr_overlapped_var(self)

ida_hexrays.lvar_t.clr_shared (method)
    clr_shared(self)

ida_hexrays.lvar_t.clr_split_var (method)
    clr_split_var(self)

ida_hexrays.lvar_t.clr_spoiled_var (method)
    clr_spoiled_var(self)

ida_hexrays.lvar_t.clr_thisarg (method)
    clr_thisarg(self)

ida_hexrays.lvar_t.clr_unknown_width (method)
    clr_unknown_width(self)

ida_hexrays.lvar_t.clr_used_byref (method)
    clr_used_byref(self)

ida_hexrays.lvar_t.clr_user_info (method)
    clr_user_info(self)

ida_hexrays.lvar_t.clr_user_name (method)
    clr_user_name(self)

ida_hexrays.lvar_t.clr_user_type (method)
    clr_user_type(self)

ida_hexrays.lvar_t.cmt (variable)
    variable comment string

ida_hexrays.lvar_t.defblk (variable)
    first block defining the variable. 0 for args, -1 if unknown

ida_hexrays.lvar_t.divisor (variable)
    max known divisor of the variable

ida_hexrays.lvar_t.has_common (method)
    has_common(self, v) -> bool
    Do variables overlap?
    
    @param v: (C++: const lvar_t &) lvar_t const &

ida_hexrays.lvar_t.has_common_bit (method)
    has_common_bit(self, loc, width2) -> bool
    Does the variable overlap with the specified location?
    
    @param loc: (C++: const vdloc_t &) vdloc_t const &
    @param width2: (C++: asize_t)

ida_hexrays.lvar_t.has_nice_name (method)
    has_nice_name(self) -> bool
    Does the variable have a nice name?

ida_hexrays.lvar_t.has_regname (method)
    has_regname(self) -> bool
    Has a register name? (like _RAX)

ida_hexrays.lvar_t.has_user_info (method)
    has_user_info(self) -> bool
    Has any user-defined information?

ida_hexrays.lvar_t.has_user_name (method)
    has_user_name(self) -> bool
    Has user-defined name?

ida_hexrays.lvar_t.has_user_type (method)
    has_user_type(self) -> bool
    Has user-defined type?

ida_hexrays.lvar_t.in_asm (method)
    in_asm(self) -> bool
    Is variable used in an instruction translated into __asm?

ida_hexrays.lvar_t.is_aliasable (method)
    is_aliasable(self, mba) -> bool
    Is the variable aliasable?
    
    @param mba: (C++: const mba_t *) ptr to the current mba_t Aliasable variables may be modified
                indirectly (through a pointer)

ida_hexrays.lvar_t.is_arg_var (method)
    is_arg_var(self) -> bool
    Is the function argument?

ida_hexrays.lvar_t.is_automapped (method)
    is_automapped(self) -> bool
    Was the variable automatically mapped to another variable?

ida_hexrays.lvar_t.is_decl_unused (method)
    is_decl_unused(self) -> bool
    Was declared as __unused by the user? See CVAR_UNUSED.

ida_hexrays.lvar_t.is_dummy_arg (method)
    is_dummy_arg(self) -> bool
    Is a dummy argument (added to fill a hole in the argument list)

ida_hexrays.lvar_t.is_fake_var (method)
    is_fake_var(self) -> bool
    Is fake return variable?

ida_hexrays.lvar_t.is_floating_var (method)
    is_floating_var(self) -> bool
    Used by a fpu insn?

ida_hexrays.lvar_t.is_mapdst_var (method)
    is_mapdst_var(self) -> bool
    Other variable(s) map to this var?

ida_hexrays.lvar_t.is_noptr_var (method)
    is_noptr_var(self) -> bool
    Variable type should not be a pointer.

ida_hexrays.lvar_t.is_notarg (method)
    is_notarg(self) -> bool
    Is a local variable? (local variable cannot be an input argument)

ida_hexrays.lvar_t.is_overlapped_var (method)
    is_overlapped_var(self) -> bool
    Is overlapped variable?

ida_hexrays.lvar_t.is_result_var (method)
    is_result_var(self) -> bool
    Is the function result?

ida_hexrays.lvar_t.is_shared (method)
    is_shared(self) -> bool
    Is lvar mapped to several chains.

ida_hexrays.lvar_t.is_split_var (method)
    is_split_var(self) -> bool
    Is a split variable?

ida_hexrays.lvar_t.is_spoiled_var (method)
    is_spoiled_var(self) -> bool
    Is spoiled var? (meaningful only during lvar allocation)

ida_hexrays.lvar_t.is_thisarg (method)
    is_thisarg(self) -> bool
    Is 'this' argument of a C++ member function?

ida_hexrays.lvar_t.is_unknown_width (method)
    is_unknown_width(self) -> bool
    Do we know the width of the variable?

ida_hexrays.lvar_t.is_used_byref (method)
    is_used_byref(self) -> bool
    Was the address of the variable taken?

ida_hexrays.lvar_t.mreg_done (method)
    mreg_done(self) -> bool
    Have corresponding microregs been replaced by references to this variable?

ida_hexrays.lvar_t.name (variable)
    variable name. use mba_t::set_nice_lvar_name() and mba_t::set_user_lvar_name()
    to modify it

ida_hexrays.lvar_t.set_arg_var (method)
    set_arg_var(self)

ida_hexrays.lvar_t.set_automapped (method)
    set_automapped(self)

ida_hexrays.lvar_t.set_decl_unused (method)
    set_decl_unused(self)

ida_hexrays.lvar_t.set_dummy_arg (method)
    set_dummy_arg(self)

ida_hexrays.lvar_t.set_fake_var (method)
    set_fake_var(self)

ida_hexrays.lvar_t.set_final_lvar_type (method)
    set_final_lvar_type(self, t)
    Set final variable type.
    
    @param t: (C++: const tinfo_t &) tinfo_t const &

ida_hexrays.lvar_t.set_floating_var (method)
    set_floating_var(self)

ida_hexrays.lvar_t.set_lvar_type (method)
    set_lvar_type(self, t, may_fail=False) -> bool
    Set variable type Note: this function does not modify the idb, only the lvar
    instance in the memory. For permanent changes see modify_user_lvars() Also, the
    variable type is not considered as final by the decompiler and may be modified
    later by the type derivation. In some cases set_final_var_type() may work
    better, but it does not do persistent changes to the database neither.
    
    @param t: (C++: const tinfo_t &) new type
    @param may_fail: (C++: bool) if false and type is bad, interr
    @return: success

ida_hexrays.lvar_t.set_mapdst_var (method)
    set_mapdst_var(self)

ida_hexrays.lvar_t.set_mreg_done (method)
    set_mreg_done(self)

ida_hexrays.lvar_t.set_non_typed (method)
    set_non_typed(self)

ida_hexrays.lvar_t.set_noptr_var (method)
    set_noptr_var(self)

ida_hexrays.lvar_t.set_notarg (method)
    set_notarg(self)

ida_hexrays.lvar_t.set_overlapped_var (method)
    set_overlapped_var(self)

ida_hexrays.lvar_t.set_shared (method)
    set_shared(self)

ida_hexrays.lvar_t.set_split_var (method)
    set_split_var(self)

ida_hexrays.lvar_t.set_spoiled_var (method)
    set_spoiled_var(self)

ida_hexrays.lvar_t.set_thisarg (method)
    set_thisarg(self)

ida_hexrays.lvar_t.set_typed (method)
    set_typed(self)

ida_hexrays.lvar_t.set_unknown_width (method)
    set_unknown_width(self)

ida_hexrays.lvar_t.set_used (method)
    set_used(self)

ida_hexrays.lvar_t.set_used_byref (method)
    set_used_byref(self)

ida_hexrays.lvar_t.set_user_name (method)
    set_user_name(self)

ida_hexrays.lvar_t.set_user_type (method)
    set_user_type(self)

ida_hexrays.lvar_t.set_width (method)
    set_width(self, w, svw_flags=0) -> bool
    Change the variable width. We call the variable size 'width', it is represents
    the number of bytes. This function may change the variable type using
    set_lvar_type().
    
    @param w: (C++: int) new width
    @param svw_flags: (C++: int) combination of SVW_... bits
    @return: success

ida_hexrays.lvar_t.tif (variable)
    variable type

ida_hexrays.lvar_t.type (method)
    type(self) -> tinfo_t

ida_hexrays.lvar_t.typed (method)
    typed(self) -> bool
    Has the variable a type?

ida_hexrays.lvar_t.used (method)
    used(self) -> bool
    Is the variable used in the code?

ida_hexrays.lvar_t.width (variable)
    variable size in bytes

ida_hexrays.lvar_uservec_t (class)
    Proxy of C++ lvar_uservec_t class.

ida_hexrays.lvar_uservec_t.__init__ (method)
    __init__(self) -> lvar_uservec_t

ida_hexrays.lvar_uservec_t.clear (method)
    clear(self)

ida_hexrays.lvar_uservec_t.empty (method)
    empty(self) -> bool

ida_hexrays.lvar_uservec_t.find_info (method)
    find_info(self, vloc) -> lvar_saved_info_t
    find saved user settings for given var
    
    @param vloc: (C++: const lvar_locator_t &) lvar_locator_t const &

ida_hexrays.lvar_uservec_t.keep_info (method)
    keep_info(self, v)
    Preserve user settings for given var.
    
    @param v: (C++: const lvar_t &) lvar_t const &

ida_hexrays.lvar_uservec_t.lmaps (variable)
    Local variable mapping (used for merging variables)

ida_hexrays.lvar_uservec_t.lvvec (variable)
    User-specified names, types, comments for lvars. Variables without user-
    specified info are not present in this vector.

ida_hexrays.lvar_uservec_t.stkoff_delta (variable)
    Delta to add to IDA stack offset to calculate Hex-Rays stack offsets. Should be
    set by the caller before calling save_user_lvar_settings();

ida_hexrays.lvar_uservec_t.swap (method)
    swap(self, r)
    
    @param r: lvar_uservec_t &

ida_hexrays.lvar_uservec_t.ulv_flags (variable)
    Various flags. Possible values are from lvar_uservec_t property bits.

ida_hexrays.lvars_t (class)
    Proxy of C++ lvars_t class.

ida_hexrays.lvars_t.__init__ (method)
    __init__(self) -> lvars_t

ida_hexrays.lvars_t.find (method)
    find(self, ll) -> lvar_t
    Find variable at the specified location.
    
    @param ll: (C++: const lvar_locator_t &) variable location
    @return: pointer to variable or nullptr

ida_hexrays.lvars_t.find_input_lvar (method)
    find_input_lvar(self, argloc, _size) -> int
    Find input variable at the specified location.
    
    @param argloc: (C++: const vdloc_t &) variable location
    @param _size: (C++: int) variable size
    @return: -1 if failed, otherwise the index into the variables vector.

ida_hexrays.lvars_t.find_lvar (method)
    find_lvar(self, location, width, defblk=-1) -> int
    Find variable at the specified location.
    
    @param location: (C++: const vdloc_t &) variable location
    @param width: (C++: int) variable size
    @param defblk: (C++: int) definition block of the lvar. -1 means any block
    @return: -1 if failed, otherwise the index into the variables vector.

ida_hexrays.lvars_t.find_stkvar (method)
    find_stkvar(self, spoff, width) -> int
    Find stack variable at the specified location.
    
    @param spoff: (C++: sval_t) offset from the minimal sp
    @param width: (C++: int) variable size
    @return: -1 if failed, otherwise the index into the variables vector.

ida_hexrays.lxe_lvar_cmt_changed (variable)
    Local variable comment got changed.

ida_hexrays.lxe_lvar_mapping_changed (variable)
    Local variable mapping got changed.

ida_hexrays.lxe_lvar_name_changed (variable)
    Local variable got renamed.

ida_hexrays.lxe_lvar_type_changed (variable)
    Local variable type got changed.

ida_hexrays.make_num (function)
    Create a number expression

ida_hexrays.make_pointer (function)
    make_pointer(type) -> tinfo_t
    Create a pointer type. This function performs the following conversion: "type"
    -> "type*"
    
    @param type: (C++: const tinfo_t &) object type.
    @return: "type*". for example, if 'char' is passed as the argument,

ida_hexrays.make_ref (function)
    Create a reference. This function performs the following conversion: "obj" =>
    "&obj". It can handle casts, annihilate "&*", and process other special cases.

ida_hexrays.mark_cfunc_dirty (function)
    mark_cfunc_dirty(ea, close_views=False) -> bool
    Flush the cached decompilation results. Erases a cache entry for the specified
    function.
    
    @param ea: (C++: ea_t) function to erase from the cache
    @param close_views: (C++: bool) close pseudocode windows that show the function
    @return: if a cache entry existed.

ida_hexrays.mba_range_iterator_t (class)
    Proxy of C++ mba_range_iterator_t class.

ida_hexrays.mba_range_iterator_t.__init__ (method)
    __init__(self) -> mba_range_iterator_t

ida_hexrays.mba_range_iterator_t.chunk (method)
    chunk(self) -> range_t

ida_hexrays.mba_range_iterator_t.is_snippet (method)
    is_snippet(self) -> bool

ida_hexrays.mba_range_iterator_t.next (method)
    next(self) -> bool

ida_hexrays.mba_range_iterator_t.set (method)
    set(self, mbr) -> bool
    
    @param mbr: mba_ranges_t const &

ida_hexrays.mba_ranges_t (class)
    Proxy of C++ mba_ranges_t class.

ida_hexrays.mba_ranges_t.__init__ (method)
    __init__(self, _pfn=None) -> mba_ranges_t
    
    @param _pfn: func_t *
    
    __init__(self, r) -> mba_ranges_t
    
    @param r: rangevec_t const &

ida_hexrays.mba_ranges_t.clear (method)
    clear(self)

ida_hexrays.mba_ranges_t.empty (method)
    empty(self) -> bool

ida_hexrays.mba_ranges_t.is_fragmented (method)
    is_fragmented(self) -> bool

ida_hexrays.mba_ranges_t.is_snippet (method)
    is_snippet(self) -> bool

ida_hexrays.mba_ranges_t.pfn (variable)
    function to decompile. if not null, then function mode.

ida_hexrays.mba_ranges_t.ranges (variable)
    snippet mode: ranges to decompile. function mode: list of outlined ranges

ida_hexrays.mba_ranges_t.start (method)
    start(self) -> ea_t

ida_hexrays.mba_t (class)
    Deprecated. Please do not use.

ida_hexrays.mba_t.__init__ (method)

ida_hexrays.mba_t._deregister (method)
    _deregister(self)

ida_hexrays.mba_t._print (method)
    _print(self, vp)
    
    Parameters
    ----------
    vp: vd_printer_t &

ida_hexrays.mba_t._register (method)
    _register(self)

ida_hexrays.mba_t.aliased_args (variable)
    Aliased stkarg locations.

ida_hexrays.mba_t.aliased_memory (variable)
    aliased_memory+restricted_memory=ALLMEM

ida_hexrays.mba_t.aliased_vars (variable)
    Aliased stkvar locations.

ida_hexrays.mba_t.alloc_fict_ea (method)
    alloc_fict_ea(self, real_ea) -> ea_t
    Allocate a fictional address. This function can be used to allocate a new unique
    address for a new instruction, if re-using any existing address leads to
    conflicts. For example, if the last instruction of the function modifies R0 and
    falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end
    of the function start of another function In this case R0 generates two
    different lvars at the same address:
    * one modified by LDM
    * another that represents the return value from the tail call Another example: a
    third-party plugin makes a copy of an instruction. This may lead to the
    generation of two variables at the same address. Example 3: fictional addresses
    can be used for new instructions created while modifying the microcode. This
    function can be used to allocate a new unique address for a new instruction or a
    variable. The fictional address is selected from an unallocated address range.
    
    @param real_ea: (C++: ea_t) real instruction address (BADADDR is ok too)
    @return: a unique fictional address

ida_hexrays.mba_t.alloc_kreg (method)
    alloc_kreg(self, size, check_size=True) -> mreg_t
    Allocate a kernel register.
    
    @param size: (C++: size_t) size of the register in bytes
    @param check_size: (C++: bool) if true, only the sizes that correspond to a size of a basic
                       type will be accepted.
    @return: allocated register. mr_none means failure.

ida_hexrays.mba_t.alloc_lvars (method)
    alloc_lvars(self)
    Allocate local variables. Must be called only immediately after
    optimize_global(), with no modifications to the microcode. Converts registers,
    stack variables, and similar operands into mop_l. This call will not fail
    because all necessary checks were performed in optimize_global(). After this
    call the microcode reaches its final state.

ida_hexrays.mba_t.analyze_calls (method)
    analyze_calls(self, acflags) -> int
    Analyze calls and determine calling conventions.
    
    @param acflags: (C++: int) permitted actions that are necessary for successful detection of
                    calling conventions. See Bits for analyze_calls()
    @return: number of calls. -1 means error.

ida_hexrays.mba_t.arg (method)
    arg(self, n) -> lvar_t
    
    @param n: int

ida_hexrays.mba_t.argbase (method)
    argbase(self) -> sval_t

ida_hexrays.mba_t.argidx (variable)
    input arguments (indexes into 'vars')

ida_hexrays.mba_t.argidx_ok (method)
    argidx_ok(self) -> bool

ida_hexrays.mba_t.argidx_sorted (method)
    argidx_sorted(self) -> bool

ida_hexrays.mba_t.bad_call_sp_detected (method)
    bad_call_sp_detected(self) -> bool

ida_hexrays.mba_t.blocks (variable)
    double linked list of blocks

ida_hexrays.mba_t.build_graph (method)
    build_graph(self) -> merror_t
    Build control flow graph. This function may be called only once. It calculates
    the type of each basic block and the adjacency list. optimize_local() calls this
    function if necessary. You need to call this function only before MMAT_LOCOPT.
    
    @return: error code

ida_hexrays.mba_t.calc_shins_flags (method)
    calc_shins_flags(self) -> int

ida_hexrays.mba_t.callinfo_built (method)
    callinfo_built(self) -> bool

ida_hexrays.mba_t.cc (variable)
    calling convention

ida_hexrays.mba_t.chain_varnums_ok (method)
    chain_varnums_ok(self) -> bool

ida_hexrays.mba_t.clr_cdtr (method)
    clr_cdtr(self)

ida_hexrays.mba_t.clr_mba_flags (method)
    clr_mba_flags(self, f)
    
    @param f: int

ida_hexrays.mba_t.clr_mba_flags2 (method)
    clr_mba_flags2(self, f)
    
    @param f: int

ida_hexrays.mba_t.code16_bit_removed (method)
    code16_bit_removed(self) -> bool

ida_hexrays.mba_t.combine_blocks (method)
    combine_blocks(self) -> bool
    Combine blocks. This function merges blocks constituting linear flow. It calls
    remove_empty_and_unreachable_blocks() as well.
    
    @return: true if changed any blocks

ida_hexrays.mba_t.common_stkvars_stkargs (method)
    common_stkvars_stkargs(self) -> bool

ida_hexrays.mba_t.consumed_argregs (variable)
    registers converted into stack arguments, should not be used as arguments

ida_hexrays.mba_t.copy_block (method)
    copy_block(self, blk, new_serial, cpblk_flags=3) -> mblock_t
    Make a copy of a block. This function makes a simple copy of the block. It does
    not fix the predecessor and successor lists, they must be fixed if necessary.
    
    @param blk: (C++: mblock_t *) block to copy
    @param new_serial: (C++: int) position of the copied block
    @param cpblk_flags: (C++: int) combination of Batch decompilation bits... bits
    @return: pointer to the new copy

ida_hexrays.mba_t.create_helper_call (method)
    create_helper_call(self, ea, helper, rettype=None, callargs=None, out=None) -> minsn_t
    Create a call of a helper function.
    
    @param ea: (C++: ea_t) The desired address of the instruction
    @param helper: (C++: const char *) The helper name
    @param rettype: (C++: const tinfo_t *) The return type (nullptr or empty type means 'void')
    @param callargs: (C++: const mcallargs_t *) The helper arguments (nullptr-no arguments)
    @param out: (C++: const mop_t *) The operand where the call result should be stored. If this argument
                is not nullptr, "mov helper_call(), out" will be generated.
                Otherwise "call helper()" will be generated. Note: the size of this
                operand must be equal to the RETTYPE size
    @return: pointer to the created instruction or nullptr if error

ida_hexrays.mba_t.deleted_pairs (method)
    deleted_pairs(self) -> bool

ida_hexrays.mba_t.deprecated_idb_node (variable)
    netnode with additional decompiler info. deprecated, do not use it anymore. it
    may get stale after undo.

ida_hexrays.mba_t.deserialize (method)
    deserialize(bytes) -> mba_t
    Deserialize a byte sequence into mbl array.
    
    @param bytes: (C++: const uchar *) pointer to the beginning of the byte sequence.
    @return: new mbl array

ida_hexrays.mba_t.display_numaddrs (method)
    display_numaddrs(self) -> bool

ida_hexrays.mba_t.display_valnums (method)
    display_valnums(self) -> bool

ida_hexrays.mba_t.dump (method)
    dump(self)
    Dump microcode to a file. The file will be created in the directory pointed by
    IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger.

ida_hexrays.mba_t.dump_mba (method)
    dump_mba(self, _verify, title)
    
    @param _verify: bool
    @param title: char const *

ida_hexrays.mba_t.error_ea (variable)
    during microcode generation holds ins.ea

ida_hexrays.mba_t.final_type (variable)
    is the function type final? (specified by the user)

ida_hexrays.mba_t.find_mop (method)
    find_mop(self, ctx, ea, is_dest, list) -> mop_t
    Find an operand in the microcode. This function tries to find the operand that
    matches LIST. Any operand that overlaps with LIST is considered as a match.
    
    @param ctx: (C++: op_parent_info_t *) context information for the result
    @param ea: (C++: ea_t) desired address of the operand. BADADDR means to accept any address.
    @param is_dest: (C++: bool) search for destination operand? this argument may be ignored if
                    the exact match could not be found
    @param list: (C++: const mlist_t &) list of locations the correspond to the operand
    @return: pointer to the operand or nullptr.

ida_hexrays.mba_t.for_all_insns (method)
    for_all_insns(self, mv) -> int
    Visit all instructions. This function visits all instruction and
    subinstructions.
    
    @param mv: (C++: minsn_visitor_t &) instruction visitor
    @return: non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.for_all_ops (method)
    for_all_ops(self, mv) -> int
    Visit all operands of all instructions.
    
    @param mv: (C++: mop_visitor_t &) operand visitor
    @return: non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.for_all_topinsns (method)
    for_all_topinsns(self, mv) -> int
    Visit all top level instructions.
    
    @param mv: (C++: minsn_visitor_t &) instruction visitor
    @return: non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.fpd (variable)
    frame pointer delta

ida_hexrays.mba_t.free_kreg (method)
    free_kreg(self, reg, size)
    Free a kernel register. If wrong arguments are passed, this function will
    generate an internal error.
    
    @param reg: (C++: mreg_t) a previously allocated kernel register
    @param size: (C++: size_t) size of the register in bytes

ida_hexrays.mba_t.frregs (variable)
    size of saved registers range in the stack frame

ida_hexrays.mba_t.frsize (variable)
    size of local stkvars range in the stack frame

ida_hexrays.mba_t.fti_flags (variable)
    FTI_... constants for the current function.

ida_hexrays.mba_t.fullsize (variable)
    Full stack size including incoming args.

ida_hexrays.mba_t.generated_asserts (method)
    generated_asserts(self) -> bool

ida_hexrays.mba_t.get_args_region (method)
    get_args_region(self) -> ivl_t

ida_hexrays.mba_t.get_curfunc (method)
    get_curfunc(self) -> func_t *

ida_hexrays.mba_t.get_func_output_lists (method)
    get_func_output_lists(self, return_regs, spoiled, type, call_ea=BADADDR, tail_call=False)
    Prepare the lists of registers & memory that are defined/killed by a function
    
    @param return_regs: (C++: mlist_t *) defined regs to return (eax,edx)
    @param spoiled: (C++: mlist_t *) spoiled regs (flags,ecx,mem)
    @param type: (C++: const tinfo_t &) the function type
    @param call_ea: (C++: ea_t) the call insn address (if known)
    @param tail_call: (C++: bool) is it the tail call?

ida_hexrays.mba_t.get_graph (method)
    get_graph(self) -> mbl_graph_t
    Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT.

ida_hexrays.mba_t.get_ida_argloc (method)
    get_ida_argloc(self, v) -> argloc_t
    
    @param v: lvar_t const &

ida_hexrays.mba_t.get_lvars_region (method)
    get_lvars_region(self) -> ivl_t

ida_hexrays.mba_t.get_mba_flags (method)
    get_mba_flags(self) -> int

ida_hexrays.mba_t.get_mba_flags2 (method)
    get_mba_flags2(self) -> int

ida_hexrays.mba_t.get_mblock (method)
    get_mblock(self, n) -> mblock_t
    
    @param n: int

ida_hexrays.mba_t.get_shadow_region (method)
    get_shadow_region(self) -> ivl_t

ida_hexrays.mba_t.get_stack_region (method)
    get_stack_region(self) -> ivl_t

ida_hexrays.mba_t.get_std_region (method)
    get_std_region(self, idx) -> ivl_t
    Get information about various memory regions. We map the stack frame to the
    global memory, to some unused range.
    
    @param idx: (C++: memreg_index_t) enum memreg_index_t

ida_hexrays.mba_t.gotoff_stkvars (variable)
    stkvars that hold .got offsets. considered to be unaliasable

ida_hexrays.mba_t.graph_insns (method)
    graph_insns(self) -> bool

ida_hexrays.mba_t.has_bad_sp (method)
    has_bad_sp(self) -> bool

ida_hexrays.mba_t.has_outlines (method)
    has_outlines(self) -> bool

ida_hexrays.mba_t.has_over_chains (method)
    has_over_chains(self) -> bool

ida_hexrays.mba_t.has_passregs (method)
    has_passregs(self) -> bool

ida_hexrays.mba_t.has_stack_retval (method)
    has_stack_retval(self) -> bool

ida_hexrays.mba_t.idaloc2vd (method)
    idaloc2vd(self, loc, width) -> vdloc_t
    
    @param loc: argloc_t const &
    @param width: int

ida_hexrays.mba_t.idb_spoiled (variable)
    MBA_SPLINFO && final_type: info in ida format.

ida_hexrays.mba_t.idb_type (variable)
    function type as retrieved from the database

ida_hexrays.mba_t.inargoff (variable)
    offset of the first stack argument; after fix_scattered_movs() INARGOFF may be
    less than STACKSIZE

ida_hexrays.mba_t.insert_block (method)
    insert_block(self, bblk) -> mblock_t
    Insert a block in the middle of the mbl array. The very first block of microcode
    must be empty, it is the entry block. The very last block of microcode must be
    BLT_STOP, it is the exit block. Therefore inserting a new block before the entry
    point or after the exit block is not a good idea.
    
    @param bblk: (C++: int) the new block will be inserted before BBLK
    @return: ptr to the new block

ida_hexrays.mba_t.is_cdtr (method)
    is_cdtr(self) -> bool

ida_hexrays.mba_t.is_ctr (method)
    is_ctr(self) -> bool

ida_hexrays.mba_t.is_dtr (method)
    is_dtr(self) -> bool

ida_hexrays.mba_t.is_pattern (method)
    is_pattern(self) -> bool

ida_hexrays.mba_t.is_snippet (method)
    is_snippet(self) -> bool

ida_hexrays.mba_t.is_stkarg (method)
    is_stkarg(self, v) -> bool
    
    @param v: lvar_t const &

ida_hexrays.mba_t.is_thunk (method)
    is_thunk(self) -> bool

ida_hexrays.mba_t.label (variable)
    name of the function or pattern (colored)

ida_hexrays.mba_t.loaded_gdl (method)
    loaded_gdl(self) -> bool

ida_hexrays.mba_t.lvar_names_ok (method)
    lvar_names_ok(self) -> bool

ida_hexrays.mba_t.lvars_allocated (method)
    lvars_allocated(self) -> bool

ida_hexrays.mba_t.lvars_renamed (method)
    lvars_renamed(self) -> bool

ida_hexrays.mba_t.map_fict_ea (method)
    map_fict_ea(self, fict_ea) -> ea_t
    Resolve a fictional address. This function provides a reverse of the mapping
    made by alloc_fict_ea().
    
    @param fict_ea: (C++: ea_t) fictional definition address
    @return: the real instruction address

ida_hexrays.mba_t.mark_chains_dirty (method)
    mark_chains_dirty(self)
    Mark the microcode use-def chains dirty. Call this function is any inter-block
    data dependencies got changed because of your modifications to the microcode.
    Failing to do so may cause an internal error.

ida_hexrays.mba_t.maturity (variable)
    current maturity level

ida_hexrays.mba_t.may_refine_rettype (method)
    may_refine_rettype(self) -> bool

ida_hexrays.mba_t.minargref (variable)
    The lowest stack argument location whose address was taken This location and
    locations above it can be aliased It controls locations >= inargoff-shadow_args

ida_hexrays.mba_t.minstkref (variable)
    The lowest stack location whose address was taken.

ida_hexrays.mba_t.minstkref_ea (variable)
    address with lowest minstkref (for debugging)

ida_hexrays.mba_t.natural (variable)
    natural order of blocks

ida_hexrays.mba_t.nodel_memory (variable)
    global dead elimination may not delete references to this area

ida_hexrays.mba_t.npurged (variable)
    -1 - unknown

ida_hexrays.mba_t.optimize_global (method)
    optimize_global(self) -> merror_t
    Optimize microcode globally. This function applies various optimization methods
    until we reach the fixed point. After that it preallocates lvars unless reqmat
    forbids it.
    
    @return: error code

ida_hexrays.mba_t.optimize_local (method)
    optimize_local(self, locopt_bits) -> int
    Optimize each basic block locally
    
    @param locopt_bits: (C++: int) combination of Bits for optimize_local() bits
    @return: number of changes. 0 means nothing changed This function is called by
             the decompiler, usually there is no need to call it explicitly.

ida_hexrays.mba_t.optimized (method)
    optimized(self) -> bool

ida_hexrays.mba_t.pfn_flags (variable)
    copy of func_t::flags

ida_hexrays.mba_t.precise_defeas (method)
    precise_defeas(self) -> bool

ida_hexrays.mba_t.prop_complex (method)
    prop_complex(self) -> bool

ida_hexrays.mba_t.propagated_asserts (method)
    propagated_asserts(self) -> bool

ida_hexrays.mba_t.qty (variable)
    number of basic blocks

ida_hexrays.mba_t.really_alloc (method)
    really_alloc(self) -> bool

ida_hexrays.mba_t.regargs_is_not_aligned (method)
    regargs_is_not_aligned(self) -> bool

ida_hexrays.mba_t.remove_block (method)
    remove_block(self, blk) -> bool
    Delete a block.
    
    @param blk: (C++: mblock_t *) block to delete
    @return: true if at least one of the other blocks became empty or unreachable

ida_hexrays.mba_t.remove_empty_and_unreachable_blocks (method)
    remove_empty_and_unreachable_blocks(self) -> bool
    Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be
    deleted.

ida_hexrays.mba_t.reqmat (variable)
    required maturity level

ida_hexrays.mba_t.retsize (variable)
    size of return address in the stack frame

ida_hexrays.mba_t.returns_fpval (method)
    returns_fpval(self) -> bool

ida_hexrays.mba_t.retvaridx (variable)
    index of variable holding the return value -1 means none

ida_hexrays.mba_t.rtype_refined (method)
    rtype_refined(self) -> bool

ida_hexrays.mba_t.save_snapshot (method)
    save_snapshot(self, description)
    Create and save microcode snapshot.
    
    @param description: (C++: const char *) char const *

ida_hexrays.mba_t.saverest_done (method)
    saverest_done(self) -> bool

ida_hexrays.mba_t.serialize (method)
    serialize(self)
    Serialize mbl array into a sequence of bytes.

ida_hexrays.mba_t.set_lvar_name (method)
    set_lvar_name(self, v, name, flagbits) -> bool
    
    @param v: lvar_t &
    @param name: char const *
    @param flagbits: int

ida_hexrays.mba_t.set_maturity (method)
    set_maturity(self, mat) -> bool
    Set maturity level.
    
    @param mat: (C++: mba_maturity_t) new maturity level
    @return: true if it is time to stop analysis Plugins may use this function to
             skip some parts of the analysis. The maturity level cannot be
             decreased.

ida_hexrays.mba_t.set_mba_flags (method)
    set_mba_flags(self, f)
    
    @param f: int

ida_hexrays.mba_t.set_mba_flags2 (method)
    set_mba_flags2(self, f)
    
    @param f: int

ida_hexrays.mba_t.set_nice_lvar_name (method)
    set_nice_lvar_name(self, v, name) -> bool
    
    @param v: lvar_t &
    @param name: char const *

ida_hexrays.mba_t.set_user_lvar_name (method)
    set_user_lvar_name(self, v, name) -> bool
    
    @param v: lvar_t &
    @param name: char const *

ida_hexrays.mba_t.shadow_args (variable)
    size of shadow argument area

ida_hexrays.mba_t.short_display (method)
    short_display(self) -> bool

ida_hexrays.mba_t.should_beautify (method)
    should_beautify(self) -> bool

ida_hexrays.mba_t.show_reduction (method)
    show_reduction(self) -> bool

ida_hexrays.mba_t.spd_adjust (variable)
    If sp>0, the max positive sp value.

ida_hexrays.mba_t.spoiled_list (variable)
    MBA_SPLINFO && !final_type: info in vd format.

ida_hexrays.mba_t.stacksize (variable)
    The maximal size of the function stack including bytes allocated for outgoing
    call arguments (up to retaddr)

ida_hexrays.mba_t.std_ivls (variable)
    we treat memory as consisting of 6 parts see memreg_index_t

ida_hexrays.mba_t.stkoff_ida2vd (method)
    stkoff_ida2vd(self, off) -> sval_t
    
    @param off: sval_t

ida_hexrays.mba_t.stkoff_vd2ida (method)
    stkoff_vd2ida(self, off) -> sval_t
    
    @param off: sval_t

ida_hexrays.mba_t.term (method)
    term(self)

ida_hexrays.mba_t.tmpstk_size (variable)
    size of the temporary stack part (which dynamically changes with push/pops)

ida_hexrays.mba_t.use_frame (method)
    use_frame(self) -> bool

ida_hexrays.mba_t.use_wingraph32 (method)
    use_wingraph32(self) -> bool

ida_hexrays.mba_t.valranges_done (method)
    valranges_done(self) -> bool

ida_hexrays.mba_t.vars (variable)
    local variables

ida_hexrays.mba_t.vd2idaloc (method)
    vd2idaloc(self, loc, width, spd) -> argloc_t
    
    @param loc: vdloc_t const &
    @param width: int
    @param spd: sval_t
    
    vd2idaloc(self, loc, width) -> argloc_t
    
    @param loc: vdloc_t const &
    @param width: int

ida_hexrays.mba_t.verify (method)
    verify(self, always)
    Verify microcode consistency.
    
    @param always: (C++: bool) if false, the check will be performed only if ida runs under
                   debugger If any inconsistency is discovered, an internal error
                   will be generated. We strongly recommend you to call this
                   function before returing control to the decompiler from your
                   callbacks, in the case if you modified the microcode. If the
                   microcode is inconsistent, this function will generate an
                   internal error. We provide the source code of this function in
                   the plugins/hexrays_sdk/verifier directory for your reference.

ida_hexrays.mba_t.write_to_const_detected (method)
    write_to_const_detected(self) -> bool

ida_hexrays.mba_t_deserialize (function)
    mba_t_deserialize(bytes) -> mba_t
    
    @param bytes: uchar const *

ida_hexrays.mbl_graph_t (class)
    Proxy of C++ mbl_graph_t class.

ida_hexrays.mbl_graph_t.__init__ (method)

ida_hexrays.mbl_graph_t.get_chain_stamp (method)
    get_chain_stamp(self) -> int

ida_hexrays.mbl_graph_t.get_du (method)
    get_du(self, gctype) -> graph_chains_t
    Get def-use chains.
    
    @param gctype: (C++: gctype_t) enum gctype_t

ida_hexrays.mbl_graph_t.get_mblock (method)
    get_mblock(self, n) -> mblock_t
    
    @param n: int

ida_hexrays.mbl_graph_t.get_ud (method)
    get_ud(self, gctype) -> graph_chains_t
    Get use-def chains.
    
    @param gctype: (C++: gctype_t) enum gctype_t

ida_hexrays.mbl_graph_t.is_du_chain_dirty (method)
    is_du_chain_dirty(self, gctype) -> bool
    Is the def-use chain of the specified kind dirty?
    
    @param gctype: (C++: gctype_t) enum gctype_t

ida_hexrays.mbl_graph_t.is_redefined_globally (method)
    is_redefined_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
    Is LIST redefined in the graph?
    
    @param list: (C++: const mlist_t &) mlist_t const &
    @param b1: (C++: int)
    @param b2: (C++: int)
    @param m1: (C++: const minsn_t *) minsn_t const *
    @param m2: (C++: const minsn_t *) minsn_t const *
    @param maymust: (C++: maymust_t)

ida_hexrays.mbl_graph_t.is_ud_chain_dirty (method)
    is_ud_chain_dirty(self, gctype) -> bool
    Is the use-def chain of the specified kind dirty?
    
    @param gctype: (C++: gctype_t) enum gctype_t

ida_hexrays.mbl_graph_t.is_used_globally (method)
    is_used_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
    Is LIST used in the graph?
    
    @param list: (C++: const mlist_t &) mlist_t const &
    @param b1: (C++: int)
    @param b2: (C++: int)
    @param m1: (C++: const minsn_t *) minsn_t const *
    @param m2: (C++: const minsn_t *) minsn_t const *
    @param maymust: (C++: maymust_t)

ida_hexrays.mblock_t (class)
    Proxy of C++ mblock_t class.

ida_hexrays.mblock_t.__init__ (method)

ida_hexrays.mblock_t._print (method)
    _print(self, vp)
    
    Parameters
    ----------
    vp: vd_printer_t &

ida_hexrays.mblock_t.append_def_list (method)
    append_def_list(self, list, op, maymust)
    Append def-list of an operand. This function calculates list of locations that
    may or must be modified by the operand and appends it to LIST.
    
    @param list: (C++: mlist_t *) ptr to the output buffer. we will append to it.
    @param op: (C++: const mop_t &) operand to calculate the def list of
    @param maymust: (C++: maymust_t) should we calculate 'may-def' or 'must-def' list? see maymust_t
                    for more details.

ida_hexrays.mblock_t.append_use_list (method)
    append_use_list(self, list, op, maymust, mask=bitrange_t(0, USHRT_MAX))
    Append use-list of an operand. This function calculates list of locations that
    may or must be used by the operand and appends it to LIST.
    
    @param list: (C++: mlist_t *) ptr to the output buffer. we will append to it.
    @param op: (C++: const mop_t &) operand to calculate the use list of
    @param maymust: (C++: maymust_t) should we calculate 'may-use' or 'must-use' list? see maymust_t
                    for more details.
    @param mask: (C++: bitrange_t) if only part of the operand should be considered, a bitmask can be
                 used to specify which part. example: op=AX,mask=0xFF means that we
                 will consider only AL.

ida_hexrays.mblock_t.build_def_list (method)
    build_def_list(self, ins, maymust) -> mlist_t
    Build def-list of an instruction. This function calculates list of locations
    that may or must be modified by the instruction. Examples: "stx ebx.4, ds.2,
    eax.4", may-list: all aliasable memory "stx ebx.4, ds.2, eax.4", must-list:
    empty Since STX uses EAX for indirect access, it may modify any aliasable
    memory. On the other hand, we cannot tell for sure which memory cells will be
    modified, this is why the must-list is empty.
    
    @param ins: (C++: const minsn_t &) instruction to calculate the def list of
    @param maymust: (C++: maymust_t) should we calculate 'may-def' or 'must-def' list? see maymust_t
                    for more details.
    @return: the calculated def-list

ida_hexrays.mblock_t.build_lists (method)
    build_lists(self, kill_deads) -> int
    Build def-use lists and eliminate deads.
    
    @param kill_deads: (C++: bool) do delete dead instructions?
    @return: the number of eliminated instructions Better mblock_t::call
             make_lists_ready() rather than this function.

ida_hexrays.mblock_t.build_use_list (method)
    build_use_list(self, ins, maymust) -> mlist_t
    Build use-list of an instruction. This function calculates list of locations
    that may or must be used by the instruction. Examples: "ldx ds.2, eax.4, ebx.4",
    may-list: all aliasable memory "ldx ds.2, eax.4, ebx.4", must-list: empty Since
    LDX uses EAX for indirect access, it may access any aliasable memory. On the
    other hand, we cannot tell for sure which memory cells will be accessed, this is
    why the must-list is empty.
    
    @param ins: (C++: const minsn_t &) instruction to calculate the use list of
    @param maymust: (C++: maymust_t) should we calculate 'may-use' or 'must-use' list? see maymust_t
                    for more details.
    @return: the calculated use-list

ida_hexrays.mblock_t.dead_at_start (variable)
    data that is dead at the block entry

ida_hexrays.mblock_t.dnu (variable)
    data that is defined but not used in the block

ida_hexrays.mblock_t.dump (method)
    dump(self)
    Dump block info. This function is useful for debugging, see mba_t::dump for info

ida_hexrays.mblock_t.dump_block (method)
    dump_block(self, title)
    
    @param title: char const *

ida_hexrays.mblock_t.empty (method)
    empty(self) -> bool

ida_hexrays.mblock_t.end (variable)
    end address note: we cannot rely on start/end addresses very much because
    instructions are propagated between blocks

ida_hexrays.mblock_t.find_access (method)
    find_access(self, op, parent, mend, fdflags) -> minsn_t
    Find the instruction that accesses the specified operand. This function search
    inside one block.
    
    @param op: (C++: const mop_t &) operand to search for
    @param parent: (C++: minsn_t **) ptr to ptr to a top level instruction. denotes the beginning of
                   the search range.
    @param mend: (C++: const minsn_t *) end instruction of the range (must be a top level insn) mend is
                 excluded from the range. it can be specified as nullptr. parent and
                 mend must belong to the same block.
    @param fdflags: (C++: int) combination of bits for mblock_t::find_access bits
    @return: the instruction that accesses the operand. this instruction may be a
             sub-instruction. to find out the top level instruction, check out
             *p_i1. nullptr means 'not found'.

ida_hexrays.mblock_t.find_def (method)
    find_def(self, op, p_i1, i2, fdflags) -> minsn_t
    
    @param op: mop_t const &
    @param p_i1: minsn_t **
    @param i2: minsn_t const *
    @param fdflags: int

ida_hexrays.mblock_t.find_first_use (method)
    find_first_use(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
    
    @param list: mlist_t *
    @param i1: minsn_t *
    @param i2: minsn_t const *
    @param maymust: maymust_t

ida_hexrays.mblock_t.find_redefinition (method)
    find_redefinition(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
    
    @param list: mlist_t const &
    @param i1: minsn_t *
    @param i2: minsn_t const *
    @param maymust: maymust_t

ida_hexrays.mblock_t.find_use (method)
    find_use(self, op, p_i1, i2, fdflags) -> minsn_t
    
    @param op: mop_t const &
    @param p_i1: minsn_t **
    @param i2: minsn_t const *
    @param fdflags: int

ida_hexrays.mblock_t.flags (variable)
    combination of Basic block properties bits

ida_hexrays.mblock_t.for_all_insns (method)
    for_all_insns(self, mv) -> int
    Visit all instructions. This function visits subinstructions too.
    
    @param mv: (C++: minsn_visitor_t &) instruction visitor
    @return: zero or the value returned by mv.visit_insn() See also
             mba_t::for_all_topinsns()

ida_hexrays.mblock_t.for_all_ops (method)
    for_all_ops(self, mv) -> int
    Visit all operands. This function visit subinstruction operands too.
    
    @param mv: (C++: mop_visitor_t &) operand visitor
    @return: zero or the value returned by mv.visit_mop()

ida_hexrays.mblock_t.for_all_uses (method)
    for_all_uses(self, list, i1, i2, mmv) -> int
    Visit all operands that use LIST.
    
    @param list: (C++: mlist_t *) ptr to the list of locations. it may be modified: parts that get
                 redefined by the instructions in [i1,i2) will be deleted.
    @param i1: (C++: minsn_t *) starting instruction. must be a top level insn.
    @param i2: (C++: minsn_t *) ending instruction (excluded). must be a top level insn.
    @param mmv: (C++: mlist_mop_visitor_t &) operand visitor
    @return: zero or the value returned by mmv.visit_mop()

ida_hexrays.mblock_t.get_reginsn_qty (method)
    get_reginsn_qty(self) -> size_t
    Calculate number of regular instructions in the block. Assertions are skipped by
    this function.
    
    @return: Number of non-assertion instructions in the block.

ida_hexrays.mblock_t.get_valranges (method)
    get_valranges(self, res, vivl, vrflags) -> bool
    Find possible values for an instruction.
    
    @param res: (C++: valrng_t *) set of value ranges
    @param vivl: (C++: const vivl_t &) what to search for
    @param vrflags: (C++: int) combination of bits for get_valranges bits
    get_valranges(self, res, vivl, m, vrflags) -> bool
    
    @param res: valrng_t *
    @param vivl: vivl_t const &
    @param m: minsn_t const *
    @param vrflags: int

ida_hexrays.mblock_t.head (variable)
    pointer to the first instruction of the block

ida_hexrays.mblock_t.insert_into_block (method)
    insert_into_block(self, nm, om) -> minsn_t
    Insert instruction into the doubly linked list
    
    @param nm: (C++: minsn_t *) new instruction
    @param om: (C++: minsn_t *) existing instruction, part of the doubly linked list if nullptr, then
               the instruction will be inserted at the beginning of the list NM will
               be inserted immediately after OM
    @return: pointer to NM

ida_hexrays.mblock_t.is_branch (method)
    is_branch(self) -> bool

ida_hexrays.mblock_t.is_call_block (method)
    is_call_block(self) -> bool

ida_hexrays.mblock_t.is_nway (method)
    is_nway(self) -> bool

ida_hexrays.mblock_t.is_redefined (method)
    is_redefined(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
    Is the list redefined by the specified instructions?
    
    @param list: (C++: const mlist_t &) list of locations to check.
    @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
    @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
               excluded from the range. it can be specified as nullptr. i1 and i2
               must belong to the same block.
    @param maymust: (C++: maymust_t) should we search in 'may-access' or 'must-access' mode?

ida_hexrays.mblock_t.is_rhs_redefined (method)
    is_rhs_redefined(self, ins, i1, i2) -> bool
    Is the right hand side of the instruction redefined the insn range? "right hand
    side" corresponds to the source operands of the instruction.
    
    @param ins: (C++: const minsn_t *) instruction to consider
    @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
    @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
               excluded from the range. it can be specified as nullptr. i1 and i2
               must belong to the same block.

ida_hexrays.mblock_t.is_simple_goto_block (method)
    is_simple_goto_block(self) -> bool

ida_hexrays.mblock_t.is_simple_jcnd_block (method)
    is_simple_jcnd_block(self) -> bool

ida_hexrays.mblock_t.is_unknown_call (method)
    is_unknown_call(self) -> bool

ida_hexrays.mblock_t.is_used (method)
    is_used(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
    Is the list used by the specified instruction range?
    
    @param list: (C++: mlist_t *) list of locations. LIST may be modified by the function: redefined
                 locations will be removed from it.
    @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
    @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
               excluded from the range. it can be specified as nullptr. i1 and i2
               must belong to the same block.
    @param maymust: (C++: maymust_t) should we search in 'may-access' or 'must-access' mode?

ida_hexrays.mblock_t.lists_dirty (method)
    lists_dirty(self) -> bool

ida_hexrays.mblock_t.lists_ready (method)
    lists_ready(self) -> bool

ida_hexrays.mblock_t.make_lists_ready (method)
    make_lists_ready(self) -> int

ida_hexrays.mblock_t.make_nop (method)
    make_nop(self, m)
    Erase the instruction (convert it to nop) and mark the lists dirty. This is the
    recommended function to use because it also marks the block use-def lists dirty.
    
    @param m: (C++: minsn_t *)

ida_hexrays.mblock_t.mark_lists_dirty (method)
    mark_lists_dirty(self)

ida_hexrays.mblock_t.maxbsp (variable)
    maximal sp value in the block (0...stacksize)

ida_hexrays.mblock_t.maybdef (variable)
    data that may be defined by the block

ida_hexrays.mblock_t.maybuse (variable)
    data that may be used by the block

ida_hexrays.mblock_t.mba (variable)
    the parent micro block array

ida_hexrays.mblock_t.minbargref (variable)
    the same for arguments

ida_hexrays.mblock_t.minbstkref (variable)
    lowest stack location accessible with indirect addressing (offset from the stack
    bottom) initially it is 0 (not computed)

ida_hexrays.mblock_t.mustbdef (variable)
    data that must be defined by the block

ida_hexrays.mblock_t.mustbuse (variable)
    data that must be used by the block

ida_hexrays.mblock_t.needs_propagation (method)
    needs_propagation(self) -> bool

ida_hexrays.mblock_t.nextb (variable)
    next block in the doubly linked list

ida_hexrays.mblock_t.npred (method)
    npred(self) -> int
    Get number of block predecessors.

ida_hexrays.mblock_t.nsucc (method)
    nsucc(self) -> int
    Get number of block successors.

ida_hexrays.mblock_t.optimize_block (method)
    optimize_block(self) -> int
    Optimize a basic block. Usually there is no need to call this function
    explicitly because the decompiler will call it itself if optinsn_t::func or
    optblock_t::func return non-zero.
    
    @return: number of changes made to the block

ida_hexrays.mblock_t.optimize_insn (method)
    optimize_insn(self, m, optflags=0x0002|0x0004) -> int
    Optimize one instruction in the context of the block.
    
    @param m: (C++: minsn_t *) pointer to a top level instruction
    @param optflags: (C++: int) combination of optimization flags bits
    @return: number of changes made to the block This function may change other
             instructions in the block too. However, it will not destroy top level
             instructions (it may convert them to nop's). This function performs
             only intrablock modifications. See also minsn_t::optimize_solo()

ida_hexrays.mblock_t.optimize_useless_jump (method)
    optimize_useless_jump(self) -> int
    Remove a jump at the end of the block if it is useless. This function preserves
    any side effects when removing a useless jump. Both conditional and
    unconditional jumps are handled (and jtbl too). This function deletes useless
    jumps, not only replaces them with a nop. (please note that \optimize_insn does
    not handle useless jumps).
    
    @return: number of changes made to the block

ida_hexrays.mblock_t.pred (method)
    pred(self, n) -> int
    
    @param n: int

ida_hexrays.mblock_t.preds (method)
    Iterates the list of predecessor blocks

ida_hexrays.mblock_t.predset (variable)
    control flow graph: list of our predecessors use npred() and pred() to access it

ida_hexrays.mblock_t.prevb (variable)
    previous block in the doubly linked list

ida_hexrays.mblock_t.remove_from_block (method)
    remove_from_block(self, m) -> minsn_t
    Remove instruction from the doubly linked list
    
    @param m: (C++: minsn_t *) instruction to remove The removed instruction is not deleted, the
              caller gets its ownership
    @return: pointer to the next instruction

ida_hexrays.mblock_t.request_demote64 (method)
    request_demote64(self)

ida_hexrays.mblock_t.request_propagation (method)
    request_propagation(self)

ida_hexrays.mblock_t.serial (variable)
    block number

ida_hexrays.mblock_t.start (variable)
    start address

ida_hexrays.mblock_t.succ (method)
    succ(self, n) -> int
    
    @param n: int

ida_hexrays.mblock_t.succs (method)
    Iterates the list of successor blocks

ida_hexrays.mblock_t.succset (variable)
    control flow graph: list of our successors use nsucc() and succ() to access it

ida_hexrays.mblock_t.tail (variable)
    pointer to the last instruction of the block

ida_hexrays.mblock_t.type (variable)
    block type (BLT_NONE - not computed yet)

ida_hexrays.mcallarg_t (class)
    Proxy of C++ mcallarg_t class.

ida_hexrays.mcallarg_t.__init__ (method)
    __init__(self) -> mcallarg_t
    __init__(self, rarg) -> mcallarg_t
    
    @param rarg: mop_t const &

ida_hexrays.mcallarg_t._print (method)
    _print(self, shins_flags=0x04|0x02)
    
    Parameters
    ----------
    shins_flags: int

ida_hexrays.mcallarg_t.argloc (variable)
    ida argloc

ida_hexrays.mcallarg_t.copy_mop (method)
    copy_mop(self, op)
    
    @param op: mop_t const &

ida_hexrays.mcallarg_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.mcallarg_t.ea (variable)
    address where the argument was initialized. BADADDR means unknown.

ida_hexrays.mcallarg_t.flags (variable)
    FAI_...

ida_hexrays.mcallarg_t.make_int (method)
    make_int(self, val, val_ea, opno=0)
    
    @param val: int
    @param val_ea: ea_t
    @param opno: int

ida_hexrays.mcallarg_t.make_uint (method)
    make_uint(self, val, val_ea, opno=0)
    
    @param val: int
    @param val_ea: ea_t
    @param opno: int

ida_hexrays.mcallarg_t.name (variable)
    formal argument name

ida_hexrays.mcallarg_t.set_regarg (method)
    set_regarg(self, mr, sz, tif)
    
    @param mr: mreg_t
    @param sz: int
    @param tif: tinfo_t const &
    
    set_regarg(self, mr, tif)
    
    @param mr: mreg_t
    @param tif: tinfo_t const &
    
    set_regarg(self, mr, dt, sign=type_unsigned)
    
    @param mr: mreg_t
    @param dt: char
    @param sign: type_sign_t

ida_hexrays.mcallarg_t.type (variable)
    formal argument type

ida_hexrays.mcallargs_t (class)
    Proxy of C++ qvector< mcallarg_t > class.

ida_hexrays.mcallargs_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< mcallarg_t > const &

ida_hexrays.mcallargs_t.__getitem__ (method)
    __getitem__(self, i) -> mcallarg_t
    
    @param i: size_t

ida_hexrays.mcallargs_t.__init__ (method)
    __init__(self) -> mcallargs_t
    __init__(self, x) -> mcallargs_t
    
    @param x: qvector< mcallarg_t > const &

ida_hexrays.mcallargs_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.mcallargs_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< mcallarg_t > const &

ida_hexrays.mcallargs_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: mcallarg_t const &

ida_hexrays.mcallargs_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: mcallarg_t const &

ida_hexrays.mcallargs_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: mcallarg_t const &

ida_hexrays.mcallargs_t.at (method)
    at(self, _idx) -> mcallarg_t
    
    @param _idx: size_t

ida_hexrays.mcallargs_t.begin (method)
    begin(self) -> mcallarg_t

ida_hexrays.mcallargs_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.mcallargs_t.clear (method)
    clear(self)

ida_hexrays.mcallargs_t.empty (method)
    empty(self) -> bool

ida_hexrays.mcallargs_t.end (method)
    end(self) -> mcallarg_t

ida_hexrays.mcallargs_t.erase (method)
    erase(self, it) -> mcallarg_t
    
    @param it: qvector< mcallarg_t >::iterator
    
    erase(self, first, last) -> mcallarg_t
    
    @param first: qvector< mcallarg_t >::iterator
    @param last: qvector< mcallarg_t >::iterator

ida_hexrays.mcallargs_t.extract (method)
    extract(self) -> mcallarg_t

ida_hexrays.mcallargs_t.find (method)
    find(self, x) -> mcallarg_t
    
    @param x: mcallarg_t const &

ida_hexrays.mcallargs_t.grow (method)
    grow(self, x=mcallarg_t())
    
    @param x: mcallarg_t const &

ida_hexrays.mcallargs_t.has (method)
    has(self, x) -> bool
    
    @param x: mcallarg_t const &

ida_hexrays.mcallargs_t.inject (method)
    inject(self, s, len)
    
    @param s: mcallarg_t *
    @param len: size_t

ida_hexrays.mcallargs_t.insert (method)
    insert(self, it, x) -> mcallarg_t
    
    @param it: qvector< mcallarg_t >::iterator
    @param x: mcallarg_t const &

ida_hexrays.mcallargs_t.pop_back (method)
    pop_back(self)

ida_hexrays.mcallargs_t.push_back (method)
    push_back(self, x)
    
    @param x: mcallarg_t const &
    
    push_back(self) -> mcallarg_t

ida_hexrays.mcallargs_t.qclear (method)
    qclear(self)

ida_hexrays.mcallargs_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.mcallargs_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: mcallarg_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.mcallargs_t.size (method)
    size(self) -> size_t

ida_hexrays.mcallargs_t.swap (method)
    swap(self, r)
    
    @param r: qvector< mcallarg_t > &

ida_hexrays.mcallargs_t.truncate (method)
    truncate(self)

ida_hexrays.mcallinfo_t (class)
    Proxy of C++ mcallinfo_t class.

ida_hexrays.mcallinfo_t.__init__ (method)
    __init__(self, _callee=BADADDR, _sargs=0) -> mcallinfo_t
    
    @param _callee: ea_t
    @param _sargs: int

ida_hexrays.mcallinfo_t._print (method)
    _print(self, size=-1, shins_flags=0x04|0x02)
    
    Parameters
    ----------
    size: int
    shins_flags: int

ida_hexrays.mcallinfo_t.args (variable)
    call arguments

ida_hexrays.mcallinfo_t.call_spd (variable)
    sp value at call insn

ida_hexrays.mcallinfo_t.callee (variable)
    address of the called function, if known

ida_hexrays.mcallinfo_t.cc (variable)
    calling convention

ida_hexrays.mcallinfo_t.dead_regs (variable)
    registers defined by the function but never used. upon propagation we do the
    following:
    * dead_regs += return_regs
    * retregs.clear() since the call is propagated

ida_hexrays.mcallinfo_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.mcallinfo_t.flags (variable)
    combination of Call properties... bits

ida_hexrays.mcallinfo_t.fti_attrs (variable)
    extended function attributes

ida_hexrays.mcallinfo_t.get_type (method)
    get_type(self) -> tinfo_t

ida_hexrays.mcallinfo_t.is_vararg (method)
    is_vararg(self) -> bool

ida_hexrays.mcallinfo_t.lexcompare (method)
    lexcompare(self, f) -> int
    
    @param f: mcallinfo_t const &

ida_hexrays.mcallinfo_t.pass_regs (variable)
    passthrough registers: registers that depend on input values (subset of spoiled)

ida_hexrays.mcallinfo_t.retregs (variable)
    return register(s) (e.g., AX, AX:DX, etc.) this vector is built from return_regs

ida_hexrays.mcallinfo_t.return_argloc (variable)
    location of the returned value

ida_hexrays.mcallinfo_t.return_regs (variable)
    list of values returned by the function

ida_hexrays.mcallinfo_t.return_type (variable)
    type of the returned value

ida_hexrays.mcallinfo_t.role (variable)
    function role

ida_hexrays.mcallinfo_t.set_type (method)
    set_type(self, type) -> bool
    
    @param type: tinfo_t const &

ida_hexrays.mcallinfo_t.solid_args (variable)
    number of solid args. there may be variadic args in addtion

ida_hexrays.mcallinfo_t.spoiled (variable)
    list of spoiled locations (includes return_regs)

ida_hexrays.mcallinfo_t.stkargs_top (variable)
    first offset past stack arguments

ida_hexrays.mcallinfo_t.visible_memory (variable)
    what memory is visible to the call?

ida_hexrays.mcases_t (class)
    Proxy of C++ mcases_t class.

ida_hexrays.mcases_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.__init__ (method)
    __init__(self) -> mcases_t

ida_hexrays.mcases_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: mcases_t const &

ida_hexrays.mcases_t._print (method)
    _print(self)

ida_hexrays.mcases_t.compare (method)
    compare(self, r) -> int
    
    @param r: mcases_t const &

ida_hexrays.mcases_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.mcases_t.empty (method)
    empty(self) -> bool

ida_hexrays.mcases_t.resize (method)
    resize(self, s)
    
    @param s: int

ida_hexrays.mcases_t.size (method)
    size(self) -> size_t

ida_hexrays.mcases_t.swap (method)
    swap(self, r)
    
    @param r: mcases_t &

ida_hexrays.mcases_t.targets (variable)
    target block numbers

ida_hexrays.mcases_t.values (variable)
    expression values for each target

ida_hexrays.mcode_modifies_d (function)
    mcode_modifies_d(mcode) -> bool
    
    @param mcode: enum mcode_t

ida_hexrays.microcode_filter_t (class)
    Proxy of C++ microcode_filter_t class.

ida_hexrays.microcode_filter_t.__disown__ (method)

ida_hexrays.microcode_filter_t.__init__ (method)
    __init__(self) -> microcode_filter_t
    
    @param self: PyObject *

ida_hexrays.microcode_filter_t.apply (method)
    apply(self, cdg) -> merror_t
    generate microcode for an instruction
    
    @param cdg: (C++: codegen_t &)
    @return: MERR_... code: MERR_OK - user-defined microcode generated, go to the
             next instruction MERR_INSN - not generated - the caller should try the
             standard way else - error

ida_hexrays.microcode_filter_t.match (method)
    match(self, cdg) -> bool
    check if the filter object is to be applied
    
    @param cdg: (C++: codegen_t &)
    @return: success

ida_hexrays.minsn_t (class)
    Proxy of C++ minsn_t class.

ida_hexrays.minsn_t.__dbg_get_meminfo (method)
    __dbg_get_meminfo(self) -> qstring

ida_hexrays.minsn_t.__dbg_get_registered_kind (method)
    __dbg_get_registered_kind(self) -> int

ida_hexrays.minsn_t.__init__ (method)
    __init__(self, _ea) -> minsn_t
    
    @param _ea: ea_t
    
    __init__(self, m) -> minsn_t
    
    @param m: minsn_t const &

ida_hexrays.minsn_t.__lt__ (method)
    __lt__(self, ri) -> bool
    
    @param ri: minsn_t const &

ida_hexrays.minsn_t._acquire_ownership (method)

ida_hexrays.minsn_t._deregister (method)
    _deregister(self)

ida_hexrays.minsn_t._ensure_cond (method)

ida_hexrays.minsn_t._ensure_no_obj (method)

ida_hexrays.minsn_t._ensure_ownership_transferrable (method)

ida_hexrays.minsn_t._make_nop (method)
    _make_nop(self)

ida_hexrays.minsn_t._maybe_disown_and_deregister (method)

ida_hexrays.minsn_t._meminfo (method)

ida_hexrays.minsn_t._obj_id (method)
    _obj_id(self) -> PyObject *

ida_hexrays.minsn_t._own_and_register (method)

ida_hexrays.minsn_t._print (method)
    _print(self, shins_flags=0x04|0x02)
    
    Parameters
    ----------
    shins_flags: int

ida_hexrays.minsn_t._register (method)
    _register(self)

ida_hexrays.minsn_t.clr_assert (method)
    clr_assert(self)

ida_hexrays.minsn_t.clr_combinable (method)
    clr_combinable(self)

ida_hexrays.minsn_t.clr_combined (method)
    clr_combined(self)

ida_hexrays.minsn_t.clr_fpinsn (method)
    clr_fpinsn(self)

ida_hexrays.minsn_t.clr_ignlowsrc (method)
    clr_ignlowsrc(self)

ida_hexrays.minsn_t.clr_multimov (method)
    clr_multimov(self)

ida_hexrays.minsn_t.clr_noret_icall (method)
    clr_noret_icall(self)

ida_hexrays.minsn_t.clr_propagatable (method)
    clr_propagatable(self)

ida_hexrays.minsn_t.clr_tailcall (method)
    clr_tailcall(self)

ida_hexrays.minsn_t.contains_call (method)
    contains_call(self, with_helpers=False) -> bool
    Does the instruction contain a call?
    
    @param with_helpers: (C++: bool)

ida_hexrays.minsn_t.contains_opcode (method)
    contains_opcode(self, mcode) -> bool
    Does the instruction have the specified opcode? This function searches
    subinstructions as well.
    
    @param mcode: (C++: mcode_t) opcode to search for.

ida_hexrays.minsn_t.d (variable)
    destination operand

ida_hexrays.minsn_t.deserialize (method)
    deserialize(self, bytes, format_version) -> bool
    Deserialize an instruction
    
    @param bytes: (C++: const uchar *) pointer to serialized data
    @param format_version: (C++: int) serialization format version. this value is returned by
                           minsn_t::serialize()
    @return: success

ida_hexrays.minsn_t.dstr (method)
    dstr(self) -> char const *
    Get displayable text without tags in a static buffer.

ida_hexrays.minsn_t.ea (variable)
    instruction address

ida_hexrays.minsn_t.equal_insns (method)
    equal_insns(self, m, eqflags) -> bool
    Compare instructions. This is the main comparison function for instructions.
    
    @param m: (C++: const minsn_t &) instruction to compare with
    @param eqflags: (C++: int) combination of comparison bits bits

ida_hexrays.minsn_t.find_call (method)
    find_call(self, with_helpers=False) -> minsn_t
    Find a call instruction. Check for the current instruction and its
    subinstructions.
    
    @param with_helpers: (C++: bool) consider helper calls as well?

ida_hexrays.minsn_t.find_ins_op (method)
    find_ins_op(self, op=m_nop) -> minsn_t
    
    @param op: enum mcode_t

ida_hexrays.minsn_t.find_num_op (method)
    find_num_op(self) -> mop_t

ida_hexrays.minsn_t.find_opcode (method)
    find_opcode(self, mcode) -> minsn_t
    
    @param mcode: enum mcode_t

ida_hexrays.minsn_t.for_all_insns (method)
    for_all_insns(self, mv) -> int
    Visit all instructions. This function visits the instruction itself and all its
    subinstructions.
    
    @param mv: (C++: minsn_visitor_t &) instruction visitor
    @return: non-zero value returned by mv.visit_mop() or zero

ida_hexrays.minsn_t.for_all_ops (method)
    for_all_ops(self, mv) -> int
    Visit all instruction operands. This function visits subinstruction operands as
    well.
    
    @param mv: (C++: mop_visitor_t &) operand visitor
    @return: non-zero value returned by mv.visit_mop() or zero

ida_hexrays.minsn_t.get_role (method)
    get_role(self) -> funcrole_t
    Get the function role of a call.

ida_hexrays.minsn_t.get_split_size (method)
    get_split_size(self) -> int

ida_hexrays.minsn_t.has_side_effects (method)
    has_side_effects(self, include_ldx_and_divs=False) -> bool
    Does the instruction have a side effect?
    
    @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects? stx is
                                 always considered as having side effects. Apart
                                 from ldx/std only call may have side effects.

ida_hexrays.minsn_t.iprops (variable)
    combination of instruction property bits bits

ida_hexrays.minsn_t.is_after (method)
    is_after(self, m) -> bool
    Is the instruction after the specified one?
    
    @param m: (C++: const minsn_t *) the instruction to compare against in the list

ida_hexrays.minsn_t.is_alloca (method)
    is_alloca(self) -> bool

ida_hexrays.minsn_t.is_assert (method)
    is_assert(self) -> bool

ida_hexrays.minsn_t.is_between (method)
    is_between(self, m1, m2) -> bool
    Is the instruction in the specified range of instructions?
    
    @param m1: (C++: const minsn_t *) beginning of the range in the doubly linked list
    @param m2: (C++: const minsn_t *) end of the range in the doubly linked list (excluded, may be nullptr)
               This function assumes that m1 and m2 belong to the same basic block
               and they are top level instructions.

ida_hexrays.minsn_t.is_bswap (method)
    is_bswap(self) -> bool

ida_hexrays.minsn_t.is_cleaning_pop (method)
    is_cleaning_pop(self) -> bool

ida_hexrays.minsn_t.is_combinable (method)
    is_combinable(self) -> bool

ida_hexrays.minsn_t.is_combined (method)
    is_combined(self) -> bool

ida_hexrays.minsn_t.is_extstx (method)
    is_extstx(self) -> bool

ida_hexrays.minsn_t.is_farcall (method)
    is_farcall(self) -> bool

ida_hexrays.minsn_t.is_fpinsn (method)
    is_fpinsn(self) -> bool

ida_hexrays.minsn_t.is_helper (method)
    is_helper(self, name) -> bool
    Is a helper call with the specified name? Helper calls usually have well-known
    function names (see Well known function names) but they may have any other name.
    The decompiler does not assume any special meaning for non-well-known names.
    
    @param name: (C++: const char *) char const *

ida_hexrays.minsn_t.is_ignlowsrc (method)
    is_ignlowsrc(self) -> bool

ida_hexrays.minsn_t.is_inverted_jx (method)
    is_inverted_jx(self) -> bool

ida_hexrays.minsn_t.is_like_move (method)
    is_like_move(self) -> bool

ida_hexrays.minsn_t.is_mbarrier (method)
    is_mbarrier(self) -> bool

ida_hexrays.minsn_t.is_memcpy (method)
    is_memcpy(self) -> bool

ida_hexrays.minsn_t.is_memset (method)
    is_memset(self) -> bool

ida_hexrays.minsn_t.is_mov (method)
    is_mov(self) -> bool

ida_hexrays.minsn_t.is_multimov (method)
    is_multimov(self) -> bool

ida_hexrays.minsn_t.is_noret_call (method)
    is_noret_call(self, flags=0) -> bool
    Is a non-returing call?
    
    @param flags: (C++: int) combination of NORET_... bits

ida_hexrays.minsn_t.is_optional (method)
    is_optional(self) -> bool

ida_hexrays.minsn_t.is_persistent (method)
    is_persistent(self) -> bool

ida_hexrays.minsn_t.is_propagatable (method)
    is_propagatable(self) -> bool

ida_hexrays.minsn_t.is_readflags (method)
    is_readflags(self) -> bool

ida_hexrays.minsn_t.is_tailcall (method)
    is_tailcall(self) -> bool

ida_hexrays.minsn_t.is_unknown_call (method)
    is_unknown_call(self) -> bool
    Is an unknown call? Unknown calls are calls without the argument list
    (mcallinfo_t). Usually the argument lists are determined by
    mba_t::analyze_calls(). Unknown calls exist until the MMAT_CALLS maturity level.
    See also mblock_t::is_call_block

ida_hexrays.minsn_t.is_wild_match (method)
    is_wild_match(self) -> bool

ida_hexrays.minsn_t.l (variable)
    left operand

ida_hexrays.minsn_t.lexcompare (method)
    lexcompare(self, ri) -> int
    
    @param ri: minsn_t const &

ida_hexrays.minsn_t.may_use_aliased_memory (method)
    may_use_aliased_memory(self) -> bool
    Is it possible for the instruction to use aliased memory?

ida_hexrays.minsn_t.modifies_d (method)
    modifies_d(self) -> bool
    Does the instruction modify its 'd' operand? Some instructions (e.g. m_stx) do
    not modify the 'd' operand.

ida_hexrays.minsn_t.modifies_pair_mop (method)
    modifies_pair_mop(self) -> bool

ida_hexrays.minsn_t.next (variable)
    next insn in doubly linked list. check also nexti()

ida_hexrays.minsn_t.opcode (variable)
    instruction opcode

ida_hexrays.minsn_t.optimize_solo (method)
    optimize_solo(self, optflags=0) -> int
    Optimize one instruction without context. This function does not have access to
    the instruction context (the previous and next instructions in the list, the
    block number, etc). It performs only basic optimizations that are available
    without this info.
    
    @param optflags: (C++: int) combination of optimization flags bits
    @return: number of changes, 0-unchanged See also mblock_t::optimize_insn()

ida_hexrays.minsn_t.optimize_subtree (method)
    optimize_subtree(self, blk, top, parent, converted_call, optflags=0x0002) -> int
    Optimize instruction in its context. Do not use this function, use
    mblock_t::optimize()
    
    @param blk: (C++: mblock_t *)
    @param top: (C++: minsn_t *)
    @param parent: (C++: minsn_t *)
    @param converted_call: (C++: ea_t *)
    @param optflags: (C++: int)

ida_hexrays.minsn_t.prev (variable)
    prev insn in doubly linked list. check also previ()

ida_hexrays.minsn_t.r (variable)
    right operand

ida_hexrays.minsn_t.replace_by (method)

ida_hexrays.minsn_t.serialize (method)
    serialize(self, b) -> int
    Serialize an instruction
    
    @param b: (C++: bytevec_t *) the output buffer
    @return: the serialization format that was used to store info

ida_hexrays.minsn_t.set_assert (method)
    set_assert(self)

ida_hexrays.minsn_t.set_cleaning_pop (method)
    set_cleaning_pop(self)

ida_hexrays.minsn_t.set_combinable (method)
    set_combinable(self)

ida_hexrays.minsn_t.set_extstx (method)
    set_extstx(self)

ida_hexrays.minsn_t.set_farcall (method)
    set_farcall(self)

ida_hexrays.minsn_t.set_fpinsn (method)
    set_fpinsn(self)

ida_hexrays.minsn_t.set_ignlowsrc (method)
    set_ignlowsrc(self)

ida_hexrays.minsn_t.set_inverted_jx (method)
    set_inverted_jx(self)

ida_hexrays.minsn_t.set_mbarrier (method)
    set_mbarrier(self)

ida_hexrays.minsn_t.set_multimov (method)
    set_multimov(self)

ida_hexrays.minsn_t.set_noret_icall (method)
    set_noret_icall(self)

ida_hexrays.minsn_t.set_optional (method)
    set_optional(self)

ida_hexrays.minsn_t.set_persistent (method)
    set_persistent(self)

ida_hexrays.minsn_t.set_split_size (method)
    set_split_size(self, s)
    
    @param s: int

ida_hexrays.minsn_t.set_tailcall (method)
    set_tailcall(self)

ida_hexrays.minsn_t.set_unmerged (method)
    set_unmerged(self)

ida_hexrays.minsn_t.set_wild_match (method)
    set_wild_match(self)

ida_hexrays.minsn_t.setaddr (method)
    setaddr(self, new_ea)
    Change the instruction address. This function modifies subinstructions as well.
    
    @param new_ea: (C++: ea_t)

ida_hexrays.minsn_t.swap (method)
    swap(self, m)
    Swap two instructions. The prev/next fields are not modified by this function
    because it would corrupt the doubly linked list.
    
    @param m: (C++: minsn_t &)

ida_hexrays.minsn_t.was_noret_icall (method)
    was_noret_icall(self) -> bool

ida_hexrays.minsn_t.was_split (method)
    was_split(self) -> bool

ida_hexrays.minsn_t.was_unmerged (method)
    was_unmerged(self) -> bool

ida_hexrays.minsn_visitor_t (class)
    Proxy of C++ minsn_visitor_t class.

ida_hexrays.minsn_visitor_t.__disown__ (method)

ida_hexrays.minsn_visitor_t.__init__ (method)
    __init__(self, _mba=None, _blk=None, _topins=None) -> minsn_visitor_t
    
    @param _mba: mba_t *
    @param _blk: mblock_t *
    @param _topins: minsn_t *

ida_hexrays.minsn_visitor_t.visit_minsn (method)
    visit_minsn(self) -> int

ida_hexrays.mlist_mop_visitor_t (class)
    Proxy of C++ mlist_mop_visitor_t class.

ida_hexrays.mlist_mop_visitor_t.__disown__ (method)

ida_hexrays.mlist_mop_visitor_t.__init__ (method)
    __init__(self) -> mlist_mop_visitor_t
    
    @param self: PyObject *

ida_hexrays.mlist_mop_visitor_t.visit_mop (method)
    visit_mop(self, op) -> int
    
    @param op: mop_t *

ida_hexrays.mlist_t (class)
    Proxy of C++ mlist_t class.

ida_hexrays.mlist_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.__init__ (method)
    __init__(self) -> mlist_t
    __init__(self, ivl) -> mlist_t
    
    @param ivl: ivl_t const &
    
    __init__(self, r, size) -> mlist_t
    
    @param r: mreg_t
    @param size: int

ida_hexrays.mlist_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: mlist_t const &

ida_hexrays.mlist_t._print (method)
    _print(self)

ida_hexrays.mlist_t.add (method)
    add(self, r, size) -> bool
    
    @param r: mreg_t
    @param size: int
    
    add(self, r) -> bool
    
    @param r: rlist_t const &
    
    add(self, ivl) -> bool
    
    @param ivl: ivl_t const &
    
    add(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.addmem (method)
    addmem(self, ea, size) -> bool
    
    @param ea: ea_t
    @param size: asize_t

ida_hexrays.mlist_t.clear (method)
    clear(self)

ida_hexrays.mlist_t.compare (method)
    compare(self, r) -> int
    
    @param r: mlist_t const &

ida_hexrays.mlist_t.count (method)
    count(self) -> asize_t

ida_hexrays.mlist_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.mlist_t.empty (method)
    empty(self) -> bool

ida_hexrays.mlist_t.has (method)
    has(self, r) -> bool
    
    @param r: mreg_t

ida_hexrays.mlist_t.has_all (method)
    has_all(self, r, size) -> bool
    
    @param r: mreg_t
    @param size: int

ida_hexrays.mlist_t.has_any (method)
    has_any(self, r, size) -> bool
    
    @param r: mreg_t
    @param size: int

ida_hexrays.mlist_t.has_common (method)
    has_common(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.has_memory (method)
    has_memory(self) -> bool

ida_hexrays.mlist_t.includes (method)
    includes(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.intersect (method)
    intersect(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.is_subset_of (method)
    is_subset_of(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.sub (method)
    sub(self, r, size) -> bool
    
    @param r: mreg_t
    @param size: int
    
    sub(self, ivl) -> bool
    
    @param ivl: ivl_t const &
    
    sub(self, lst) -> bool
    
    @param lst: mlist_t const &

ida_hexrays.mlist_t.swap (method)
    swap(self, r)
    
    @param r: mlist_t &

ida_hexrays.mnumber_t (class)
    Proxy of C++ mnumber_t class.

ida_hexrays.mnumber_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.__init__ (method)
    __init__(self, v, _ea=BADADDR, n=0) -> mnumber_t
    
    @param v: uint64
    @param _ea: ea_t
    @param n: int

ida_hexrays.mnumber_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.compare (method)
    compare(self, r) -> int
    
    @param r: mnumber_t const &

ida_hexrays.mnumber_t.update_value (method)
    update_value(self, val64)
    
    @param val64: uint64

ida_hexrays.modify_user_lvar_info (function)
    modify_user_lvar_info(func_ea, mli_flags, info) -> bool
    Modify saved local variable settings of one variable.
    
    @param func_ea: (C++: ea_t) function start address
    @param mli_flags: (C++: uint) bits that specify which attrs defined by INFO are to be set
    @param info: (C++: const lvar_saved_info_t &) local variable info attrs
    @return: true if modified, false if invalid MLI_FLAGS passed

ida_hexrays.modify_user_lvars (function)
    modify_user_lvars(entry_ea, mlv) -> bool
    Modify saved local variable settings.
    
    @param entry_ea: (C++: ea_t) function start address
    @param mlv: (C++: user_lvar_modifier_t &) local variable modifier
    @return: true if modified variables

ida_hexrays.mop_S (variable)
    local stack variable (they exist until MMAT_LVARS)

ida_hexrays.mop_addr_t (class)
    Proxy of C++ mop_addr_t class.

ida_hexrays.mop_addr_t.__init__ (method)
    __init__(self) -> mop_addr_t
    __init__(self, ra) -> mop_addr_t
    
    @param ra: mop_addr_t const &
    
    __init__(self, ra, isz, osz) -> mop_addr_t
    
    @param ra: mop_t const &
    @param isz: int
    @param osz: int

ida_hexrays.mop_addr_t.lexcompare (method)
    lexcompare(self, ra) -> int
    
    @param ra: mop_addr_t const &

ida_hexrays.mop_b (variable)
    micro basic block (mblock_t)

ida_hexrays.mop_c (variable)
    mcases

ida_hexrays.mop_d (variable)
    result of another instruction

ida_hexrays.mop_f (variable)
    list of arguments

ida_hexrays.mop_fn (variable)
    floating point constant

ida_hexrays.mop_h (variable)
    helper function

ida_hexrays.mop_l (variable)
    local variable

ida_hexrays.mop_n (variable)
    immediate number constant

ida_hexrays.mop_p (variable)
    operand pair

ida_hexrays.mop_pair_t (class)
    Proxy of C++ mop_pair_t class.

ida_hexrays.mop_pair_t.__init__ (method)
    __init__(self) -> mop_pair_t

ida_hexrays.mop_pair_t.hop (variable)
    high operand

ida_hexrays.mop_pair_t.lop (variable)
    low operand

ida_hexrays.mop_r (variable)
    register (they exist until MMAT_LVARS)

ida_hexrays.mop_sc (variable)
    scattered

ida_hexrays.mop_str (variable)
    immediate string constant (user representation)

ida_hexrays.mop_t (class)
    Proxy of C++ mop_t class.

ida_hexrays.mop_t.__dbg_get_meminfo (method)
    __dbg_get_meminfo(self) -> qstring

ida_hexrays.mop_t.__dbg_get_registered_kind (method)
    __dbg_get_registered_kind(self) -> int

ida_hexrays.mop_t.__eq__ (method)
    __eq__(self, rop) -> bool
    
    @param rop: mop_t const &

ida_hexrays.mop_t.__init__ (method)
    __init__(self) -> mop_t
    __init__(self, rop) -> mop_t
    
    @param rop: mop_t const &
    
    __init__(self, _r, _s) -> mop_t
    
    @param _r: mreg_t
    @param _s: int

ida_hexrays.mop_t.__lt__ (method)
    __lt__(self, rop) -> bool
    
    @param rop: mop_t const &

ida_hexrays.mop_t.__ne__ (method)
    __ne__(self, rop) -> bool
    
    @param rop: mop_t const &

ida_hexrays.mop_t._acquire_ownership (method)

ida_hexrays.mop_t._deregister (method)
    _deregister(self)

ida_hexrays.mop_t._ensure_cond (method)

ida_hexrays.mop_t._ensure_no_obj (method)

ida_hexrays.mop_t._ensure_no_t (method)

ida_hexrays.mop_t._ensure_ownership_transferrable (method)

ida_hexrays.mop_t._get_a (method)
    _get_a(self) -> mop_addr_t

ida_hexrays.mop_t._get_b (method)
    _get_b(self) -> int

ida_hexrays.mop_t._get_c (method)
    _get_c(self) -> mcases_t

ida_hexrays.mop_t._get_cstr (method)
    _get_cstr(self) -> char const *

ida_hexrays.mop_t._get_d (method)
    _get_d(self) -> minsn_t

ida_hexrays.mop_t._get_f (method)
    _get_f(self) -> mcallinfo_t

ida_hexrays.mop_t._get_fpc (method)
    _get_fpc(self) -> fnumber_t

ida_hexrays.mop_t._get_g (method)
    _get_g(self) -> ea_t

ida_hexrays.mop_t._get_helper (method)
    _get_helper(self) -> char const *

ida_hexrays.mop_t._get_l (method)
    _get_l(self) -> lvar_ref_t

ida_hexrays.mop_t._get_nnn (method)
    _get_nnn(self) -> mnumber_t

ida_hexrays.mop_t._get_pair (method)
    _get_pair(self) -> mop_pair_t

ida_hexrays.mop_t._get_r (method)
    _get_r(self) -> mreg_t

ida_hexrays.mop_t._get_s (method)
    _get_s(self) -> stkvar_ref_t

ida_hexrays.mop_t._get_scif (method)
    _get_scif(self) -> scif_t

ida_hexrays.mop_t._get_t (method)
    _get_t(self) -> mopt_t

ida_hexrays.mop_t._make_blkref (method)
    _make_blkref(self, blknum)
    
    Parameters
    ----------
    blknum: int

ida_hexrays.mop_t._make_callinfo (method)
    _make_callinfo(self, fi)
    
    Parameters
    ----------
    fi: mcallinfo_t *

ida_hexrays.mop_t._make_cases (method)
    _make_cases(self, _cases)
    
    Parameters
    ----------
    _cases: mcases_t *

ida_hexrays.mop_t._make_gvar (method)
    _make_gvar(self, ea)
    
    Parameters
    ----------
    ea: ea_t

ida_hexrays.mop_t._make_insn (method)
    _make_insn(self, ins)
    
    Parameters
    ----------
    ins: minsn_t *

ida_hexrays.mop_t._make_lvar (method)
    _make_lvar(self, mba, idx, off=0)
    
    Parameters
    ----------
    mba: mba_t *
    idx: int
    off: sval_t

ida_hexrays.mop_t._make_pair (method)
    _make_pair(self, _pair)
    
    Parameters
    ----------
    _pair: mop_pair_t *

ida_hexrays.mop_t._make_reg (method)
    _make_reg(self, reg)
    
    Parameters
    ----------
    reg: mreg_t
    
    _make_reg(self, reg, _size)
    
    Parameters
    ----------
    reg: mreg_t
    _size: int

ida_hexrays.mop_t._make_stkvar (method)
    _make_stkvar(self, mba, off)
    
    Parameters
    ----------
    mba: mba_t *
    off: sval_t

ida_hexrays.mop_t._make_strlit (method)
    _make_strlit(self, str)
    
    Parameters
    ----------
    str: char const *

ida_hexrays.mop_t._maybe_disown_and_deregister (method)

ida_hexrays.mop_t._meminfo (method)

ida_hexrays.mop_t._obj_id (method)
    _obj_id(self) -> PyObject *

ida_hexrays.mop_t._own_and_register (method)

ida_hexrays.mop_t._print (method)
    _print(self, shins_flags=0x04|0x02)
    
    Parameters
    ----------
    shins_flags: int

ida_hexrays.mop_t._register (method)
    _register(self)

ida_hexrays.mop_t._set_a (method)
    _set_a(self, _v)
    
    Parameters
    ----------
    _v: mop_addr_t *

ida_hexrays.mop_t._set_b (method)
    _set_b(self, _v)
    
    Parameters
    ----------
    _v: int

ida_hexrays.mop_t._set_c (method)
    _set_c(self, _v)
    
    Parameters
    ----------
    _v: mcases_t *

ida_hexrays.mop_t._set_cstr (method)
    _set_cstr(self, _v)
    
    Parameters
    ----------
    _v: char const *

ida_hexrays.mop_t._set_d (method)
    _set_d(self, _v)
    
    Parameters
    ----------
    _v: minsn_t *

ida_hexrays.mop_t._set_f (method)
    _set_f(self, _v)
    
    Parameters
    ----------
    _v: mcallinfo_t *

ida_hexrays.mop_t._set_fpc (method)
    _set_fpc(self, _v)
    
    Parameters
    ----------
    _v: fnumber_t *

ida_hexrays.mop_t._set_g (method)
    _set_g(self, _v)
    
    Parameters
    ----------
    _v: ea_t

ida_hexrays.mop_t._set_helper (method)
    _set_helper(self, _v)
    
    Parameters
    ----------
    _v: char const *

ida_hexrays.mop_t._set_l (method)
    _set_l(self, _v)
    
    Parameters
    ----------
    _v: lvar_ref_t *

ida_hexrays.mop_t._set_nnn (method)
    _set_nnn(self, _v)
    
    Parameters
    ----------
    _v: mnumber_t *

ida_hexrays.mop_t._set_pair (method)
    _set_pair(self, _v)
    
    Parameters
    ----------
    _v: mop_pair_t *

ida_hexrays.mop_t._set_r (method)
    _set_r(self, _v)
    
    Parameters
    ----------
    _v: mreg_t

ida_hexrays.mop_t._set_s (method)
    _set_s(self, _v)
    
    Parameters
    ----------
    _v: stkvar_ref_t *

ida_hexrays.mop_t._set_scif (method)
    _set_scif(self, _v)
    
    Parameters
    ----------
    _v: scif_t *

ida_hexrays.mop_t._set_t (method)
    _set_t(self, v)
    
    Parameters
    ----------
    v: mopt_t

ida_hexrays.mop_t.apply_ld_mcode (method)
    apply_ld_mcode(self, mcode, ea, newsize)
    Apply a unary opcode to the operand.
    
    @param mcode: (C++: mcode_t) opcode to apply. it must accept 'l' and 'd' operands but not 'r'.
    @param ea: (C++: ea_t) value of minsn_t::ea for the newly created insruction
    @param newsize: (C++: int) new operand size Example: apply_ld_mcode(m_low) will convert op
                    => low(op)

ida_hexrays.mop_t.apply_xds (method)
    apply_xds(self, ea, newsize)
    
    @param ea: ea_t
    @param newsize: int

ida_hexrays.mop_t.apply_xdu (method)
    apply_xdu(self, ea, newsize)
    
    @param ea: ea_t
    @param newsize: int

ida_hexrays.mop_t.assign (method)
    assign(self, rop) -> mop_t
    
    @param rop: mop_t const &

ida_hexrays.mop_t.change_size (method)
    change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
    Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
    change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4)
    -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1
    
    @param nsize: (C++: int) new operand size
    @param sideff: (C++: side_effect_t) may modify the database because of the size change?
    @return: success

ida_hexrays.mop_t.create_from_insn (method)
    create_from_insn(self, m)
    Create operand from an instruction. This function creates a nested instruction
    that can be used as an operand. Example: if m="add x,y,z", our operand will be
    (t=mop_d,d=m). The destination operand of 'add' (z) is lost.
    
    @param m: (C++: const minsn_t *) instruction to embed into operand. may not be nullptr.

ida_hexrays.mop_t.create_from_ivlset (method)
    create_from_ivlset(self, mba, ivs, fullsize) -> bool
    Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our
    operand will be (t=mop_v, g=&glbvar, size=4)
    
    @param mba: (C++: mba_t *) pointer to microcode
    @param ivs: (C++: const ivlset_t &) set of memory intervals
    @param fullsize: (C++: sval_t) mba->fullsize
    @return: success

ida_hexrays.mop_t.create_from_mlist (method)
    create_from_mlist(self, mba, lst, fullsize) -> bool
    Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our
    operand will be (t=mop_r, r=R0, size=4)
    
    @param mba: (C++: mba_t *) pointer to microcode
    @param lst: (C++: const mlist_t &) list of locations
    @param fullsize: (C++: sval_t) mba->fullsize
    @return: success

ida_hexrays.mop_t.create_from_scattered_vdloc (method)
    create_from_scattered_vdloc(self, mba, name, type, loc)
    Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4,
    EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4,
    EDX.4})
    
    @param mba: (C++: mba_t *) pointer to microcode
    @param name: (C++: const char *) name of the operand, if available
    @param type: (C++: tinfo_t) type of the operand, must be present
    @param loc: (C++: const vdloc_t &) a scattered location
    @return: success

ida_hexrays.mop_t.create_from_vdloc (method)
    create_from_vdloc(self, mba, loc, _size)
    Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0),
    our operand will be (t=mop_r, r=R0, size=_SIZE)
    
    @param mba: (C++: mba_t *) pointer to microcode
    @param loc: (C++: const vdloc_t &) location
    @param _size: (C++: int) operand size Note: this function cannot handle scattered
                  locations.
    @return: success

ida_hexrays.mop_t.double_size (method)
    double_size(self, sideff=WITH_SIDEFF) -> bool
    
    @param sideff: enum side_effect_t

ida_hexrays.mop_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.mop_t.empty (method)
    empty(self) -> bool

ida_hexrays.mop_t.equal_mops (method)
    equal_mops(self, rop, eqflags) -> bool
    Compare operands. This is the main comparison function for operands.
    
    @param rop: (C++: const mop_t &) operand to compare with
    @param eqflags: (C++: int) combination of comparison bits bits

ida_hexrays.mop_t.erase (method)
    erase(self)

ida_hexrays.mop_t.erase_but_keep_size (method)
    erase_but_keep_size(self)

ida_hexrays.mop_t.for_all_ops (method)
    for_all_ops(self, mv, type=None, is_target=False) -> int
    Visit the operand and all its sub-operands. This function visits the current
    operand as well.
    
    @param mv: (C++: mop_visitor_t &) visitor object
    @param type: (C++: const tinfo_t *) operand type
    @param is_target: (C++: bool) is a destination operand?

ida_hexrays.mop_t.for_all_scattered_submops (method)
    for_all_scattered_submops(self, sv) -> int
    Visit all sub-operands of a scattered operand. This function does not visit the
    current operand, only its sub-operands. All sub-operands are synthetic and are
    destroyed after the visitor. This function works only with scattered operands.
    
    @param sv: (C++: scif_visitor_t &) visitor object

ida_hexrays.mop_t.get_insn (method)
    get_insn(self, code) -> minsn_t
    
    @param code: enum mcode_t

ida_hexrays.mop_t.get_stkoff (method)
    get_stkoff(self, p_off) -> bool
    Get the referenced stack offset. This function can also handle mop_sc if it is
    entirely mapped into a continuous stack region.
    
    @param p_off: (C++: sval_t *) the output buffer
    @return: success

ida_hexrays.mop_t.get_stkvar (method)
    get_stkvar(self, p_off) -> member_t *
    Retrieve the referenced stack variable.
    
    @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
    @return: pointer to the stack variable

ida_hexrays.mop_t.has_side_effects (method)
    has_side_effects(self, include_ldx_and_divs=False) -> bool
    Has any side effects?
    
    @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects?

ida_hexrays.mop_t.is01 (method)
    is01(self) -> bool
    Are the possible values of the operand only 0 and 1? This function returns true
    for 0/1 constants, bit registers, the result of 'set' insns, etc.

ida_hexrays.mop_t.is_arglist (method)
    is_arglist(self) -> bool
    Is a list of arguments?

ida_hexrays.mop_t.is_bit_reg (method)
    is_bit_reg(self, reg) -> bool
    Is a bit register? This includes condition codes and eventually other bit
    registers
    
    @param reg: (C++: mreg_t)
    
    is_bit_reg(self) -> bool

ida_hexrays.mop_t.is_cc (method)
    is_cc(self) -> bool
    Is a condition code?

ida_hexrays.mop_t.is_ccflags (method)
    is_ccflags(self) -> bool

ida_hexrays.mop_t.is_constant (method)
    is_constant(self, is_signed=True) -> bool
    Retrieve value of a constant integer operand.
    
    @param is_signed: (C++: bool) should treat the value as signed
    @return: true if the operand is mop_n

ida_hexrays.mop_t.is_equal_to (method)
    is_equal_to(self, n, is_signed=True) -> bool
    
    @param n: uint64
    @param is_signed: bool

ida_hexrays.mop_t.is_extended_from (method)
    is_extended_from(self, nbytes, is_signed) -> bool
    Does the high part of the operand consist of zero or sign bytes?
    
    @param nbytes: (C++: int)
    @param is_signed: (C++: bool)

ida_hexrays.mop_t.is_glbaddr (method)
    is_glbaddr(self) -> bool
    Is address of the specified global memory cell?
    is_glbaddr(self, ea) -> bool
    
    @param ea: ea_t

ida_hexrays.mop_t.is_glbaddr_from_fixup (method)
    is_glbaddr_from_fixup(self) -> bool

ida_hexrays.mop_t.is_impptr_done (method)
    is_impptr_done(self) -> bool

ida_hexrays.mop_t.is_insn (method)
    is_insn(self) -> bool
    Is a sub-instruction with the specified opcode?
    is_insn(self, code) -> bool
    
    @param code: enum mcode_t

ida_hexrays.mop_t.is_kreg (method)
    is_kreg(self) -> bool
    Is a kernel register?

ida_hexrays.mop_t.is_lowaddr (method)
    is_lowaddr(self) -> bool

ida_hexrays.mop_t.is_mob (method)
    is_mob(self, serial) -> bool
    Is a block reference to the specified block?
    
    @param serial: (C++: int)

ida_hexrays.mop_t.is_negative_constant (method)
    is_negative_constant(self) -> bool

ida_hexrays.mop_t.is_one (method)
    is_one(self) -> bool

ida_hexrays.mop_t.is_pcval (method)
    is_pcval(self) -> bool

ida_hexrays.mop_t.is_positive_constant (method)
    is_positive_constant(self) -> bool

ida_hexrays.mop_t.is_reg (method)
    is_reg(self) -> bool
    Is the specified register of the specified size?
    is_reg(self, _r) -> bool
    
    @param _r: mreg_t
    
    is_reg(self, _r, _size) -> bool
    
    @param _r: mreg_t
    @param _size: int

ida_hexrays.mop_t.is_scattered (method)
    is_scattered(self) -> bool
    Is a scattered operand?

ida_hexrays.mop_t.is_sign_extended_from (method)
    is_sign_extended_from(self, nbytes) -> bool
    Does the high part of the operand consist of the sign bytes?
    
    @param nbytes: (C++: int) number of bytes that were sign extended. the remaining size-
                   nbytes high bytes must be sign bytes Example:
                   is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3
                   bytes are certainly sign bits

ida_hexrays.mop_t.is_stkaddr (method)
    is_stkaddr(self) -> bool
    Is address of a stack variable?

ida_hexrays.mop_t.is_udt (method)
    is_udt(self) -> bool

ida_hexrays.mop_t.is_undef_val (method)
    is_undef_val(self) -> bool

ida_hexrays.mop_t.is_zero (method)
    is_zero(self) -> bool

ida_hexrays.mop_t.is_zero_extended_from (method)
    is_zero_extended_from(self, nbytes) -> bool
    Does the high part of the operand consist of zero bytes?
    
    @param nbytes: (C++: int) number of bytes that were zero extended. the remaining size-
                   nbytes high bytes must be zero Example:
                   is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6
                   bytes are certainly zero

ida_hexrays.mop_t.lexcompare (method)
    lexcompare(self, rop) -> int
    
    @param rop: mop_t const &

ida_hexrays.mop_t.make_blkref (method)
    make_blkref(self, blknum)
    Create a global variable operand.
    
    @param blknum: (C++: int)

ida_hexrays.mop_t.make_first_half (method)
    make_first_half(self, width) -> bool
    Make the first part of the operand. This function does not care about the memory
    endianness
    
    @param width: (C++: int) the desired size of the operand part in bytes
    @return: success

ida_hexrays.mop_t.make_fpnum (method)
    make_fpnum(self, bytes) -> bool
    Create a floating point constant operand.
    
    @param bytes: (C++: const void *) pointer to the floating point value as used by the current
                  processor (e.g. for x86 it must be in IEEE 754)
    @return: success

ida_hexrays.mop_t.make_gvar (method)
    make_gvar(self, ea)
    Create a global variable operand.
    
    @param ea: (C++: ea_t)

ida_hexrays.mop_t.make_helper (method)
    make_helper(self, name)
    Create a helper operand. A helper operand usually keeps a built-in function name
    like "va_start" It is essentially just an arbitrary identifier without any
    additional info.
    
    @param name: (C++: const char *) char const *

ida_hexrays.mop_t.make_high_half (method)
    make_high_half(self, width) -> bool
    Make the high part of the operand. This function takes into account the memory
    endianness (byte sex)
    
    @param width: (C++: int) the desired size of the operand part in bytes
    @return: success

ida_hexrays.mop_t.make_insn (method)
    make_insn(self, ins)
    Create a nested instruction.
    
    @param ins: (C++: minsn_t *)

ida_hexrays.mop_t.make_low_half (method)
    make_low_half(self, width) -> bool
    Make the low part of the operand. This function takes into account the memory
    endianness (byte sex)
    
    @param width: (C++: int) the desired size of the operand part in bytes
    @return: success

ida_hexrays.mop_t.make_number (method)
    make_number(self, _value, _size, _ea=BADADDR, opnum=0)
    Create an integer constant operand.
    
    @param _value: (C++: uint64) value to store in the operand
    @param _size: (C++: int) size of the value in bytes (1,2,4,8)
    @param _ea: (C++: ea_t) address of the processor instruction that made the value
    @param opnum: (C++: int) operand number of the processor instruction

ida_hexrays.mop_t.make_reg (method)
    make_reg(self, reg)
    
    @param reg: mreg_t
    
    make_reg(self, reg, _size)
    
    @param reg: mreg_t
    @param _size: int

ida_hexrays.mop_t.make_reg_pair (method)
    make_reg_pair(self, loreg, hireg, halfsize)
    Create pair of registers.
    
    @param loreg: (C++: int) register holding the low part of the value
    @param hireg: (C++: int) register holding the high part of the value
    @param halfsize: (C++: int) the size of each of loreg/hireg

ida_hexrays.mop_t.make_second_half (method)
    make_second_half(self, width) -> bool
    Make the second part of the operand. This function does not care about the
    memory endianness
    
    @param width: (C++: int) the desired size of the operand part in bytes
    @return: success

ida_hexrays.mop_t.make_stkvar (method)
    make_stkvar(self, mba, off)
    
    @param mba: mba_t *
    @param off: sval_t

ida_hexrays.mop_t.may_use_aliased_memory (method)
    may_use_aliased_memory(self) -> bool
    Is it possible for the operand to use aliased memory?

ida_hexrays.mop_t.oprops (variable)
    Operand properties.

ida_hexrays.mop_t.preserve_side_effects (method)
    preserve_side_effects(self, blk, top, moved_calls=None) -> bool
    Move subinstructions with side effects out of the operand. If we decide to
    delete an instruction operand, it is a good idea to call this function.
    Alternatively we should skip such operands by calling mop_t::has_side_effects()
    For example, if we transform: jnz x, x, @blk => goto @blk then we must call this
    function before deleting the X operands.
    
    @param blk: (C++: mblock_t *) current block
    @param top: (C++: minsn_t *) top level instruction that contains our operand
    @param moved_calls: (C++: bool *) pointer to the boolean that will track if all side effects
                        get handled correctly. must be false initially.
    @return: false failed to preserve a side effect, it is not safe to delete the
             operand true no side effects or successfully preserved them

ida_hexrays.mop_t.probably_floating (method)
    probably_floating(self) -> bool

ida_hexrays.mop_t.replace_by (method)

ida_hexrays.mop_t.set_impptr_done (method)
    set_impptr_done(self)

ida_hexrays.mop_t.set_lowaddr (method)
    set_lowaddr(self)

ida_hexrays.mop_t.set_udt (method)
    set_udt(self)

ida_hexrays.mop_t.set_undef_val (method)
    set_undef_val(self)

ida_hexrays.mop_t.shift_mop (method)
    shift_mop(self, offset) -> bool
    Shift the operand. This function shifts only the beginning of the operand. The
    operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2
    shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) ->
    #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
    
    @param offset: (C++: int) shift count (the number of bytes to shift)
    @return: success

ida_hexrays.mop_t.signed_value (method)
    signed_value(self) -> int64

ida_hexrays.mop_t.size (variable)
    Operand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs other sizes are
    permitted

ida_hexrays.mop_t.swap (method)
    swap(self, rop)
    
    @param rop: mop_t &

ida_hexrays.mop_t.t (variable)
    Operand type.

ida_hexrays.mop_t.unsigned_value (method)
    unsigned_value(self) -> uint64

ida_hexrays.mop_t.update_numop_value (method)
    update_numop_value(self, val)
    
    @param val: uint64

ida_hexrays.mop_t.valnum (variable)
    Value number. Zero means unknown. Operands with the same value number are equal.

ida_hexrays.mop_t.value (method)
    value(self, is_signed) -> uint64
    Retrieve value of a constant integer operand. These functions can be called only
    for mop_n operands. See is_constant() that can be called on any operand.
    
    @param is_signed: (C++: bool)

ida_hexrays.mop_t.zero (method)
    zero(self)

ida_hexrays.mop_v (variable)
    global variable

ida_hexrays.mop_visitor_t (class)
    Proxy of C++ mop_visitor_t class.

ida_hexrays.mop_visitor_t.__disown__ (method)

ida_hexrays.mop_visitor_t.__init__ (method)
    __init__(self, _mba=None, _blk=None, _topins=None) -> mop_visitor_t
    
    @param _mba: mba_t *
    @param _blk: mblock_t *
    @param _topins: minsn_t *

ida_hexrays.mop_visitor_t.prune (variable)
    Should skip sub-operands of the current operand? visit_mop() may set
    'prune=true' for that.

ida_hexrays.mop_visitor_t.visit_mop (method)
    visit_mop(self, op, type, is_target) -> int
    
    @param op: mop_t *
    @param type: tinfo_t const *
    @param is_target: bool

ida_hexrays.mop_z (variable)
    none

ida_hexrays.mopvec_t (class)
    Proxy of C++ qvector< mop_t > class.

ida_hexrays.mopvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< mop_t > const &

ida_hexrays.mopvec_t.__getitem__ (method)
    __getitem__(self, i) -> mop_t
    
    @param i: size_t

ida_hexrays.mopvec_t.__init__ (method)
    __init__(self) -> mopvec_t
    __init__(self, x) -> mopvec_t
    
    @param x: qvector< mop_t > const &

ida_hexrays.mopvec_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.mopvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< mop_t > const &

ida_hexrays.mopvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: mop_t const &

ida_hexrays.mopvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: mop_t const &

ida_hexrays.mopvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: mop_t const &

ida_hexrays.mopvec_t.at (method)
    at(self, _idx) -> mop_t
    
    @param _idx: size_t

ida_hexrays.mopvec_t.begin (method)
    begin(self) -> mop_t

ida_hexrays.mopvec_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.mopvec_t.clear (method)
    clear(self)

ida_hexrays.mopvec_t.empty (method)
    empty(self) -> bool

ida_hexrays.mopvec_t.end (method)
    end(self) -> mop_t

ida_hexrays.mopvec_t.erase (method)
    erase(self, it) -> mop_t
    
    @param it: qvector< mop_t >::iterator
    
    erase(self, first, last) -> mop_t
    
    @param first: qvector< mop_t >::iterator
    @param last: qvector< mop_t >::iterator

ida_hexrays.mopvec_t.extract (method)
    extract(self) -> mop_t

ida_hexrays.mopvec_t.find (method)
    find(self, x) -> mop_t
    
    @param x: mop_t const &

ida_hexrays.mopvec_t.grow (method)
    grow(self, x=mop_t())
    
    @param x: mop_t const &

ida_hexrays.mopvec_t.has (method)
    has(self, x) -> bool
    
    @param x: mop_t const &

ida_hexrays.mopvec_t.inject (method)
    inject(self, s, len)
    
    @param s: mop_t *
    @param len: size_t

ida_hexrays.mopvec_t.insert (method)
    insert(self, it, x) -> mop_t
    
    @param it: qvector< mop_t >::iterator
    @param x: mop_t const &

ida_hexrays.mopvec_t.pop_back (method)
    pop_back(self)

ida_hexrays.mopvec_t.push_back (method)
    push_back(self, x)
    
    @param x: mop_t const &
    
    push_back(self) -> mop_t

ida_hexrays.mopvec_t.qclear (method)
    qclear(self)

ida_hexrays.mopvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.mopvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: mop_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.mopvec_t.size (method)
    size(self) -> size_t

ida_hexrays.mopvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< mop_t > &

ida_hexrays.mopvec_t.truncate (method)
    truncate(self)

ida_hexrays.mreg2reg (function)
    mreg2reg(reg, width) -> int
    Map a microregister to a processor register.
    
    @param reg: (C++: mreg_t) microregister number
    @param width: (C++: int) size of microregister in bytes
    @return: processor register id or -1

ida_hexrays.must_mcode_close_block (function)
    must_mcode_close_block(mcode, including_calls) -> bool
    Must an instruction with the given opcode be the last one in a block? Such
    opcodes are called closing opcodes.
    
    @param mcode: (C++: mcode_t) instruction opcode
    @param including_calls: (C++: bool) should m_call/m_icall be considered as the closing
                            opcodes? If this function returns true, the opcode
                            cannot appear in the middle of a block. Calls are a
                            special case: unknown calls (is_unknown_call) are
                            considered as closing opcodes.

ida_hexrays.negate_mcode_relation (function)
    negate_mcode_relation(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.negated_relation (function)
    negated_relation(op) -> ctype_t
    Negate a comparison operator. For example, cot_sge becomes cot_slt.
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.new_block (function)
    Create a new block-statement.

ida_hexrays.number_format_t (class)
    Proxy of C++ number_format_t class.

ida_hexrays.number_format_t.__init__ (method)
    __init__(self, _opnum=0) -> number_format_t
    
    @param _opnum: int

ida_hexrays.number_format_t.flags (variable)
    ida flags, which describe number radix, enum, etc

ida_hexrays.number_format_t.flags32 (variable)
    low 32bit of flags (for compatibility)

ida_hexrays.number_format_t.get_radix (method)
    get_radix(self) -> int
    Get number radix
    
    @return: 2,8,10, or 16

ida_hexrays.number_format_t.has_unmutable_type (method)
    has_unmutable_type(self) -> bool

ida_hexrays.number_format_t.is_char (method)
    is_char(self) -> bool
    Is a character constant?

ida_hexrays.number_format_t.is_dec (method)
    is_dec(self) -> bool
    Is a decimal number?

ida_hexrays.number_format_t.is_enum (method)
    is_enum(self) -> bool
    Is a symbolic constant?

ida_hexrays.number_format_t.is_fixed (method)
    is_fixed(self) -> bool
    Is number representation fixed? Fixed representation cannot be modified by the
    decompiler

ida_hexrays.number_format_t.is_hex (method)
    is_hex(self) -> bool
    Is a hexadecimal number?

ida_hexrays.number_format_t.is_numop (method)
    is_numop(self) -> bool
    Is a number?

ida_hexrays.number_format_t.is_oct (method)
    is_oct(self) -> bool
    Is a octal number?

ida_hexrays.number_format_t.is_stroff (method)
    is_stroff(self) -> bool
    Is a structure field offset?

ida_hexrays.number_format_t.needs_to_be_inverted (method)
    needs_to_be_inverted(self) -> bool
    Does the number need to be negated or bitwise negated? Returns true if the user
    requested a negation but it is not done yet

ida_hexrays.number_format_t.opnum (variable)
    operand number: 0..UA_MAXOP

ida_hexrays.number_format_t.org_nbytes (variable)
    original number size in bytes

ida_hexrays.number_format_t.serial (variable)
    for enums: constant serial number

ida_hexrays.number_format_t.type_name (variable)
    for stroffs: structure for offsetof()
    for enums: enum name

ida_hexrays.op_parent_info_t (class)
    Proxy of C++ op_parent_info_t class.

ida_hexrays.op_parent_info_t.__init__ (method)
    __init__(self, _mba=None, _blk=None, _topins=None) -> op_parent_info_t
    
    @param _mba: mba_t *
    @param _blk: mblock_t *
    @param _topins: minsn_t *

ida_hexrays.op_uses_x (function)
    op_uses_x(op) -> bool
    Does operator use the 'x' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.op_uses_y (function)
    op_uses_y(op) -> bool
    Does operator use the 'y' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.op_uses_z (function)
    op_uses_z(op) -> bool
    Does operator use the 'z' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.open_pseudocode (function)
    open_pseudocode(ea, flags) -> vdui_t
    Open pseudocode window. The specified function is decompiled and the pseudocode
    window is opened.
    
    @param ea: (C++: ea_t) function to decompile
    @param flags: (C++: int) a combination of OPF_ flags
    @return: false if failed

ida_hexrays.operand_locator_t (class)
    Proxy of C++ operand_locator_t class.

ida_hexrays.operand_locator_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.__init__ (method)
    __init__(self, _ea, _opnum) -> operand_locator_t
    
    @param _ea: ea_t
    @param _opnum: int

ida_hexrays.operand_locator_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.compare (method)
    compare(self, r) -> int
    
    @param r: operand_locator_t const &

ida_hexrays.operand_locator_t.ea (variable)
    address of the original processor instruction

ida_hexrays.operand_locator_t.opnum (variable)
    operand number in the instruction

ida_hexrays.optblock_t (class)
    Proxy of C++ optblock_t class.

ida_hexrays.optblock_t.__disown__ (method)

ida_hexrays.optblock_t.__init__ (method)
    __init__(self) -> optblock_t
    
    @param self: PyObject *

ida_hexrays.optblock_t.func (method)
    func(self, blk) -> int
    Optimize a block. This function usually performs the optimizations that require
    analyzing the entire block and/or its neighbors. For example it can recognize
    patterns and perform conversions like: b0: b0: ... ... jnz x, 0, @b2 => jnz x,
    0, @b2 b1: b1: add x, 0, y mov x, y ... ...
    
    @param blk: (C++: mblock_t *) Basic block to optimize as a whole.
    @return: number of changes made to the block. See also mark_lists_dirty.

ida_hexrays.optblock_t.install (method)
    install(self)

ida_hexrays.optblock_t.remove (method)
    remove(self) -> bool

ida_hexrays.optinsn_t (class)
    Proxy of C++ optinsn_t class.

ida_hexrays.optinsn_t.__disown__ (method)

ida_hexrays.optinsn_t.__init__ (method)
    __init__(self) -> optinsn_t
    
    @param self: PyObject *

ida_hexrays.optinsn_t.func (method)
    func(self, blk, ins, optflags) -> int
    Optimize an instruction.
    
    @param blk: (C++: mblock_t *) current basic block. maybe nullptr, which means that the instruction
                must be optimized without context
    @param ins: (C++: minsn_t *) instruction to optimize; it is always a top-level instruction. the
                callback may not delete the instruction but may convert it into nop
                (see mblock_t::make_nop). to optimize sub-instructions, visit them
                using minsn_visitor_t. sub-instructions may not be converted into
                nop but can be converted to "mov x,x". for example: add x,0,x => mov
                x,x this callback may change other instructions in the block, but
                should do this with care, e.g. to no break the propagation algorithm
                if called with OPTI_NO_LDXOPT.
    @param optflags: (C++: int) combination of optimization flags bits
    @return: number of changes made to the instruction. if after this call the
             instruction's use/def lists have changed, you must mark the block level
             lists as dirty (see mark_lists_dirty)

ida_hexrays.optinsn_t.install (method)
    install(self)

ida_hexrays.optinsn_t.remove (method)
    remove(self) -> bool

ida_hexrays.parse_user_call (function)
    parse_user_call(udc, decl, silent) -> bool
    Convert function type declaration into internal structure
    
    @param udc: (C++: udcall_t *) - pointer to output structure
    @param decl: (C++: const char *) - function type declaration
    @param silent: (C++: bool) - if TRUE: do not show warning in case of incorrect type
    @return: success

ida_hexrays.partial_type_num (function)
    partial_type_num(type) -> int
    Calculate number of partial subtypes.
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: number of partial subtypes. The bigger is this number, the uglier is
             the type.

ida_hexrays.print_vdloc (function)
    print_vdloc(loc, nbytes) -> str
    Print vdloc. Since vdloc does not always carry the size info, we pass it as
    NBYTES..
    
    @param loc: (C++: const vdloc_t &) vdloc_t const &
    @param nbytes: (C++: int)

ida_hexrays.property_op_to_typename (function)

ida_hexrays.qstring_printer_t (class)
    Proxy of C++ qstring_printer_t class.

ida_hexrays.qstring_printer_t.__init__ (method)
    __init__(self, f, tags) -> qstring_printer_t
    
    @param f: cfunc_t const *
    @param tags: bool

ida_hexrays.qstring_printer_t._print (method)
    _print(self, indent, format) -> int
    
    Parameters
    ----------
    indent: int
    format: char const *

ida_hexrays.qstring_printer_t.get_s (method)
    get_s(self) -> qstring

ida_hexrays.qstring_printer_t.s (variable)
    Reference to the output string

ida_hexrays.qstring_printer_t.with_tags (variable)
    Generate output with color tags.

ida_hexrays.qswap (function)
    qswap(a, b)
    
    @param a: cinsn_t &
    @param b: cinsn_t &

ida_hexrays.qvector_carg_t (class)
    Proxy of C++ qvector< carg_t > class.

ida_hexrays.qvector_carg_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< carg_t > const &

ida_hexrays.qvector_carg_t.__getitem__ (method)
    __getitem__(self, i) -> carg_t
    
    @param i: size_t

ida_hexrays.qvector_carg_t.__init__ (method)
    __init__(self) -> qvector_carg_t
    __init__(self, x) -> qvector_carg_t
    
    @param x: qvector< carg_t > const &

ida_hexrays.qvector_carg_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.qvector_carg_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< carg_t > const &

ida_hexrays.qvector_carg_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: carg_t const &

ida_hexrays.qvector_carg_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: carg_t const &

ida_hexrays.qvector_carg_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: carg_t const &

ida_hexrays.qvector_carg_t.at (method)
    at(self, _idx) -> carg_t
    
    @param _idx: size_t

ida_hexrays.qvector_carg_t.begin (method)
    begin(self) -> carg_t

ida_hexrays.qvector_carg_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.qvector_carg_t.clear (method)
    clear(self)

ida_hexrays.qvector_carg_t.empty (method)
    empty(self) -> bool

ida_hexrays.qvector_carg_t.end (method)
    end(self) -> carg_t

ida_hexrays.qvector_carg_t.erase (method)
    erase(self, it) -> carg_t
    
    @param it: qvector< carg_t >::iterator
    
    erase(self, first, last) -> carg_t
    
    @param first: qvector< carg_t >::iterator
    @param last: qvector< carg_t >::iterator

ida_hexrays.qvector_carg_t.extract (method)
    extract(self) -> carg_t

ida_hexrays.qvector_carg_t.find (method)
    find(self, x) -> carg_t
    
    @param x: carg_t const &

ida_hexrays.qvector_carg_t.grow (method)
    grow(self, x=carg_t())
    
    @param x: carg_t const &

ida_hexrays.qvector_carg_t.has (method)
    has(self, x) -> bool
    
    @param x: carg_t const &

ida_hexrays.qvector_carg_t.inject (method)
    inject(self, s, len)
    
    @param s: carg_t *
    @param len: size_t

ida_hexrays.qvector_carg_t.insert (method)
    insert(self, it, x) -> carg_t
    
    @param it: qvector< carg_t >::iterator
    @param x: carg_t const &

ida_hexrays.qvector_carg_t.pop_back (method)
    pop_back(self)

ida_hexrays.qvector_carg_t.push_back (method)
    push_back(self, x)
    
    @param x: carg_t const &
    
    push_back(self) -> carg_t

ida_hexrays.qvector_carg_t.qclear (method)
    qclear(self)

ida_hexrays.qvector_carg_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.qvector_carg_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: carg_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.qvector_carg_t.size (method)
    size(self) -> size_t

ida_hexrays.qvector_carg_t.swap (method)
    swap(self, r)
    
    @param r: qvector< carg_t > &

ida_hexrays.qvector_carg_t.truncate (method)
    truncate(self)

ida_hexrays.qvector_ccase_t (class)
    Proxy of C++ qvector< ccase_t > class.

ida_hexrays.qvector_ccase_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< ccase_t > const &

ida_hexrays.qvector_ccase_t.__getitem__ (method)
    __getitem__(self, i) -> ccase_t
    
    @param i: size_t

ida_hexrays.qvector_ccase_t.__init__ (method)
    __init__(self) -> qvector_ccase_t
    __init__(self, x) -> qvector_ccase_t
    
    @param x: qvector< ccase_t > const &

ida_hexrays.qvector_ccase_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.qvector_ccase_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< ccase_t > const &

ida_hexrays.qvector_ccase_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: ccase_t const &

ida_hexrays.qvector_ccase_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: ccase_t const &

ida_hexrays.qvector_ccase_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: ccase_t const &

ida_hexrays.qvector_ccase_t.at (method)
    at(self, _idx) -> ccase_t
    
    @param _idx: size_t

ida_hexrays.qvector_ccase_t.begin (method)
    begin(self) -> ccase_t

ida_hexrays.qvector_ccase_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.qvector_ccase_t.clear (method)
    clear(self)

ida_hexrays.qvector_ccase_t.empty (method)
    empty(self) -> bool

ida_hexrays.qvector_ccase_t.end (method)
    end(self) -> ccase_t

ida_hexrays.qvector_ccase_t.erase (method)
    erase(self, it) -> ccase_t
    
    @param it: qvector< ccase_t >::iterator
    
    erase(self, first, last) -> ccase_t
    
    @param first: qvector< ccase_t >::iterator
    @param last: qvector< ccase_t >::iterator

ida_hexrays.qvector_ccase_t.extract (method)
    extract(self) -> ccase_t

ida_hexrays.qvector_ccase_t.find (method)
    find(self, x) -> ccase_t
    
    @param x: ccase_t const &

ida_hexrays.qvector_ccase_t.grow (method)
    grow(self, x=ccase_t())
    
    @param x: ccase_t const &

ida_hexrays.qvector_ccase_t.has (method)
    has(self, x) -> bool
    
    @param x: ccase_t const &

ida_hexrays.qvector_ccase_t.inject (method)
    inject(self, s, len)
    
    @param s: ccase_t *
    @param len: size_t

ida_hexrays.qvector_ccase_t.insert (method)
    insert(self, it, x) -> ccase_t
    
    @param it: qvector< ccase_t >::iterator
    @param x: ccase_t const &

ida_hexrays.qvector_ccase_t.pop_back (method)
    pop_back(self)

ida_hexrays.qvector_ccase_t.push_back (method)
    push_back(self, x)
    
    @param x: ccase_t const &
    
    push_back(self) -> ccase_t

ida_hexrays.qvector_ccase_t.qclear (method)
    qclear(self)

ida_hexrays.qvector_ccase_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.qvector_ccase_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: ccase_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.qvector_ccase_t.size (method)
    size(self) -> size_t

ida_hexrays.qvector_ccase_t.swap (method)
    swap(self, r)
    
    @param r: qvector< ccase_t > &

ida_hexrays.qvector_ccase_t.truncate (method)
    truncate(self)

ida_hexrays.qvector_history_t (class)
    Proxy of C++ qvector< history_item_t > class.

ida_hexrays.qvector_history_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< history_item_t > const &

ida_hexrays.qvector_history_t.__getitem__ (method)
    __getitem__(self, i) -> history_item_t
    
    @param i: size_t

ida_hexrays.qvector_history_t.__init__ (method)
    __init__(self) -> qvector_history_t
    __init__(self, x) -> qvector_history_t
    
    @param x: qvector< history_item_t > const &

ida_hexrays.qvector_history_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.qvector_history_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< history_item_t > const &

ida_hexrays.qvector_history_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: history_item_t const &

ida_hexrays.qvector_history_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: history_item_t const &

ida_hexrays.qvector_history_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: history_item_t const &

ida_hexrays.qvector_history_t.at (method)
    at(self, _idx) -> history_item_t
    
    @param _idx: size_t

ida_hexrays.qvector_history_t.begin (method)
    begin(self) -> history_item_t

ida_hexrays.qvector_history_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.qvector_history_t.clear (method)
    clear(self)

ida_hexrays.qvector_history_t.empty (method)
    empty(self) -> bool

ida_hexrays.qvector_history_t.end (method)
    end(self) -> history_item_t

ida_hexrays.qvector_history_t.erase (method)
    erase(self, it) -> history_item_t
    
    @param it: qvector< history_item_t >::iterator
    
    erase(self, first, last) -> history_item_t
    
    @param first: qvector< history_item_t >::iterator
    @param last: qvector< history_item_t >::iterator

ida_hexrays.qvector_history_t.extract (method)
    extract(self) -> history_item_t

ida_hexrays.qvector_history_t.find (method)
    find(self, x) -> history_item_t
    
    @param x: history_item_t const &

ida_hexrays.qvector_history_t.grow (method)
    grow(self, x=history_item_t())
    
    @param x: history_item_t const &

ida_hexrays.qvector_history_t.has (method)
    has(self, x) -> bool
    
    @param x: history_item_t const &

ida_hexrays.qvector_history_t.inject (method)
    inject(self, s, len)
    
    @param s: history_item_t *
    @param len: size_t

ida_hexrays.qvector_history_t.insert (method)
    insert(self, it, x) -> history_item_t
    
    @param it: qvector< history_item_t >::iterator
    @param x: history_item_t const &

ida_hexrays.qvector_history_t.pop_back (method)
    pop_back(self)

ida_hexrays.qvector_history_t.push_back (method)
    push_back(self, x)
    
    @param x: history_item_t const &
    
    push_back(self) -> history_item_t

ida_hexrays.qvector_history_t.qclear (method)
    qclear(self)

ida_hexrays.qvector_history_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.qvector_history_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: history_item_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.qvector_history_t.size (method)
    size(self) -> size_t

ida_hexrays.qvector_history_t.swap (method)
    swap(self, r)
    
    @param r: qvector< history_item_t > &

ida_hexrays.qvector_history_t.truncate (method)
    truncate(self)

ida_hexrays.qvector_lvar_t (class)
    Proxy of C++ qvector< lvar_t > class.

ida_hexrays.qvector_lvar_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< lvar_t > const &

ida_hexrays.qvector_lvar_t.__getitem__ (method)
    __getitem__(self, i) -> lvar_t
    
    @param i: size_t

ida_hexrays.qvector_lvar_t.__init__ (method)
    __init__(self) -> qvector_lvar_t
    __init__(self, x) -> qvector_lvar_t
    
    @param x: qvector< lvar_t > const &

ida_hexrays.qvector_lvar_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.qvector_lvar_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< lvar_t > const &

ida_hexrays.qvector_lvar_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: lvar_t const &

ida_hexrays.qvector_lvar_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: lvar_t const &

ida_hexrays.qvector_lvar_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: lvar_t const &

ida_hexrays.qvector_lvar_t.at (method)
    at(self, _idx) -> lvar_t
    
    @param _idx: size_t

ida_hexrays.qvector_lvar_t.begin (method)
    begin(self) -> lvar_t

ida_hexrays.qvector_lvar_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.qvector_lvar_t.clear (method)
    clear(self)

ida_hexrays.qvector_lvar_t.empty (method)
    empty(self) -> bool

ida_hexrays.qvector_lvar_t.end (method)
    end(self) -> lvar_t

ida_hexrays.qvector_lvar_t.erase (method)
    erase(self, it) -> lvar_t
    
    @param it: qvector< lvar_t >::iterator
    
    erase(self, first, last) -> lvar_t
    
    @param first: qvector< lvar_t >::iterator
    @param last: qvector< lvar_t >::iterator

ida_hexrays.qvector_lvar_t.extract (method)
    extract(self) -> lvar_t

ida_hexrays.qvector_lvar_t.find (method)
    find(self, x) -> lvar_t
    
    @param x: lvar_t const &

ida_hexrays.qvector_lvar_t.grow (method)
    grow(self, x=lvar_t())
    
    @param x: lvar_t const &

ida_hexrays.qvector_lvar_t.has (method)
    has(self, x) -> bool
    
    @param x: lvar_t const &

ida_hexrays.qvector_lvar_t.inject (method)
    inject(self, s, len)
    
    @param s: lvar_t *
    @param len: size_t

ida_hexrays.qvector_lvar_t.insert (method)
    insert(self, it, x) -> lvar_t
    
    @param it: qvector< lvar_t >::iterator
    @param x: lvar_t const &

ida_hexrays.qvector_lvar_t.pop_back (method)
    pop_back(self)

ida_hexrays.qvector_lvar_t.push_back (method)
    push_back(self, x)
    
    @param x: lvar_t const &
    
    push_back(self) -> lvar_t

ida_hexrays.qvector_lvar_t.qclear (method)
    qclear(self)

ida_hexrays.qvector_lvar_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.qvector_lvar_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: lvar_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.qvector_lvar_t.size (method)
    size(self) -> size_t

ida_hexrays.qvector_lvar_t.swap (method)
    swap(self, r)
    
    @param r: qvector< lvar_t > &

ida_hexrays.qvector_lvar_t.truncate (method)
    truncate(self)

ida_hexrays.reg2mreg (function)
    reg2mreg(reg) -> mreg_t
    Map a processor register to a microregister.
    
    @param reg: (C++: int) processor register number
    @return: microregister register id or mr_none

ida_hexrays.remitem (function)
    remitem(e)
    
    @param e: citem_t const *

ida_hexrays.remove_hexrays_callback (function)
    Deprecated. Please use Hexrays_Hooks instead
    Uninstall handler for decompiler events.
    
    @return: number of uninstalled handlers.

ida_hexrays.rename_lvar (function)
    rename_lvar(func_ea, oldname, newname) -> bool
    Rename a local variable.
    
    @param func_ea: (C++: ea_t) function start address
    @param oldname: (C++: const char *) old name of the variable
    @param newname: (C++: const char *) new name of the variable
    @return: success This is a convenience function. For bulk renaming consider
             using modify_user_lvars.

ida_hexrays.restore_user_cmts (function)
    restore_user_cmts(func_ea) -> user_cmts_t
    Restore user defined comments from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined comments. The returned object must be
             deleted by the caller using delete_user_cmts()

ida_hexrays.restore_user_defined_calls (function)
    restore_user_defined_calls(udcalls, func_ea) -> bool
    Restore user defined function calls from the database.
    
    @param udcalls: (C++: udcall_map_t *) ptr to output buffer
    @param func_ea: (C++: ea_t) entry address of the function
    @return: success

ida_hexrays.restore_user_iflags (function)
    restore_user_iflags(func_ea) -> user_iflags_t
    Restore user defined citem iflags from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined iflags. The returned object must be deleted
             by the caller using delete_user_iflags()

ida_hexrays.restore_user_labels (function)
    restore_user_labels(func_ea) -> user_labels_t
    Restore user defined labels from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function, ignored if FUNC != nullptr
    @return: collection of user defined labels. The returned object must be deleted
             by the caller using delete_user_labels()

ida_hexrays.restore_user_labels2 (function)
    restore_user_labels2(func_ea, func=None) -> user_labels_t
    
    @param func_ea: ea_t
    @param func: cfunc_t const *

ida_hexrays.restore_user_lvar_settings (function)
    restore_user_lvar_settings(lvinf, func_ea) -> bool
    Restore user defined local variable settings in the database.
    
    @param lvinf: (C++: lvar_uservec_t *) ptr to output buffer
    @param func_ea: (C++: ea_t) entry address of the function
    @return: success

ida_hexrays.restore_user_numforms (function)
    restore_user_numforms(func_ea) -> user_numforms_t
    Restore user defined number formats from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined number formats. The returned object must be
             deleted by the caller using delete_user_numforms()

ida_hexrays.restore_user_unions (function)
    restore_user_unions(func_ea) -> user_unions_t
    Restore user defined union field selections from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of union field selections The returned object must be
             deleted by the caller using delete_user_unions()

ida_hexrays.rlist_t (class)
    Proxy of C++ rlist_t class.

ida_hexrays.rlist_t.__init__ (method)
    __init__(self) -> rlist_t
    __init__(self, m) -> rlist_t
    
    @param m: rlist_t const &
    
    __init__(self, reg, width) -> rlist_t
    
    @param reg: mreg_t
    @param width: int

ida_hexrays.rlist_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.save_user_cmts (function)
    save_user_cmts(func_ea, user_cmts)
    Save user defined comments into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param user_cmts: (C++: const user_cmts_t *) collection of user defined comments

ida_hexrays.save_user_defined_calls (function)
    save_user_defined_calls(func_ea, udcalls)
    Save user defined local function calls into the database.
    
    @param func_ea: (C++: ea_t) entry address of the function
    @param udcalls: (C++: const udcall_map_t &) user-specified info about user defined function calls

ida_hexrays.save_user_iflags (function)
    save_user_iflags(func_ea, iflags)
    Save user defined citem iflags into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param iflags: (C++: const user_iflags_t *) collection of user defined citem iflags

ida_hexrays.save_user_labels (function)
    save_user_labels(func_ea, user_labels)
    Save user defined labels into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function, ignored if FUNC != nullptr
    @param user_labels: (C++: const user_labels_t *) collection of user defined labels

ida_hexrays.save_user_labels2 (function)
    save_user_labels2(func_ea, user_labels, func=None)
    
    @param func_ea: ea_t
    @param user_labels: user_labels_t const *
    @param func: cfunc_t const *

ida_hexrays.save_user_lvar_settings (function)
    save_user_lvar_settings(func_ea, lvinf)
    Save user defined local variable settings into the database.
    
    @param func_ea: (C++: ea_t) entry address of the function
    @param lvinf: (C++: const lvar_uservec_t &) user-specified info about local variables

ida_hexrays.save_user_numforms (function)
    save_user_numforms(func_ea, numforms)
    Save user defined number formats into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param numforms: (C++: const user_numforms_t *) collection of user defined comments

ida_hexrays.save_user_unions (function)
    save_user_unions(func_ea, unions)
    Save user defined union field selections into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param unions: (C++: const user_unions_t *) collection of union field selections

ida_hexrays.scif_t (class)
    Proxy of C++ scif_t class.

ida_hexrays.scif_t.__init__ (method)
    __init__(self, _mba, tif, n=None) -> scif_t
    
    @param _mba: mba_t *
    @param tif: tinfo_t *
    @param n: qstring *

ida_hexrays.scif_t.mba (variable)
    Pointer to the parent mba_t object. Some operations may convert a scattered
    operand into something simpler, (a stack operand, for example). We will need to
    create stkvar_ref_t at that moment, this is why we need this pointer. See notes
    for lvar_ref_t::mba.

ida_hexrays.scif_t.name (variable)
    Usually scattered operands are created from a function prototype, which has the
    name information. We preserve it and use it to name the corresponding local
    variable.

ida_hexrays.scif_t.type (variable)
    Scattered operands always have type info assigned to them because without it we
    won't be able to manipulte them.

ida_hexrays.scif_visitor_t (class)
    Proxy of C++ scif_visitor_t class.

ida_hexrays.scif_visitor_t.__disown__ (method)

ida_hexrays.scif_visitor_t.__init__ (method)
    __init__(self) -> scif_visitor_t
    
    @param self: PyObject *

ida_hexrays.scif_visitor_t.visit_scif_mop (method)
    visit_scif_mop(self, r, off) -> int
    
    @param r: mop_t const &
    @param off: int

ida_hexrays.select_udt_by_offset (function)
    select_udt_by_offset(udts, ops, applicator) -> int
    Select UDT
    
    @param udts: (C++: const qvector< tinfo_t > *) list of UDT tinfo_t for the selection, if nullptr or empty then
                 UDTs from the "Local types" will be used
    @param ops: (C++: const ui_stroff_ops_t &) operands
    @param applicator: (C++: ui_stroff_applicator_t &) callback will be called to apply the selection for every
                       operand

ida_hexrays.send_database (function)
    send_database(err, silent)
    Send the database to Hex-Rays. This function sends the current database to the
    Hex-Rays server. The database is sent in the compressed form over an encrypted
    (SSL) connection.
    
    @param err: (C++: const hexrays_failure_t &) failure description object. Empty hexrays_failure_t object can be
                used if error information is not available.
    @param silent: (C++: bool) if false, a dialog box will be displayed before sending the
                   database.

ida_hexrays.set2jcnd (function)
    set2jcnd(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.set_type (function)
    set_type(id, tif, source, force=False) -> bool
    Set a global type.
    
    @param id: (C++: uval_t) address or id of the object
    @param tif: (C++: const tinfo_t &) new type info
    @param source: (C++: type_source_t) where the type comes from
    @param force: (C++: bool) true means to set the type as is, false means to merge the new
                  type with the possibly existing old type info.
    @return: success

ida_hexrays.simple_graph_t (class)
    Proxy of C++ simple_graph_t class.

ida_hexrays.simple_graph_t.__init__ (method)

ida_hexrays.stkvar_ref_t (class)
    Proxy of C++ stkvar_ref_t class.

ida_hexrays.stkvar_ref_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.__init__ (method)
    __init__(self, m, o) -> stkvar_ref_t
    
    @param m: mba_t *
    @param o: sval_t

ida_hexrays.stkvar_ref_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.compare (method)
    compare(self, r) -> int
    
    @param r: stkvar_ref_t const &

ida_hexrays.stkvar_ref_t.get_stkvar (method)
    get_stkvar(self, p_off=None) -> member_t *
    Retrieve the referenced stack variable.
    
    @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
    @return: pointer to the stack variable

ida_hexrays.stkvar_ref_t.mba (variable)
    Pointer to the parent mba_t object. We need it in order to retrieve the
    referenced stack variable. See notes for lvar_ref_t::mba.

ida_hexrays.stkvar_ref_t.off (variable)
    Offset to the stack variable from the bottom of the stack frame. It is called
    'decompiler stkoff' and it is different from IDA stkoff. See a note and a
    picture about 'decompiler stkoff' below.

ida_hexrays.stkvar_ref_t.swap (method)
    swap(self, r)
    
    @param r: stkvar_ref_t &

ida_hexrays.swap_mcode_relation (function)
    swap_mcode_relation(code) -> mcode_t
    
    @param code: enum mcode_t

ida_hexrays.swapped_relation (function)
    swapped_relation(op) -> ctype_t
    Swap a comparison operator. For example, cot_sge becomes cot_sle.
    
    @param op: (C++: ctype_t) enum ctype_t

ida_hexrays.term_hexrays_plugin (function)
    term_hexrays_plugin()
    Stop working with hex-rays decompiler.

ida_hexrays.treeloc_t (class)
    Proxy of C++ treeloc_t class.

ida_hexrays.treeloc_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: treeloc_t const &

ida_hexrays.treeloc_t.__init__ (method)
    __init__(self) -> treeloc_t

ida_hexrays.treeloc_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: treeloc_t const &

ida_hexrays.udc_filter_t (class)
    Proxy of C++ udc_filter_t class.

ida_hexrays.udc_filter_t.__disown__ (method)

ida_hexrays.udc_filter_t.__init__ (method)
    __init__(self) -> udc_filter_t
    
    @param self: PyObject *

ida_hexrays.udc_filter_t.apply (method)
    apply(self, cdg) -> merror_t
    generate microcode for an instruction
    
    @param cdg: (C++: codegen_t &)
    @return: MERR_... code: MERR_OK - user-defined microcode generated, go to the
             next instruction MERR_INSN - not generated - the caller should try the
             standard way else - error

ida_hexrays.udc_filter_t.cleanup (method)
    cleanup(self)
    Cleanup the filter This function properly clears type information associated to
    this filter.

ida_hexrays.udc_filter_t.empty (method)
    empty(self) -> bool

ida_hexrays.udc_filter_t.init (method)
    init(self, decl) -> bool
    
    @param decl: char const *

ida_hexrays.udc_filter_t.install (method)
    install(self)

ida_hexrays.udc_filter_t.match (method)
    match(self, cdg) -> bool
    return true if the filter object should be applied to given instruction
    
    @param cdg: (C++: codegen_t &)

ida_hexrays.udc_filter_t.remove (method)
    remove(self) -> bool

ida_hexrays.udcall_map_begin (function)
    udcall_map_begin(map) -> udcall_map_iterator_t
    Get iterator pointing to the beginning of udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *

ida_hexrays.udcall_map_clear (function)
    udcall_map_clear(map)
    Clear udcall_map_t.
    
    @param map: (C++: udcall_map_t *)

ida_hexrays.udcall_map_end (function)
    udcall_map_end(map) -> udcall_map_iterator_t
    Get iterator pointing to the end of udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *

ida_hexrays.udcall_map_erase (function)
    udcall_map_erase(map, p)
    Erase current element from udcall_map_t.
    
    @param map: (C++: udcall_map_t *)
    @param p: (C++: udcall_map_iterator_t)

ida_hexrays.udcall_map_find (function)
    udcall_map_find(map, key) -> udcall_map_iterator_t
    Find the specified key in udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *
    @param key: (C++: const ea_t &) ea_t const &

ida_hexrays.udcall_map_first (function)
    udcall_map_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: udcall_map_iterator_t)

ida_hexrays.udcall_map_free (function)
    udcall_map_free(map)
    Delete udcall_map_t instance.
    
    @param map: (C++: udcall_map_t *)

ida_hexrays.udcall_map_insert (function)
    udcall_map_insert(map, key, val) -> udcall_map_iterator_t
    Insert new (ea_t, udcall_t) pair into udcall_map_t.
    
    @param map: (C++: udcall_map_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const udcall_t &) udcall_t const &

ida_hexrays.udcall_map_iterator_t (class)
    Proxy of C++ udcall_map_iterator_t class.

ida_hexrays.udcall_map_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: udcall_map_iterator_t const &

ida_hexrays.udcall_map_iterator_t.__init__ (method)
    __init__(self) -> udcall_map_iterator_t

ida_hexrays.udcall_map_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: udcall_map_iterator_t const &

ida_hexrays.udcall_map_new (function)
    udcall_map_new() -> udcall_map_t *
    Create a new udcall_map_t instance.

ida_hexrays.udcall_map_next (function)
    udcall_map_next(p) -> udcall_map_iterator_t
    Move to the next element.
    
    @param p: (C++: udcall_map_iterator_t)

ida_hexrays.udcall_map_prev (function)
    udcall_map_prev(p) -> udcall_map_iterator_t
    Move to the previous element.
    
    @param p: (C++: udcall_map_iterator_t)

ida_hexrays.udcall_map_second (function)
    udcall_map_second(p) -> udcall_t
    Get reference to the current map value.
    
    @param p: (C++: udcall_map_iterator_t)

ida_hexrays.udcall_map_size (function)
    udcall_map_size(map) -> size_t
    Get size of udcall_map_t.
    
    @param map: (C++: udcall_map_t *)

ida_hexrays.udcall_t (class)
    Proxy of C++ udcall_t class.

ida_hexrays.udcall_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.__init__ (method)
    __init__(self) -> udcall_t

ida_hexrays.udcall_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.compare (method)
    compare(self, r) -> int
    
    @param r: udcall_t const &

ida_hexrays.udcall_t.empty (method)
    empty(self) -> bool

ida_hexrays.ui_stroff_applicator_t (class)
    Proxy of C++ ui_stroff_applicator_t class.

ida_hexrays.ui_stroff_applicator_t.__disown__ (method)

ida_hexrays.ui_stroff_applicator_t.__init__ (method)
    __init__(self) -> ui_stroff_applicator_t
    
    @param self: PyObject *

ida_hexrays.ui_stroff_applicator_t.apply (method)
    apply(self, opnum, path, top_tif, spath) -> bool
    
    @param opnum: (C++: size_t) operand ordinal number, see below
    @param path: (C++: const intvec_t &) path describing the union selection, maybe empty
    @param top_tif: (C++: const tinfo_t &) tinfo_t of the selected toplevel UDT
    @param spath: (C++: const char *) selected path

ida_hexrays.ui_stroff_op_t (class)
    Proxy of C++ ui_stroff_op_t class.

ida_hexrays.ui_stroff_op_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ui_stroff_op_t const &

ida_hexrays.ui_stroff_op_t.__init__ (method)
    __init__(self) -> ui_stroff_op_t

ida_hexrays.ui_stroff_op_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ui_stroff_op_t const &

ida_hexrays.ui_stroff_op_t.offset (variable)
    operand offset, will be used when calculating the UDT path

ida_hexrays.ui_stroff_op_t.text (variable)
    any text for the column "Operand" of widget

ida_hexrays.ui_stroff_ops_t (class)
    Proxy of C++ qvector< ui_stroff_op_t > class.

ida_hexrays.ui_stroff_ops_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< ui_stroff_op_t > const &

ida_hexrays.ui_stroff_ops_t.__getitem__ (method)
    __getitem__(self, i) -> ui_stroff_op_t
    
    @param i: size_t

ida_hexrays.ui_stroff_ops_t.__init__ (method)
    __init__(self) -> ui_stroff_ops_t
    __init__(self, x) -> ui_stroff_ops_t
    
    @param x: qvector< ui_stroff_op_t > const &

ida_hexrays.ui_stroff_ops_t.__len__ (method)
    __len__(self) -> size_t

ida_hexrays.ui_stroff_ops_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< ui_stroff_op_t > const &

ida_hexrays.ui_stroff_ops_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.at (method)
    at(self, _idx) -> ui_stroff_op_t
    
    @param _idx: size_t

ida_hexrays.ui_stroff_ops_t.begin (method)
    begin(self) -> ui_stroff_op_t

ida_hexrays.ui_stroff_ops_t.capacity (method)
    capacity(self) -> size_t

ida_hexrays.ui_stroff_ops_t.clear (method)
    clear(self)

ida_hexrays.ui_stroff_ops_t.empty (method)
    empty(self) -> bool

ida_hexrays.ui_stroff_ops_t.end (method)
    end(self) -> ui_stroff_op_t

ida_hexrays.ui_stroff_ops_t.erase (method)
    erase(self, it) -> ui_stroff_op_t
    
    @param it: qvector< ui_stroff_op_t >::iterator
    
    erase(self, first, last) -> ui_stroff_op_t
    
    @param first: qvector< ui_stroff_op_t >::iterator
    @param last: qvector< ui_stroff_op_t >::iterator

ida_hexrays.ui_stroff_ops_t.extract (method)
    extract(self) -> ui_stroff_op_t

ida_hexrays.ui_stroff_ops_t.find (method)
    find(self, x) -> ui_stroff_op_t
    
    @param x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.grow (method)
    grow(self, x=ui_stroff_op_t())
    
    @param x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.has (method)
    has(self, x) -> bool
    
    @param x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.inject (method)
    inject(self, s, len)
    
    @param s: ui_stroff_op_t *
    @param len: size_t

ida_hexrays.ui_stroff_ops_t.insert (method)
    insert(self, it, x) -> ui_stroff_op_t
    
    @param it: qvector< ui_stroff_op_t >::iterator
    @param x: ui_stroff_op_t const &

ida_hexrays.ui_stroff_ops_t.pop_back (method)
    pop_back(self)

ida_hexrays.ui_stroff_ops_t.push_back (method)
    push_back(self, x)
    
    @param x: ui_stroff_op_t const &
    
    push_back(self) -> ui_stroff_op_t

ida_hexrays.ui_stroff_ops_t.qclear (method)
    qclear(self)

ida_hexrays.ui_stroff_ops_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_hexrays.ui_stroff_ops_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: ui_stroff_op_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_hexrays.ui_stroff_ops_t.size (method)
    size(self) -> size_t

ida_hexrays.ui_stroff_ops_t.swap (method)
    swap(self, r)
    
    @param r: qvector< ui_stroff_op_t > &

ida_hexrays.ui_stroff_ops_t.truncate (method)
    truncate(self)

ida_hexrays.user_cmts_begin (function)
    user_cmts_begin(map) -> user_cmts_iterator_t
    Get iterator pointing to the beginning of user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *

ida_hexrays.user_cmts_clear (function)
    user_cmts_clear(map)
    Clear user_cmts_t.
    
    @param map: (C++: user_cmts_t *)

ida_hexrays.user_cmts_end (function)
    user_cmts_end(map) -> user_cmts_iterator_t
    Get iterator pointing to the end of user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *

ida_hexrays.user_cmts_erase (function)
    user_cmts_erase(map, p)
    Erase current element from user_cmts_t.
    
    @param map: (C++: user_cmts_t *)
    @param p: (C++: user_cmts_iterator_t)

ida_hexrays.user_cmts_find (function)
    user_cmts_find(map, key) -> user_cmts_iterator_t
    Find the specified key in user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *
    @param key: (C++: const treeloc_t &) treeloc_t const &

ida_hexrays.user_cmts_first (function)
    user_cmts_first(p) -> treeloc_t
    Get reference to the current map key.
    
    @param p: (C++: user_cmts_iterator_t)

ida_hexrays.user_cmts_free (function)
    user_cmts_free(map)
    Delete user_cmts_t instance.
    
    @param map: (C++: user_cmts_t *)

ida_hexrays.user_cmts_insert (function)
    user_cmts_insert(map, key, val) -> user_cmts_iterator_t
    Insert new (treeloc_t, citem_cmt_t) pair into user_cmts_t.
    
    @param map: (C++: user_cmts_t *)
    @param key: (C++: const treeloc_t &) treeloc_t const &
    @param val: (C++: const citem_cmt_t &) citem_cmt_t const &

ida_hexrays.user_cmts_iterator_t (class)
    Proxy of C++ user_cmts_iterator_t class.

ida_hexrays.user_cmts_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: user_cmts_iterator_t const &

ida_hexrays.user_cmts_iterator_t.__init__ (method)
    __init__(self) -> user_cmts_iterator_t

ida_hexrays.user_cmts_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: user_cmts_iterator_t const &

ida_hexrays.user_cmts_new (function)
    user_cmts_new() -> user_cmts_t
    Create a new user_cmts_t instance.

ida_hexrays.user_cmts_next (function)
    user_cmts_next(p) -> user_cmts_iterator_t
    Move to the next element.
    
    @param p: (C++: user_cmts_iterator_t)

ida_hexrays.user_cmts_prev (function)
    user_cmts_prev(p) -> user_cmts_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_cmts_iterator_t)

ida_hexrays.user_cmts_second (function)
    user_cmts_second(p) -> citem_cmt_t
    Get reference to the current map value.
    
    @param p: (C++: user_cmts_iterator_t)

ida_hexrays.user_cmts_size (function)
    user_cmts_size(map) -> size_t
    Get size of user_cmts_t.
    
    @param map: (C++: user_cmts_t *)

ida_hexrays.user_cmts_t (class)
    Proxy of C++ std::map< treeloc_t,citem_cmt_t > class.

ida_hexrays.user_cmts_t.__init__ (method)
    __init__(self) -> user_cmts_t

ida_hexrays.user_cmts_t.at (method)
    at(self, _Keyval) -> citem_cmt_t
    
    @param _Keyval: treeloc_t const &

ida_hexrays.user_cmts_t.size (method)
    size(self) -> size_t

ida_hexrays.user_iflags_begin (function)
    user_iflags_begin(map) -> user_iflags_iterator_t
    Get iterator pointing to the beginning of user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *

ida_hexrays.user_iflags_clear (function)
    user_iflags_clear(map)
    Clear user_iflags_t.
    
    @param map: (C++: user_iflags_t *)

ida_hexrays.user_iflags_end (function)
    user_iflags_end(map) -> user_iflags_iterator_t
    Get iterator pointing to the end of user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *

ida_hexrays.user_iflags_erase (function)
    user_iflags_erase(map, p)
    Erase current element from user_iflags_t.
    
    @param map: (C++: user_iflags_t *)
    @param p: (C++: user_iflags_iterator_t)

ida_hexrays.user_iflags_find (function)
    user_iflags_find(map, key) -> user_iflags_iterator_t
    Find the specified key in user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *
    @param key: (C++: const citem_locator_t &) citem_locator_t const &

ida_hexrays.user_iflags_first (function)
    user_iflags_first(p) -> citem_locator_t
    Get reference to the current map key.
    
    @param p: (C++: user_iflags_iterator_t)

ida_hexrays.user_iflags_free (function)
    user_iflags_free(map)
    Delete user_iflags_t instance.
    
    @param map: (C++: user_iflags_t *)

ida_hexrays.user_iflags_insert (function)
    user_iflags_insert(map, key, val) -> user_iflags_iterator_t
    Insert new (citem_locator_t, int32) pair into user_iflags_t.
    
    @param map: (C++: user_iflags_t *)
    @param key: (C++: const citem_locator_t &) citem_locator_t const &
    @param val: (C++: const int32 &) int32 const &

ida_hexrays.user_iflags_iterator_t (class)
    Proxy of C++ user_iflags_iterator_t class.

ida_hexrays.user_iflags_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: user_iflags_iterator_t const &

ida_hexrays.user_iflags_iterator_t.__init__ (method)
    __init__(self) -> user_iflags_iterator_t

ida_hexrays.user_iflags_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: user_iflags_iterator_t const &

ida_hexrays.user_iflags_new (function)
    user_iflags_new() -> user_iflags_t
    Create a new user_iflags_t instance.

ida_hexrays.user_iflags_next (function)
    user_iflags_next(p) -> user_iflags_iterator_t
    Move to the next element.
    
    @param p: (C++: user_iflags_iterator_t)

ida_hexrays.user_iflags_prev (function)
    user_iflags_prev(p) -> user_iflags_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_iflags_iterator_t)

ida_hexrays.user_iflags_second (function)
    user_iflags_second(p) -> int32 const &
    Get reference to the current map value.
    
    @param p: (C++: user_iflags_iterator_t)

ida_hexrays.user_iflags_size (function)
    user_iflags_size(map) -> size_t
    Get size of user_iflags_t.
    
    @param map: (C++: user_iflags_t *)

ida_hexrays.user_iflags_t (class)
    Proxy of C++ std::map< citem_locator_t,int32 > class.

ida_hexrays.user_iflags_t.__init__ (method)
    __init__(self) -> user_iflags_t

ida_hexrays.user_iflags_t.at (method)
    at(self, _Keyval) -> int &
    
    @param _Keyval: citem_locator_t const &

ida_hexrays.user_iflags_t.size (method)
    size(self) -> size_t

ida_hexrays.user_labels_begin (function)
    user_labels_begin(map) -> user_labels_iterator_t
    Get iterator pointing to the beginning of user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *

ida_hexrays.user_labels_clear (function)
    user_labels_clear(map)
    Clear user_labels_t.
    
    @param map: (C++: user_labels_t *)

ida_hexrays.user_labels_end (function)
    user_labels_end(map) -> user_labels_iterator_t
    Get iterator pointing to the end of user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *

ida_hexrays.user_labels_erase (function)
    user_labels_erase(map, p)
    Erase current element from user_labels_t.
    
    @param map: (C++: user_labels_t *)
    @param p: (C++: user_labels_iterator_t)

ida_hexrays.user_labels_find (function)
    user_labels_find(map, key) -> user_labels_iterator_t
    Find the specified key in user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *
    @param key: (C++: const int &) int const &

ida_hexrays.user_labels_first (function)
    user_labels_first(p) -> int const &
    Get reference to the current map key.
    
    @param p: (C++: user_labels_iterator_t)

ida_hexrays.user_labels_free (function)
    user_labels_free(map)
    Delete user_labels_t instance.
    
    @param map: (C++: user_labels_t *)

ida_hexrays.user_labels_insert (function)
    user_labels_insert(map, key, val) -> user_labels_iterator_t
    Insert new (int, qstring) pair into user_labels_t.
    
    @param map: (C++: user_labels_t *)
    @param key: (C++: const int &) int const &
    @param val: (C++: const qstring &) qstring const &

ida_hexrays.user_labels_iterator_t (class)
    Proxy of C++ user_labels_iterator_t class.

ida_hexrays.user_labels_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: user_labels_iterator_t const &

ida_hexrays.user_labels_iterator_t.__init__ (method)
    __init__(self) -> user_labels_iterator_t

ida_hexrays.user_labels_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: user_labels_iterator_t const &

ida_hexrays.user_labels_new (function)
    user_labels_new() -> user_labels_t
    Create a new user_labels_t instance.

ida_hexrays.user_labels_next (function)
    user_labels_next(p) -> user_labels_iterator_t
    Move to the next element.
    
    @param p: (C++: user_labels_iterator_t)

ida_hexrays.user_labels_prev (function)
    user_labels_prev(p) -> user_labels_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_labels_iterator_t)

ida_hexrays.user_labels_second (function)
    user_labels_second(p) -> qstring &
    Get reference to the current map value.
    
    @param p: (C++: user_labels_iterator_t)

ida_hexrays.user_labels_size (function)
    user_labels_size(map) -> size_t
    Get size of user_labels_t.
    
    @param map: (C++: user_labels_t *)

ida_hexrays.user_labels_t (class)
    Proxy of C++ std::map< int,qstring > class.

ida_hexrays.user_labels_t.__init__ (method)
    __init__(self) -> user_labels_t

ida_hexrays.user_labels_t.at (method)
    at(self, _Keyval) -> _qstring< char > &
    
    @param _Keyval: int const &

ida_hexrays.user_labels_t.size (method)
    size(self) -> size_t

ida_hexrays.user_lvar_modifier_t (class)
    Proxy of C++ user_lvar_modifier_t class.

ida_hexrays.user_lvar_modifier_t.__disown__ (method)

ida_hexrays.user_lvar_modifier_t.__init__ (method)
    __init__(self) -> user_lvar_modifier_t
    
    @param self: PyObject *

ida_hexrays.user_lvar_modifier_t.modify_lvars (method)
    modify_lvars(self, lvinf) -> bool
    Modify lvar settings. Returns: true-modified
    
    @param lvinf: (C++: lvar_uservec_t *)

ida_hexrays.user_numforms_begin (function)
    user_numforms_begin(map) -> user_numforms_iterator_t
    Get iterator pointing to the beginning of user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *

ida_hexrays.user_numforms_clear (function)
    user_numforms_clear(map)
    Clear user_numforms_t.
    
    @param map: (C++: user_numforms_t *)

ida_hexrays.user_numforms_end (function)
    user_numforms_end(map) -> user_numforms_iterator_t
    Get iterator pointing to the end of user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *

ida_hexrays.user_numforms_erase (function)
    user_numforms_erase(map, p)
    Erase current element from user_numforms_t.
    
    @param map: (C++: user_numforms_t *)
    @param p: (C++: user_numforms_iterator_t)

ida_hexrays.user_numforms_find (function)
    user_numforms_find(map, key) -> user_numforms_iterator_t
    Find the specified key in user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *
    @param key: (C++: const operand_locator_t &) operand_locator_t const &

ida_hexrays.user_numforms_first (function)
    user_numforms_first(p) -> operand_locator_t
    Get reference to the current map key.
    
    @param p: (C++: user_numforms_iterator_t)

ida_hexrays.user_numforms_free (function)
    user_numforms_free(map)
    Delete user_numforms_t instance.
    
    @param map: (C++: user_numforms_t *)

ida_hexrays.user_numforms_insert (function)
    user_numforms_insert(map, key, val) -> user_numforms_iterator_t
    Insert new (operand_locator_t, number_format_t) pair into user_numforms_t.
    
    @param map: (C++: user_numforms_t *)
    @param key: (C++: const operand_locator_t &) operand_locator_t const &
    @param val: (C++: const number_format_t &) number_format_t const &

ida_hexrays.user_numforms_iterator_t (class)
    Proxy of C++ user_numforms_iterator_t class.

ida_hexrays.user_numforms_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: user_numforms_iterator_t const &

ida_hexrays.user_numforms_iterator_t.__init__ (method)
    __init__(self) -> user_numforms_iterator_t

ida_hexrays.user_numforms_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: user_numforms_iterator_t const &

ida_hexrays.user_numforms_new (function)
    user_numforms_new() -> user_numforms_t
    Create a new user_numforms_t instance.

ida_hexrays.user_numforms_next (function)
    user_numforms_next(p) -> user_numforms_iterator_t
    Move to the next element.
    
    @param p: (C++: user_numforms_iterator_t)

ida_hexrays.user_numforms_prev (function)
    user_numforms_prev(p) -> user_numforms_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_numforms_iterator_t)

ida_hexrays.user_numforms_second (function)
    user_numforms_second(p) -> number_format_t
    Get reference to the current map value.
    
    @param p: (C++: user_numforms_iterator_t)

ida_hexrays.user_numforms_size (function)
    user_numforms_size(map) -> size_t
    Get size of user_numforms_t.
    
    @param map: (C++: user_numforms_t *)

ida_hexrays.user_numforms_t (class)
    Proxy of C++ std::map< operand_locator_t,number_format_t > class.

ida_hexrays.user_numforms_t.__init__ (method)
    __init__(self) -> user_numforms_t

ida_hexrays.user_numforms_t.at (method)
    at(self, _Keyval) -> number_format_t
    
    @param _Keyval: operand_locator_t const &

ida_hexrays.user_numforms_t.size (method)
    size(self) -> size_t

ida_hexrays.user_unions_begin (function)
    user_unions_begin(map) -> user_unions_iterator_t
    Get iterator pointing to the beginning of user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *

ida_hexrays.user_unions_clear (function)
    user_unions_clear(map)
    Clear user_unions_t.
    
    @param map: (C++: user_unions_t *)

ida_hexrays.user_unions_end (function)
    user_unions_end(map) -> user_unions_iterator_t
    Get iterator pointing to the end of user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *

ida_hexrays.user_unions_erase (function)
    user_unions_erase(map, p)
    Erase current element from user_unions_t.
    
    @param map: (C++: user_unions_t *)
    @param p: (C++: user_unions_iterator_t)

ida_hexrays.user_unions_find (function)
    user_unions_find(map, key) -> user_unions_iterator_t
    Find the specified key in user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *
    @param key: (C++: const ea_t &) ea_t const &

ida_hexrays.user_unions_first (function)
    user_unions_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: user_unions_iterator_t)

ida_hexrays.user_unions_free (function)
    user_unions_free(map)
    Delete user_unions_t instance.
    
    @param map: (C++: user_unions_t *)

ida_hexrays.user_unions_insert (function)
    user_unions_insert(map, key, val) -> user_unions_iterator_t
    Insert new (ea_t, intvec_t) pair into user_unions_t.
    
    @param map: (C++: user_unions_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const intvec_t &) intvec_t const &

ida_hexrays.user_unions_iterator_t (class)
    Proxy of C++ user_unions_iterator_t class.

ida_hexrays.user_unions_iterator_t.__eq__ (method)
    __eq__(self, p) -> bool
    
    @param p: user_unions_iterator_t const &

ida_hexrays.user_unions_iterator_t.__init__ (method)
    __init__(self) -> user_unions_iterator_t

ida_hexrays.user_unions_iterator_t.__ne__ (method)
    __ne__(self, p) -> bool
    
    @param p: user_unions_iterator_t const &

ida_hexrays.user_unions_new (function)
    user_unions_new() -> user_unions_t
    Create a new user_unions_t instance.

ida_hexrays.user_unions_next (function)
    user_unions_next(p) -> user_unions_iterator_t
    Move to the next element.
    
    @param p: (C++: user_unions_iterator_t)

ida_hexrays.user_unions_prev (function)
    user_unions_prev(p) -> user_unions_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_unions_iterator_t)

ida_hexrays.user_unions_second (function)
    user_unions_second(p) -> intvec_t
    Get reference to the current map value.
    
    @param p: (C++: user_unions_iterator_t)

ida_hexrays.user_unions_size (function)
    user_unions_size(map) -> size_t
    Get size of user_unions_t.
    
    @param map: (C++: user_unions_t *)

ida_hexrays.user_unions_t (class)
    Proxy of C++ std::map< ea_t,intvec_t > class.

ida_hexrays.user_unions_t.__init__ (method)
    __init__(self) -> user_unions_t

ida_hexrays.user_unions_t.at (method)
    at(self, _Keyval) -> intvec_t
    
    @param _Keyval: unsigned-ea-like-numeric-type const &

ida_hexrays.user_unions_t.size (method)
    size(self) -> size_t

ida_hexrays.uval_ivl_ivlset_t (class)
    Proxy of C++ ivlset_tpl< ivl_t,uval_t > class.

ida_hexrays.uval_ivl_ivlset_t.__eq__ (method)
    __eq__(self, v) -> bool
    
    @param v: ivl_t const &

ida_hexrays.uval_ivl_ivlset_t.__init__ (method)
    __init__(self) -> uval_ivl_ivlset_t
    __init__(self, ivl) -> uval_ivl_ivlset_t
    
    @param ivl: ivl_t const &

ida_hexrays.uval_ivl_ivlset_t.__ne__ (method)
    __ne__(self, v) -> bool
    
    @param v: ivl_t const &

ida_hexrays.uval_ivl_ivlset_t.all_values (method)
    all_values(self) -> bool

ida_hexrays.uval_ivl_ivlset_t.begin (method)
    begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
    begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator

ida_hexrays.uval_ivl_ivlset_t.clear (method)
    clear(self)

ida_hexrays.uval_ivl_ivlset_t.empty (method)
    empty(self) -> bool

ida_hexrays.uval_ivl_ivlset_t.end (method)
    end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
    end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator

ida_hexrays.uval_ivl_ivlset_t.getivl (method)
    getivl(self, idx) -> ivl_t
    
    @param idx: int

ida_hexrays.uval_ivl_ivlset_t.lastivl (method)
    lastivl(self) -> ivl_t

ida_hexrays.uval_ivl_ivlset_t.nivls (method)
    nivls(self) -> size_t

ida_hexrays.uval_ivl_ivlset_t.qclear (method)
    qclear(self)

ida_hexrays.uval_ivl_ivlset_t.set_all_values (method)
    set_all_values(self)

ida_hexrays.uval_ivl_ivlset_t.single_value (method)
    single_value(self) -> bool
    single_value(self, v) -> bool
    
    @param v: unsigned-ea-like-numeric-type

ida_hexrays.uval_ivl_ivlset_t.swap (method)
    swap(self, r)
    
    @param r: ivlset_tpl< ivl_t,uval_t > &

ida_hexrays.uval_ivl_t (class)
    Proxy of C++ ivl_tpl< uval_t > class.

ida_hexrays.uval_ivl_t.__init__ (method)
    __init__(self, _off, _size) -> uval_ivl_t
    
    @param _off: unsigned-ea-like-numeric-type
    @param _size: unsigned-ea-like-numeric-type

ida_hexrays.uval_ivl_t.end (method)
    end(self) -> unsigned-ea-like-numeric-type

ida_hexrays.uval_ivl_t.last (method)
    last(self) -> unsigned-ea-like-numeric-type

ida_hexrays.uval_ivl_t.valid (method)
    valid(self) -> bool

ida_hexrays.valrng_t (class)
    Proxy of C++ valrng_t class.

ida_hexrays.valrng_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__init__ (method)
    __init__(self, size_=MAX_VLR_SIZE) -> valrng_t
    
    @param size_: int
    
    __init__(self, r) -> valrng_t
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t._deregister (method)
    _deregister(self)

ida_hexrays.valrng_t._print (method)
    _print(self)

ida_hexrays.valrng_t._register (method)
    _register(self)

ida_hexrays.valrng_t.all_values (method)
    all_values(self) -> bool

ida_hexrays.valrng_t.compare (method)
    compare(self, r) -> int
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.cvt_to_cmp (method)
    cvt_to_cmp(self, strict) -> bool
    
    @param strict: bool

ida_hexrays.valrng_t.cvt_to_single_value (method)
    cvt_to_single_value(self) -> bool

ida_hexrays.valrng_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.valrng_t.empty (method)
    empty(self) -> bool

ida_hexrays.valrng_t.get_size (method)
    get_size(self) -> int

ida_hexrays.valrng_t.has (method)
    has(self, v) -> bool
    
    @param v: uvlr_t

ida_hexrays.valrng_t.intersect_with (method)
    intersect_with(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.valrng_t.inverse (method)
    inverse(self)

ida_hexrays.valrng_t.is_unknown (method)
    is_unknown(self) -> bool

ida_hexrays.valrng_t.max_svalue (method)
    max_svalue(self, size_) -> uvlr_t
    
    @param size_: int
    
    max_svalue(self) -> uvlr_t

ida_hexrays.valrng_t.max_value (method)
    max_value(self, size_) -> uvlr_t
    
    @param size_: int
    
    max_value(self) -> uvlr_t

ida_hexrays.valrng_t.min_svalue (method)
    min_svalue(self, size_) -> uvlr_t
    
    @param size_: int
    
    min_svalue(self) -> uvlr_t

ida_hexrays.valrng_t.reduce_size (method)
    reduce_size(self, new_size) -> bool
    
    @param new_size: int

ida_hexrays.valrng_t.set_all (method)
    set_all(self)

ida_hexrays.valrng_t.set_cmp (method)
    set_cmp(self, cmp, _value)
    
    @param cmp: enum cmpop_t
    @param _value: uvlr_t

ida_hexrays.valrng_t.set_eq (method)
    set_eq(self, v)
    
    @param v: uvlr_t

ida_hexrays.valrng_t.set_none (method)
    set_none(self)

ida_hexrays.valrng_t.set_unk (method)
    set_unk(self)

ida_hexrays.valrng_t.swap (method)
    swap(self, r)
    
    @param r: valrng_t &

ida_hexrays.valrng_t.unite_with (method)
    unite_with(self, r) -> bool
    
    @param r: valrng_t const &

ida_hexrays.var_ref_t (class)
    Proxy of C++ var_ref_t class.

ida_hexrays.var_ref_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.__init__ (method)
    __init__(self) -> var_ref_t

ida_hexrays.var_ref_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.compare (method)
    compare(self, r) -> int
    
    @param r: var_ref_t const &

ida_hexrays.var_ref_t.getv (method)
    getv(self) -> lvar_t

ida_hexrays.var_ref_t.idx (variable)
    index into lvars_t

ida_hexrays.var_ref_t.mba (variable)
    pointer to the underlying micro array

ida_hexrays.vc_printer_t (class)
    Proxy of C++ vc_printer_t class.

ida_hexrays.vc_printer_t.__disown__ (method)

ida_hexrays.vc_printer_t.__init__ (method)
    __init__(self, f) -> vc_printer_t
    
    @param f: cfunc_t const *

ida_hexrays.vc_printer_t.func (variable)
    cfunc_t to generate text for

ida_hexrays.vc_printer_t.oneliner (method)
    oneliner(self) -> bool
    Are we generating one-line text representation?
    
    @return: true if the output will occupy one line without line breaks

ida_hexrays.vd_failure_t (class)
    Proxy of C++ vd_failure_t class.

ida_hexrays.vd_failure_t.__init__ (method)
    __init__(self) -> vd_failure_t
    __init__(self, code, ea, buf=None) -> vd_failure_t
    
    @param code: enum merror_t
    @param ea: ea_t
    @param buf: char const *
    
    __init__(self, code, ea, buf) -> vd_failure_t
    
    @param code: enum merror_t
    @param ea: ea_t
    @param buf: qstring const &
    
    __init__(self, _hf) -> vd_failure_t
    
    @param _hf: hexrays_failure_t const &

ida_hexrays.vd_failure_t.desc (method)
    desc(self) -> qstring

ida_hexrays.vd_interr_t (class)
    Proxy of C++ vd_interr_t class.

ida_hexrays.vd_interr_t.__init__ (method)
    __init__(self, ea, buf) -> vd_interr_t
    
    @param ea: ea_t
    @param buf: char const *

ida_hexrays.vd_printer_t (class)
    Proxy of C++ vd_printer_t class.

ida_hexrays.vd_printer_t.__disown__ (method)

ida_hexrays.vd_printer_t.__init__ (method)
    __init__(self) -> vd_printer_t
    
    @param self: PyObject *

ida_hexrays.vd_printer_t._print (method)
    _print(self, indent, format) -> int
    
    Parameters
    ----------
    indent: int
    format: char const *

ida_hexrays.vd_printer_t.hdrlines (variable)
    number of header lines (prototype+typedef+lvars) valid at the end of print
    process

ida_hexrays.vdloc_t (class)
    Proxy of C++ vdloc_t class.

ida_hexrays.vdloc_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.__init__ (method)
    __init__(self) -> vdloc_t

ida_hexrays.vdloc_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t._set_reg1 (method)
    _set_reg1(self, r1)
    
    Parameters
    ----------
    r1: int

ida_hexrays.vdloc_t.compare (method)
    compare(self, r) -> int
    
    @param r: vdloc_t const &

ida_hexrays.vdloc_t.is_aliasable (method)
    is_aliasable(self, mb, size) -> bool
    
    @param mb: mba_t const *
    @param size: int

ida_hexrays.vdloc_t.reg1 (method)
    reg1(self) -> int

ida_hexrays.vdloc_t.set_reg1 (method)
    set_reg1(self, r1)
    
    @param r1: int

ida_hexrays.vdui_t (class)
    Proxy of C++ vdui_t class.

ida_hexrays.vdui_t.__init__ (method)

ida_hexrays.vdui_t.calc_cmt_type (method)
    calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
    Check if the specified line can have a comment. Due to the coordinate system for
    comments: (\link{https://www.hex-rays.com/blog/coordinate-system-for-hex-rays})
    some function lines cannot have comments. This function checks if a comment can
    be attached to the specified line.
    
    @param lnnum: (C++: size_t) line number (0 based)
    @param cmttype: (C++: cmt_type_t) comment types to check
    @return: possible comment types

ida_hexrays.vdui_t.cfunc (variable)
    pointer to function object

ida_hexrays.vdui_t.clear (method)
    clear(self)
    Clear the pseudocode window. It deletes the current function and microcode.

ida_hexrays.vdui_t.collapse_item (method)
    collapse_item(self, hide) -> bool
    Collapse/uncollapse item. This function collapses the current item.
    
    @param hide: (C++: bool)
    @return: false if failed.

ida_hexrays.vdui_t.collapse_lvars (method)
    collapse_lvars(self, hide) -> bool
    Collapse/uncollapse local variable declarations.
    
    @param hide: (C++: bool)
    @return: false if failed.

ida_hexrays.vdui_t.cpos (variable)
    Current ctext position.

ida_hexrays.vdui_t.ct (variable)
    pseudocode view

ida_hexrays.vdui_t.ctree_to_disasm (method)
    ctree_to_disasm(self) -> bool
    Jump to disassembly. This function jumps to the address in the disassembly
    window which corresponds to the current item. The current item is determined
    based on the current keyboard cursor position.
    
    @return: false if failed

ida_hexrays.vdui_t.del_orphan_cmts (method)
    del_orphan_cmts(self) -> bool
    Delete all orphan comments. Delete all orphan comments and refresh the screen.
    
    @return: true

ida_hexrays.vdui_t.edit_cmt (method)
    edit_cmt(self, loc) -> bool
    Edit an indented comment. This function displays a dialog box and allows the
    user to edit the comment for the specified ctree location.
    
    @param loc: (C++: const treeloc_t &) comment location
    @return: false if failed or cancelled

ida_hexrays.vdui_t.edit_func_cmt (method)
    edit_func_cmt(self) -> bool
    Edit a function comment. This function displays a dialog box and allows the user
    to edit the function comment.
    
    @return: false if failed or cancelled

ida_hexrays.vdui_t.flags (variable)
    Properties of pseudocode window

ida_hexrays.vdui_t.get_current_item (method)
    get_current_item(self, idv) -> bool
    Get current item. This function refreshes the cpos, item, tail fields.
    
    @param idv: (C++: input_device_t) keyboard or mouse
    @see: cfunc_t::get_line_item()
    @return: false if failed

ida_hexrays.vdui_t.get_current_label (method)
    get_current_label(self) -> int
    Get current label. If there is a label under the cursor, return its number.
    
    @return: -1 if there is no label under the cursor. prereq: get_current_item()
             has been called

ida_hexrays.vdui_t.get_number (method)
    get_number(self) -> cnumber_t
    Get current number. If the current item is a number, return pointer to it.
    
    @return: nullptr if the current item is not a number This function returns non-
             null for the cases of a 'switch' statement Also, if the current item is
             a casted number, then this function will succeed.

ida_hexrays.vdui_t.head (variable)
    First ctree item on the current line (for block comments)

ida_hexrays.vdui_t.in_ctree (method)
    in_ctree(self) -> bool
    Is the current item a statement?
    
    @return: false if the cursor is in the local variable/type declaration area
    true if the cursor is in the statement area

ida_hexrays.vdui_t.invert_bits (method)
    invert_bits(self) -> bool
    Bitwise negate a number. This function inverts all bits of the current number.
    
    @return: false if failed.

ida_hexrays.vdui_t.invert_sign (method)
    invert_sign(self) -> bool
    Negate a number. This function negates the current number.
    
    @return: false if failed.

ida_hexrays.vdui_t.item (variable)
    Current ctree item.

ida_hexrays.vdui_t.jump_enter (method)
    jump_enter(self, idv, omflags) -> bool
    Process the Enter key. This function jumps to the definition of the item under
    the cursor. If the current item is a function, it will be decompiled. If the
    current item is a global data, its disassemly text will be displayed.
    
    @param idv: (C++: input_device_t) what cursor must be used, the keyboard or the mouse
    @param omflags: (C++: int) OM_NEWWIN: new pseudocode window will open, 0: reuse the
                    existing window
    @return: false if failed

ida_hexrays.vdui_t.last_code (variable)
    result of the last user action. See Microcode error codes

ida_hexrays.vdui_t.locked (method)
    locked(self) -> bool
    Does the pseudocode window contain valid code? We lock windows before modifying
    them, to avoid recursion due to the events generated by the IDA kernel.
    @retval true: The window is locked and may have stale info

ida_hexrays.vdui_t.map_lvar (method)
    map_lvar(self, frm, to) -> bool
    Map a local variable to another. This function permanently maps one lvar to
    another. All occurrences of the mapped variable are replaced by the new variable
    
    @param from: (C++: lvar_t *) the variable being mapped
    @param to: (C++: lvar_t *) the variable to map to. if nullptr, unmaps the variable
    @return: false if failed

ida_hexrays.vdui_t.mba (variable)
    pointer to underlying microcode

ida_hexrays.vdui_t.refresh_cpos (method)
    refresh_cpos(self, idv) -> bool
    Refresh the current position. This function refreshes the cpos field.
    
    @param idv: (C++: input_device_t) keyboard or mouse
    @return: false if failed

ida_hexrays.vdui_t.refresh_ctext (method)
    refresh_ctext(self, activate=True)
    Refresh pseudocode window. This function refreshes the pseudocode window by
    regenerating its text from cfunc_t. Instead of this function use
    refresh_func_ctext(), which refreshes all pseudocode windows for the function.
    @see: refresh_view(), refresh_func_ctext()
    
    @param activate: (C++: bool)

ida_hexrays.vdui_t.refresh_view (method)
    refresh_view(self, redo_mba)
    Refresh pseudocode window. This is the highest level refresh function. It causes
    the most profound refresh possible and can lead to redecompilation of the
    current function. Please consider using refresh_ctext() if you need a more
    superficial refresh.
    
    @param redo_mba: (C++: bool) true means to redecompile the current function
    false means to rebuild ctree without regenerating microcode
    @see: refresh_ctext()

ida_hexrays.vdui_t.rename_global (method)
    rename_global(self, ea) -> bool
    Rename global item. This function displays a dialog box and allows the user to
    rename a global item (data or function).
    
    @param ea: (C++: ea_t) address of the global item
    @return: false if failed or cancelled

ida_hexrays.vdui_t.rename_label (method)
    rename_label(self, label) -> bool
    Rename a label. This function displays a dialog box and allows the user to
    rename a statement label.
    
    @param label: (C++: int) label number
    @return: false if failed or cancelled

ida_hexrays.vdui_t.rename_lvar (method)
    rename_lvar(self, v, name, is_user_name) -> bool
    Rename local variable. This function permanently renames a local variable.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @param name: (C++: const char *) new variable name
    @param is_user_name: (C++: bool) use true to save the new name into the database. use false
                         to delete the saved name.
    @see: ::rename_lvar()
    @return: false if failed

ida_hexrays.vdui_t.rename_strmem (method)
    rename_strmem(self, sptr, mptr) -> bool
    Rename structure field. This function displays a dialog box and allows the user
    to rename a structure field.
    
    @param sptr: (C++: struc_t *) pointer to structure
    @param mptr: (C++: member_t *) pointer to structure member OBSOLETE FUNCTION, do not use!
    @return: false if failed or cancelled

ida_hexrays.vdui_t.rename_udm (method)
    rename_udm(self, udt_type, udm_idx) -> bool
    Rename structure field. This function displays a dialog box and allows the user
    to rename a structure field.
    
    @param udt_type: (C++: tinfo_t &) structure/union type
    @param udm_idx: (C++: int) index of the structure/union member
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_global_type (method)
    set_global_type(self, ea) -> bool
    Set global item type. This function displays a dialog box and allows the user to
    change the type of a global item (data or function).
    
    @param ea: (C++: ea_t) address of the global item
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_locked (method)
    set_locked(self, v) -> bool
    
    @param v: bool

ida_hexrays.vdui_t.set_lvar_cmt (method)
    set_lvar_cmt(self, v, cmt) -> bool
    Set local variable comment. This function permanently sets a variable comment.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @param cmt: (C++: const char *) new comment
    @return: false if failed

ida_hexrays.vdui_t.set_lvar_type (method)
    set_lvar_type(self, v, type) -> bool
    Set local variable type. This function permanently sets a local variable type
    and clears NOPTR flag if it was set before by function 'set_noptr_lvar'
    
    @param v: (C++: lvar_t *) pointer to local variable
    @param type: (C++: const tinfo_t &) new variable type
    @return: false if failed

ida_hexrays.vdui_t.set_noptr_lvar (method)
    set_noptr_lvar(self, v) -> bool
    Inform that local variable should have a non-pointer type This function
    permanently sets a corresponding variable flag (NOPTR) and removes type if it
    was set before by function 'set_lvar_type'
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed

ida_hexrays.vdui_t.set_num_enum (method)
    set_num_enum(self) -> bool
    Convert number to symbolic constant. This function displays a dialog box and
    allows the user to select a symbolic constant to represent the number.
    
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_num_radix (method)
    set_num_radix(self, base) -> bool
    Change number base. This function changes the current number representation.
    
    @param base: (C++: int) number radix (10 or 16)
    0 means a character constant
    @return: false if failed

ida_hexrays.vdui_t.set_num_stroff (method)
    set_num_stroff(self) -> bool
    Convert number to structure field offset. Currently not implemented.
    
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_strmem_type (method)
    set_strmem_type(self, sptr, mptr) -> bool
    Set structure field type. This function displays a dialog box and allows the
    user to change the type of a structure field.
    
    @param sptr: (C++: struc_t *) pointer to structure
    @param mptr: (C++: member_t *) pointer to structure member OBSOLETE FUNCTION, do not use!
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_udm_type (method)
    set_udm_type(self, udt_type, udm_idx) -> bool
    Set structure field type. This function displays a dialog box and allows the
    user to change the type of a structure field.
    
    @param udt_type: (C++: tinfo_t &) structure/union type
    @param udm_idx: (C++: int) index of the structure/union member
    @return: false if failed or cancelled

ida_hexrays.vdui_t.set_valid (method)
    set_valid(self, v)
    
    @param v: bool

ida_hexrays.vdui_t.set_visible (method)
    set_visible(self, v)
    
    @param v: bool

ida_hexrays.vdui_t.split_item (method)
    split_item(self, split) -> bool
    Split/unsplit item. This function splits the current assignment expression.
    
    @param split: (C++: bool)
    @return: false if failed.

ida_hexrays.vdui_t.switch_to (method)
    switch_to(self, f, activate)
    Display the specified pseudocode. This function replaces the pseudocode window
    contents with the specified cfunc_t.
    
    @param f: (C++: cfuncptr_t) pointer to the function to display.
    @param activate: (C++: bool) should the pseudocode window get focus?

ida_hexrays.vdui_t.tail (variable)
    Tail ctree item on the current line (for indented comments)

ida_hexrays.vdui_t.ui_edit_lvar_cmt (method)
    ui_edit_lvar_cmt(self, v) -> bool
    Set local variable comment. This function displays a dialog box and allows the
    user to edit the comment of a local variable.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed or cancelled

ida_hexrays.vdui_t.ui_map_lvar (method)
    ui_map_lvar(self, v) -> bool
    Map a local variable to another. This function displays a variable list and
    allows the user to select mapping.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed or cancelled

ida_hexrays.vdui_t.ui_rename_lvar (method)
    ui_rename_lvar(self, v) -> bool
    Rename local variable. This function displays a dialog box and allows the user
    to rename a local variable.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed or cancelled

ida_hexrays.vdui_t.ui_set_call_type (method)
    ui_set_call_type(self, e) -> bool
    Set type of a function call This function displays a dialog box and allows the
    user to change the type of a function call
    
    @param e: (C++: const cexpr_t *) pointer to call expression
    @return: false if failed or cancelled

ida_hexrays.vdui_t.ui_set_lvar_type (method)
    ui_set_lvar_type(self, v) -> bool
    Set local variable type. This function displays a dialog box and allows the user
    to change the type of a local variable.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed or cancelled

ida_hexrays.vdui_t.ui_unmap_lvar (method)
    ui_unmap_lvar(self, v) -> bool
    Unmap a local variable. This function displays list of variables mapped to the
    specified variable and allows the user to select a variable to unmap.
    
    @param v: (C++: lvar_t *) pointer to local variable
    @return: false if failed or cancelled

ida_hexrays.vdui_t.valid (method)
    valid(self) -> bool
    Does the pseudocode window contain valid code? It can become invalid if the
    function type gets changed in IDA.

ida_hexrays.vdui_t.view_idx (variable)
    pseudocode window index (0..)

ida_hexrays.vdui_t.visible (method)
    visible(self) -> bool
    Is the pseudocode window visible? if not, it might be invisible or destroyed

ida_hexrays.vivl_t (class)
    Proxy of C++ vivl_t class.

ida_hexrays.vivl_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: vivl_t const &
    
    __eq__(self, mop) -> bool
    
    @param mop: mop_t const &

ida_hexrays.vivl_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: vivl_t const &

ida_hexrays.vivl_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: vivl_t const &

ida_hexrays.vivl_t.__init__ (method)
    __init__(self, _type=mop_z, _off=-1, _size=0) -> vivl_t
    
    @param _type: mopt_t
    @param _off: sval_t
    @param _size: int
    
    __init__(self, ch) -> vivl_t
    
    @param ch: chain_t const &
    
    __init__(self, op) -> vivl_t
    
    @param op: mop_t const &

ida_hexrays.vivl_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: vivl_t const &

ida_hexrays.vivl_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: vivl_t const &

ida_hexrays.vivl_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: vivl_t const &

ida_hexrays.vivl_t._print (method)
    _print(self)

ida_hexrays.vivl_t.compare (method)
    compare(self, r) -> int
    
    @param r: vivl_t const &

ida_hexrays.vivl_t.contains (method)
    contains(self, voff2) -> bool
    Does our value interval contain the specified value offset?
    
    @param voff2: (C++: const voff_t &) voff_t const &

ida_hexrays.vivl_t.dstr (method)
    dstr(self) -> char const *

ida_hexrays.vivl_t.extend_to_cover (method)
    extend_to_cover(self, r) -> bool
    Extend a value interval using another value interval of the same type
    
    @param r: (C++: const vivl_t &) vivl_t const &
    @return: success

ida_hexrays.vivl_t.includes (method)
    includes(self, r) -> bool
    Does our value interval include another?
    
    @param r: (C++: const vivl_t &) vivl_t const &

ida_hexrays.vivl_t.intersect (method)
    intersect(self, r) -> uval_t
    Intersect value intervals the same type
    
    @param r: (C++: const vivl_t &) vivl_t const &
    @return: size of the resulting intersection

ida_hexrays.vivl_t.overlap (method)
    overlap(self, r) -> bool
    Do two value intervals overlap?
    
    @param r: (C++: const vivl_t &) vivl_t const &

ida_hexrays.vivl_t.set (method)
    set(self, _type, _off, _size=0)
    
    @param _type: mopt_t
    @param _off: sval_t
    @param _size: int
    
    set(self, voff, _size)
    
    @param voff: voff_t const &
    @param _size: int

ida_hexrays.vivl_t.set_reg (method)
    set_reg(self, mreg, sz=0)
    
    @param mreg: mreg_t
    @param sz: int

ida_hexrays.vivl_t.set_stkoff (method)
    set_stkoff(self, stkoff, sz=0)
    
    @param stkoff: sval_t
    @param sz: int

ida_hexrays.vivl_t.size (variable)
    Interval size in bytes.

ida_hexrays.voff_t (class)
    Proxy of C++ voff_t class.

ida_hexrays.voff_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.__init__ (method)
    __init__(self) -> voff_t
    __init__(self, _type, _off) -> voff_t
    
    @param _type: mopt_t
    @param _off: sval_t
    
    __init__(self, op) -> voff_t
    
    @param op: mop_t const &

ida_hexrays.voff_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: voff_t const &

ida_hexrays.voff_t.add (method)
    add(self, width) -> voff_t
    
    @param width: int

ida_hexrays.voff_t.compare (method)
    compare(self, r) -> int
    
    @param r: voff_t const &

ida_hexrays.voff_t.defined (method)
    defined(self) -> bool

ida_hexrays.voff_t.diff (method)
    diff(self, r) -> sval_t
    
    @param r: voff_t const &

ida_hexrays.voff_t.get_reg (method)
    get_reg(self) -> mreg_t

ida_hexrays.voff_t.get_stkoff (method)
    get_stkoff(self) -> sval_t

ida_hexrays.voff_t.inc (method)
    inc(self, delta)
    
    @param delta: sval_t

ida_hexrays.voff_t.is_reg (method)
    is_reg(self) -> bool

ida_hexrays.voff_t.is_stkoff (method)
    is_stkoff(self) -> bool

ida_hexrays.voff_t.off (variable)
    register number or stack offset

ida_hexrays.voff_t.set (method)
    set(self, _type, _off)
    
    @param _type: mopt_t
    @param _off: sval_t

ida_hexrays.voff_t.set_reg (method)
    set_reg(self, mreg)
    
    @param mreg: mreg_t

ida_hexrays.voff_t.set_stkoff (method)
    set_stkoff(self, stkoff)
    
    @param stkoff: sval_t

ida_hexrays.voff_t.type (variable)
    mop_r - register, mop_S - stack, mop_z - undefined

ida_hexrays.voff_t.undef (method)
    undef(self)

ida_allins (module)
    

ida_auto (module)
    Functions that work with the autoanalyzer queue.
    
    The autoanalyzer works when IDA is not busy processing the user keystrokes. It
    has several queues, each queue having its own priority. The analyzer stops when
    all queues are empty.
    
    A queue contains addresses or address ranges. The addresses are kept sorted by
    their values. The analyzer will process all addresses from the first queue, then
    switch to the second queue and so on. There are no limitations on the size of
    the queues.
    
    This file also contains functions that deal with the IDA status indicator and
    the autoanalysis indicator. You may use these functions to change the indicator
    value.

ida_auto.AU_CHLB (variable)
    12: load signature file (file name is kept separately)

ida_auto.AU_CODE (variable)
    1: convert to instruction

ida_auto.AU_FCHUNK (variable)
    5: find func chunks

ida_auto.AU_FINAL (variable)
    13: final pass

ida_auto.AU_LBF2 (variable)
    10: the same, second pass

ida_auto.AU_LBF3 (variable)
    11: the same, third pass

ida_auto.AU_LIBF (variable)
    9: apply signature to address

ida_auto.AU_NONE (variable)
    placeholder, not used

ida_auto.AU_PROC (variable)
    3: convert to procedure start

ida_auto.AU_TAIL (variable)
    4: add a procedure tail

ida_auto.AU_TYPE (variable)
    8: apply type information

ida_auto.AU_UNK (variable)
    0: convert to unexplored

ida_auto.AU_USD2 (variable)
    7: reanalyze, second pass

ida_auto.AU_USED (variable)
    6: reanalyze

ida_auto.AU_WEAK (variable)
    2: convert to instruction (ida decision)

ida_auto.auto_apply_tail (function)
    auto_apply_tail(tail_ea, parent_ea)
    Plan to apply the tail_ea chunk to the parent
    
    @param tail_ea: (C++: ea_t) linear address of start of tail
    @param parent_ea: (C++: ea_t) linear address within parent. If BADADDR, automatically try to
                      find parent via xrefs.

ida_auto.auto_apply_type (function)
    auto_apply_type(caller, callee)
    Plan to apply the callee's type to the calling point.
    
    @param caller: (C++: ea_t)
    @param callee: (C++: ea_t)

ida_auto.auto_cancel (function)
    auto_cancel(ea1, ea2)
    Remove an address range (ea1..ea2) from queues AU_CODE, AU_PROC, AU_USED. To
    remove an address range from other queues use auto_unmark() function. 'ea1' may
    be higher than 'ea2', the kernel will swap them in this case. 'ea2' doesn't
    belong to the range.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

ida_auto.auto_display_t (class)
    Proxy of C++ auto_display_t class.

ida_auto.auto_display_t.__init__ (method)
    __init__(self) -> auto_display_t

ida_auto.auto_get (function)
    auto_get(type, lowEA, highEA) -> ea_t
    Retrieve an address from queues regarding their priority. Returns BADADDR if no
    addresses not lower than 'lowEA' and less than 'highEA' are found in the queues.
    Otherwise *type will have queue type.
    
    @param type: (C++: atype_t *)
    @param lowEA: (C++: ea_t)
    @param highEA: (C++: ea_t)

ida_auto.auto_is_ok (function)
    auto_is_ok() -> bool
    Are all queues empty? (i.e. has autoanalysis finished?).

ida_auto.auto_make_code (function)
    auto_make_code(ea)
    Plan to make code.
    
    @param ea: (C++: ea_t)

ida_auto.auto_make_proc (function)
    auto_make_proc(ea)
    Plan to make code&function.
    
    @param ea: (C++: ea_t)

ida_auto.auto_make_step (function)
    auto_make_step(ea1, ea2) -> bool
    Analyze one address in the specified range and return true.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @return: if processed anything. false means that there is nothing to process in
             the specified range.

ida_auto.auto_mark (function)
    auto_mark(ea, type)
    Put single address into a queue. Queues keep addresses sorted.
    
    @param ea: (C++: ea_t)
    @param type: (C++: atype_t)

ida_auto.auto_mark_range (function)
    auto_mark_range(start, end, type)
    Put range of addresses into a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

ida_auto.auto_postpone_analysis (function)
    auto_postpone_analysis(ea) -> bool
    Plan to reanalyze on the second pass The typical usage of this function in
    emu.cpp is: if ( !auto_postpone_analysis(ea) ) op_offset(ea, 0, ...); (we make
    an offset only on the second pass)
    
    @param ea: (C++: ea_t)

ida_auto.auto_recreate_insn (function)
    auto_recreate_insn(ea) -> int
    Try to create instruction
    
    @param ea: (C++: ea_t) linear address of callee
    @return: the length of the instruction or 0

ida_auto.auto_unmark (function)
    auto_unmark(start, end, type)
    Remove range of addresses from a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

ida_auto.auto_wait (function)
    auto_wait() -> bool
    Process everything in the queues and return true.
    
    @return: false if the user clicked cancel. (the wait box must be displayed by
             the caller if desired)

ida_auto.auto_wait_range (function)
    auto_wait_range(ea1, ea2) -> ssize_t
    Process everything in the specified range and return true.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @return: number of autoanalysis steps made. -1 if the user clicked cancel. (the
             wait box must be displayed by the caller if desired)

ida_auto.enable_auto (function)
    enable_auto(enable) -> bool
    Temporarily enable/disable autoanalyzer. Not user-facing, but rather because IDA
    sometimes need to turn AA on/off regardless of inf.s_genflags:INFFL_AUTO
    
    @param enable: (C++: bool)
    @return: old state

ida_auto.get_auto_display (function)
    get_auto_display(auto_display) -> bool
    Get structure which holds the autoanalysis indicator contents.
    
    @param auto_display: (C++: auto_display_t *)

ida_auto.get_auto_state (function)
    get_auto_state() -> atype_t
    Get current state of autoanalyzer. If auto_state == AU_NONE, IDA is currently
    not running the analysis (it could be temporarily interrupted to perform the
    user's requests, for example).

ida_auto.is_auto_enabled (function)
    is_auto_enabled() -> bool
    Get autoanalyzer state.

ida_auto.may_create_stkvars (function)
    may_create_stkvars() -> bool
    Is it allowed to create stack variables automatically?. This function should be
    used by IDP modules before creating stack vars.

ida_auto.may_trace_sp (function)
    may_trace_sp() -> bool
    Is it allowed to trace stack pointer automatically?. This function should be
    used by IDP modules before tracing sp.

ida_auto.peek_auto_queue (function)
    peek_auto_queue(low_ea, type) -> ea_t
    Peek into a queue 'type' for an address not lower than 'low_ea'. Do not remove
    address from the queue.
    
    @param low_ea: (C++: ea_t)
    @param type: (C++: atype_t)
    @return: the address or BADADDR

ida_auto.plan_and_wait (function)
    plan_and_wait(ea1, ea2, final_pass=True) -> int
    Analyze the specified range. Try to create instructions where possible. Make the
    final pass over the specified range if specified. This function doesn't return
    until the range is analyzed.
    @retval 1: ok
    @retval 0: Ctrl-Break was pressed
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @param final_pass: (C++: bool)

ida_auto.plan_ea (function)
    plan_ea(ea)
    Plan to perform reanalysis.
    
    @param ea: (C++: ea_t)

ida_auto.plan_range (function)
    plan_range(sEA, eEA)
    Plan to perform reanalysis.
    
    @param sEA: (C++: ea_t)
    @param eEA: (C++: ea_t)

ida_auto.reanalyze_callers (function)
    reanalyze_callers(ea, noret)
    Plan to reanalyze callers of the specified address. This function will add to
    AU_USED queue all instructions that call (not jump to) the specified address.
    
    @param ea: (C++: ea_t) linear address of callee
    @param noret: (C++: bool) !=0: the callee doesn't return, mark to undefine subsequent
                  instructions in the caller. 0: do nothing.

ida_auto.revert_ida_decisions (function)
    revert_ida_decisions(ea1, ea2)
    Delete all analysis info that IDA generated for for the given range.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

ida_auto.set_auto_state (function)
    set_auto_state(new_state) -> atype_t
    Set current state of autoanalyzer.
    
    @param new_state: (C++: atype_t) new state of autoanalyzer
    @return: previous state

ida_auto.set_ida_state (function)
    set_ida_state(st) -> idastate_t
    Change IDA status indicator value
    
    @param st: (C++: idastate_t) - new indicator status
    @return: old indicator status

ida_auto.show_addr (function)
    show_addr(ea)
    Show an address on the autoanalysis indicator. The address is displayed in the
    form " @:12345678".
    
    @param ea: (C++: ea_t) - linear address to display

ida_auto.show_auto (function)
    show_auto(ea, type=AU_NONE)
    Change autoanalysis indicator value.
    
    @param ea: (C++: ea_t) linear address being analyzed
    @param type: (C++: atype_t) autoanalysis type (see Autoanalysis queues)

ida_bitrange (module)
    Definition of the bitrange_t class.

ida_bitrange.bitrange_t (class)
    Proxy of C++ bitrange_t class.

ida_bitrange.bitrange_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__init__ (method)
    __init__(self, bit_ofs=0, size_in_bits=0) -> bitrange_t
    
    @param bit_ofs: uint16
    @param size_in_bits: uint16

ida_bitrange.bitrange_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.__str__ (method)
    __str__(self) -> qstring

ida_bitrange.bitrange_t.apply_mask (method)
    apply_mask(self, subrange) -> bool
    Apply mask to a bitrange
    
    @param subrange: (C++: const bitrange_t &) range *inside* the main bitrange to keep After this operation
                     the main bitrange will be truncated to have only the bits that
                     are specified by subrange. Example: [off=8,nbits=4],
                     subrange[off=1,nbits=2] => [off=9,nbits=2]
    @return: success

ida_bitrange.bitrange_t.bitoff (method)
    bitoff(self) -> uint
    Get offset of 1st bit.

ida_bitrange.bitrange_t.bitsize (method)
    bitsize(self) -> uint
    Get size of the value in bits.

ida_bitrange.bitrange_t.bytesize (method)
    bytesize(self) -> uint
    Size of the value in bytes.

ida_bitrange.bitrange_t.compare (method)
    compare(self, r) -> int
    
    @param r: bitrange_t const &

ida_bitrange.bitrange_t.create_union (method)
    create_union(self, r)
    Create union of 2 ranges including the hole between them.
    
    @param r: (C++: const bitrange_t &) bitrange_t const &

ida_bitrange.bitrange_t.empty (method)
    empty(self) -> bool
    Is the bitrange empty?

ida_bitrange.bitrange_t.extract (method)
    extract(self, src, is_mf) -> bool
    
    @param src: void const *
    @param is_mf: bool

ida_bitrange.bitrange_t.has_common (method)
    has_common(self, r) -> bool
    Does have common bits with another bitrange?
    
    @param r: (C++: const bitrange_t &) bitrange_t const &

ida_bitrange.bitrange_t.init (method)
    init(self, bit_ofs, size_in_bits)
    Initialize offset and size to given values.
    
    @param bit_ofs: (C++: uint16)
    @param size_in_bits: (C++: uint16)

ida_bitrange.bitrange_t.inject (method)
    inject(self, dst, src, is_mf) -> bool
    
    @param dst: void *
    @param src: bytevec_t const &
    @param is_mf: bool

ida_bitrange.bitrange_t.intersect (method)
    intersect(self, r)
    Intersect two ranges.
    
    @param r: (C++: const bitrange_t &) bitrange_t const &

ida_bitrange.bitrange_t.mask64 (method)
    mask64(self) -> uint64
    Convert to mask of 64 bits.

ida_bitrange.bitrange_t.reset (method)
    reset(self)
    Make the bitrange empty.

ida_bitrange.bitrange_t.shift_down (method)
    shift_down(self, cnt)
    Shift range down (left)
    
    @param cnt: (C++: uint)

ida_bitrange.bitrange_t.shift_up (method)
    shift_up(self, cnt)
    Shift range up (right)
    
    @param cnt: (C++: uint)

ida_bitrange.bitrange_t.sub (method)
    sub(self, r) -> bool
    Subtract a bitrange.
    
    @param r: (C++: const bitrange_t &) bitrange_t const &

ida_bytes (module)
    Contains functions that deal with individual byte characteristics.
    
    Each byte of the disassembled program is represented by a 32-bit value. We will
    call this value 'flags'. The structure of the flags is here.
    
    You are not allowed to inspect individual bits of flags and modify them
    directly. Use special functions to inspect and/or modify flags.
    
    Flags are kept in a virtual array file (*.id1). Addresses (ea) are all 32-bit
    (or 64-bit) quantities.

ida_bytes.ALOPT_APPEND (variable)
    if an existing strlit is encountered, then append it to the string.

ida_bytes.ALOPT_IGNCLT (variable)
    if set, don't stop at codepoints that are not part of the current 'culture';
    accept all those that are graphical (this is typically used used by user-
    initiated actions creating string literals.)

ida_bytes.ALOPT_IGNHEADS (variable)
    don't stop if another data item is encountered. only the byte values will be
    used to determine the string length. if not set, a defined data item or
    instruction will truncate the string

ida_bytes.ALOPT_IGNPRINT (variable)
    if set, don't stop at non-printable codepoints, but only at the terminating
    character (or not unicode-mapped character (e.g., 0x8f in CP1252))

ida_bytes.ALOPT_MAX4K (variable)
    if string length is more than 4K, return the accumulated length

ida_bytes.ALOPT_ONLYTERM (variable)
    only the termination characters can be at the string end. Without this option
    illegal characters also terminate the string.

ida_bytes.BIN_SEARCH_BACKWARD (variable)
    search backward for bytes

ida_bytes.BIN_SEARCH_BITMASK (variable)
    searching using strict bit mask

ida_bytes.BIN_SEARCH_CASE (variable)
    case sensitive

ida_bytes.BIN_SEARCH_FORWARD (variable)
    search forward for bytes

ida_bytes.BIN_SEARCH_INITED (variable)
    find_byte, find_byter: any initilized value

ida_bytes.BIN_SEARCH_NOBREAK (variable)
    don't check for Ctrl-Break

ida_bytes.BIN_SEARCH_NOCASE (variable)
    case insensitive

ida_bytes.BIN_SEARCH_NOSHOW (variable)
    don't show search progress or update screen

ida_bytes.DELIT_DELNAMES (variable)
    delete any names at the specified address range (except for the starting
    address). this bit is valid if nbytes > 1

ida_bytes.DELIT_EXPAND (variable)
    propagate undefined items; for example if removing an instruction removes all
    references to the next instruction, then plan to convert to unexplored the next
    instruction too.

ida_bytes.DELIT_KEEPFUNC (variable)
    do not undefine the function start. Just delete xrefs, ops e.t.c.

ida_bytes.DELIT_NOCMT (variable)
    reject to delete if a comment is in address range (except for the starting
    address). this bit is valid if nbytes > 1

ida_bytes.DELIT_NOTRUNC (variable)
    don't truncate the current function even if AF_TRFUNC is set

ida_bytes.DELIT_NOUNAME (variable)
    reject to delete if a user name is in address range (except for the starting
    address). this bit is valid if nbytes > 1

ida_bytes.DELIT_SIMPLE (variable)
    simply undefine the specified item(s)

ida_bytes.DTP_NODUP (variable)
    do not use dup construct

ida_bytes.DT_TYPE (variable)
    Mask for DATA typing.

ida_bytes.FF_ALIGN (variable)
    alignment directive

ida_bytes.FF_BNOT (variable)
    Bitwise negation of operands.

ida_bytes.FF_BYTE (variable)
    byte

ida_bytes.FF_CODE (variable)
    Code ?

ida_bytes.FF_COMM (variable)
    Has comment ?

ida_bytes.FF_CUSTOM (variable)
    custom data type

ida_bytes.FF_DATA (variable)
    Data ?

ida_bytes.FF_DOUBLE (variable)
    double

ida_bytes.FF_DWORD (variable)
    double word

ida_bytes.FF_FLOAT (variable)
    float

ida_bytes.FF_FLOW (variable)
    Exec flow from prev instruction.

ida_bytes.FF_FUNC (variable)
    function start?

ida_bytes.FF_IMMD (variable)
    Has Immediate value ?

ida_bytes.FF_IVL (variable)
    Byte has value ?

ida_bytes.FF_JUMP (variable)
    Has jump table or switch_info?

ida_bytes.FF_LABL (variable)
    Has dummy name?

ida_bytes.FF_LINE (variable)
    Has next or prev lines ?

ida_bytes.FF_NAME (variable)
    Has name ?

ida_bytes.FF_N_CHAR (variable)
    Char ('x')?

ida_bytes.FF_N_CUST (variable)
    Custom representation?

ida_bytes.FF_N_ENUM (variable)
    Enumeration?

ida_bytes.FF_N_FLT (variable)
    Floating point number?

ida_bytes.FF_N_FOP (variable)
    Forced operand?

ida_bytes.FF_N_NUMB (variable)
    Binary number?

ida_bytes.FF_N_NUMD (variable)
    Decimal number?

ida_bytes.FF_N_NUMH (variable)
    Hexadecimal number?

ida_bytes.FF_N_NUMO (variable)
    Octal number?

ida_bytes.FF_N_OFF (variable)
    Offset?

ida_bytes.FF_N_SEG (variable)
    Segment?

ida_bytes.FF_N_STK (variable)
    Stack variable?

ida_bytes.FF_N_STRO (variable)
    Struct offset?

ida_bytes.FF_N_VOID (variable)
    Void (unknown)?

ida_bytes.FF_OWORD (variable)
    octaword/xmm word (16 bytes/128 bits)

ida_bytes.FF_PACKREAL (variable)
    packed decimal real

ida_bytes.FF_QWORD (variable)
    quadro word

ida_bytes.FF_REF (variable)
    has references

ida_bytes.FF_SIGN (variable)
    Inverted sign of operands.

ida_bytes.FF_STRLIT (variable)
    string literal

ida_bytes.FF_STRUCT (variable)
    struct variable

ida_bytes.FF_TAIL (variable)
    Tail ?

ida_bytes.FF_TBYTE (variable)
    tbyte

ida_bytes.FF_UNK (variable)
    Unknown ?

ida_bytes.FF_UNUSED (variable)
    unused bit (was used for variable bytes)

ida_bytes.FF_WORD (variable)
    word

ida_bytes.FF_YWORD (variable)
    ymm word (32 bytes/256 bits)

ida_bytes.FF_ZWORD (variable)
    zmm word (64 bytes/512 bits)

ida_bytes.GFE_IDB_VALUE (variable)
    get flags with FF_IVL & MS_VAL. but never use the debugger memory.

ida_bytes.GFE_VALUE (variable)
    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because
    the kernel needs to read the process memory.

ida_bytes.GMB_READALL (variable)
    try to read all bytes; if this bit is not set, fail at first uninited byte

ida_bytes.GMB_WAITBOX (variable)
    show wait box (may return -1 in this case)

ida_bytes.ITEM_END_CANCEL (variable)
    stop when operation cancelled, it is the responsibility of the caller to show
    the wait dialog

ida_bytes.ITEM_END_FIXUP (variable)
    stop at the first fixup

ida_bytes.ITEM_END_INITED (variable)
    stop when initialization changes i.e.
    * if is_loaded(ea): stop if uninitialized byte is encountered
    * if !is_loaded(ea): stop if initialized byte is encountered

ida_bytes.ITEM_END_NAME (variable)
    stop at the first named location

ida_bytes.ITEM_END_XREF (variable)
    stop at the first referenced location

ida_bytes.MS_CLS (variable)
    Mask for typing.

ida_bytes.MS_CODE (variable)
    Mask for code bits.

ida_bytes.MS_COMM (variable)
    Mask of common bits.

ida_bytes.MS_N_TYPE (variable)
    Mask for nth arg (a 64-bit constant)

ida_bytes.MS_VAL (variable)
    Mask for byte value.

ida_bytes.OPND_ALL (variable)
    all operands

ida_bytes.OPND_MASK (variable)
    mask for operand number

ida_bytes.OPND_OUTER (variable)
    outer offset base (combined with operand number). used only in set, get,
    del_offset() functions

ida_bytes.PSTF_ATTRIB (variable)
    generate for type attribute usage

ida_bytes.PSTF_ENC (variable)
    if encoding is specified, append it

ida_bytes.PSTF_HOTKEY (variable)
    have hotkey markers part of the name

ida_bytes.PSTF_ONLY_ENC (variable)
    generate only the encoding name

ida_bytes.PSTF_TBRIEF (variable)
    use brief name (e.g., in the 'Strings' window)

ida_bytes.PSTF_TINLIN (variable)
    use 'inline' name (e.g., in the structures comments)

ida_bytes.PSTF_TMASK (variable)
    type mask

ida_bytes.PSTF_TNORM (variable)
    use normal name

ida_bytes.STRCONV_ESCAPE (variable)
    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

ida_bytes.STRCONV_INCLLEN (variable)
    for Pascal-style strings, include the prefixing length byte(s) as C-escaped
    sequence

ida_bytes.STRCONV_REPLCHAR (variable)
    convert non-printable characters to the Unicode replacement character (U+FFFD)

ida_bytes.__walk_types_and_formats (function)

ida_bytes.add_byte (function)
    add_byte(ea, value)
    Add a value to one byte of the program. This function works for wide byte
    processors too.
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint32) byte value

ida_bytes.add_dword (function)
    add_dword(ea, value)
    Add a value to one dword of the program. This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    @note: this function works incorrectly if processor_t::nbits > 16
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

ida_bytes.add_hidden_range (function)
    add_hidden_range(ea1, ea2, description, header, footer, color=bgcolor_t(-1)) -> bool
    Mark a range of addresses as hidden. The range will be created in the invisible
    state with the default color
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range
    @param description: (C++: const char *) ,header,footer: range parameters
    @param header: (C++: const char *) char const *
    @param footer: (C++: const char *) char const *
    @param color: (C++: bgcolor_t) the range color
    @return: success

ida_bytes.add_mapping (function)
    add_mapping(_from, to, size) -> bool
    IDA supports memory mapping. References to the addresses from the mapped range
    use data and meta-data from the mapping range.
    @note: You should set flag PR2_MAPPING in ph.flag2 to use memory mapping Add
           memory mapping range.
    
    @param from: (C++: ea_t) start of the mapped range (nonexistent address)
    @param to: (C++: ea_t) start of the mapping range (existent address)
    @param size: (C++: asize_t) size of the range
    @return: success

ida_bytes.add_qword (function)
    add_qword(ea, value)
    Add a value to one qword of the program. This function does not work for wide
    byte processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

ida_bytes.add_word (function)
    add_word(ea, value)
    Add a value to one word of the program. This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

ida_bytes.align_flag (function)
    align_flag() -> flags64_t
    Get a flags64_t representing an alignment directive.

ida_bytes.append_cmt (function)
    append_cmt(ea, str, rptble) -> bool
    Append to an indented comment. Creates a new comment if none exists. Appends a
    newline character and the specified string otherwise.
    
    @param ea: (C++: ea_t) linear address
    @param str: (C++: const char *) comment string to append
    @param rptble: (C++: bool) append to repeatable comment?
    @return: success

ida_bytes.attach_custom_data_format (function)
    attach_custom_data_format(dtid, dfid) -> bool
    Attach the data format to the data type.
    
    @param dtid: (C++: int) data type id that can use the data format. 0 means all standard
                 data types. Such data formats can be applied to any data item or
                 instruction operands. For instruction operands, the
                 data_format_t::value_size check is not performed by the kernel.
    @param dfid: (C++: int) data format id
    @retval true: ok
    @retval false: no such `dtid', or no such `dfid', or the data format has already
                   been attached to the data type

ida_bytes.bin_flag (function)
    bin_flag() -> flags64_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

ida_bytes.bin_search (function)
    bin_search(start_ea, end_ea, data, flags) -> ea_t
    Search for a set of bytes in the program
    
    @param start_ea: linear address, start of range to search
    @param end_ea: linear address, end of range to search (exclusive)
    @param data: the prepared data to search for (see parse_binpat_str())
    @param flags: combination of BIN_SEARCH_* flags
    @return: the address of a match, or ida_idaapi.BADADDR if not found
    bin_search(start_ea, end_ea, image, imask, step, flags) -> ea_t
    
    @param start_ea: ea_t
    @param end_ea: ea_t
    @param image: bytevec_t const &
    @param imask: bytevec_t const &
    @param step: int
    @param flags: int

ida_bytes.bin_search3 (function)
    bin_search3(start_ea, end_ea, data, flags) -> ea_t
    Search for a patter in the program.
    
    @param start_ea: (C++: ea_t) linear address, start of range to search
    @param end_ea: (C++: ea_t) linear address, end of range to search (exclusive)
    @param data: (C++: const compiled_binpat_vec_t &) the prepared data to search for (see parse_binpat_str())
    @param flags: (C++: int) combination of Search flags
    @return: BADADDR (if pressed Ctrl-Break or not found) or pattern address.

ida_bytes.byte_flag (function)
    byte_flag() -> flags64_t
    Get a flags64_t representing a byte.

ida_bytes.bytesize (function)
    bytesize(ea) -> int
    Get number of bytes required to store a byte at the given address.
    
    @param ea: (C++: ea_t)

ida_bytes.calc_def_align (function)
    calc_def_align(ea, mina, maxa) -> int
    Calculate the default alignment exponent.
    
    @param ea: (C++: ea_t) linear address
    @param mina: (C++: int) minimal possible alignment exponent.
    @param maxa: (C++: int) minimal possible alignment exponent.

ida_bytes.calc_dflags (function)
    calc_dflags(f, force) -> flags64_t
    
    @param f: flags64_t
    @param force: bool

ida_bytes.calc_max_align (function)
    calc_max_align(endea) -> int
    Calculate the maximal possible alignment exponent.
    
    @param endea: (C++: ea_t) end address of the alignment item.
    @return: a value in the 0..32 range

ida_bytes.calc_max_item_end (function)
    calc_max_item_end(ea, how=15) -> ea_t
    Calculate maximal reasonable end address of a new item. This function will limit
    the item with the current segment bounds.
    
    @param ea: (C++: ea_t) linear address
    @param how: (C++: int) when to stop the search. A combination of Item end search flags
    @return: end of new item. If it is not possible to create an item, it will
             return 'ea'. If operation was cancelled by user, it will return 'ea'

ida_bytes.calc_min_align (function)
    calc_min_align(length) -> int
    Calculate the minimal possible alignment exponent.
    
    @param length: (C++: asize_t) size of the item in bytes.
    @return: a value in the 1..32 range

ida_bytes.can_define_item (function)
    can_define_item(ea, length, flags) -> bool
    Can define item (instruction/data) of the specified 'length', starting at 'ea'?
    @note: if there is an item starting at 'ea', this function ignores it
    @note: this function converts to unexplored all encountered data items with
           fixup information. Should be fixed in the future.
    
    @param ea: (C++: ea_t) start of the range for the new item
    @param length: (C++: asize_t) length of the new item in bytes
    @param flags: (C++: flags64_t) if not 0, then the kernel will ignore the data types specified by
                  the flags and destroy them. For example:
    1000 dw 5
                     1002 db 5 ; undef
                     1003 db 5 ; undef
                     1004 dw 5
                     1006 dd 5
                      can_define_item(1000, 6, 0) - false because of dw at 1004
    can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed
    @return: 1-yes, 0-no
    * a new item would cross segment boundaries
    * a new item would overlap with existing items (except items specified by
    'flags')

ida_bytes.change_storage_type (function)
    change_storage_type(start_ea, end_ea, stt) -> error_t
    Change flag storage type for address range.
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @param stt: (C++: storage_type_t)
    @return: error code

ida_bytes.char_flag (function)
    char_flag() -> flags64_t
    see FF_opbits

ida_bytes.chunk_size (function)
    chunk_size(ea) -> asize_t
    Get size of the contiguous address block containing 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 0 if 'ea' doesn't belong to the program.

ida_bytes.chunk_start (function)
    chunk_start(ea) -> ea_t
    Get start of the contiguous address block containing 'ea'.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if 'ea' doesn't belong to the program.

ida_bytes.clr_lzero (function)
    clr_lzero(ea, n) -> bool
    Clear toggle lzero bit. This function reset the display of leading zeroes for
    the specified operand to the default. If the default is not to display leading
    zeroes, leading zeroes will not be displayed, as vice versa.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

ida_bytes.clr_op_type (function)
    clr_op_type(ea, n) -> bool
    Remove operand representation information. (set operand representation to be
    'undefined')
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @return: success

ida_bytes.code_flag (function)
    code_flag() -> flags64_t
    FF_CODE

ida_bytes.combine_flags (function)
    combine_flags(F) -> flags64_t
    
    @param F: flags64_t

ida_bytes.compiled_binpat_t (class)
    Proxy of C++ compiled_binpat_t class.

ida_bytes.compiled_binpat_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: compiled_binpat_t const &

ida_bytes.compiled_binpat_t.__init__ (method)
    __init__(self) -> compiled_binpat_t

ida_bytes.compiled_binpat_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: compiled_binpat_t const &

ida_bytes.compiled_binpat_t.all_bytes_defined (method)
    all_bytes_defined(self) -> bool

ida_bytes.compiled_binpat_t.qclear (method)
    qclear(self)

ida_bytes.compiled_binpat_vec_t (class)
    Proxy of C++ qvector< compiled_binpat_t > class.

ida_bytes.compiled_binpat_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< compiled_binpat_t > const &

ida_bytes.compiled_binpat_vec_t.__getitem__ (method)
    __getitem__(self, i) -> compiled_binpat_t
    
    @param i: size_t

ida_bytes.compiled_binpat_vec_t.__init__ (method)
    __init__(self) -> compiled_binpat_vec_t
    __init__(self, x) -> compiled_binpat_vec_t
    
    @param x: qvector< compiled_binpat_t > const &

ida_bytes.compiled_binpat_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_bytes.compiled_binpat_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< compiled_binpat_t > const &

ida_bytes.compiled_binpat_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.at (method)
    at(self, _idx) -> compiled_binpat_t
    
    @param _idx: size_t

ida_bytes.compiled_binpat_vec_t.begin (method)
    begin(self) -> compiled_binpat_t

ida_bytes.compiled_binpat_vec_t.capacity (method)
    capacity(self) -> size_t

ida_bytes.compiled_binpat_vec_t.clear (method)
    clear(self)

ida_bytes.compiled_binpat_vec_t.empty (method)
    empty(self) -> bool

ida_bytes.compiled_binpat_vec_t.end (method)
    end(self) -> compiled_binpat_t

ida_bytes.compiled_binpat_vec_t.erase (method)
    erase(self, it) -> compiled_binpat_t
    
    @param it: qvector< compiled_binpat_t >::iterator
    
    erase(self, first, last) -> compiled_binpat_t
    
    @param first: qvector< compiled_binpat_t >::iterator
    @param last: qvector< compiled_binpat_t >::iterator

ida_bytes.compiled_binpat_vec_t.extract (method)
    extract(self) -> compiled_binpat_t

ida_bytes.compiled_binpat_vec_t.find (method)
    find(self, x) -> compiled_binpat_t
    
    @param x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.grow (method)
    grow(self, x=compiled_binpat_t())
    
    @param x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: compiled_binpat_t *
    @param len: size_t

ida_bytes.compiled_binpat_vec_t.insert (method)
    insert(self, it, x) -> compiled_binpat_t
    
    @param it: qvector< compiled_binpat_t >::iterator
    @param x: compiled_binpat_t const &

ida_bytes.compiled_binpat_vec_t.pop_back (method)
    pop_back(self)

ida_bytes.compiled_binpat_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: compiled_binpat_t const &
    
    push_back(self) -> compiled_binpat_t

ida_bytes.compiled_binpat_vec_t.qclear (method)
    qclear(self)

ida_bytes.compiled_binpat_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_bytes.compiled_binpat_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: compiled_binpat_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_bytes.compiled_binpat_vec_t.size (method)
    size(self) -> size_t

ida_bytes.compiled_binpat_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< compiled_binpat_t > &

ida_bytes.compiled_binpat_vec_t.truncate (method)
    truncate(self)

ida_bytes.create_16bit_data (function)
    create_16bit_data(ea, length) -> bool
    Convert to 16-bit quantity (take the byte size into account)
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)

ida_bytes.create_32bit_data (function)
    create_32bit_data(ea, length) -> bool
    Convert to 32-bit quantity (take the byte size into account)
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)

ida_bytes.create_align (function)
    create_align(ea, length, alignment) -> bool
    Create an alignment item.
    
    @param ea: (C++: ea_t) linear address
    @param length: (C++: asize_t) size of the item in bytes. 0 means to infer from ALIGNMENT
    @param alignment: (C++: int) alignment exponent. Example: 3 means align to 8 bytes. 0 means
                      to infer from LENGTH It is forbidden to specify both LENGTH
                      and ALIGNMENT as 0.
    @return: success

ida_bytes.create_byte (function)
    create_byte(ea, length, force=False) -> bool
    Convert to byte.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_custdata (function)
    create_custdata(ea, length, dtid, fid, force=False) -> bool
    Convert to custom data type.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param dtid: (C++: int)
    @param fid: (C++: int)
    @param force: (C++: bool)

ida_bytes.create_data (function)
    create_data(ea, dataflag, size, tid) -> bool
    Convert to data (byte, word, dword, etc). This function may be used to create
    arrays.
    
    @param ea: (C++: ea_t) linear address
    @param dataflag: (C++: flags64_t) type of data. Value of function byte_flag(), word_flag(), etc.
    @param size: (C++: asize_t) size of array in bytes. should be divisible by the size of one item
                 of the specified type. for variable sized items it can be specified
                 as 0, and the kernel will try to calculate the size.
    @param tid: (C++: tid_t) type id. If the specified type is a structure, then tid is structure
                id. Otherwise should be BADNODE.
    @return: success

ida_bytes.create_double (function)
    create_double(ea, length, force=False) -> bool
    Convert to double.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_dword (function)
    create_dword(ea, length, force=False) -> bool
    Convert to dword.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_float (function)
    create_float(ea, length, force=False) -> bool
    Convert to float.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_oword (function)
    create_oword(ea, length, force=False) -> bool
    Convert to octaword/xmm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_packed_real (function)
    create_packed_real(ea, length, force=False) -> bool
    Convert to packed decimal real.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_qword (function)
    create_qword(ea, length, force=False) -> bool
    Convert to quadword.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_strlit (function)
    create_strlit(start, len, strtype) -> bool
    Convert to string literal and give a meaningful name. 'start' may be higher than
    'end', the kernel will swap them in this case
    
    @param start: (C++: ea_t) starting address
    @param len: (C++: size_t) length of the string in bytes. if 0, then get_max_strlit_length()
                will be used to determine the length
    @param strtype: (C++: int32) string type. one of String type codes
    @return: success

ida_bytes.create_struct (function)
    create_struct(ea, length, tid, force=False) -> bool
    Convert to struct.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param tid: (C++: tid_t)
    @param force: (C++: bool)

ida_bytes.create_tbyte (function)
    create_tbyte(ea, length, force=False) -> bool
    Convert to tbyte.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_word (function)
    create_word(ea, length, force=False) -> bool
    Convert to word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_yword (function)
    create_yword(ea, length, force=False) -> bool
    Convert to ymm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.create_zword (function)
    create_zword(ea, length, force=False) -> bool
    Convert to zmm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

ida_bytes.cust_flag (function)
    cust_flag() -> flags64_t
    Get a flags64_t representing custom type data.

ida_bytes.custfmt_flag (function)
    custfmt_flag() -> flags64_t
    see FF_opbits

ida_bytes.data_format_t (class)
    Proxy of C++ data_format_t class.

ida_bytes.data_format_t.__get_id (method)
    __get_id(self) -> int

ida_bytes.data_format_t.__init__ (method)
    __init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
    
    @param self: PyObject *
    @param name: char const *
    @param value_size: asize_t
    @param menu_name: char const *
    @param props: int
    @param hotkey: char const *
    @param text_width: int32

ida_bytes.data_format_t.__init__ (method)

ida_bytes.data_format_t.hotkey (variable)
    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated
    with the menu item

ida_bytes.data_format_t.is_present_in_menus (method)
    is_present_in_menus(self) -> bool
    Should this format be shown in UI menus
    
    @return: success

ida_bytes.data_format_t.menu_name (variable)
    Visible format name to use in menus if nullptr, no menu item will be created

ida_bytes.data_format_t.name (variable)
    Format name, must be unique.

ida_bytes.data_format_t.props (variable)
    properties (currently 0)

ida_bytes.data_format_t.text_width (variable)
    Usual width of the text representation This value is used to calculate the width
    of the control to display values of this type

ida_bytes.data_format_t.value_size (variable)
    size of the value in bytes 0 means any size is ok data formats that are
    registered for standard types (dtid 0) may be called with any value_size
    (instruction operands only)

ida_bytes.data_type_t (class)
    Proxy of C++ data_type_t class.

ida_bytes.data_type_t.__get_id (method)
    __get_id(self) -> int

ida_bytes.data_type_t.__init__ (method)
    __init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
    
    @param self: PyObject *
    @param name: char const *
    @param value_size: asize_t
    @param menu_name: char const *
    @param hotkey: char const *
    @param asm_keyword: char const *
    @param props: int

ida_bytes.data_type_t.__init__ (method)

ida_bytes.data_type_t.asm_keyword (variable)
    keyword to use for this type in the assembly if nullptr, the data type cannot be
    used in the listing it can still be used in cpuregs window

ida_bytes.data_type_t.hotkey (variable)
    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated
    with the menu item

ida_bytes.data_type_t.is_present_in_menus (method)
    is_present_in_menus(self) -> bool
    Should this type be shown in UI menus
    
    @return: success

ida_bytes.data_type_t.menu_name (variable)
    Visible data type name to use in menus if nullptr, no menu item will be created

ida_bytes.data_type_t.name (variable)
    name of the data type. must be unique

ida_bytes.data_type_t.props (variable)
    properties

ida_bytes.data_type_t.value_size (variable)
    size of the value in bytes

ida_bytes.dec_flag (function)
    dec_flag() -> flags64_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

ida_bytes.del_hidden_range (function)
    del_hidden_range(ea) -> bool
    Delete hidden range.
    
    @param ea: (C++: ea_t) any address in the hidden range
    @return: success

ida_bytes.del_items (function)
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
    Convert item (instruction/data) to unexplored bytes. The whole item (including
    the head and tail bytes) will be destroyed. It is allowed to pass any address in
    the item to this function
    
    @param ea: (C++: ea_t) any address within the first item to delete
    @param flags: (C++: int) combination of Unexplored byte conversion flags
    @param nbytes: (C++: asize_t) number of bytes in the range to be undefined
    @param may_destroy: (C++: may_destroy_cb_t *) optional routine invoked before deleting a head item. If
                        callback returns false then item is not to be deleted and
                        operation fails
    @return: true on sucessful operation, otherwise false

ida_bytes.del_mapping (function)
    del_mapping(ea)
    Delete memory mapping range.
    
    @param ea: (C++: ea_t) any address in the mapped range

ida_bytes.del_value (function)
    del_value(ea)
    Delete byte value from flags. The corresponding byte becomes uninitialized.
    
    @param ea: (C++: ea_t)

ida_bytes.detach_custom_data_format (function)
    detach_custom_data_format(dtid, dfid) -> bool
    Detach the data format from the data type. Unregistering a custom data type
    detaches all attached data formats, no need to detach them explicitly. You still
    need unregister them. Unregistering a custom data format detaches it from all
    attached data types.
    
    @param dtid: (C++: int) data type id to detach data format from
    @param dfid: (C++: int) data format id to detach
    @retval true: ok
    @retval false: no such `dtid', or no such `dfid', or the data format was not
                   attached to the data type

ida_bytes.disable_flags (function)
    disable_flags(start_ea, end_ea) -> error_t
    Deallocate flags for address range. Exit with an error message if not enough
    disk space (this may occur too).
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @return: 0 if ok, otherwise return error code

ida_bytes.double_flag (function)
    double_flag() -> flags64_t
    Get a flags64_t representing a double.

ida_bytes.dword_flag (function)
    dword_flag() -> flags64_t
    Get a flags64_t representing a double word.

ida_bytes.enable_flags (function)
    enable_flags(start_ea, end_ea, stt) -> error_t
    Allocate flags for address range. This function does not change the storage type
    of existing ranges. Exit with an error message if not enough disk space.
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @param stt: (C++: storage_type_t)
    @return: 0 if ok, otherwise an error code

ida_bytes.enum_flag (function)
    enum_flag() -> flags64_t
    see FF_opbits

ida_bytes.equal_bytes (function)
    equal_bytes(ea, image, mask, len, bin_search_flags) -> bool
    Compare 'len' bytes of the program starting from 'ea' with 'image'.
    
    @param ea: (C++: ea_t) linear address
    @param image: (C++: const uchar *) bytes to compare with
    @param mask: (C++: const uchar *) array of mask bytes, it's length is 'len'. if the flag
                 BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if
                 not; 1 means to perform the comparison of the corresponding byte. 0
                 means not to perform. if mask == nullptr, then all bytes of 'image'
                 will be compared. if mask == SKIP_FF_MASK then 0xFF bytes will be
                 skipped
    @param len: (C++: size_t) length of block to compare in bytes.
    @param bin_search_flags: (C++: int) combination of Search flags
    @retval 1: equal
    @retval 0: not equal

ida_bytes.f_has_cmt (function)
    f_has_cmt(f, arg2) -> bool
    
    @param f: flags64_t
    @param arg2: void *

ida_bytes.f_has_dummy_name (function)
    f_has_dummy_name(f, arg2) -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?
    
    @param f: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_has_extra_cmts (function)
    f_has_extra_cmts(f, arg2) -> bool
    
    @param f: flags64_t
    @param arg2: void *

ida_bytes.f_has_name (function)
    f_has_name(f, arg2) -> bool
    Does the current byte have non-trivial (non-dummy) name?
    
    @param f: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_has_user_name (function)
    f_has_user_name(F, arg2) -> bool
    Does the current byte have user-specified name?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_has_xref (function)
    f_has_xref(f, arg2) -> bool
    Does the current byte have cross-references to it?
    
    @param f: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_align (function)
    f_is_align(F, arg2) -> bool
    See is_align()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_byte (function)
    f_is_byte(F, arg2) -> bool
    See is_byte()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_code (function)
    f_is_code(F, arg2) -> bool
    Does flag denote start of an instruction?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_custom (function)
    f_is_custom(F, arg2) -> bool
    See is_custom()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_data (function)
    f_is_data(F, arg2) -> bool
    Does flag denote start of data?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_double (function)
    f_is_double(F, arg2) -> bool
    See is_double()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_dword (function)
    f_is_dword(F, arg2) -> bool
    See is_dword()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_float (function)
    f_is_float(F, arg2) -> bool
    See is_float()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_head (function)
    f_is_head(F, arg2) -> bool
    Does flag denote start of instruction OR data?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_not_tail (function)
    f_is_not_tail(F, arg2) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_oword (function)
    f_is_oword(F, arg2) -> bool
    See is_oword()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_pack_real (function)
    f_is_pack_real(F, arg2) -> bool
    See is_pack_real()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_qword (function)
    f_is_qword(F, arg2) -> bool
    See is_qword()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_strlit (function)
    f_is_strlit(F, arg2) -> bool
    See is_strlit()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_struct (function)
    f_is_struct(F, arg2) -> bool
    See is_struct()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_tail (function)
    f_is_tail(F, arg2) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_tbyte (function)
    f_is_tbyte(F, arg2) -> bool
    See is_tbyte()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_word (function)
    f_is_word(F, arg2) -> bool
    See is_word()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.f_is_yword (function)
    f_is_yword(F, arg2) -> bool
    See is_yword()
    
    @param F: (C++: flags64_t)
    @param arg2: void *

ida_bytes.find_byte (function)
    find_byte(sEA, size, value, bin_search_flags) -> ea_t
    Find forward a byte with the specified value (only 8-bit value from the
    database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
    
    @param sEA: (C++: ea_t) linear address
    @param size: (C++: asize_t) number of bytes to inspect
    @param value: (C++: uchar) value to find
    @param bin_search_flags: (C++: int) combination of Search flags
    @return: address of byte or BADADDR

ida_bytes.find_byter (function)
    find_byter(sEA, size, value, bin_search_flags) -> ea_t
    Find reverse a byte with the specified value (only 8-bit value from the
    database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
    
    @param sEA: (C++: ea_t) the lower address of the search range
    @param size: (C++: asize_t) number of bytes to inspect
    @param value: (C++: uchar) value to find
    @param bin_search_flags: (C++: int) combination of Search flags
    @return: address of byte or BADADDR

ida_bytes.find_custom_data_format (function)
    find_custom_data_format(name) -> int
    Get id of a custom data format.
    
    @param name: (C++: const char *) name of the custom data format
    @return: id or -1

ida_bytes.find_custom_data_type (function)
    find_custom_data_type(name) -> int
    Get id of a custom data type.
    
    @param name: (C++: const char *) name of the custom data type
    @return: id or -1

ida_bytes.find_free_chunk (function)
    find_free_chunk(start, size, alignment) -> ea_t
    Search for a hole in the addressing space of the program.
    
    @param start: (C++: ea_t) Address to start searching from
    @param size: (C++: asize_t) Size of the desired empty range
    @param alignment: (C++: asize_t) Alignment bitmask, must be a pow2-1. (for example, 0xF would
                      align the returned range to 16 bytes).
    @return: Start of the found empty range or BADADDR

ida_bytes.float_flag (function)
    float_flag() -> flags64_t
    Get a flags64_t representing a float.

ida_bytes.flt_flag (function)
    flt_flag() -> flags64_t
    see FF_opbits

ida_bytes.free_chunk (function)
    free_chunk(bottom, size, step) -> ea_t
    
    @param bottom: ea_t
    @param size: asize_t
    @param step: int32

ida_bytes.get_16bit (function)
    get_16bit(ea) -> uint32
    Get 16bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 1 byte (getFullByte()) if the current processor has 16-bit byte,
             otherwise return get_word()

ida_bytes.get_32bit (function)
    get_32bit(ea) -> uint32
    Get not more than 32bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 32 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_dword(ea);
    * if ( nbits <= 16) return get_wide_word(ea);
    * return get_wide_byte(ea);

ida_bytes.get_64bit (function)
    get_64bit(ea) -> uint64
    Get not more than 64bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 64 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_qword(ea);
    * if ( nbits <= 16) return get_wide_dword(ea);
    * return get_wide_byte(ea);

ida_bytes.get_8bit (function)
    get_8bit(ea, v, nbit) -> PyObject *
    
    @param ea: ea_t
    @param v: uint32
    @param nbit: int

ida_bytes.get_byte (function)
    get_byte(ea) -> uchar
    Get one byte (8-bit) of the program at 'ea'. This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

ida_bytes.get_bytes (function)
    get_bytes(ea, size, gmb_flags=0x01) -> bytes or None
    Get the specified number of bytes of the program.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: int
    @return: the bytes (as a str), or None in case of failure

ida_bytes.get_bytes_and_mask (function)
    get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: int
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.

ida_bytes.get_cmt (function)
    get_cmt(ea, rptble) -> str
    Get an indented comment.
    
    @param ea: (C++: ea_t) linear address. may point to tail byte, the function will find start
               of the item
    @param rptble: (C++: bool) get repeatable comment?
    @return: size of comment or -1

ida_bytes.get_custom_data_format (function)
    get_custom_data_format(dfid) -> data_format_t
    Get definition of a registered custom data format.
    
    @param dfid: (C++: int) data format id
    @return: data format definition or nullptr

ida_bytes.get_custom_data_formats (function)
    get_custom_data_formats(out, dtid) -> int
    Get list of attached custom data formats for the specified data type.
    
    @param out: (C++: intvec_t *) buffer for the output. may be nullptr
    @param dtid: (C++: int) data type id
    @return: number of returned custom data formats. if error, returns -1

ida_bytes.get_custom_data_type (function)
    get_custom_data_type(dtid) -> data_type_t
    Get definition of a registered custom data type.
    
    @param dtid: (C++: int) data type id
    @return: data type definition or nullptr

ida_bytes.get_custom_data_types (function)
    get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
    Get list of registered custom data type ids.
    
    @param out: (C++: intvec_t *) buffer for the output. may be nullptr
    @param min_size: (C++: asize_t) minimum value size
    @param max_size: (C++: asize_t) maximum value size
    @return: number of custom data types with the specified size limits

ida_bytes.get_data_elsize (function)
    get_data_elsize(ea, F, ti=None) -> asize_t
    Get size of data type specified in flags 'F'.
    
    @param ea: (C++: ea_t) linear address of the item
    @param F: (C++: flags64_t) flags
    @param ti: (C++: const opinfo_t *) additional information about the data type. For example, if the
               current item is a structure instance, then ti->tid is structure id.
               Otherwise is ignored (may be nullptr). If specified as nullptr, will
               be automatically retrieved from the database
    @return: * byte : 1
    * word : 2
    * etc...

ida_bytes.get_data_value (function)
    get_data_value(v, ea, size) -> bool
    Get the value at of the item at 'ea'. This function works with entities up to
    sizeof(ea_t) (bytes, word, etc)
    
    @param v: (C++: uval_t *) pointer to the result. may be nullptr
    @param ea: (C++: ea_t) linear address
    @param size: (C++: asize_t) size of data to read. If 0, then the item type at 'ea' will be used
    @return: success

ida_bytes.get_db_byte (function)
    get_db_byte(ea) -> uchar
    Get one byte (8-bit) of the program at 'ea' from the database. Works even if the
    debugger is active. See also get_dbg_byte() to read the process memory directly.
    This function works only for 8bit byte processors.
    
    @param ea: (C++: ea_t)

ida_bytes.get_default_radix (function)
    get_default_radix() -> int
    Get default base of number for the current processor.
    
    @return: 2, 8, 10, 16

ida_bytes.get_dword (function)
    get_dword(ea) -> uint32
    Get one dword (32-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

ida_bytes.get_enum_id (function)
    get_enum_id(ea, n) -> enum_t
    Get enum id of 'enum' operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL one of the operands
    @return: id of enum or BADNODE

ida_bytes.get_first_hidden_range (function)
    get_first_hidden_range() -> hidden_range_t
    Get pointer to the first hidden range.
    
    @return: ptr to hidden range or nullptr

ida_bytes.get_flags (function)
    get_flags(ea) -> flags64_t
    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because
    the kernel needs to read the process memory.
    
    @param ea: (C++: ea_t)

ida_bytes.get_flags_by_size (function)
    get_flags_by_size(size) -> flags64_t
    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32. For other
    sizes returns 0
    
    @param size: (C++: size_t)

ida_bytes.get_flags_ex (function)
    get_flags_ex(ea, how) -> flags64_t
    Get flags for the specified address, extended form.
    
    @param ea: (C++: ea_t)
    @param how: (C++: int)

ida_bytes.get_forced_operand (function)
    get_forced_operand(ea, n) -> str
    Get forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number
    @return: size of forced operand or -1

ida_bytes.get_full_data_elsize (function)
    get_full_data_elsize(ea, F, ti=None) -> asize_t
    Get full size of data type specified in flags 'F'. takes into account processors
    with wide bytes e.g. returns 2 for a byte element with 16-bit bytes
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags64_t)
    @param ti: (C++: const opinfo_t *) opinfo_t const *

ida_bytes.get_full_flags (function)
    get_full_flags(ea) -> flags64_t
    Get flags value for address 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 0 if address is not present in the program

ida_bytes.get_hidden_range (function)
    get_hidden_range(ea) -> hidden_range_t
    Get pointer to hidden range structure, in: linear address.
    
    @param ea: (C++: ea_t) any address in the hidden range

ida_bytes.get_hidden_range_num (function)
    get_hidden_range_num(ea) -> int
    Get number of a hidden range.
    
    @param ea: (C++: ea_t) any address in the hidden range
    @return: number of hidden range (0..get_hidden_range_qty()-1)

ida_bytes.get_hidden_range_qty (function)
    get_hidden_range_qty() -> int
    Get number of hidden ranges.

ida_bytes.get_item_end (function)
    get_item_end(ea) -> ea_t
    Get the end address of the item at 'ea'. The returned address doesn't belong to
    the current item. Unexplored bytes are counted as 1 byte entities.
    
    @param ea: (C++: ea_t)

ida_bytes.get_item_flag (function)
    get_item_flag(_from, n, ea, appzero) -> flags64_t
    Get flag of the item at 'ea' even if it is a tail byte of some array or
    structure. This function is used to get flags of structure members or array
    elements.
    
    @param from: (C++: ea_t) linear address of the instruction which refers to 'ea'
    @param n: (C++: int) operand number which refers to 'ea' or OPND_ALL for one of the
              operands
    @param ea: (C++: ea_t) the referenced address
    @param appzero: (C++: bool) append a struct field name if the field offset is zero?
                    meaningful only if the name refers to a structure.
    @return: flags or 0 (if failed)

ida_bytes.get_item_head (function)
    get_item_head(ea) -> ea_t
    Get the start address of the item at 'ea'. If there is no current item, then
    'ea' will be returned (see definition at the end of bytes.hpp source)
    
    @param ea: (C++: ea_t)

ida_bytes.get_item_refinfo (function)
    get_item_refinfo(ri, ea, n) -> bool
    Get refinfo of the item at 'ea'. This function works for a regular offset
    operand as well as for a tail byte of a structure variable (in this case refinfo
    to corresponding structure member will be returned)
    
    @param ri: (C++: refinfo_t *) refinfo holder
    @param ea: (C++: ea_t) the item address
    @param n: (C++: int) operand number which refers to 'ea' or OPND_ALL for one of the
              operands
    @return: success

ida_bytes.get_item_size (function)
    get_item_size(ea) -> asize_t
    Get size of item (instruction/data) in bytes. Unexplored bytes have length of 1
    byte. This function returns 0 only for BADADDR.
    
    @param ea: (C++: ea_t)

ida_bytes.get_last_hidden_range (function)
    get_last_hidden_range() -> hidden_range_t
    Get pointer to the last hidden range.
    
    @return: ptr to hidden range or nullptr

ida_bytes.get_manual_insn (function)
    get_manual_insn(ea) -> str
    Retrieve the user-specified string for the manual instruction.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @return: size of manual instruction or -1

ida_bytes.get_mapping (function)
    get_mapping(n) -> bool
    Get memory mapping range by its number.
    
    @param n: (C++: size_t) number of mapping range (0..get_mappings_qty()-1)
    @return: false if the specified range doesn't exist, otherwise returns `from',
             `to', `size'

ida_bytes.get_mappings_qty (function)
    get_mappings_qty() -> size_t
    Get number of mappings.

ida_bytes.get_max_strlit_length (function)
    get_max_strlit_length(ea, strtype, options=0) -> size_t
    Determine maximum length of string literal.
    
    If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte
    length prefix), the length of that prefix (i.e., 2) will be part of the returned
    value.
    
    @param ea: (C++: ea_t) starting address
    @param strtype: (C++: int32) string type. one of String type codes
    @param options: (C++: int) combination of string literal length options
    @return: length of the string in octets (octet==8bit)

ida_bytes.get_next_hidden_range (function)
    get_next_hidden_range(ea) -> hidden_range_t
    Get pointer to next hidden range.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to hidden range or nullptr if next hidden range doesn't exist

ida_bytes.get_octet (function)
    get_octet(ea, v, nbit) -> (int, int, int, int)
    
    @param ea: ea_t
    @param v: uint64
    @param nbit: int

ida_bytes.get_octet2 (function)
    get_octet2(ogen) -> bool
    
    @param ogen: octet_generator_t *

ida_bytes.get_operand_flag (function)
    get_operand_flag(typebits, n) -> flags64_t
    Place operand `n`'s type flag in the right nibble of a 64-bit flags set.
    
    @param typebits: (C++: uint8) the type bits (one of `FF_N_`)
    @param n: (C++: int) the operand number
    @return: the shift to the nibble

ida_bytes.get_operand_type_shift (function)
    get_operand_type_shift(n) -> int
    Get the shift in `flags64_t` for the nibble representing operand `n`'s type
    
    Note: n must be < UA_MAXOP, and is not checked
    
    @param n: (C++: uint32) the operand number
    @return: the shift to the nibble

ida_bytes.get_opinfo (function)
    get_opinfo(buf, ea, n, flags) -> opinfo_t
    Get additional information about an operand representation.
    
    @param buf: (C++: opinfo_t *) buffer to receive the result. may not be nullptr
    @param ea: (C++: ea_t) linear address of item
    @param n: (C++: int) number of operand, 0 or 1
    @param flags: (C++: flags64_t) flags of the item
    @return: nullptr if no additional representation information

ida_bytes.get_optype_flags0 (function)
    get_optype_flags0(F) -> flags64_t
    Get flags for first operand.
    
    @param F: (C++: flags64_t)

ida_bytes.get_optype_flags1 (function)
    get_optype_flags1(F) -> flags64_t
    Get flags for second operand.
    
    @param F: (C++: flags64_t)

ida_bytes.get_original_byte (function)
    get_original_byte(ea) -> uint64
    Get original byte value (that was before patching). This function works for wide
    byte processors too.
    
    @param ea: (C++: ea_t)

ida_bytes.get_original_dword (function)
    get_original_dword(ea) -> uint64
    Get original dword (that was before patching) This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t)

ida_bytes.get_original_qword (function)
    get_original_qword(ea) -> uint64
    Get original qword value (that was before patching) This function DOESN'T work
    for wide byte processors too. This function takes into account order of bytes
    specified in idainfo::is_be()
    
    @param ea: (C++: ea_t)

ida_bytes.get_original_word (function)
    get_original_word(ea) -> uint64
    Get original word value (that was before patching). This function works for wide
    byte processors too. This function takes into account order of bytes specified
    in idainfo::is_be()
    
    @param ea: (C++: ea_t)

ida_bytes.get_possible_item_varsize (function)
    get_possible_item_varsize(ea, tif) -> asize_t
    Return the possible size of the item at EA of type TIF if TIF is the variable
    structure.
    
    @param ea: (C++: ea_t) the linear address of the item
    @param tif: (C++: const tinfo_t &) the item type
    @return: the possible size
    @retval asize_t(-1): TIF is not a variable structure

ida_bytes.get_predef_insn_cmt (function)
    get_predef_insn_cmt(ins) -> str
    Get predefined comment.
    
    @param ins: (C++: const insn_t &) current instruction information
    @return: size of comment or -1

ida_bytes.get_prev_hidden_range (function)
    get_prev_hidden_range(ea) -> hidden_range_t
    Get pointer to previous hidden range.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to hidden range or nullptr if previous hidden range doesn't exist

ida_bytes.get_qword (function)
    get_qword(ea) -> uint64
    Get one qword (64-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

ida_bytes.get_radix (function)
    get_radix(F, n) -> int
    Get radix of the operand, in: flags. If the operand is not a number, returns
    get_default_radix()
    
    @param F: (C++: flags64_t) flags
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: 2, 8, 10, 16

ida_bytes.get_strlit_contents (function)
    get_strlit_contents(ea, py_len, type, flags=0) -> bytes or None
    Get contents of string literal, as UTF-8-encoded codepoints.
    It works even if the string has not been created in the database yet.
    
    Note that the returned value will be of type 'bytes'; if
    you want auto-conversion to unicode strings (that is: real Python
    strings), you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param py_len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.

ida_bytes.get_stroff_path (function)
    get_stroff_path(path, delta, ea, n) -> int
    Get struct path of operand.
    
    @param path: (C++: tid_t *) buffer for structure path (strpath). see nalt.hpp for more info.
    @param delta: (C++: adiff_t *) struct offset delta
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL one of the operands
    @return: length of strpath

ida_bytes.get_wide_byte (function)
    get_wide_byte(ea) -> uint64
    Get one wide byte of the program at 'ea'. Some processors may access more than
    8bit quantity at an address. These processors have 32-bit byte organization from
    the IDA's point of view.
    
    @param ea: (C++: ea_t)

ida_bytes.get_wide_dword (function)
    get_wide_dword(ea) -> uint64
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors may
    access more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    @note: this function works incorrectly if processor_t::nbits > 16
    
    @param ea: (C++: ea_t)

ida_bytes.get_wide_word (function)
    get_wide_word(ea) -> uint64
    Get one wide word (2 'byte') of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    
    @param ea: (C++: ea_t)

ida_bytes.get_word (function)
    get_word(ea) -> ushort
    Get one word (16-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

ida_bytes.get_zero_ranges (function)
    get_zero_ranges(zranges, range) -> bool
    Return set of ranges with zero initialized bytes. The returned set includes only
    big zero initialized ranges (at least >1KB). Some zero initialized byte ranges
    may be not included. Only zero bytes that use the sparse storage method (STT_MM)
    are reported.
    
    @param zranges: (C++: rangeset_t *) pointer to the return value. cannot be nullptr
    @param range: (C++: const range_t *) the range of addresses to verify. can be nullptr - means all
                  ranges
    @return: true if the result is a non-empty set

ida_bytes.getn_hidden_range (function)
    getn_hidden_range(n) -> hidden_range_t
    Get pointer to hidden range structure, in: number of hidden range.
    
    @param n: (C++: int) number of hidden range, is in range 0..get_hidden_range_qty()-1

ida_bytes.has_any_name (function)
    has_any_name(F) -> bool
    Does the current byte have any name?
    
    @param F: (C++: flags64_t)

ida_bytes.has_auto_name (function)
    has_auto_name(F) -> bool
    Does the current byte have auto-generated (no special prefix) name?
    
    @param F: (C++: flags64_t)

ida_bytes.has_cmt (function)
    has_cmt(F) -> bool
    Does the current byte have an indented comment?
    
    @param F: (C++: flags64_t)

ida_bytes.has_dummy_name (function)
    has_dummy_name(F) -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?
    
    @param F: (C++: flags64_t)

ida_bytes.has_extra_cmts (function)
    has_extra_cmts(F) -> bool
    Does the current byte have additional anterior or posterior lines?
    
    @param F: (C++: flags64_t)

ida_bytes.has_immd (function)
    has_immd(F) -> bool
    Has immediate value?
    
    @param F: (C++: flags64_t)

ida_bytes.has_name (function)
    has_name(F) -> bool
    Does the current byte have non-trivial (non-dummy) name?
    
    @param F: (C++: flags64_t)

ida_bytes.has_user_name (function)
    has_user_name(F) -> bool
    Does the current byte have user-specified name?
    
    @param F: (C++: flags64_t)

ida_bytes.has_value (function)
    has_value(F) -> bool
    Do flags contain byte value?
    
    @param F: (C++: flags64_t)

ida_bytes.has_xref (function)
    has_xref(F) -> bool
    Does the current byte have cross-references to it?
    
    @param F: (C++: flags64_t)

ida_bytes.hex_flag (function)
    hex_flag() -> flags64_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

ida_bytes.hidden_range_t (class)
    Proxy of C++ hidden_range_t class.

ida_bytes.hidden_range_t.__init__ (method)
    __init__(self) -> hidden_range_t

ida_bytes.hidden_range_t.color (variable)
    range color

ida_bytes.hidden_range_t.description (variable)
    description to display if the range is collapsed

ida_bytes.hidden_range_t.footer (variable)
    footer lines to display if the range is expanded

ida_bytes.hidden_range_t.header (variable)
    header lines to display if the range is expanded

ida_bytes.hidden_range_t.visible (variable)
    the range state

ida_bytes.is_align (function)
    is_align(F) -> bool
    FF_ALIGN
    
    @param F: (C++: flags64_t)

ida_bytes.is_attached_custom_data_format (function)
    is_attached_custom_data_format(dtid, dfid) -> bool
    Is the custom data format attached to the custom data type?
    
    @param dtid: (C++: int) data type id
    @param dfid: (C++: int) data format id
    @return: true or false

ida_bytes.is_bnot (function)
    is_bnot(ea, F, n) -> bool
    Should we negate the operand?. asm_t::a_bnot should be defined in the idp module
    in order to work with this function
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_byte (function)
    is_byte(F) -> bool
    FF_BYTE
    
    @param F: (C++: flags64_t)

ida_bytes.is_char (function)
    is_char(F, n) -> bool
    is character constant?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_char0 (function)
    is_char0(F) -> bool
    Is the first operand character constant? (example: push 'a')
    
    @param F: (C++: flags64_t)

ida_bytes.is_char1 (function)
    is_char1(F) -> bool
    Is the second operand character constant? (example: mov al, 'a')
    
    @param F: (C++: flags64_t)

ida_bytes.is_code (function)
    is_code(F) -> bool
    Does flag denote start of an instruction?
    
    @param F: (C++: flags64_t)

ida_bytes.is_custfmt (function)
    is_custfmt(F, n) -> bool
    is custom data format?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_custfmt0 (function)
    is_custfmt0(F) -> bool
    Does the first operand use a custom data representation?
    
    @param F: (C++: flags64_t)

ida_bytes.is_custfmt1 (function)
    is_custfmt1(F) -> bool
    Does the second operand use a custom data representation?
    
    @param F: (C++: flags64_t)

ida_bytes.is_custom (function)
    is_custom(F) -> bool
    FF_CUSTOM
    
    @param F: (C++: flags64_t)

ida_bytes.is_data (function)
    is_data(F) -> bool
    Does flag denote start of data?
    
    @param F: (C++: flags64_t)

ida_bytes.is_defarg (function)
    is_defarg(F, n) -> bool
    is defined?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_defarg0 (function)
    is_defarg0(F) -> bool
    Is the first operand defined? Initially operand has no defined representation.
    
    @param F: (C++: flags64_t)

ida_bytes.is_defarg1 (function)
    is_defarg1(F) -> bool
    Is the second operand defined? Initially operand has no defined representation.
    
    @param F: (C++: flags64_t)

ida_bytes.is_double (function)
    is_double(F) -> bool
    FF_DOUBLE
    
    @param F: (C++: flags64_t)

ida_bytes.is_dword (function)
    is_dword(F) -> bool
    FF_DWORD
    
    @param F: (C++: flags64_t)

ida_bytes.is_enum (function)
    is_enum(F, n) -> bool
    is enum?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_enum0 (function)
    is_enum0(F) -> bool
    Is the first operand a symbolic constant (enum member)?
    
    @param F: (C++: flags64_t)

ida_bytes.is_enum1 (function)
    is_enum1(F) -> bool
    Is the second operand a symbolic constant (enum member)?
    
    @param F: (C++: flags64_t)

ida_bytes.is_flag_for_operand (function)
    is_flag_for_operand(F, typebits, n) -> bool
    Check that the 64-bit flags set has the expected type for operand `n`.
    
    @param F: (C++: flags64_t) the flags
    @param typebits: (C++: uint8) the type bits (one of `FF_N_`)
    @param n: (C++: int) the operand number
    @return: success

ida_bytes.is_float (function)
    is_float(F) -> bool
    FF_FLOAT
    
    @param F: (C++: flags64_t)

ida_bytes.is_float0 (function)
    is_float0(F) -> bool
    Is the first operand a floating point number?
    
    @param F: (C++: flags64_t)

ida_bytes.is_float1 (function)
    is_float1(F) -> bool
    Is the second operand a floating point number?
    
    @param F: (C++: flags64_t)

ida_bytes.is_flow (function)
    is_flow(F) -> bool
    Does the previous instruction exist and pass execution flow to the current byte?
    
    @param F: (C++: flags64_t)

ida_bytes.is_fltnum (function)
    is_fltnum(F, n) -> bool
    is floating point number?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_forced_operand (function)
    is_forced_operand(ea, n) -> bool
    Is operand manually defined?.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number

ida_bytes.is_func (function)
    is_func(F) -> bool
    Is function start?
    
    @param F: (C++: flags64_t)

ida_bytes.is_head (function)
    is_head(F) -> bool
    Does flag denote start of instruction OR data?
    
    @param F: (C++: flags64_t)

ida_bytes.is_invsign (function)
    is_invsign(ea, F, n) -> bool
    Should sign of n-th operand inverted during output?. allowed values of n:
    0-first operand, 1-other operands
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_loaded (function)
    is_loaded(ea) -> bool
    Does the specified address have a byte value (is initialized?)
    
    @param ea: (C++: ea_t)

ida_bytes.is_lzero (function)
    is_lzero(ea, n) -> bool
    Display leading zeroes? Display leading zeroes in operands. The global switch
    for the leading zeroes is in idainfo::s_genflags Note: the leading zeroes
    doesn't work if for the target assembler octal numbers start with 0.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

ida_bytes.is_manual (function)
    is_manual(F, n) -> bool
    is forced operand? (use is_forced_operand())
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_manual_insn (function)
    is_manual_insn(ea) -> bool
    Is the instruction overridden?
    
    @param ea: (C++: ea_t) linear address of the instruction or data item

ida_bytes.is_mapped (function)
    is_mapped(ea) -> bool
    Is the specified address 'ea' present in the program?
    
    @param ea: (C++: ea_t)

ida_bytes.is_not_tail (function)
    is_not_tail(F) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags64_t)

ida_bytes.is_numop (function)
    is_numop(F, n) -> bool
    is number (bin, oct, dec, hex)?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_numop0 (function)
    is_numop0(F) -> bool
    Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    @param F: (C++: flags64_t)

ida_bytes.is_numop1 (function)
    is_numop1(F) -> bool
    Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    @param F: (C++: flags64_t)

ida_bytes.is_off (function)
    is_off(F, n) -> bool
    is offset?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_off0 (function)
    is_off0(F) -> bool
    Is the first operand offset? (example: push offset xxx)
    
    @param F: (C++: flags64_t)

ida_bytes.is_off1 (function)
    is_off1(F) -> bool
    Is the second operand offset? (example: mov ax, offset xxx)
    
    @param F: (C++: flags64_t)

ida_bytes.is_oword (function)
    is_oword(F) -> bool
    FF_OWORD
    
    @param F: (C++: flags64_t)

ida_bytes.is_pack_real (function)
    is_pack_real(F) -> bool
    FF_PACKREAL
    
    @param F: (C++: flags64_t)

ida_bytes.is_qword (function)
    is_qword(F) -> bool
    FF_QWORD
    
    @param F: (C++: flags64_t)

ida_bytes.is_same_data_type (function)
    is_same_data_type(F1, F2) -> bool
    Do the given flags specify the same data type?
    
    @param F1: (C++: flags64_t)
    @param F2: (C++: flags64_t)

ida_bytes.is_seg (function)
    is_seg(F, n) -> bool
    is segment?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_seg0 (function)
    is_seg0(F) -> bool
    Is the first operand segment selector? (example: push seg seg001)
    
    @param F: (C++: flags64_t)

ida_bytes.is_seg1 (function)
    is_seg1(F) -> bool
    Is the second operand segment selector? (example: mov dx, seg dseg)
    
    @param F: (C++: flags64_t)

ida_bytes.is_stkvar (function)
    is_stkvar(F, n) -> bool
    is stack variable?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_stkvar0 (function)
    is_stkvar0(F) -> bool
    Is the first operand a stack variable?
    
    @param F: (C++: flags64_t)

ida_bytes.is_stkvar1 (function)
    is_stkvar1(F) -> bool
    Is the second operand a stack variable?
    
    @param F: (C++: flags64_t)

ida_bytes.is_strlit (function)
    is_strlit(F) -> bool
    FF_STRLIT
    
    @param F: (C++: flags64_t)

ida_bytes.is_stroff (function)
    is_stroff(F, n) -> bool
    is struct offset?
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_stroff0 (function)
    is_stroff0(F) -> bool
    Is the first operand an offset within a struct?
    
    @param F: (C++: flags64_t)

ida_bytes.is_stroff1 (function)
    is_stroff1(F) -> bool
    Is the second operand an offset within a struct?
    
    @param F: (C++: flags64_t)

ida_bytes.is_struct (function)
    is_struct(F) -> bool
    FF_STRUCT
    
    @param F: (C++: flags64_t)

ida_bytes.is_suspop (function)
    is_suspop(ea, F, n) -> bool
    is suspicious operand?
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.is_tail (function)
    is_tail(F) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags64_t)

ida_bytes.is_tbyte (function)
    is_tbyte(F) -> bool
    FF_TBYTE
    
    @param F: (C++: flags64_t)

ida_bytes.is_unknown (function)
    is_unknown(F) -> bool
    Does flag denote unexplored byte?
    
    @param F: (C++: flags64_t)

ida_bytes.is_varsize_item (function)
    is_varsize_item(ea, F, ti=None, itemsize=None) -> int
    Is the item at 'ea' variable size?.
    
    @param ea: (C++: ea_t) linear address of the item
    @param F: (C++: flags64_t) flags
    @param ti: (C++: const opinfo_t *) additional information about the data type. For example, if the
               current item is a structure instance, then ti->tid is structure id.
               Otherwise is ignored (may be nullptr). If specified as nullptr, will
               be automatically retrieved from the database
    @param itemsize: (C++: asize_t *) if not nullptr and the item is varsize, itemsize will contain
                     the calculated item size (for struct types, the minimal size is
                     returned)
    @retval 1: varsize item
    @retval 0: fixed item
    @retval -1: error (bad data definition)

ida_bytes.is_word (function)
    is_word(F) -> bool
    FF_WORD
    
    @param F: (C++: flags64_t)

ida_bytes.is_yword (function)
    is_yword(F) -> bool
    FF_YWORD
    
    @param F: (C++: flags64_t)

ida_bytes.is_zword (function)
    is_zword(F) -> bool
    FF_ZWORD
    
    @param F: (C++: flags64_t)

ida_bytes.leading_zero_important (function)
    leading_zero_important(ea, n) -> bool
    Check if leading zeroes are important.
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.nbits (function)
    nbits(ea) -> int
    Get number of bits in a byte at the given address.
    
    @param ea: (C++: ea_t)
    @return: processor_t::dnbits() if the address doesn't belong to a segment,
             otherwise the result depends on the segment type

ida_bytes.next_addr (function)
    next_addr(ea) -> ea_t
    Get next address in the program (i.e. next address which has flags).
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

ida_bytes.next_chunk (function)
    next_chunk(ea) -> ea_t
    Get the first address of next contiguous chunk in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if next chunk doesn't exist.

ida_bytes.next_head (function)
    next_head(ea, maxea) -> ea_t
    Get start of next defined item.
    
    @param ea: (C++: ea_t) begin search at this address
    @param maxea: (C++: ea_t) not included in the search range
    @return: BADADDR if none exists.

ida_bytes.next_inited (function)
    next_inited(ea, maxea) -> ea_t
    Find the next initialized address.
    
    @param ea: (C++: ea_t)
    @param maxea: (C++: ea_t)

ida_bytes.next_not_tail (function)
    next_not_tail(ea) -> ea_t
    Get address of next non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

ida_bytes.next_that (function)
    next_that(ea, maxea, testf) -> ea_t
    Find next address with a flag satisfying the function 'testf'.
    @note: do not pass is_unknown() to this function to find unexplored bytes. It
           will fail under the debugger. To find unexplored bytes, use
           next_unknown().
    
    @param ea: (C++: ea_t) start searching at this address + 1
    @param maxea: (C++: ea_t) not included in the search range.
    @param testf: (C++: testf_t *) test function to find next address
    @return: the found address or BADADDR.

ida_bytes.next_unknown (function)
    next_unknown(ea, maxea) -> ea_t
    Similar to next_that(), but will find the next address that is unexplored.
    
    @param ea: (C++: ea_t)
    @param maxea: (C++: ea_t)

ida_bytes.next_visea (function)
    next_visea(ea) -> ea_t
    Get next visible address.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

ida_bytes.num_flag (function)
    num_flag() -> flags64_t
    Get number of default base (bin, oct, dec, hex)

ida_bytes.oct_flag (function)
    oct_flag() -> flags64_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

ida_bytes.octet_generator_t (class)
    Proxy of C++ octet_generator_t class.

ida_bytes.octet_generator_t.__init__ (method)
    __init__(self, _ea) -> octet_generator_t
    
    @param _ea: ea_t

ida_bytes.octet_generator_t.invert_byte_order (method)
    invert_byte_order(self)

ida_bytes.off_flag (function)
    off_flag() -> flags64_t
    see FF_opbits

ida_bytes.op_adds_xrefs (function)
    op_adds_xrefs(F, n) -> bool
    Should processor module create xrefs from the operand?. Currently 'offset' and
    'structure offset' operands create xrefs
    
    @param F: (C++: flags64_t)
    @param n: (C++: int)

ida_bytes.op_based_stroff (function)
    op_based_stroff(insn, n, opval, base) -> bool
    Set operand representation to be 'struct offset' if the operand likely points to
    a structure member. For example, let's there is a structure at 1000 1000
    stru_1000 Elf32_Sym <...> the operand #8 will be represented as
    '#Elf32_Sym.st_size' after the call of 'op_based_stroff(..., 8, 0x1000)' By the
    way, after the call of 'op_plain_offset(..., 0x1000)' it will be represented as
    '#(stru_1000.st_size - 0x1000)'
    
    @param insn: (C++: const insn_t &) the instruction
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @param opval: (C++: adiff_t) operand value (usually op_t::value or op_t::addr)
    @param base: (C++: ea_t) base reference
    @return: success

ida_bytes.op_bin (function)
    op_bin(ea, n) -> bool
    set op type to bin_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_chr (function)
    op_chr(ea, n) -> bool
    set op type to char_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_custfmt (function)
    op_custfmt(ea, n, fid) -> bool
    Set custom data format for operand (fid-custom data format id)
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param fid: (C++: int)

ida_bytes.op_dec (function)
    op_dec(ea, n) -> bool
    set op type to dec_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_enum (function)
    op_enum(ea, n, id, serial=0) -> bool
    Set operand representation to be 'enum_t'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @param id: (C++: enum_t) id of enum
    @param serial: (C++: uchar) the serial number of the constant in the enumeration, usually 0.
                   the serial numbers are used if the enumeration contains several
                   constants with the same value
    @return: success

ida_bytes.op_flt (function)
    op_flt(ea, n) -> bool
    set op type to flt_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_hex (function)
    op_hex(ea, n) -> bool
    set op type to hex_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_num (function)
    op_num(ea, n) -> bool
    set op type to num_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_oct (function)
    op_oct(ea, n) -> bool
    set op type to oct_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.op_seg (function)
    op_seg(ea, n) -> bool
    Set operand representation to be 'segment'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @return: success

ida_bytes.op_stkvar (function)
    op_stkvar(ea, n) -> bool
    Set operand representation to be 'stack variable'. Should be applied to an
    instruction within a function. Should be applied after creating a stack var
    using insn_t::create_stkvar().
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @return: success

ida_bytes.op_stroff (function)
    op_stroff(insn, n, path, path_len, delta) -> bool
    Set operand representation to be 'struct offset'.
    
    @param insn: (C++: const insn_t &) the instruction
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @param path: (C++: const tid_t *) structure path (strpath). see nalt.hpp for more info.
    @param path_len: (C++: int) length of the structure path
    @param delta: (C++: adiff_t) struct offset delta. usually 0. denotes the difference between the
                  structure base and the pointer into the structure.
    @return: success
    op_stroff(insn, n, path, delta) -> bool
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param n: int
    @param path: qvector< tid_t > const &
    @param delta: adiff_t

ida_bytes.oword_flag (function)
    oword_flag() -> flags64_t
    Get a flags64_t representing a octaword.

ida_bytes.packreal_flag (function)
    packreal_flag() -> flags64_t
    Get a flags64_t representing a packed decimal real.

ida_bytes.parse_binpat_str (function)
    parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -> str
    Convert user-specified binary string to internal representation. The 'in'
    parameter contains space-separated tokens:
    - numbers (numeric base is determined by 'radix')
    - if value of number fits a byte, it is considered as a byte
    - if value of number fits a word, it is considered as 2 bytes
    - if value of number fits a dword,it is considered as 4 bytes
    - "..." string constants
    - 'x'  single-character constants
    - ?    variable bytes
    
    Note that string constants are surrounded with double quotes.
    
    Here are a few examples (assuming base 16):
    CD 21          - bytes 0xCD, 0x21
    21CD           - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
    "Hello", 0     - the null terminated string "Hello"
    L"Hello"       - 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
    B8 ? ? ? ? 90  - byte 0xB8, 4 bytes with any value, byte 0x90
    
    @param out: (C++: compiled_binpat_vec_t *) a vector of compiled binary patterns, for use with bin_search2()
    @param ea: (C++: ea_t) linear address to convert for (the conversion depends on the address,
               because the number of bits in a byte depend on the segment type)
    @param in: (C++: const char *) input text string
    @param radix: (C++: int) numeric base of numbers (8,10,16)
    @param strlits_encoding: (C++: int) the target encoding into which the string literals
                             present in 'in', should be encoded. Can be any from [1,
                             get_encoding_qty()), or the special values PBSENC_*
    @return: false either in case of parsing error, or if at least one requested
             target encoding couldn't encode the string literals present in "in".

ida_bytes.patch_byte (function)
    patch_byte(ea, x) -> bool
    Patch a byte of the program. The original value of the byte is saved and can be
    obtained by get_original_byte(). This function works for wide byte processors
    too.
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

ida_bytes.patch_bytes (function)
    patch_bytes(ea, buf)
    Patch the specified number of bytes of the program. Original values of bytes are
    saved and are available with get_original...() functions. See also put_bytes().
    
    @param ea: (C++: ea_t) linear address
    @param buf: (C++: const void *) buffer with new values of bytes

ida_bytes.patch_dword (function)
    patch_dword(ea, x) -> bool
    Patch a dword of the program. The original value of the dword is saved and can
    be obtained by get_original_dword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

ida_bytes.patch_qword (function)
    patch_qword(ea, x) -> bool
    Patch a qword of the program. The original value of the qword is saved and can
    be obtained by get_original_qword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

ida_bytes.patch_word (function)
    patch_word(ea, x) -> bool
    Patch a word of the program. The original value of the word is saved and can be
    obtained by get_original_word(). This function works for wide byte processors
    too. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

ida_bytes.prev_addr (function)
    prev_addr(ea) -> ea_t
    Get previous address in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

ida_bytes.prev_chunk (function)
    prev_chunk(ea) -> ea_t
    Get the last address of previous contiguous chunk in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if previous chunk doesn't exist.

ida_bytes.prev_head (function)
    prev_head(ea, minea) -> ea_t
    Get start of previous defined item.
    
    @param ea: (C++: ea_t) begin search at this address
    @param minea: (C++: ea_t) included in the search range
    @return: BADADDR if none exists.

ida_bytes.prev_inited (function)
    prev_inited(ea, minea) -> ea_t
    Find the previous initialized address.
    
    @param ea: (C++: ea_t)
    @param minea: (C++: ea_t)

ida_bytes.prev_not_tail (function)
    prev_not_tail(ea) -> ea_t
    Get address of previous non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

ida_bytes.prev_that (function)
    prev_that(ea, minea, testf) -> ea_t
    Find previous address with a flag satisfying the function 'testf'.
    @note: do not pass is_unknown() to this function to find unexplored bytes It
           will fail under the debugger. To find unexplored bytes, use
           prev_unknown().
    
    @param ea: (C++: ea_t) start searching from this address - 1.
    @param minea: (C++: ea_t) included in the search range.
    @param testf: (C++: testf_t *) test function to find previous address
    @return: the found address or BADADDR.

ida_bytes.prev_unknown (function)
    prev_unknown(ea, minea) -> ea_t
    Similar to prev_that(), but will find the previous address that is unexplored.
    
    @param ea: (C++: ea_t)
    @param minea: (C++: ea_t)

ida_bytes.prev_visea (function)
    prev_visea(ea) -> ea_t
    Get previous visible address.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

ida_bytes.print_strlit_type (function)
    print_strlit_type(strtype, flags=0) -> (str, str)
    Get string type information: the string type name (possibly decorated with
    hotkey markers), and the tooltip.
    
    @param strtype: (C++: int32) the string type
    @param flags: (C++: int) or'ed PSTF_* constants
    @return: length of generated text

ida_bytes.put_byte (function)
    put_byte(ea, x) -> bool
    Set value of one byte of the program. This function modifies the database. If
    the debugger is active then the debugged process memory is patched too.
    @note: The original value of the byte is completely lost and can't be recovered
           by the get_original_byte() function. See also put_dbg_byte() to write to
           the process memory directly when the debugger is active. This function
           can handle wide byte processors.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) byte value
    @return: true if the database has been modified

ida_bytes.put_bytes (function)
    put_bytes(ea, buf)
    Modify the specified number of bytes of the program. This function does not save
    the original values of bytes. See also patch_bytes().
    
    @param ea: (C++: ea_t) linear address
    @param buf: (C++: const void *) buffer with new values of bytes

ida_bytes.put_dword (function)
    put_dword(ea, x)
    Set value of one dword of the program. This function takes into account order of
    bytes specified in idainfo::is_be() This function works for wide byte processors
    too.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) dword value
    @note: the original value of the dword is completely lost and can't be recovered
           by the get_original_dword() function.

ida_bytes.put_qword (function)
    put_qword(ea, x)
    Set value of one qword (8 bytes) of the program. This function takes into
    account order of bytes specified in idainfo::is_be() This function DOESN'T works
    for wide byte processors.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) qword value

ida_bytes.put_word (function)
    put_word(ea, x)
    Set value of one word of the program. This function takes into account order of
    bytes specified in idainfo::is_be() This function works for wide byte processors
    too.
    @note: The original value of the word is completely lost and can't be recovered
           by the get_original_word() function. ea - linear address x - word value
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

ida_bytes.qword_flag (function)
    qword_flag() -> flags64_t
    Get a flags64_t representing a quad word.

ida_bytes.register_custom_data_format (function)
    register_custom_data_format(py_df) -> int
    Registers a custom data format with a given data type.
    
    @param py_df: an instance of data_format_t
    @return:     < 0 if failed to register
        > 0 data format id

ida_bytes.register_custom_data_type (function)
    register_custom_data_type(py_dt) -> int
    Registers a custom data type.
    
    @param py_dt: an instance of the data_type_t class
    @return:     < 0 if failed to register
        > 0 data type id

ida_bytes.register_data_types_and_formats (function)
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1

ida_bytes.register_data_types_and_formats.__reg_format (function)

ida_bytes.register_data_types_and_formats.__reg_type (function)

ida_bytes.revert_byte (function)
    revert_byte(ea) -> bool
    Revert patched byte
    @retval true: byte was patched before and reverted now
    
    @param ea: (C++: ea_t)

ida_bytes.seg_flag (function)
    seg_flag() -> flags64_t
    see FF_opbits

ida_bytes.set_cmt (function)
    set_cmt(ea, comm, rptble) -> bool
    Set an indented comment.
    
    @param ea: (C++: ea_t) linear address
    @param comm: (C++: const char *) comment string
    * nullptr: do nothing (return 0)
    * "" : delete comment
    @param rptble: (C++: bool) is repeatable?
    @return: success

ida_bytes.set_forced_operand (function)
    set_forced_operand(ea, n, op) -> bool
    Set forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number
    @param op: (C++: const char *) text of operand
    * nullptr: do nothing (return 0)
    * "" : delete forced operand
    @return: success

ida_bytes.set_immd (function)
    set_immd(ea) -> bool
    Set 'has immediate operand' flag. Returns true if the FF_IMMD bit was not set
    and now is set
    
    @param ea: (C++: ea_t)

ida_bytes.set_lzero (function)
    set_lzero(ea, n) -> bool
    Set toggle lzero bit. This function changes the display of leading zeroes for
    the specified operand. If the default is not to display leading zeroes, this
    function will display them and vice versa.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

ida_bytes.set_manual_insn (function)
    set_manual_insn(ea, manual_insn)
    Set manual instruction string.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @param manual_insn: (C++: const char *) "" - delete manual string. nullptr - do nothing

ida_bytes.set_op_type (function)
    set_op_type(ea, type, n) -> bool
    (internal function) change representation of operand(s).
    
    @param ea: (C++: ea_t) linear address
    @param type: (C++: flags64_t) new flag value (should be obtained from char_flag(), num_flag() and
                 similar functions)
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @retval 1: ok
    @retval 0: failed (applied to a tail byte)

ida_bytes.set_opinfo (function)
    set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
    Set additional information about an operand representation. This function is a
    low level one. Only the kernel should use it.
    
    @param ea: (C++: ea_t) linear address of the item
    @param n: (C++: int) number of operand, 0 or 1 (see the note below)
    @param flag: (C++: flags64_t) flags of the item
    @param ti: (C++: const opinfo_t *) additional representation information
    @param suppress_events: (C++: bool) do not generate changing_op_type and op_type_changed
                            events
    @return: success
    @note: for custom formats (if is_custfmt(flag, n) is true) or for offsets (if
           is_off(flag, n) is true) N can be in range 0..UA_MAXOP-1 or equal to
           OPND_ALL. In the case of OPND_ALL the additional information about all
           operands will be set.

ida_bytes.stkvar_flag (function)
    stkvar_flag() -> flags64_t
    see FF_opbits

ida_bytes.strlit_flag (function)
    strlit_flag() -> flags64_t
    Get a flags64_t representing a string literal.

ida_bytes.stroff_flag (function)
    stroff_flag() -> flags64_t
    see FF_opbits

ida_bytes.stru_flag (function)
    stru_flag() -> flags64_t
    Get a flags64_t representing a struct.

ida_bytes.tbyte_flag (function)
    tbyte_flag() -> flags64_t
    Get a flags64_t representing a tbyte.

ida_bytes.toggle_bnot (function)
    toggle_bnot(ea, n) -> bool
    Toggle binary negation of operand. also see is_bnot()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.toggle_lzero (function)
    toggle_lzero(ea, n) -> bool
    Toggle lzero bit.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

ida_bytes.toggle_sign (function)
    toggle_sign(ea, n) -> bool
    Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other
    operands
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

ida_bytes.unregister_custom_data_format (function)
    unregister_custom_data_format(dfid) -> bool
    Unregisters a custom data format
    
    @param dfid: data format id
    @return: Boolean

ida_bytes.unregister_custom_data_type (function)
    unregister_custom_data_type(dtid) -> bool
    Unregisters a custom data type.
    
    @param dtid: the data type id
    @return: Boolean

ida_bytes.unregister_data_types_and_formats (function)
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.

ida_bytes.unregister_data_types_and_formats.__unreg_format (function)

ida_bytes.unregister_data_types_and_formats.__unreg_type (function)

ida_bytes.update_hidden_range (function)
    update_hidden_range(ha) -> bool
    Update hidden range information in the database. You cannot use this function to
    change the range boundaries
    
    @param ha: (C++: const hidden_range_t *) range to update
    @return: success

ida_bytes.use_mapping (function)
    use_mapping(ea) -> ea_t
    Translate address according to current mappings.
    
    @param ea: (C++: ea_t) address to translate
    @return: translated address

ida_bytes.visit_patched_bytes (function)
    visit_patched_bytes(ea1, ea2, py_callable) -> int
    Enumerates patched bytes in the given range and invokes a callable
    
    @param ea1: start address
    @param ea2: end address
    @param py_callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.

ida_bytes.word_flag (function)
    word_flag() -> flags64_t
    Get a flags64_t representing a word.

ida_bytes.yword_flag (function)
    yword_flag() -> flags64_t
    Get a flags64_t representing a ymm word.

ida_bytes.zword_flag (function)
    zword_flag() -> flags64_t
    Get a flags64_t representing a zmm word.

ida_dbg (module)
    Contains functions to control the debugging of a process.
    
    See Debugger functions for a complete explanation of these functions.
    
    These functions are inlined for the kernel. They are not inlined for the user-
    interfaces.

ida_dbg.BKPT_ACTIVE (variable)
    active?

ida_dbg.BKPT_BADBPT (variable)
    failed to write the bpt to the process memory (at least one location)

ida_dbg.BKPT_CNDREADY (variable)
    condition has been compiled

ida_dbg.BKPT_FAKEPEND (variable)
    fake pending bpt: it is inactive but another bpt of the same type is active at
    the same address(es)

ida_dbg.BKPT_LISTBPT (variable)
    include in bpt list (user-defined bpt)

ida_dbg.BKPT_PAGE (variable)
    written to the process as a page bpt. Available only after writing the bpt to
    the process.

ida_dbg.BKPT_PARTIAL (variable)
    partially active? (some locations were not written yet)

ida_dbg.BKPT_TRACE (variable)
    trace bpt; should not be deleted when the process gets suspended

ida_dbg.BPLT_ABS (variable)
    absolute address: ea

ida_dbg.BPLT_REL (variable)
    relative address: module_path, offset

ida_dbg.BPLT_SRC (variable)
    source level: filename, lineno

ida_dbg.BPTCK_ACT (variable)
    breakpoint is active (written to the process)

ida_dbg.BPTCK_NO (variable)
    breakpoint is disabled

ida_dbg.BPTCK_NONE (variable)
    breakpoint does not exist

ida_dbg.BPTCK_YES (variable)
    breakpoint is enabled

ida_dbg.BPTEV_ADDED (variable)
    Breakpoint has been added.

ida_dbg.BPTEV_CHANGED (variable)
    Breakpoint has been modified.

ida_dbg.BPTEV_REMOVED (variable)
    Breakpoint has been removed.

ida_dbg.BPT_BRK (variable)
    suspend execution upon hit

ida_dbg.BPT_ELANG_SHIFT (variable)
    index of the extlang (scripting language) of the condition

ida_dbg.BPT_ENABLED (variable)
    enabled?

ida_dbg.BPT_LOWCND (variable)
    condition is calculated at low level (on the server side)

ida_dbg.BPT_TRACE (variable)
    add trace information upon hit

ida_dbg.BPT_TRACEON (variable)
    enable tracing when the breakpoint is reached

ida_dbg.BPT_TRACE_BBLK (variable)
    basic block tracing

ida_dbg.BPT_TRACE_FUNC (variable)
    function tracing

ida_dbg.BPT_TRACE_INSN (variable)
    instruction tracing

ida_dbg.BPT_TRACE_TYPES (variable)
    trace insns, functions, and basic blocks. if any of BPT_TRACE_TYPES bits are set
    but BPT_TRACEON is clear, then turn off tracing for the specified trace types

ida_dbg.BPT_UPDMEM (variable)
    refresh the memory layout and contents before evaluating bpt condition

ida_dbg.BT_LOG_INSTS (variable)
    specific options for basic block tracing (see set_bblk_trace_options())
    
    log all instructions in the current basic block

ida_dbg.DBGINV_ALL (variable)
    invalidate everything

ida_dbg.DBGINV_MEMCFG (variable)
    invalidate cached process segmentation

ida_dbg.DBGINV_MEMORY (variable)
    invalidate cached memory contents

ida_dbg.DBGINV_NONE (variable)
    invalidate nothing

ida_dbg.DBGINV_REDRAW (variable)
    refresh the screen

ida_dbg.DBGINV_REGS (variable)
    invalidate cached register values

ida_dbg.DBG_Hooks (class)
    Proxy of C++ DBG_Hooks class.

ida_dbg.DBG_Hooks.__disown__ (method)

ida_dbg.DBG_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> DBG_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_dbg.DBG_Hooks.dbg_bpt (method)
    dbg_bpt(self, tid, bptea) -> int
    A user defined breakpoint was reached.
    
    @param tid: (thid_t)
    @param bptea: (::ea_t)

ida_dbg.DBG_Hooks.dbg_bpt_changed (method)
    dbg_bpt_changed(self, bptev_code, bpt)
    Breakpoint has been changed.
    
    @param bptev_code: (int) Breakpoint modification events
    @param bpt: (bpt_t *)

ida_dbg.DBG_Hooks.dbg_exception (method)
    dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
    
    @param event: (const debug_event_t *)
    @param warn: (int *) filled with:
    * -1: display an exception warning dialog if the process is suspended.
    * 0: never display an exception warning dialog.
    * 1: always display an exception warning dialog.
    @param ea: ea_t
    @param exc_code: int
    @param exc_can_cont: bool
    @param exc_ea: ea_t
    @param exc_info: char const *

ida_dbg.DBG_Hooks.dbg_finished_loading_bpts (method)
    dbg_finished_loading_bpts(self)
    Finished loading breakpoint info from idb.

ida_dbg.DBG_Hooks.dbg_information (method)
    dbg_information(self, pid, tid, ea, info)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t
    @param info: char const *

ida_dbg.DBG_Hooks.dbg_library_load (method)
    dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t
    @param modinfo_name: char const *
    @param modinfo_base: ea_t
    @param modinfo_size: asize_t

ida_dbg.DBG_Hooks.dbg_library_unload (method)
    dbg_library_unload(self, pid, tid, ea, info)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t
    @param info: char const *

ida_dbg.DBG_Hooks.dbg_process_attach (method)
    dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
    
    @param event: (const debug_event_t *)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !
    @param tid: thid_t
    @param ea: ea_t
    @param modinfo_name: char const *
    @param modinfo_base: ea_t
    @param modinfo_size: asize_t

ida_dbg.DBG_Hooks.dbg_process_detach (method)
    dbg_process_detach(self, pid, tid, ea)
    
    @param event: (const debug_event_t *)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !
    @param tid: thid_t
    @param ea: ea_t

ida_dbg.DBG_Hooks.dbg_process_exit (method)
    dbg_process_exit(self, pid, tid, ea, exit_code)
    
    @param event: (const debug_event_t *)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !
    @param tid: thid_t
    @param ea: ea_t
    @param exit_code: int

ida_dbg.DBG_Hooks.dbg_process_start (method)
    dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
    
    @param event: (const debug_event_t *)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !
    @param tid: thid_t
    @param ea: ea_t
    @param modinfo_name: char const *
    @param modinfo_base: ea_t
    @param modinfo_size: asize_t

ida_dbg.DBG_Hooks.dbg_request_error (method)
    dbg_request_error(self, failed_command, failed_dbg_notification)
    An error occurred during the processing of a request.
    
    @param failed_command: (ui_notification_t)
    @param failed_dbg_notification: (dbg_notification_t)

ida_dbg.DBG_Hooks.dbg_run_to (method)
    dbg_run_to(self, pid, tid, ea)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t

ida_dbg.DBG_Hooks.dbg_started_loading_bpts (method)
    dbg_started_loading_bpts(self)
    Started loading breakpoint info from idb.

ida_dbg.DBG_Hooks.dbg_step_into (method)
    dbg_step_into(self)

ida_dbg.DBG_Hooks.dbg_step_over (method)
    dbg_step_over(self)

ida_dbg.DBG_Hooks.dbg_step_until_ret (method)
    dbg_step_until_ret(self)

ida_dbg.DBG_Hooks.dbg_suspend_process (method)
    dbg_suspend_process(self)
    The process is now suspended.

ida_dbg.DBG_Hooks.dbg_thread_exit (method)
    dbg_thread_exit(self, pid, tid, ea, exit_code)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t
    @param exit_code: int

ida_dbg.DBG_Hooks.dbg_thread_start (method)
    dbg_thread_start(self, pid, tid, ea)
    
    @param event: (const debug_event_t *)
    @param tid: thid_t
    @param ea: ea_t

ida_dbg.DBG_Hooks.dbg_trace (method)
    dbg_trace(self, tid, ip) -> int
    A step occurred (one instruction was executed). This event notification is only
    generated if step tracing is enabled.
    
    @param tid: (thid_t) thread ID
    @param ip: (::ea_t) current instruction pointer. usually points after the
               executed instruction
    @retval 1: do not log this trace event
    @retval 0: log it

ida_dbg.DBG_Hooks.hook (method)
    hook(self) -> bool

ida_dbg.DBG_Hooks.unhook (method)
    unhook(self) -> bool

ida_dbg.DEC_ERROR (variable)
    error

ida_dbg.DEC_NOTASK (variable)
    process does not exist

ida_dbg.DEC_TIMEOUT (variable)
    timeout

ida_dbg.DOPT_BPT_MSGS (variable)
    log breakpoints

ida_dbg.DOPT_DISABLE_ASLR (variable)
    disable ASLR

ida_dbg.DOPT_END_BPT (variable)
    evaluate event condition on process end

ida_dbg.DOPT_ENTRY_BPT (variable)
    break on program entry point

ida_dbg.DOPT_EXCDLG (variable)
    exception dialogs:

ida_dbg.DOPT_FAST_STEP (variable)
    prevent debugger memory refreshes when single-stepping

ida_dbg.DOPT_INFO_BPT (variable)
    break on debugging information

ida_dbg.DOPT_INFO_MSGS (variable)
    log debugging info events

ida_dbg.DOPT_LIB_BPT (variable)
    break on library load/unload

ida_dbg.DOPT_LIB_MSGS (variable)
    log library loads/unloads

ida_dbg.DOPT_LOAD_DINFO (variable)
    automatically load debug files (pdb)

ida_dbg.DOPT_REAL_MEMORY (variable)
    do not hide breakpoint instructions

ida_dbg.DOPT_REDO_STACK (variable)
    reconstruct the stack

ida_dbg.DOPT_SEGM_MSGS (variable)
    log debugger segments modifications

ida_dbg.DOPT_START_BPT (variable)
    break on process start

ida_dbg.DOPT_TEMP_HWBPT (variable)
    when possible use hardware bpts for temp bpts

ida_dbg.DOPT_THREAD_BPT (variable)
    break on thread start/exit

ida_dbg.DOPT_THREAD_MSGS (variable)
    log thread starts/exits

ida_dbg.DSTATE_NOTASK (variable)
    no process is currently debugged

ida_dbg.DSTATE_RUN (variable)
    process is running

ida_dbg.DSTATE_SUSP (variable)
    process is suspended and will not continue

ida_dbg.EXCDLG_ALWAYS (variable)
    always display

ida_dbg.EXCDLG_NEVER (variable)
    never display exception dialogs

ida_dbg.EXCDLG_UNKNOWN (variable)
    display for unknown exceptions

ida_dbg.FT_LOG_RET (variable)
    specific options for function tracing (see set_func_trace_options())
    
    function tracing will log returning instructions

ida_dbg.IT_LOG_SAME_IP (variable)
    specific options for instruction tracing (see set_insn_trace_options())
    
    instruction tracing will log new instructions even when IP doesn't change

ida_dbg.SRCIT_EXPR (variable)
    an expression (a+b*c)

ida_dbg.SRCIT_FUNC (variable)
    function

ida_dbg.SRCIT_LOCVAR (variable)
    a stack, register, or register-relative local variable or parameter

ida_dbg.SRCIT_MODULE (variable)
    module

ida_dbg.SRCIT_NONE (variable)
    unknown

ida_dbg.SRCIT_STMT (variable)
    a statement (if/while/for...)

ida_dbg.SRCIT_STTVAR (variable)
    static variable/code

ida_dbg.ST_ALREADY_LOGGED (variable)
    step tracing will be disabled when IP is already logged

ida_dbg.ST_OPTIONS_MASK (variable)
    mask of available options, to ensure compatibility with newer IDA versions

ida_dbg.ST_OVER_DEBUG_SEG (variable)
    step tracing will be disabled when IP is in a debugger segment

ida_dbg.ST_OVER_LIB_FUNC (variable)
    step tracing will be disabled when IP is in a library function

ida_dbg.ST_SKIP_LOOPS (variable)
    step tracing will try to skip loops already recorded

ida_dbg.WFNE_ANY (variable)
    return the first event (even if it doesn't suspend the process)

ida_dbg.WFNE_CONT (variable)
    continue from the suspended state

ida_dbg.WFNE_NOWAIT (variable)
    do not wait for any event, immediately return DEC_TIMEOUT (to be used with
    WFNE_CONT)

ida_dbg.WFNE_SILENT (variable)
    1: be silent, 0:display modal boxes if necessary

ida_dbg.WFNE_SUSP (variable)
    wait until the process gets suspended

ida_dbg.WFNE_USEC (variable)
    timeout is specified in microseconds (minimum non-zero timeout is 40000us)

ida_dbg.add_bpt (function)
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param bpt: (C++: const bpt_t &) Breakpoint to add. It describes the break condition, type, flags,
                location (module relative, source breakpoint or absolute) and other
                attributes.
    @param size: asize_t
    @param type: bpttype_t
    
    add_bpt(bpt) -> bool
    
    @param bpt: bpt_t const &

ida_dbg.add_path_mapping (function)
    add_path_mapping(src, dst)
    
    @param src: char const *
    @param dst: char const *

ida_dbg.add_virt_module (function)
    add_virt_module(mod) -> bool
    
    @param mod: modinfo_t const *

ida_dbg.attach_process (function)
    attach_process(pid=pid_t(-1), event_id=-1) -> int
    Attach the debugger to a running process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_attach}
    @note: This function shouldn't be called as a request if NO_PROCESS is used.
    
    @param pid: (C++: pid_t) PID of the process to attach to. If NO_PROCESS, a dialog box will
                interactively ask the user for the process to attach to.
    @retval -4: debugger was not inited
    @retval -3: the attaching is not supported
    @retval -2: impossible to find a compatible process
    @retval -1: impossible to attach to the given process (process died, privilege
                needed, not supported by the debugger plugin, ...)
    @retval 0: the user cancelled the attaching to the process
    @retval 1: the debugger properly attached to the process

ida_dbg.bpt_location_t (class)
    Proxy of C++ bpt_location_t class.

ida_dbg.bpt_location_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.__init__ (method)
    __init__(self) -> bpt_location_t

ida_dbg.bpt_location_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: bpt_location_t const &

ida_dbg.bpt_location_t.compare (method)
    compare(self, r) -> int
    Lexically compare two breakpoint locations. Bpt locations are first compared
    based on type (i.e. BPLT_ABS < BPLT_REL). BPLT_ABS locations are compared based
    on their ea values. For all other location types, locations are first compared
    based on their string (path/filename/symbol), then their offset/lineno.
    
    @param r: (C++: const bpt_location_t &) bpt_location_t const &

ida_dbg.bpt_location_t.ea (method)
    ea(self) -> ea_t
    Get address (BPLT_ABS)

ida_dbg.bpt_location_t.is_empty_path (method)
    is_empty_path(self) -> bool
    No path/filename specified? (BPLT_REL, BPLT_SRC)

ida_dbg.bpt_location_t.lineno (method)
    lineno(self) -> int
    Get line number (BPLT_SRC)

ida_dbg.bpt_location_t.offset (method)
    offset(self) -> uval_t
    Get offset (BPLT_REL, BPLT_SYM)

ida_dbg.bpt_location_t.path (method)
    path(self) -> char const *
    Get path/filename (BPLT_REL, BPLT_SRC)

ida_dbg.bpt_location_t.set_abs_bpt (method)
    set_abs_bpt(self, a)
    Specify an absolute address location.
    
    @param a: (C++: ea_t)

ida_dbg.bpt_location_t.set_rel_bpt (method)
    set_rel_bpt(self, mod, _offset)
    Specify a relative address location.
    
    @param mod: (C++: const char *) char const *
    @param _offset: (C++: uval_t)

ida_dbg.bpt_location_t.set_src_bpt (method)
    set_src_bpt(self, fn, _lineno)
    Specify a source level location.
    
    @param fn: (C++: const char *) char const *
    @param _lineno: (C++: int)

ida_dbg.bpt_location_t.set_sym_bpt (method)
    set_sym_bpt(self, _symbol, _offset=0)
    Specify a symbolic location.
    
    @param _symbol: (C++: const char *) char const *
    @param _offset: (C++: uval_t)

ida_dbg.bpt_location_t.symbol (method)
    symbol(self) -> char const *
    Get symbol name (BPLT_SYM)

ida_dbg.bpt_location_t.type (method)
    type(self) -> bpt_loctype_t
    Get bpt type.

ida_dbg.bpt_t (class)
    Proxy of C++ bpt_t class.

ida_dbg.bpt_t.__init__ (method)
    __init__(self) -> bpt_t

ida_dbg.bpt_t.badbpt (method)
    badbpt(self) -> bool
    Failed to write bpt to process memory?

ida_dbg.bpt_t.bptid (variable)
    Internal breakpoint id.

ida_dbg.bpt_t.cb (variable)
    size of this structure

ida_dbg.bpt_t.cndidx (variable)
    Internal number of the condition (<0-none)

ida_dbg.bpt_t.ea (variable)
    Address, if known. For BPLT_SRC, index into an internal data struct.

ida_dbg.bpt_t.enabled (method)
    enabled(self) -> bool
    Is breakpoint enabled?

ida_dbg.bpt_t.flags (variable)
    Breakpoint property bits

ida_dbg.bpt_t.get_cnd_elang_idx (method)
    get_cnd_elang_idx(self) -> size_t

ida_dbg.bpt_t.get_size (method)
    get_size(self) -> int
    Get bpt size.

ida_dbg.bpt_t.is_absbpt (method)
    is_absbpt(self) -> bool
    Is absolute address breakpoint?

ida_dbg.bpt_t.is_active (method)
    is_active(self) -> bool
    Written completely to process?

ida_dbg.bpt_t.is_compiled (method)
    is_compiled(self) -> bool
    Condition has been compiled?

ida_dbg.bpt_t.is_hwbpt (method)
    is_hwbpt(self) -> bool
    Is hardware breakpoint?

ida_dbg.bpt_t.is_inactive (method)
    is_inactive(self) -> bool
    Not written to process at all?

ida_dbg.bpt_t.is_low_level (method)
    is_low_level(self) -> bool
    Is bpt condition calculated at low level?

ida_dbg.bpt_t.is_page_bpt (method)
    is_page_bpt(self) -> bool
    Page breakpoint?

ida_dbg.bpt_t.is_partially_active (method)
    is_partially_active(self) -> bool
    Written partially to process?

ida_dbg.bpt_t.is_relbpt (method)
    is_relbpt(self) -> bool
    Is relative address breakpoint?

ida_dbg.bpt_t.is_srcbpt (method)
    is_srcbpt(self) -> bool
    Is source level breakpoint?

ida_dbg.bpt_t.is_symbpt (method)
    is_symbpt(self) -> bool
    Is symbolic breakpoint?

ida_dbg.bpt_t.is_tracemodebpt (method)
    is_tracemodebpt(self) -> bool
    Does breakpoint trace anything?

ida_dbg.bpt_t.is_traceoffbpt (method)
    is_traceoffbpt(self) -> bool
    Is this a tracing breakpoint, and is tracing disabled?

ida_dbg.bpt_t.is_traceonbpt (method)
    is_traceonbpt(self) -> bool
    Is this a tracing breakpoint, and is tracing enabled?

ida_dbg.bpt_t.listbpt (method)
    listbpt(self) -> bool
    Include in the bpt list?

ida_dbg.bpt_t.loc (variable)
    Location.

ida_dbg.bpt_t.pass_count (variable)
    Number of times the breakpoint is hit before stopping (default is 0: stop
    always)

ida_dbg.bpt_t.pid (variable)
    breakpoint process id

ida_dbg.bpt_t.props (variable)
    Internal breakpoint properties

ida_dbg.bpt_t.set_abs_bpt (method)
    set_abs_bpt(self, a)
    Set bpt location to an absolute address.
    
    @param a: (C++: ea_t)

ida_dbg.bpt_t.set_rel_bpt (method)
    set_rel_bpt(self, mod, o)
    Set bpt location to a relative address.
    
    @param mod: (C++: const char *) char const *
    @param o: (C++: uval_t)

ida_dbg.bpt_t.set_src_bpt (method)
    set_src_bpt(self, fn, lineno)
    Set bpt location to a source line.
    
    @param fn: (C++: const char *) char const *
    @param lineno: (C++: int)

ida_dbg.bpt_t.set_sym_bpt (method)
    set_sym_bpt(self, sym, o)
    Set bpt location to a symbol.
    
    @param sym: (C++: const char *) char const *
    @param o: (C++: uval_t)

ida_dbg.bpt_t.set_trace_action (method)
    set_trace_action(self, enable, trace_types) -> bool
    Configure tracing options.
    
    @param enable: (C++: bool)
    @param trace_types: (C++: int)

ida_dbg.bpt_t.size (variable)
    Size of the breakpoint (0 for software breakpoints)

ida_dbg.bpt_t.tid (variable)
    breakpoint thread id

ida_dbg.bpt_t.type (variable)
    Breakpoint type.

ida_dbg.bpt_vec_t (class)
    Proxy of C++ qvector< bpt_t > class.

ida_dbg.bpt_vec_t.__getitem__ (method)
    __getitem__(self, i) -> bpt_t
    
    @param i: size_t

ida_dbg.bpt_vec_t.__init__ (method)
    __init__(self) -> bpt_vec_t
    __init__(self, x) -> bpt_vec_t
    
    @param x: qvector< bpt_t > const &

ida_dbg.bpt_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_dbg.bpt_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: bpt_t const &

ida_dbg.bpt_vec_t.at (method)
    at(self, _idx) -> bpt_t
    
    @param _idx: size_t

ida_dbg.bpt_vec_t.begin (method)
    begin(self) -> bpt_t

ida_dbg.bpt_vec_t.capacity (method)
    capacity(self) -> size_t

ida_dbg.bpt_vec_t.clear (method)
    clear(self)

ida_dbg.bpt_vec_t.empty (method)
    empty(self) -> bool

ida_dbg.bpt_vec_t.end (method)
    end(self) -> bpt_t

ida_dbg.bpt_vec_t.erase (method)
    erase(self, it) -> bpt_t
    
    @param it: qvector< bpt_t >::iterator
    
    erase(self, first, last) -> bpt_t
    
    @param first: qvector< bpt_t >::iterator
    @param last: qvector< bpt_t >::iterator

ida_dbg.bpt_vec_t.extract (method)
    extract(self) -> bpt_t

ida_dbg.bpt_vec_t.grow (method)
    grow(self, x=bpt_t())
    
    @param x: bpt_t const &

ida_dbg.bpt_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: bpt_t *
    @param len: size_t

ida_dbg.bpt_vec_t.insert (method)
    insert(self, it, x) -> bpt_t
    
    @param it: qvector< bpt_t >::iterator
    @param x: bpt_t const &

ida_dbg.bpt_vec_t.pop_back (method)
    pop_back(self)

ida_dbg.bpt_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: bpt_t const &
    
    push_back(self) -> bpt_t

ida_dbg.bpt_vec_t.qclear (method)
    qclear(self)

ida_dbg.bpt_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dbg.bpt_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: bpt_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dbg.bpt_vec_t.size (method)
    size(self) -> size_t

ida_dbg.bpt_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< bpt_t > &

ida_dbg.bpt_vec_t.truncate (method)
    truncate(self)

ida_dbg.bptaddrs_t (class)
    Proxy of C++ bptaddrs_t class.

ida_dbg.bptaddrs_t.__init__ (method)
    __init__(self) -> bptaddrs_t

ida_dbg.bring_debugger_to_front (function)
    bring_debugger_to_front()

ida_dbg.check_bpt (function)
    check_bpt(ea) -> int
    Check the breakpoint at the specified address.
    
    @param ea: (C++: ea_t)
    @return: one of Breakpoint status codes

ida_dbg.choose_trace_file (function)
    choose_trace_file() -> str
    Show the choose trace dialog.

ida_dbg.clear_requests_queue (function)
    clear_requests_queue()
    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    @note: If a request is currently running, this one isn't stopped.

ida_dbg.clear_trace (function)
    clear_trace()
    Clear all events in the trace buffer. \sq{Type, Synchronous function - available
    as request, Notification, none (synchronous function)}

ida_dbg.collect_stack_trace (function)
    collect_stack_trace(tid, trace) -> bool
    
    @param tid: thid_t
    @param trace: call_stack_t *

ida_dbg.continue_process (function)
    continue_process() -> bool
    Continue the execution of the process in the debugger. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous function)}
    @note: The continue_process() function can be called from a notification handler
           to force the continuation of the process. In this case the request queue
           will not be examined, IDA will simply resume execution. Usually it makes
           sense to call request_continue_process() followed by run_requests(), so
           that IDA will first start a queued request (if any) and then resume the
           application.

ida_dbg.create_source_viewer (function)
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
    Create a source code view.
    
    @param out_ccv: (C++: TWidget **)
    @param parent: (C++: TWidget *)
    @param custview: (C++: TWidget *)
    @param sf: (C++: source_file_ptr)
    @param lines: (C++: strvec_t *)
    @param lnnum: (C++: int)
    @param colnum: (C++: int)
    @param flags: (C++: int)

ida_dbg.dbg_add_bpt_tev (function)
    dbg_add_bpt_tev(tid, ea, bp) -> bool
    Add a new breakpoint trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ea: (C++: ea_t)
    @param bp: (C++: ea_t)
    @return: false if the operation failed, true otherwise

ida_dbg.dbg_add_call_tev (function)
    dbg_add_call_tev(tid, caller, callee)
    Add a new call trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param caller: (C++: ea_t)
    @param callee: (C++: ea_t)

ida_dbg.dbg_add_debug_event (function)
    dbg_add_debug_event(event)
    Add a new debug event to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param event: (C++: debug_event_t *)

ida_dbg.dbg_add_insn_tev (function)
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
    Add a new instruction trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ea: (C++: ea_t)
    @param save: (C++: save_reg_values_t) enum save_reg_values_t
    @return: false if the operation failed, true otherwise

ida_dbg.dbg_add_many_tevs (function)
    dbg_add_many_tevs(new_tevs) -> bool
    Add many new trace elements to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param new_tevs: (C++: tevinforeg_vec_t *)
    @return: false if the operation failed for any tev_info_t object

ida_dbg.dbg_add_ret_tev (function)
    dbg_add_ret_tev(tid, ret_insn, return_to)
    Add a new return trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ret_insn: (C++: ea_t)
    @param return_to: (C++: ea_t)

ida_dbg.dbg_add_tev (function)
    dbg_add_tev(type, tid, address)
    Add a new trace element to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param type: (C++: tev_type_t) enum tev_type_t
    @param tid: (C++: thid_t)
    @param address: (C++: ea_t)

ida_dbg.dbg_add_thread (function)
    dbg_add_thread(tid)
    Add a thread to the current trace. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param tid: (C++: thid_t)

ida_dbg.dbg_bin_search (function)
    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str
    
    @param start_ea: ea_t
    @param end_ea: ea_t
    @param data: compiled_binpat_vec_t const &
    @param srch_flags: int

ida_dbg.dbg_bpt (variable)
    A user defined breakpoint was reached.

ida_dbg.dbg_bpt_changed (variable)
    Breakpoint has been changed.

ida_dbg.dbg_can_query (function)
    dbg_can_query() -> bool
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    
    @return: Boolean

ida_dbg.dbg_del_thread (function)
    dbg_del_thread(tid)
    Delete a thread from the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)

ida_dbg.dbg_finished_loading_bpts (variable)
    Finished loading breakpoint info from idb.

ida_dbg.dbg_is_loaded (function)
    dbg_is_loaded() -> bool
    Checks if a debugger is loaded
    
    @return: Boolean

ida_dbg.dbg_last (variable)
    The last debugger notification code.

ida_dbg.dbg_process_attach (variable)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !

ida_dbg.dbg_process_detach (variable)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !

ida_dbg.dbg_process_exit (variable)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !

ida_dbg.dbg_process_start (variable)
    @note: This event notification is also an asynchronous function result
           notification for start_process() !

ida_dbg.dbg_request_error (variable)
    An error occurred during the processing of a request.

ida_dbg.dbg_started_loading_bpts (variable)
    Started loading breakpoint info from idb.

ida_dbg.dbg_suspend_process (variable)
    The process is now suspended.
    
    @note: This event notification is also an asynchronous function result
           notification for suspend_process() !

ida_dbg.dbg_trace (variable)
    A step occurred (one instruction was executed). This event notification is only
    generated if step tracing is enabled.
    
    @retval 1: do not log this trace event
    @retval 0: log it

ida_dbg.define_exception (function)
    define_exception(code, name, desc, flags) -> char const *
    Convenience function: define new exception code.
    
    @param code: (C++: uint) exception code (cannot be 0)
    @param name: (C++: const char *) exception name (cannot be empty or nullptr)
    @param desc: (C++: const char *) exception description (maybe nullptr)
    @param flags: (C++: int) combination of Exception info flags
    @return: failure message or nullptr. You must call store_exceptions() if this
             function succeeds

ida_dbg.del_bpt (function)
    del_bpt(ea) -> bool
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) Breakpoint location
    del_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

ida_dbg.del_bptgrp (function)
    del_bptgrp(name) -> bool
    Delete a folder, bpt that were part of this folder are moved to the root folder
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param name: (C++: const char *) full path to the folder to be deleted
    @return: success

ida_dbg.del_virt_module (function)
    del_virt_module(base) -> bool
    
    @param base: ea_t const

ida_dbg.detach_process (function)
    detach_process() -> bool
    Detach the debugger from the debugged process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_detach}

ida_dbg.diff_trace_file (function)
    diff_trace_file(NONNULL_filename) -> bool
    Show difference between the current trace and the one from 'filename'.
    
    @param NONNULL_filename: (C++: const char *) char const *

ida_dbg.disable_bblk_trace (function)
    disable_bblk_trace() -> bool

ida_dbg.disable_bpt (function)
    disable_bpt(ea) -> bool
    
    @param ea: ea_t
    
    disable_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

ida_dbg.disable_func_trace (function)
    disable_func_trace() -> bool

ida_dbg.disable_insn_trace (function)
    disable_insn_trace() -> bool

ida_dbg.disable_step_trace (function)
    disable_step_trace() -> bool

ida_dbg.edit_manual_regions (function)
    edit_manual_regions()

ida_dbg.enable_bblk_trace (function)
    enable_bblk_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.enable_bpt (function)
    enable_bpt(ea, enable=True) -> bool
    
    @param ea: ea_t
    @param enable: bool
    
    enable_bpt(bptloc, enable=True) -> bool
    
    @param bptloc: bpt_location_t const &
    @param enable: bool

ida_dbg.enable_bptgrp (function)
    enable_bptgrp(bptgrp_name, enable=True) -> int
    Enable (or disable) all bpts in a folder \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bptgrp_name: (C++: const char *) absolute path to the folder
    @param enable: (C++: bool) by default true, enable bpts, false disable bpts
    @return: -1 an error occured 0 no changes >0 nubmers of bpts udpated

ida_dbg.enable_func_trace (function)
    enable_func_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.enable_insn_trace (function)
    enable_insn_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.enable_manual_regions (function)
    enable_manual_regions(enable)
    
    @param enable: bool

ida_dbg.enable_step_trace (function)
    enable_step_trace(enable=1) -> bool
    
    @param enable: int

ida_dbg.eval_ctx_t (class)
    Proxy of C++ eval_ctx_t class.

ida_dbg.eval_ctx_t.__init__ (method)
    __init__(self, _ea) -> eval_ctx_t
    
    @param _ea: ea_t

ida_dbg.exist_bpt (function)
    exist_bpt(ea) -> bool
    Does a breakpoint exist at the given location?
    
    @param ea: (C++: ea_t)

ida_dbg.exit_process (function)
    exit_process() -> bool
    Terminate the debugging of the current process. \sq{Type, Asynchronous function
    - available as Request, Notification, dbg_process_exit}

ida_dbg.find_bpt (function)
    find_bpt(bptloc, bpt) -> bool
    Find a breakpoint by location. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) Breakpoint location
    @param bpt: (C++: bpt_t *) bpt is filled if the breakpoint was found

ida_dbg.get_bblk_trace_options (function)
    get_bblk_trace_options() -> int
    Get current basic block tracing options. Also see BT_LOG_INSTS \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

ida_dbg.get_bpt (function)
    get_bpt(ea, bpt) -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param ea: (C++: ea_t) any address in the breakpoint range
    @param bpt: (C++: bpt_t *) if not nullptr, is filled with the characteristics.
    @return: false if no breakpoint exists

ida_dbg.get_bpt_group (function)
    get_bpt_group(bptloc) -> str
    Retrieve the absolute path to the folder of the bpt based on the bpt_location
    find_bpt is called to retrieve the bpt \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) bptlocation of the bpt
    @return: breakpoint correclty moved to the directory
    success

ida_dbg.get_bpt_qty (function)
    get_bpt_qty() -> int
    Get number of breakpoints. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

ida_dbg.get_bpt_tev_ea (function)
    get_bpt_tev_ea(n) -> ea_t
    Get the address associated to a read, read/write or execution trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a read, read/write or execution trace event.
    @note: Usually, a breakpoint is associated with a read, read/write or execution
           trace event. However, the returned address could be any address in the
           range of this breakpoint. If the breakpoint was deleted after the trace
           event, the address no longer corresponds to a valid breakpoint.

ida_dbg.get_bptloc_string (function)
    get_bptloc_string(i) -> char const *
    
    @param i: int

ida_dbg.get_call_tev_callee (function)
    get_call_tev_callee(n) -> ea_t
    Get the called function from a function call trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function call event.

ida_dbg.get_current_source_file (function)
    get_current_source_file() -> str

ida_dbg.get_current_source_line (function)
    get_current_source_line() -> int

ida_dbg.get_current_thread (function)
    get_current_thread() -> thid_t
    Get current thread ID. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

ida_dbg.get_dbg_byte (function)
    get_dbg_byte(ea) -> bool
    Get one byte of the debugged process memory.
    
    @param ea: (C++: ea_t) linear address
    @return: true success
    false address inaccessible or debugger not running

ida_dbg.get_dbg_memory_info (function)
    get_dbg_memory_info(ranges) -> int
    
    @param ranges: meminfo_vec_t *

ida_dbg.get_dbg_reg_info (function)
    get_dbg_reg_info(regname, ri) -> bool
    Get register information \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param regname: (C++: const char *) char const *
    @param ri: (C++: register_info_t *)

ida_dbg.get_debug_event (function)
    get_debug_event() -> debug_event_t
    Get the current debugger event.

ida_dbg.get_debugger_event_cond (function)
    get_debugger_event_cond() -> char const *

ida_dbg.get_first_module (function)
    get_first_module(modinfo) -> bool
    
    @param modinfo: modinfo_t *

ida_dbg.get_func_trace_options (function)
    get_func_trace_options() -> int
    Get current function tracing options. Also see FT_LOG_RET \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

ida_dbg.get_global_var (function)
    get_global_var(prov, ea, name, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param name: char const *
    @param out: source_item_ptr *

ida_dbg.get_grp_bpts (function)
    get_grp_bpts(bpts, grp_name) -> ssize_t
    Retrieve a copy the bpts stored in a folder \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bpts: (C++: bpt_vec_t *) : pointer to a vector where the copy of bpts are stored
    @param grp_name: (C++: const char *) absolute path to the folder
    @return: number of bpts present in the vector

ida_dbg.get_insn_tev_reg_mem (function)
    get_insn_tev_reg_mem(n, memmap) -> bool
    Read the memory pointed by register values from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param memmap: (C++: memreg_infos_t *) result
    @return: false if not an instruction event or no memory is available

ida_dbg.get_insn_tev_reg_result (function)
    get_insn_tev_reg_result(n, regname, regval) -> bool
    
    @param n: int
    @param regname: char const *
    @param regval: regval_t *

ida_dbg.get_insn_tev_reg_val (function)
    get_insn_tev_reg_val(n, regname, regval) -> bool
    
    @param n: int
    @param regname: char const *
    @param regval: regval_t *

ida_dbg.get_insn_trace_options (function)
    get_insn_trace_options() -> int
    Get current instruction tracing options. Also see IT_LOG_SAME_IP \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

ida_dbg.get_ip_val (function)
    get_ip_val() -> bool
    Get value of the IP (program counter) register for the current thread. Requires
    a suspended debugger.

ida_dbg.get_local_var (function)
    get_local_var(prov, ea, name, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param name: char const *
    @param out: source_item_ptr *

ida_dbg.get_local_vars (function)
    get_local_vars(prov, ea, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param out: source_items_t *

ida_dbg.get_manual_regions (function)
    get_manual_regions(ranges)
    Returns the manual memory regions
    
    @param ranges: meminfo_vec_t *
    
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)
    get_manual_regions() -> [(int, int, str, str, int, int, int), ...] or None

ida_dbg.get_module_info (function)
    get_module_info(ea, modinfo) -> bool
    
    @param ea: ea_t
    @param modinfo: modinfo_t *

ida_dbg.get_next_module (function)
    get_next_module(modinfo) -> bool
    
    @param modinfo: modinfo_t *

ida_dbg.get_process_options (function)
    get_process_options()
    Get process options. Any of the arguments may be nullptr

ida_dbg.get_process_state (function)
    get_process_state() -> int
    Return the state of the currently debugged process. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @return: one of Debugged process states

ida_dbg.get_processes (function)
    get_processes(proclist) -> ssize_t
    Take a snapshot of running processes and return their description. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param proclist: (C++: procinfo_vec_t *) array with information about each running process
    @return: number of processes or -1 on error

ida_dbg.get_reg_val (function)
    get_reg_val(regname, regval) -> bool
    Get register value as an unsigned 64-bit int.
    
    @param regname: (C++: const char *) char const *
    @param regval: regval_t *
    
    get_reg_val(regname, ival) -> bool
    
    @param regname: char const *
    @param ival: uint64 *
    
    get_reg_val(regname) -> bool, float, int
    
    @param regname: char const *

ida_dbg.get_reg_vals (function)
    get_reg_vals(tid, clsmask=-1) -> regvals_t
    Fetch live registers values for the thread
    
    @param tid: The ID of the thread to read registers for
    @param clsmask: An OR'ed mask of register classes to
           read values for (can be used to speed up the
           retrieval process)
    
    @return: a regvals_t instance (empty if an error occurs)

ida_dbg.get_ret_tev_return (function)
    get_ret_tev_return(n) -> ea_t
    Get the return address from a function return trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function return event.

ida_dbg.get_running_notification (function)
    get_running_notification() -> dbg_notification_t
    Get the notification associated (if any) with the current running request.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @return: dbg_null if no running request

ida_dbg.get_running_request (function)
    get_running_request() -> ui_notification_t
    Get the current running request. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @return: ui_null if no running request

ida_dbg.get_sp_val (function)
    get_sp_val() -> bool
    Get value of the SP register for the current thread. Requires a suspended
    debugger.

ida_dbg.get_srcinfo_provider (function)
    get_srcinfo_provider(name) -> srcinfo_provider_t *
    
    @param name: char const *

ida_dbg.get_step_trace_options (function)
    get_step_trace_options() -> int
    Get current step tracing options. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @return: Step trace options

ida_dbg.get_tev_ea (function)
    get_tev_ea(n) -> ea_t
    
    @param n: int

ida_dbg.get_tev_event (function)
    get_tev_event(n, d) -> bool
    Get the corresponding debug event, if any, for the specified tev object.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param d: (C++: debug_event_t *) result
    @return: false if the tev_t object doesn't have any associated debug event, true
             otherwise, with the debug event in "d".

ida_dbg.get_tev_info (function)
    get_tev_info(n, tev_info) -> bool
    Get main information about a trace event. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param tev_info: (C++: tev_info_t *) result
    @return: success

ida_dbg.get_tev_memory_info (function)
    get_tev_memory_info(n, mi) -> bool
    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param mi: (C++: meminfo_vec_t *) result
    @return: false if the tev_t object is not of type tev_mem, true otherwise, with
             the new memory layout in "mi".

ida_dbg.get_tev_qty (function)
    get_tev_qty() -> int
    Get number of trace events available in trace buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

ida_dbg.get_tev_reg_mem (function)

ida_dbg.get_tev_reg_mem_ea (function)

ida_dbg.get_tev_reg_mem_qty (function)

ida_dbg.get_tev_reg_val (function)

ida_dbg.get_tev_tid (function)
    get_tev_tid(n) -> int
    
    @param n: int

ida_dbg.get_tev_type (function)
    get_tev_type(n) -> int
    
    @param n: int

ida_dbg.get_thread_qty (function)
    get_thread_qty() -> int
    Get number of threads. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

ida_dbg.get_trace_base_address (function)
    get_trace_base_address() -> ea_t
    Get the base address of the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: the base address of the currently loaded trace

ida_dbg.get_trace_dynamic_register_set (function)
    get_trace_dynamic_register_set(idaregs)
    Get dynamic register set of current trace.
    
    @param idaregs: (C++: dynamic_register_set_t *)

ida_dbg.get_trace_file_desc (function)
    get_trace_file_desc(filename) -> str
    Get the file header of the specified trace file.
    
    @param filename: (C++: const char *) char const *

ida_dbg.get_trace_platform (function)
    get_trace_platform() -> char const *
    Get platform name of current trace.

ida_dbg.getn_bpt (function)
    getn_bpt(n, bpt) -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param n: (C++: int) number of breakpoint, is in range 0..get_bpt_qty()-1
    @param bpt: (C++: bpt_t *) filled with the characteristics.
    @return: false if no breakpoint exists

ida_dbg.getn_thread (function)
    getn_thread(n) -> thid_t
    Get the ID of a thread. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1
    @return: NO_THREAD if the thread doesn't exist.

ida_dbg.getn_thread_name (function)
    getn_thread_name(n) -> char const *
    Get the NAME of a thread \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1 or -1 for the
              current thread
    @return: thread name or nullptr if the thread doesn't exist.

ida_dbg.graph_trace (function)
    graph_trace() -> bool
    Show the trace callgraph.

ida_dbg.handle_debug_event (function)
    handle_debug_event(ev, rqflags) -> int
    
    @param ev: debug_event_t const *
    @param rqflags: int

ida_dbg.hide_all_bpts (function)
    hide_all_bpts() -> int

ida_dbg.internal_get_sreg_base (function)
    internal_get_sreg_base(tid, sreg_value) -> ea_t
    Get the sreg base, for the given thread.
    
    @param tid: thid_t
    @param sreg_value: int
    @return: The sreg base, or BADADDR on failure.

ida_dbg.internal_ioctl (function)
    internal_ioctl(fn, buf, poutbuf, poutsize) -> int
    
    @param fn: int
    @param buf: void const *
    @param poutbuf: void **
    @param poutsize: ssize_t *

ida_dbg.invalidate_dbg_state (function)
    invalidate_dbg_state(dbginv) -> int
    Invalidate cached debugger information. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param dbginv: (C++: int) Debugged process invalidation options
    @return: current debugger state (one of Debugged process states)

ida_dbg.invalidate_dbgmem_config (function)
    invalidate_dbgmem_config()
    Invalidate the debugged process memory configuration. Call this function if the
    debugged process might have changed its memory layout (allocated more memory,
    for example)

ida_dbg.invalidate_dbgmem_contents (function)
    invalidate_dbgmem_contents(ea, size)
    Invalidate the debugged process memory contents. Call this function each time
    the process has been stopped or the process memory is modified. If ea ==
    BADADDR, then the whole memory contents will be invalidated
    
    @param ea: (C++: ea_t)
    @param size: (C++: asize_t)

ida_dbg.is_bblk_trace_enabled (function)
    is_bblk_trace_enabled() -> bool

ida_dbg.is_debugger_busy (function)
    is_debugger_busy() -> bool
    Is the debugger busy?. Some debuggers do not accept any commands while the
    debugged application is running. For such a debugger, it is unsafe to do
    anything with the database (even simple queries like get_byte may lead to
    undesired consequences). Returns: true if the debugged application is running
    under such a debugger

ida_dbg.is_debugger_memory (function)
    is_debugger_memory(ea) -> bool
    Is the address mapped to debugger memory?
    
    @param ea: (C++: ea_t)

ida_dbg.is_debugger_on (function)
    is_debugger_on() -> bool
    Is the debugger currently running?

ida_dbg.is_func_trace_enabled (function)
    is_func_trace_enabled() -> bool
    Get current state of functions tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

ida_dbg.is_insn_trace_enabled (function)
    is_insn_trace_enabled() -> bool
    Get current state of instruction tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

ida_dbg.is_reg_custom (function)
    is_reg_custom(regname) -> bool
    Does a register contain a value of a custom data type? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

ida_dbg.is_reg_float (function)
    is_reg_float(regname) -> bool
    Does a register contain a floating point value? \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

ida_dbg.is_reg_integer (function)
    is_reg_integer(regname) -> bool
    Does a register contain an integer value? \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

ida_dbg.is_request_running (function)
    is_request_running() -> bool
    Is a request currently running?

ida_dbg.is_step_trace_enabled (function)
    is_step_trace_enabled() -> bool
    Get current state of step tracing. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

ida_dbg.is_valid_dstate (function)
    is_valid_dstate(state) -> bool
    
    @param state: int

ida_dbg.is_valid_trace_file (function)
    is_valid_trace_file(filename) -> bool
    Is the specified file a valid trace file for the current database?
    
    @param filename: (C++: const char *) char const *

ida_dbg.list_bptgrps (function)
    list_bptgrps(bptgrps) -> size_t
    Retrieve the list of absolute path of all folders of bpt dirtree \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param bptgrps: (C++: qstrvec_t *) list of absolute path in the bpt dirtree
    @return: number of folders returned
    list_bptgrps() -> [str, ...]

ida_dbg.load_debugger (function)
    load_debugger(dbgname, use_remote) -> bool
    
    @param dbgname: char const *
    @param use_remote: bool

ida_dbg.load_trace_file (function)
    load_trace_file(filename) -> str
    Load a recorded trace file in the 'Tracing' window. If the call succeeds and
    'buf' is not null, the description of the trace stored in the binary trace file
    will be returned in 'buf'
    
    @param filename: (C++: const char *) char const *

ida_dbg.memreg_info_t (class)
    Proxy of C++ memreg_info_t class.

ida_dbg.memreg_info_t.__init__ (method)
    __init__(self) -> memreg_info_t

ida_dbg.memreg_info_t.get_bytes (method)
    get_bytes(self) -> PyObject *

ida_dbg.memreg_infos_t (class)
    Proxy of C++ qvector< memreg_info_t > class.

ida_dbg.memreg_infos_t.__getitem__ (method)
    __getitem__(self, i) -> memreg_info_t
    
    @param i: size_t

ida_dbg.memreg_infos_t.__init__ (method)
    __init__(self) -> memreg_infos_t
    __init__(self, x) -> memreg_infos_t
    
    @param x: qvector< memreg_info_t > const &

ida_dbg.memreg_infos_t.__len__ (method)
    __len__(self) -> size_t

ida_dbg.memreg_infos_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: memreg_info_t const &

ida_dbg.memreg_infos_t.at (method)
    at(self, _idx) -> memreg_info_t
    
    @param _idx: size_t

ida_dbg.memreg_infos_t.begin (method)
    begin(self) -> memreg_info_t

ida_dbg.memreg_infos_t.capacity (method)
    capacity(self) -> size_t

ida_dbg.memreg_infos_t.clear (method)
    clear(self)

ida_dbg.memreg_infos_t.empty (method)
    empty(self) -> bool

ida_dbg.memreg_infos_t.end (method)
    end(self) -> memreg_info_t

ida_dbg.memreg_infos_t.erase (method)
    erase(self, it) -> memreg_info_t
    
    @param it: qvector< memreg_info_t >::iterator
    
    erase(self, first, last) -> memreg_info_t
    
    @param first: qvector< memreg_info_t >::iterator
    @param last: qvector< memreg_info_t >::iterator

ida_dbg.memreg_infos_t.extract (method)
    extract(self) -> memreg_info_t

ida_dbg.memreg_infos_t.grow (method)
    grow(self, x=memreg_info_t())
    
    @param x: memreg_info_t const &

ida_dbg.memreg_infos_t.inject (method)
    inject(self, s, len)
    
    @param s: memreg_info_t *
    @param len: size_t

ida_dbg.memreg_infos_t.insert (method)
    insert(self, it, x) -> memreg_info_t
    
    @param it: qvector< memreg_info_t >::iterator
    @param x: memreg_info_t const &

ida_dbg.memreg_infos_t.pop_back (method)
    pop_back(self)

ida_dbg.memreg_infos_t.push_back (method)
    push_back(self, x)
    
    @param x: memreg_info_t const &
    
    push_back(self) -> memreg_info_t

ida_dbg.memreg_infos_t.qclear (method)
    qclear(self)

ida_dbg.memreg_infos_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dbg.memreg_infos_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: memreg_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dbg.memreg_infos_t.size (method)
    size(self) -> size_t

ida_dbg.memreg_infos_t.swap (method)
    swap(self, r)
    
    @param r: qvector< memreg_info_t > &

ida_dbg.memreg_infos_t.truncate (method)
    truncate(self)

ida_dbg.put_dbg_byte (function)
    put_dbg_byte(ea, x) -> bool
    Change one byte of the debugged process memory.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint32) byte value
    @return: true if the process memory has been modified

ida_dbg.read_dbg_memory (function)
    read_dbg_memory(ea, buffer, size) -> ssize_t
    
    @param ea: ea_t
    @param buffer: void *
    @param size: size_t

ida_dbg.refresh_debugger_memory (function)
    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    
    @return: Nothing

ida_dbg.rename_bptgrp (function)
    rename_bptgrp(old_name, new_name) -> bool
    Rename a folder of bpt dirtree \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param old_name: (C++: const char *) absolute path to the folder to be renamed
    @param new_name: (C++: const char *) absolute path of the new folder name
    @return: success

ida_dbg.request_add_bpt (function)
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    Post an add_bpt(const bpt_t &) request.
    
    @param ea: ea_t
    @param size: asize_t
    @param type: bpttype_t
    
    request_add_bpt(bpt) -> bool
    
    @param bpt: bpt_t const &

ida_dbg.request_attach_process (function)
    request_attach_process(pid, event_id) -> int
    Post an attach_process() request.
    
    @param pid: (C++: pid_t)
    @param event_id: (C++: int)

ida_dbg.request_clear_trace (function)
    request_clear_trace()
    Post a clear_trace() request.

ida_dbg.request_continue_process (function)
    request_continue_process() -> bool
    Post a continue_process() request.
    @note: This requires an explicit call to run_requests()

ida_dbg.request_del_bpt (function)
    request_del_bpt(ea) -> bool
    Post a del_bpt(const bpt_location_t &) request.
    
    @param ea: ea_t
    
    request_del_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

ida_dbg.request_detach_process (function)
    request_detach_process() -> bool
    Post a detach_process() request.

ida_dbg.request_disable_bblk_trace (function)
    request_disable_bblk_trace() -> bool

ida_dbg.request_disable_bpt (function)
    request_disable_bpt(ea) -> bool
    
    @param ea: ea_t
    
    request_disable_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

ida_dbg.request_disable_func_trace (function)
    request_disable_func_trace() -> bool

ida_dbg.request_disable_insn_trace (function)
    request_disable_insn_trace() -> bool

ida_dbg.request_disable_step_trace (function)
    request_disable_step_trace() -> bool

ida_dbg.request_enable_bblk_trace (function)
    request_enable_bblk_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.request_enable_bpt (function)
    request_enable_bpt(ea, enable=True) -> bool
    
    @param ea: ea_t
    @param enable: bool
    
    request_enable_bpt(bptloc, enable=True) -> bool
    
    @param bptloc: bpt_location_t const &
    @param enable: bool

ida_dbg.request_enable_func_trace (function)
    request_enable_func_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.request_enable_insn_trace (function)
    request_enable_insn_trace(enable=True) -> bool
    
    @param enable: bool

ida_dbg.request_enable_step_trace (function)
    request_enable_step_trace(enable=1) -> bool
    
    @param enable: int

ida_dbg.request_exit_process (function)
    request_exit_process() -> bool
    Post an exit_process() request.

ida_dbg.request_resume_thread (function)
    request_resume_thread(tid) -> int
    Post a resume_thread() request.
    
    @param tid: (C++: thid_t)

ida_dbg.request_run_to (function)
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
    Post a run_to() request.
    
    @param ea: (C++: ea_t)
    @param pid: (C++: pid_t)

ida_dbg.request_select_thread (function)
    request_select_thread(tid) -> bool
    Post a select_thread() request.
    
    @param tid: (C++: thid_t)

ida_dbg.request_set_bblk_trace_options (function)
    request_set_bblk_trace_options(options)
    Post a set_bblk_trace_options() request.
    
    @param options: (C++: int)

ida_dbg.request_set_func_trace_options (function)
    request_set_func_trace_options(options)
    Post a set_func_trace_options() request.
    
    @param options: (C++: int)

ida_dbg.request_set_insn_trace_options (function)
    request_set_insn_trace_options(options)
    Post a set_insn_trace_options() request.
    
    @param options: (C++: int)

ida_dbg.request_set_reg_val (function)
    request_set_reg_val(regname, o) -> PyObject *
    Post a set_reg_val() request.
    
    @param regname: (C++: const char *) char const *
    @param o: PyObject *

ida_dbg.request_set_resume_mode (function)
    request_set_resume_mode(tid, mode) -> bool
    Post a set_resume_mode() request.
    
    @param tid: (C++: thid_t)
    @param mode: (C++: resume_mode_t) enum resume_mode_t

ida_dbg.request_set_step_trace_options (function)
    request_set_step_trace_options(options)
    Post a set_step_trace_options() request.
    
    @param options: (C++: int)

ida_dbg.request_start_process (function)
    request_start_process(path=None, args=None, sdir=None) -> int
    Post a start_process() request.
    
    @param path: (C++: const char *) char const *
    @param args: (C++: const char *) char const *
    @param sdir: (C++: const char *) char const *

ida_dbg.request_step_into (function)
    request_step_into() -> bool
    Post a step_into() request.

ida_dbg.request_step_over (function)
    request_step_over() -> bool
    Post a step_over() request.

ida_dbg.request_step_until_ret (function)
    request_step_until_ret() -> bool
    Post a step_until_ret() request.

ida_dbg.request_suspend_process (function)
    request_suspend_process() -> bool
    Post a suspend_process() request.

ida_dbg.request_suspend_thread (function)
    request_suspend_thread(tid) -> int
    Post a suspend_thread() request.
    
    @param tid: (C++: thid_t)

ida_dbg.resume_thread (function)
    resume_thread(tid) -> int
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

ida_dbg.retrieve_exceptions (function)
    retrieve_exceptions() -> excvec_t
    Retrieve the exception information. You may freely modify the returned vector
    and add/edit/delete exceptions You must call store_exceptions() after any
    modifications Note: exceptions with code zero, multiple exception codes or names
    are prohibited

ida_dbg.run_requests (function)
    run_requests() -> bool
    Execute requests until all requests are processed or an asynchronous function is
    called. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @return: false if not all requests could be processed (indicates an asynchronous
             function was started)
    @note: If called from a notification handler, the execution of requests will be
           postponed to the end of the execution of all notification handlers.

ida_dbg.run_to (function)
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
    Execute the process until the given address is reached. If no process is active,
    a new process is started. Technically, the debugger sets up a temporary
    breakpoint at the given address, and continues (or starts) the execution of the
    whole process. So, all threads continue their execution! \sq{Type, Asynchronous
    function - available as Request, Notification, dbg_run_to}
    
    @param ea: (C++: ea_t) target address
    @param pid: (C++: pid_t) not used yet. please do not specify this parameter.

ida_dbg.save_trace_file (function)
    save_trace_file(filename, description) -> bool
    Save the current trace in the specified file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

ida_dbg.select_thread (function)
    select_thread(tid) -> bool
    Select the given thread as the current debugged thread. All thread related
    execution functions will work on this thread. The process must be suspended to
    select a new thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) ID of the thread to select
    @return: false if the thread doesn't exist.

ida_dbg.send_dbg_command (function)
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure

ida_dbg.set_bblk_trace_options (function)
    set_bblk_trace_options(options)
    Modify basic block tracing options (see BT_LOG_INSTS)
    
    @param options: (C++: int)

ida_dbg.set_bpt_group (function)
    set_bpt_group(bpt, grp_name) -> bool
    Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists,
    it will be created \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param bpt: (C++: bpt_t &) bpt that will be moved
    @param grp_name: (C++: const char *) absolute path to the breakpoint dirtree folder
    @return: success

ida_dbg.set_bptloc_group (function)
    set_bptloc_group(bptloc, grp_name) -> bool
    Move a bpt into a folder in the breakpoint dirtree based on the bpt_location
    find_bpt is called to retrieve the bpt and then set_bpt_group if the folder
    didn't exists, it will be created \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) bptlocation of the bpt that will be moved
    @param grp_name: (C++: const char *) absolute path to the breakpoint dirtree folder
    @return: success

ida_dbg.set_bptloc_string (function)
    set_bptloc_string(s) -> int
    
    @param s: char const *

ida_dbg.set_debugger_event_cond (function)
    set_debugger_event_cond(NONNULL_evcond)
    
    @param NONNULL_evcond: char const *

ida_dbg.set_debugger_options (function)
    set_debugger_options(options) -> uint
    Set debugger options. Replaces debugger options with the specification
    combination Debugger options
    
    @param options: (C++: uint)
    @return: the old debugger options

ida_dbg.set_func_trace_options (function)
    set_func_trace_options(options)
    Modify function tracing options. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

ida_dbg.set_highlight_trace_options (function)
    set_highlight_trace_options(hilight, color, diff)
    Set highlight trace parameters.
    
    @param hilight: (C++: bool)
    @param color: (C++: bgcolor_t)
    @param diff: (C++: bgcolor_t)

ida_dbg.set_insn_trace_options (function)
    set_insn_trace_options(options)
    Modify instruction tracing options. \sq{Type, Synchronous function - available
    as request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

ida_dbg.set_manual_regions (function)
    set_manual_regions(ranges)
    
    @param ranges: meminfo_vec_t const *

ida_dbg.set_process_options (function)
    set_process_options(path, args, sdir, host, _pass, port)
    Set process options. Any of the arguments may be nullptr, which means 'do not
    modify'
    
    @param path: (C++: const char *) char const *
    @param args: (C++: const char *) char const *
    @param sdir: (C++: const char *) char const *
    @param host: (C++: const char *) char const *
    @param pass: (C++: const char *) char const *
    @param port: (C++: int)

ida_dbg.set_process_state (function)
    set_process_state(newstate, p_thid, dbginv) -> int
    Set new state for the debugged process. Notifies the IDA kernel about the change
    of the debugged process state. For example, a debugger module could call this
    function when it knows that the process is suspended for a short period of time.
    Some IDA API calls can be made only when the process is suspended. The process
    state is usually restored before returning control to the caller. You must know
    that it is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param newstate: (C++: int) new process state (one of Debugged process states) if
                     DSTATE_NOTASK is passed then the state is not changed
    @param p_thid: (C++: thid_t *) ptr to new thread id. may be nullptr or pointer to NO_THREAD. the
                   pointed variable will contain the old thread id upon return
    @param dbginv: (C++: int) Debugged process invalidation options
    @return: old debugger state (one of Debugged process states)

ida_dbg.set_reg_val (function)
    set_reg_val(regname, o) -> PyObject
    
    @param regname: char const *
    @param o: PyObject *
    
    set_reg_val(tid, regidx, o) -> bool, int
    
    @param tid: thid_t
    @param regidx: int
    @param o: PyObject *

ida_dbg.set_remote_debugger (function)
    set_remote_debugger(host, _pass, port=-1)
    Set remote debugging options. Should be used before starting the debugger.
    
    @param host: (C++: const char *) If empty, IDA will use local debugger. If nullptr, the host will
                 not be set.
    @param pass: (C++: const char *) If nullptr, the password will not be set
    @param port: (C++: int) If -1, the default port number will be used

ida_dbg.set_resume_mode (function)
    set_resume_mode(tid, mode) -> bool
    How to resume the application. Set resume mode but do not resume process.
    
    @param tid: (C++: thid_t)
    @param mode: (C++: resume_mode_t) enum resume_mode_t

ida_dbg.set_step_trace_options (function)
    set_step_trace_options(options)
    Modify step tracing options. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

ida_dbg.set_trace_base_address (function)
    set_trace_base_address(ea)
    Set the base address of the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param ea: (C++: ea_t)

ida_dbg.set_trace_dynamic_register_set (function)
    set_trace_dynamic_register_set(idaregs)
    Set dynamic register set of current trace.
    
    @param idaregs: (C++: dynamic_register_set_t &)

ida_dbg.set_trace_file_desc (function)
    set_trace_file_desc(filename, description) -> bool
    Change the description of the specified trace file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

ida_dbg.set_trace_platform (function)
    set_trace_platform(platform)
    Set platform name of current trace.
    
    @param platform: (C++: const char *) char const *

ida_dbg.set_trace_size (function)
    set_trace_size(size) -> bool
    Specify the new size of the circular buffer. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param size: (C++: int) if 0, buffer isn't circular and events are never removed. If the
                 new size is smaller than the existing number of trace events, a
                 corresponding number of trace events are removed.
    @note: If you specify 0, all available memory can be quickly used !!!

ida_dbg.srcdbg_request_step_into (function)
    srcdbg_request_step_into() -> bool

ida_dbg.srcdbg_request_step_over (function)
    srcdbg_request_step_over() -> bool

ida_dbg.srcdbg_request_step_until_ret (function)
    srcdbg_request_step_until_ret() -> bool

ida_dbg.srcdbg_step_into (function)
    srcdbg_step_into() -> bool

ida_dbg.srcdbg_step_over (function)
    srcdbg_step_over() -> bool

ida_dbg.srcdbg_step_until_ret (function)
    srcdbg_step_until_ret() -> bool

ida_dbg.start_process (function)
    start_process(path=None, args=None, sdir=None) -> int
    Start a process in the debugger. \sq{Type, Asynchronous function - available as
    Request, Notification, dbg_process_start}
    @note: You can also use the run_to() function to easily start the execution of a
           process until a given address is reached.
    @note: For all parameters, a nullptr value indicates the debugger will take the
           value from the defined Process Options.
    
    @param path: (C++: const char *) path to the executable to start
    @param args: (C++: const char *) arguments to pass to process
    @param sdir: (C++: const char *) starting directory for the process
    @retval -1: impossible to create the process
    @retval 0: the starting of the process was cancelled by the user
    @retval 1: the process was properly started

ida_dbg.step_into (function)
    step_into() -> bool
    Execute one instruction in the current thread. Other threads are kept suspended.
    \sq{Type, Asynchronous function - available as Request, Notification,
    dbg_step_into}

ida_dbg.step_over (function)
    step_over() -> bool
    Execute one instruction in the current thread, but without entering into
    functions. Others threads keep suspended. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_step_over}

ida_dbg.step_until_ret (function)
    step_until_ret() -> bool
    Execute instructions in the current thread until a function return instruction
    is executed (aka "step out"). Other threads are kept suspended. \sq{Type,
    Asynchronous function - available as Request, Notification, dbg_step_until_ret}

ida_dbg.store_exceptions (function)
    store_exceptions() -> bool
    Update the exception information stored in the debugger module by invoking its
    dbg->set_exception_info callback

ida_dbg.suspend_process (function)
    suspend_process() -> bool
    Suspend the process in the debugger. \sq{ Type,
    * Synchronous function (if in a notification handler)
    * Asynchronous function (everywhere else)
    * available as Request, Notification,
    * none (if in a notification handler)
    * dbg_suspend_process (everywhere else) }
    @note: The suspend_process() function can be called from a notification handler
           to force the stopping of the process. In this case, no notification will
           be generated. When you suspend a process, the running command is always
           aborted.

ida_dbg.suspend_thread (function)
    suspend_thread(tid) -> int
    Suspend thread. Suspending a thread may deadlock the whole application if the
    suspended was owning some synchronization objects. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

ida_dbg.tev_bpt (variable)
    write, read/write, execution trace

ida_dbg.tev_call (variable)
    a function call trace

ida_dbg.tev_event (variable)
    debug event occurred

ida_dbg.tev_info_reg_t (class)
    Proxy of C++ tev_info_reg_t class.

ida_dbg.tev_info_reg_t.__init__ (method)
    __init__(self) -> tev_info_reg_t

ida_dbg.tev_info_t (class)
    Proxy of C++ tev_info_t class.

ida_dbg.tev_info_t.__init__ (method)
    __init__(self) -> tev_info_t

ida_dbg.tev_info_t.ea (variable)
    address where the event occurred

ida_dbg.tev_info_t.tid (variable)
    thread where the event was recorded

ida_dbg.tev_info_t.type (variable)
    trace event type

ida_dbg.tev_insn (variable)
    an instruction trace

ida_dbg.tev_max (variable)
    first unused event type

ida_dbg.tev_mem (variable)
    memory layout changed

ida_dbg.tev_none (variable)
    no event

ida_dbg.tev_reg_value_t (class)
    Proxy of C++ tev_reg_value_t class.

ida_dbg.tev_reg_value_t.__init__ (method)
    __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
    
    @param _reg_idx: int
    @param _value: uint64

ida_dbg.tev_reg_values_t (class)
    Proxy of C++ qvector< tev_reg_value_t > class.

ida_dbg.tev_reg_values_t.__getitem__ (method)
    __getitem__(self, i) -> tev_reg_value_t
    
    @param i: size_t

ida_dbg.tev_reg_values_t.__init__ (method)
    __init__(self) -> tev_reg_values_t
    __init__(self, x) -> tev_reg_values_t
    
    @param x: qvector< tev_reg_value_t > const &

ida_dbg.tev_reg_values_t.__len__ (method)
    __len__(self) -> size_t

ida_dbg.tev_reg_values_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: tev_reg_value_t const &

ida_dbg.tev_reg_values_t.at (method)
    at(self, _idx) -> tev_reg_value_t
    
    @param _idx: size_t

ida_dbg.tev_reg_values_t.begin (method)
    begin(self) -> tev_reg_value_t

ida_dbg.tev_reg_values_t.capacity (method)
    capacity(self) -> size_t

ida_dbg.tev_reg_values_t.clear (method)
    clear(self)

ida_dbg.tev_reg_values_t.empty (method)
    empty(self) -> bool

ida_dbg.tev_reg_values_t.end (method)
    end(self) -> tev_reg_value_t

ida_dbg.tev_reg_values_t.erase (method)
    erase(self, it) -> tev_reg_value_t
    
    @param it: qvector< tev_reg_value_t >::iterator
    
    erase(self, first, last) -> tev_reg_value_t
    
    @param first: qvector< tev_reg_value_t >::iterator
    @param last: qvector< tev_reg_value_t >::iterator

ida_dbg.tev_reg_values_t.extract (method)
    extract(self) -> tev_reg_value_t

ida_dbg.tev_reg_values_t.grow (method)
    grow(self, x=tev_reg_value_t())
    
    @param x: tev_reg_value_t const &

ida_dbg.tev_reg_values_t.inject (method)
    inject(self, s, len)
    
    @param s: tev_reg_value_t *
    @param len: size_t

ida_dbg.tev_reg_values_t.insert (method)
    insert(self, it, x) -> tev_reg_value_t
    
    @param it: qvector< tev_reg_value_t >::iterator
    @param x: tev_reg_value_t const &

ida_dbg.tev_reg_values_t.pop_back (method)
    pop_back(self)

ida_dbg.tev_reg_values_t.push_back (method)
    push_back(self, x)
    
    @param x: tev_reg_value_t const &
    
    push_back(self) -> tev_reg_value_t

ida_dbg.tev_reg_values_t.qclear (method)
    qclear(self)

ida_dbg.tev_reg_values_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dbg.tev_reg_values_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: tev_reg_value_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dbg.tev_reg_values_t.size (method)
    size(self) -> size_t

ida_dbg.tev_reg_values_t.swap (method)
    swap(self, r)
    
    @param r: qvector< tev_reg_value_t > &

ida_dbg.tev_reg_values_t.truncate (method)
    truncate(self)

ida_dbg.tev_ret (variable)
    a function return trace

ida_dbg.tevinforeg_vec_t (class)
    Proxy of C++ qvector< tev_info_reg_t > class.

ida_dbg.tevinforeg_vec_t.__getitem__ (method)
    __getitem__(self, i) -> tev_info_reg_t
    
    @param i: size_t

ida_dbg.tevinforeg_vec_t.__init__ (method)
    __init__(self) -> tevinforeg_vec_t
    __init__(self, x) -> tevinforeg_vec_t
    
    @param x: qvector< tev_info_reg_t > const &

ida_dbg.tevinforeg_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_dbg.tevinforeg_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: tev_info_reg_t const &

ida_dbg.tevinforeg_vec_t.at (method)
    at(self, _idx) -> tev_info_reg_t
    
    @param _idx: size_t

ida_dbg.tevinforeg_vec_t.begin (method)
    begin(self) -> tev_info_reg_t

ida_dbg.tevinforeg_vec_t.capacity (method)
    capacity(self) -> size_t

ida_dbg.tevinforeg_vec_t.clear (method)
    clear(self)

ida_dbg.tevinforeg_vec_t.empty (method)
    empty(self) -> bool

ida_dbg.tevinforeg_vec_t.end (method)
    end(self) -> tev_info_reg_t

ida_dbg.tevinforeg_vec_t.erase (method)
    erase(self, it) -> tev_info_reg_t
    
    @param it: qvector< tev_info_reg_t >::iterator
    
    erase(self, first, last) -> tev_info_reg_t
    
    @param first: qvector< tev_info_reg_t >::iterator
    @param last: qvector< tev_info_reg_t >::iterator

ida_dbg.tevinforeg_vec_t.extract (method)
    extract(self) -> tev_info_reg_t

ida_dbg.tevinforeg_vec_t.grow (method)
    grow(self, x=tev_info_reg_t())
    
    @param x: tev_info_reg_t const &

ida_dbg.tevinforeg_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: tev_info_reg_t *
    @param len: size_t

ida_dbg.tevinforeg_vec_t.insert (method)
    insert(self, it, x) -> tev_info_reg_t
    
    @param it: qvector< tev_info_reg_t >::iterator
    @param x: tev_info_reg_t const &

ida_dbg.tevinforeg_vec_t.pop_back (method)
    pop_back(self)

ida_dbg.tevinforeg_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: tev_info_reg_t const &
    
    push_back(self) -> tev_info_reg_t

ida_dbg.tevinforeg_vec_t.qclear (method)
    qclear(self)

ida_dbg.tevinforeg_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dbg.tevinforeg_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: tev_info_reg_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dbg.tevinforeg_vec_t.size (method)
    size(self) -> size_t

ida_dbg.tevinforeg_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< tev_info_reg_t > &

ida_dbg.tevinforeg_vec_t.truncate (method)
    truncate(self)

ida_dbg.update_bpt (function)
    update_bpt(bpt) -> bool
    Update modifiable characteristics of an existing breakpoint. To update the
    breakpoint location, use change_bptlocs() \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    @note: Only the following fields can be modified:
    * bpt_t::cndbody
    * bpt_t::pass_count
    * bpt_t::flags
    * bpt_t::size
    * bpt_t::type
    @note: Changing some properties will require removing and then re-adding the
           breakpoint to the process memory (or the debugger backend), which can
           lead to race conditions (i.e., breakpoint(s) can be missed) in case the
           process is not suspended. Here are a list of scenarios that will require
           the breakpoint to be removed & then re-added:
    * bpt_t::size is modified
    * bpt_t::type is modified
    * bpt_t::flags's BPT_ENABLED is modified
    * bpt_t::flags's BPT_LOWCND is changed
    * bpt_t::flags's BPT_LOWCND remains set, but cndbody changed
    
    @param bpt: (C++: const bpt_t *) bpt_t const *

ida_dbg.wait_for_next_event (function)
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
    Wait for the next event.
    
    This function (optionally) resumes the process execution, and waits for a
    debugger event until a possible timeout occurs.
    
    @param wfne: (C++: int) combination of Wait for debugger event flags constants
    @param timeout: (C++: int) number of seconds to wait, -1-infinity
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)

ida_dbg.write_dbg_memory (function)
    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
    
    @param ea: ea_t
    @param py_buf: PyObject *
    @param size: size_t

ida_diskio (module)
    File I/O functions for IDA.
    
    You should not use standard C file I/O functions in modules. Use functions from
    this header, pro.h and fpro.h instead.
    
    This file also declares a call_system() function.

ida_diskio.IDA_SUBDIR_IDADIR_FIRST (variable)
    $IDADIR/subdir will be first, not last

ida_diskio.IDA_SUBDIR_IDP (variable)
    append the processor name as a subdirectory

ida_diskio.IDA_SUBDIR_ONLY_EXISTING (variable)
    only existing directories will be present

ida_diskio.LINPUT_GENERIC (variable)
    generic linput

ida_diskio.LINPUT_LOCAL (variable)
    local file

ida_diskio.LINPUT_NONE (variable)
    invalid linput

ida_diskio.LINPUT_PROCMEM (variable)
    debugged process memory (read_dbg_memory())

ida_diskio.LINPUT_RFILE (variable)
    remote file ( debugger_t::open_file, debugger_t::read_file)

ida_diskio.choose_ioport_device2 (function)
    choose_ioport_device2(_device, file, parse_params) -> bool
    
    @param _device: qstring *
    @param file: char const *
    @param parse_params: choose_ioport_parser_t *

ida_diskio.choose_ioport_parser_t (class)
    Proxy of C++ choose_ioport_parser_t class.

ida_diskio.choose_ioport_parser_t.__disown__ (method)

ida_diskio.choose_ioport_parser_t.__init__ (method)
    __init__(self) -> choose_ioport_parser_t
    
    @param self: PyObject *

ida_diskio.choose_ioport_parser_t.parse (method)
    parse(self, param, line) -> bool
    @retval true: and fill PARAM with a displayed string
    @retval false: and empty PARAM to skip the current device
    @retval false: and fill PARAM with an error message
    
    @param param: (C++: qstring *)
    @param line: (C++: const char *) char const *

ida_diskio.close_linput (function)
    close_linput(li)
    Close loader input.
    
    @param li: (C++: linput_t *)

ida_diskio.create_bytearray_linput (function)
    create_bytearray_linput(s) -> linput_t *
    Trivial memory linput.
    
    @param s: qstring const &

ida_diskio.create_generic_linput (function)
    create_generic_linput(gl) -> linput_t *
    Create a generic linput
    
    @param gl: (C++: generic_linput_t *) linput description. this object will be destroyed by close_linput()
               using "delete gl;"

ida_diskio.create_memory_linput (function)
    create_memory_linput(start, size) -> linput_t *
    Create a linput for process memory. This linput will use read_dbg_memory() to
    read data.
    
    @param start: (C++: ea_t) starting address of the input
    @param size: (C++: asize_t) size of the memory area to represent as linput if unknown, may be
                 passed as 0

ida_diskio.eclose (function)
    eclose(fp)
    
    @param fp: FILE *

ida_diskio.enumerate_files (function)
    enumerate_files(path, fname, callback) -> PyObject *
    Enumerate files in the specified directory while the callback returns 0.
    
    @param path: directory to enumerate files in
    @param fname: mask of file names to enumerate
    @param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    @return:     None in case of script errors
        tuple(code, fname) : If the callback returns non-zero

ida_diskio.enumerate_files2 (function)
    enumerate_files2(answer, answer_size, path, fname, fv) -> int
    
    @param answer: char *
    @param answer_size: size_t
    @param path: char const *
    @param fname: char const *
    @param fv: file_enumerator_t &

ida_diskio.file_enumerator_t (class)
    Proxy of C++ file_enumerator_t class.

ida_diskio.file_enumerator_t.__disown__ (method)

ida_diskio.file_enumerator_t.__init__ (method)
    __init__(self) -> file_enumerator_t
    
    @param self: PyObject *

ida_diskio.file_enumerator_t.visit_file (method)
    visit_file(self, file) -> int
    
    @param file: char const *

ida_diskio.fopenA (function)
    fopenA(file) -> FILE *
    Open a file for append in text mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.fopenM (function)
    fopenM(file) -> FILE *
    Open a file for read/write in binary mode, deny write.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.fopenRB (function)
    fopenRB(file) -> FILE *
    Open a file for read in binary mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.fopenRT (function)
    fopenRT(file) -> FILE *
    Open a file for read in text mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.fopenWB (function)
    fopenWB(file) -> FILE *
    Open a new file for write in binary mode, deny read/write. If a file exists, it
    will be removed.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.fopenWT (function)
    fopenWT(file) -> FILE *
    Open a new file for write in text mode, deny write. If a file exists, it will be
    removed.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

ida_diskio.generic_linput_t (class)
    Proxy of C++ generic_linput_t class.

ida_diskio.generic_linput_t.__init__ (method)

ida_diskio.generic_linput_t.blocksize (variable)
    preferred block size to work with read/write sizes will be in multiples of this
    number. for example, 4096 is a nice value blocksize 0 means that the filesize is
    unknown. the internal cache will be disabled in this case. also, seeks from the
    file end will fail. blocksize=-1 means error.

ida_diskio.generic_linput_t.filesize (variable)
    input file size

ida_diskio.generic_linput_t.read (method)
    read(self, off, buffer, nbytes) -> ssize_t
    
    @param off: qoff64_t
    @param buffer: void *
    @param nbytes: size_t

ida_diskio.get_ida_subdirs (function)
    get_ida_subdirs(subdir, flags=0) -> int
    Get list of directories in which to find a specific IDA resource (see IDA
    subdirectories). The order of the resulting list is as follows:
    - [$IDAUSR/subdir (0..N entries)]
    - $IDADIR/subdir
    
    @param subdir: (C++: const char *) name of the resource to list
    @param flags: (C++: int) Subdirectory modification flags bits
    @return: number of directories appended to 'dirs'

ida_diskio.get_linput_type (function)
    get_linput_type(li) -> linput_type_t
    Get linput type.
    
    @param li: (C++: linput_t *)

ida_diskio.get_special_folder (function)
    get_special_folder(csidl) -> str
    Get a folder location by CSIDL (see Common CSIDLs). Path should be of at least
    MAX_PATH size
    
    @param csidl: (C++: int)

ida_diskio.get_user_idadir (function)
    get_user_idadir() -> char const *
    Get user ida related directory.
    - if $IDAUSR is defined:
    - the first element in $IDAUSR
    - else
    - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)

ida_diskio.getsysfile (function)
    getsysfile(filename, subdir) -> str
    Search for IDA system file. This function searches for a file in:
    1. each directory specified by IDAUSR%
    2. ida directory [+ subdir] and returns the first match.
    
    @param filename: (C++: const char *) name of file to search
    @param subdir: (C++: const char *) if specified, the file is looked for in the specified
                   subdirectory of the ida directory first (see IDA subdirectories)
    @return: nullptr if not found, otherwise a pointer to full file name.

ida_diskio.idadir (function)
    idadir(subdir) -> char const *
    Get IDA directory (if subdir==nullptr) or the specified subdirectory (see IDA
    subdirectories)
    
    @param subdir: (C++: const char *) char const *

ida_diskio.ioports_fallback_t (class)
    Proxy of C++ ioports_fallback_t class.

ida_diskio.ioports_fallback_t.__disown__ (method)

ida_diskio.ioports_fallback_t.__init__ (method)
    __init__(self) -> ioports_fallback_t
    
    @param self: PyObject *

ida_diskio.ioports_fallback_t.handle (method)
    handle(self, ports, line) -> bool
    
    @param ports: ioports_t const &
    @param line: char const *

ida_diskio.open_linput (function)
    open_linput(file, remote) -> linput_t *
    Open loader input.
    
    @param file: (C++: const char *) char const *
    @param remote: (C++: bool)

ida_diskio.qlgetz (function)
    qlgetz(li, fpos) -> str
    Read a zero-terminated string from the input. If fpos == -1 then no seek will be
    performed.
    
    @param li: (C++: linput_t *)
    @param fpos: (C++: int64)

ida_diskio.read_ioports2 (function)
    read_ioports2(ports, device, file, callback=None) -> ssize_t
    
    @param ports: ioports_t *
    @param device: qstring *
    @param file: char const *
    @param callback: ioports_fallback_t *

ida_dirtree (module)
    Types involved in grouping of item into folders.
    
    The dirtree_t class is used to organize a directory tree on top of any
    collection that allows for accessing its elements by an id (inode).
    
    No requirements are imposed on the inodes apart from the forbidden value -1 (it
    is used ot denote a bad inode).
    
    The dirspec_t class is used to specialize the dirtree. It can be used to
    introduce a directory structure for:
    * local types
    * structs
    * enums
    * functions
    * names
    * etc
    
    @note: you should be manipulating dirtree_t (and, if implementing a new tree
           backend, dirspec_t) instances, not calling top-level functions in this
           file directly.

ida_dirtree.DTN_DISPLAY_NAME (variable)
    use short, displayable form of the entry name. for example, 'std::string'
    instead of 'std::basic_string<char, ...>'. Note that more than one "full name"
    can have the same displayable name.

ida_dirtree.DTN_FULL_NAME (variable)
    use long form of the entry name. That name is unique.

ida_dirtree.direntry_t (class)
    Proxy of C++ direntry_t class.

ida_dirtree.direntry_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: direntry_t const &

ida_dirtree.direntry_t.__init__ (method)
    __init__(self, i=BADIDX, d=False) -> direntry_t
    
    @param i: uval_t
    @param d: bool

ida_dirtree.direntry_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: direntry_t const &

ida_dirtree.direntry_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: direntry_t const &

ida_dirtree.direntry_t.idx (variable)
    diridx_t or inode_t

ida_dirtree.direntry_t.isdir (variable)
    is 'idx' a diridx_t, or an inode_t

ida_dirtree.direntry_t.valid (method)
    valid(self) -> bool

ida_dirtree.direntry_vec_t (class)
    Proxy of C++ qvector< direntry_t > class.

ida_dirtree.direntry_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< direntry_t > const &

ida_dirtree.direntry_vec_t.__getitem__ (method)
    __getitem__(self, i) -> direntry_t
    
    @param i: size_t

ida_dirtree.direntry_vec_t.__init__ (method)
    __init__(self) -> direntry_vec_t
    __init__(self, x) -> direntry_vec_t
    
    @param x: qvector< direntry_t > const &

ida_dirtree.direntry_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_dirtree.direntry_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< direntry_t > const &

ida_dirtree.direntry_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: direntry_t const &

ida_dirtree.direntry_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: direntry_t const &

ida_dirtree.direntry_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: direntry_t const &

ida_dirtree.direntry_vec_t.at (method)
    at(self, _idx) -> direntry_t
    
    @param _idx: size_t

ida_dirtree.direntry_vec_t.begin (method)
    begin(self) -> direntry_t

ida_dirtree.direntry_vec_t.capacity (method)
    capacity(self) -> size_t

ida_dirtree.direntry_vec_t.clear (method)
    clear(self)

ida_dirtree.direntry_vec_t.empty (method)
    empty(self) -> bool

ida_dirtree.direntry_vec_t.end (method)
    end(self) -> direntry_t

ida_dirtree.direntry_vec_t.erase (method)
    erase(self, it) -> direntry_t
    
    @param it: qvector< direntry_t >::iterator
    
    erase(self, first, last) -> direntry_t
    
    @param first: qvector< direntry_t >::iterator
    @param last: qvector< direntry_t >::iterator

ida_dirtree.direntry_vec_t.extract (method)
    extract(self) -> direntry_t

ida_dirtree.direntry_vec_t.find (method)
    find(self, x) -> direntry_t
    
    @param x: direntry_t const &

ida_dirtree.direntry_vec_t.grow (method)
    grow(self, x=direntry_t())
    
    @param x: direntry_t const &

ida_dirtree.direntry_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: direntry_t const &

ida_dirtree.direntry_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: direntry_t *
    @param len: size_t

ida_dirtree.direntry_vec_t.insert (method)
    insert(self, it, x) -> direntry_t
    
    @param it: qvector< direntry_t >::iterator
    @param x: direntry_t const &

ida_dirtree.direntry_vec_t.pop_back (method)
    pop_back(self)

ida_dirtree.direntry_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: direntry_t const &
    
    push_back(self) -> direntry_t

ida_dirtree.direntry_vec_t.qclear (method)
    qclear(self)

ida_dirtree.direntry_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dirtree.direntry_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: direntry_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dirtree.direntry_vec_t.size (method)
    size(self) -> size_t

ida_dirtree.direntry_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< direntry_t > &

ida_dirtree.direntry_vec_t.truncate (method)
    truncate(self)

ida_dirtree.dirspec_t (class)
    Proxy of C++ dirspec_t class.

ida_dirtree.dirspec_t.__disown__ (method)

ida_dirtree.dirspec_t.__init__ (method)
    __init__(self, nm=None, f=0) -> dirspec_t
    
    @param nm: char const *
    @param f: uint32

ida_dirtree.dirspec_t.get_attrs (method)
    get_attrs(self, inode) -> qstring
    
    @param inode: inode_t

ida_dirtree.dirspec_t.get_inode (method)
    get_inode(self, dirpath, name) -> inode_t
    get the entry inode in the specified directory
    
    @param dirpath: (C++: const char *) the absolute directory path with trailing slash
    @param name: (C++: const char *) the entry name in the directory
    @return: the entry inode

ida_dirtree.dirspec_t.get_name (method)
    get_name(self, inode, name_flags=DTN_FULL_NAME) -> bool
    get the entry name. for example, the structure name
    
    @param inode: (C++: inode_t) inode number of the entry
    @param name_flags: (C++: uint32) how exactly the name should be retrieved. combination of bits
                       for get_...name() methods bits
    @return: false if the entry does not exist.

ida_dirtree.dirspec_t.is_orderable (method)
    is_orderable(self) -> bool

ida_dirtree.dirspec_t.rename_inode (method)
    rename_inode(self, inode, newname) -> bool
    rename the entry
    
    @param inode: (C++: inode_t)
    @param newname: (C++: const char *)
    @return: success

ida_dirtree.dirspec_t.unlink_inode (method)
    unlink_inode(self, inode)
    
    @param inode: (C++: inode_t)

ida_dirtree.dirtree_cursor_t (class)
    Proxy of C++ dirtree_cursor_t class.

ida_dirtree.dirtree_cursor_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.__init__ (method)
    __init__(self, _parent=BADIDX, _rank=size_t(-1)) -> dirtree_cursor_t
    
    @param _parent: diridx_t
    @param _rank: size_t

ida_dirtree.dirtree_cursor_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.compare (method)
    compare(self, r) -> int
    
    @param r: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_t.is_root_cursor (method)
    is_root_cursor(self) -> bool

ida_dirtree.dirtree_cursor_t.parent (variable)
    the parent directory

ida_dirtree.dirtree_cursor_t.rank (variable)
    the index into the parent directory

ida_dirtree.dirtree_cursor_t.root_cursor (method)
    root_cursor() -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_t.set_root_cursor (method)
    set_root_cursor(self)

ida_dirtree.dirtree_cursor_t.valid (method)
    valid(self) -> bool

ida_dirtree.dirtree_cursor_t_root_cursor (function)
    dirtree_cursor_t_root_cursor() -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_vec_t (class)
    Proxy of C++ qvector< dirtree_cursor_t > class.

ida_dirtree.dirtree_cursor_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< dirtree_cursor_t > const &

ida_dirtree.dirtree_cursor_vec_t.__getitem__ (method)
    __getitem__(self, i) -> dirtree_cursor_t
    
    @param i: size_t

ida_dirtree.dirtree_cursor_vec_t.__init__ (method)
    __init__(self) -> dirtree_cursor_vec_t
    __init__(self, x) -> dirtree_cursor_vec_t
    
    @param x: qvector< dirtree_cursor_t > const &

ida_dirtree.dirtree_cursor_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_dirtree.dirtree_cursor_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< dirtree_cursor_t > const &

ida_dirtree.dirtree_cursor_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.at (method)
    at(self, _idx) -> dirtree_cursor_t
    
    @param _idx: size_t

ida_dirtree.dirtree_cursor_vec_t.begin (method)
    begin(self) -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_vec_t.capacity (method)
    capacity(self) -> size_t

ida_dirtree.dirtree_cursor_vec_t.clear (method)
    clear(self)

ida_dirtree.dirtree_cursor_vec_t.empty (method)
    empty(self) -> bool

ida_dirtree.dirtree_cursor_vec_t.end (method)
    end(self) -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_vec_t.erase (method)
    erase(self, it) -> dirtree_cursor_t
    
    @param it: qvector< dirtree_cursor_t >::iterator
    
    erase(self, first, last) -> dirtree_cursor_t
    
    @param first: qvector< dirtree_cursor_t >::iterator
    @param last: qvector< dirtree_cursor_t >::iterator

ida_dirtree.dirtree_cursor_vec_t.extract (method)
    extract(self) -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_vec_t.find (method)
    find(self, x) -> dirtree_cursor_t
    
    @param x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.grow (method)
    grow(self, x=dirtree_cursor_t())
    
    @param x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: dirtree_cursor_t *
    @param len: size_t

ida_dirtree.dirtree_cursor_vec_t.insert (method)
    insert(self, it, x) -> dirtree_cursor_t
    
    @param it: qvector< dirtree_cursor_t >::iterator
    @param x: dirtree_cursor_t const &

ida_dirtree.dirtree_cursor_vec_t.pop_back (method)
    pop_back(self)

ida_dirtree.dirtree_cursor_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: dirtree_cursor_t const &
    
    push_back(self) -> dirtree_cursor_t

ida_dirtree.dirtree_cursor_vec_t.qclear (method)
    qclear(self)

ida_dirtree.dirtree_cursor_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_dirtree.dirtree_cursor_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: dirtree_cursor_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_dirtree.dirtree_cursor_vec_t.size (method)
    size(self) -> size_t

ida_dirtree.dirtree_cursor_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< dirtree_cursor_t > &

ida_dirtree.dirtree_cursor_vec_t.truncate (method)
    truncate(self)

ida_dirtree.dirtree_iterator_t (class)
    Proxy of C++ dirtree_iterator_t class.

ida_dirtree.dirtree_iterator_t.__init__ (method)
    __init__(self) -> dirtree_iterator_t

ida_dirtree.dirtree_selection_t (class)
    Proxy of C++ dirtree_selection_t class.

ida_dirtree.dirtree_selection_t.__init__ (method)
    __init__(self) -> dirtree_selection_t

ida_dirtree.dirtree_t (class)
    Proxy of C++ dirtree_t class.

ida_dirtree.dirtree_t.__init__ (method)
    __init__(self, ds) -> dirtree_t
    
    @param ds: dirspec_t *

ida_dirtree.dirtree_t.change_rank (method)
    change_rank(self, path, rank_delta) -> dterr_t
    Change ordering rank of an item.
    
    @param path: (C++: const char *) path to the item
    @param rank_delta: (C++: ssize_t) the amount of the change. positive numbers mean to move down
                       in the list; negative numbers mean to move up.
    @return: dterr_t error code
    @note: this function may disable natural ordering of the parent folder
    @see: set_natural_order()

ida_dirtree.dirtree_t.chdir (method)
    chdir(self, path) -> dterr_t
    Change current directory
    
    @param path: (C++: const char *) new current directory
    @return: dterr_t error code

ida_dirtree.dirtree_t.errstr (method)
    errstr(err) -> char const *
    Get textual representation of the error code.
    
    @param err: (C++: dterr_t) enum dterr_t

ida_dirtree.dirtree_t.find_entry (method)
    find_entry(self, de) -> dirtree_cursor_t
    Find the cursor corresponding to an entry of a directory
    
    @param de: (C++: const direntry_t &) directory entry
    @return: cursor corresponding to the directory entry

ida_dirtree.dirtree_t.findfirst (method)
    findfirst(self, ff, pattern) -> bool
    Start iterating over files in a directory
    
    @param ff: (C++: dirtree_iterator_t *) directory iterator. it will be initialized by the function
    @param pattern: (C++: const char *) pattern to search for
    @return: success

ida_dirtree.dirtree_t.findnext (method)
    findnext(self, ff) -> bool
    Continue iterating over files in a directory
    
    @param ff: (C++: dirtree_iterator_t *) directory iterator
    @return: success

ida_dirtree.dirtree_t.get_abspath (method)
    get_abspath(self, cursor, name_flags=DTN_FULL_NAME) -> qstring
    Construct an absolute path from the specified relative path. This function
    verifies the directory part of the specified path. The last component of the
    specified path is not verified.
    
    @param cursor: dirtree_cursor_t const &
    @param name_flags: uint32
    
    @return: path. empty path means wrong directory part of RELPATH
    get_abspath(self, relpath) -> qstring
    
    @param relpath: char const *

ida_dirtree.dirtree_t.get_dir_size (method)
    get_dir_size(self, diridx) -> ssize_t
    Get dir size
    
    @param diridx: (C++: diridx_t) directory index
    @return: number of entries under this directory; if error, return -1

ida_dirtree.dirtree_t.get_entry_attrs (method)
    get_entry_attrs(self, de) -> qstring
    Get entry attributes
    
    @param de: (C++: const direntry_t &) directory entry
    @return: name

ida_dirtree.dirtree_t.get_entry_name (method)
    get_entry_name(self, de, name_flags=DTN_FULL_NAME) -> qstring
    Get entry name
    
    @param de: (C++: const direntry_t &) directory entry
    @param name_flags: (C++: uint32) how exactly the name should be retrieved. combination of bits
                       for get_...name() methods bits
    @return: name

ida_dirtree.dirtree_t.get_id (method)
    get_id(self) -> char const *
    netnode name

ida_dirtree.dirtree_t.get_parent_cursor (method)
    get_parent_cursor(self, cursor) -> dirtree_cursor_t
    Get parent cursor.
    
    @param cursor: (C++: const dirtree_cursor_t &) a valid ditree cursor
    @return: cursor's parent

ida_dirtree.dirtree_t.get_rank (method)
    get_rank(self, diridx, de) -> ssize_t
    Get ordering rank of an item.
    
    @param diridx: (C++: diridx_t) index of the parent directory
    @param de: (C++: const direntry_t &) directory entry
    @return: number in a range of [0..n) where n is the number of entries in the
             parent directory. -1 if error

ida_dirtree.dirtree_t.getcwd (method)
    getcwd(self) -> qstring
    Get current directory
    
    @return: the current working directory

ida_dirtree.dirtree_t.is_dir_ordered (method)
    is_dir_ordered(self, diridx) -> bool
    Is dir ordered?
    
    @param diridx: (C++: diridx_t)
    @return: true if the dirtree has natural ordering

ida_dirtree.dirtree_t.is_orderable (method)
    is_orderable(self) -> bool
    Is dirtree orderable?
    
    @return: true if the dirtree is orderable

ida_dirtree.dirtree_t.isdir (method)
    isdir(self, de) -> bool
    
    @param de: direntry_t const &
    
    isdir(self, path) -> bool
    
    @param path: char const *

ida_dirtree.dirtree_t.isfile (method)
    isfile(self, de) -> bool
    
    @param de: direntry_t const &
    
    isfile(self, path) -> bool
    
    @param path: char const *

ida_dirtree.dirtree_t.link (method)
    link(self, path) -> dterr_t
    Add an inode into the current directory
    
    @param path: char const *
    
    @return: dterr_t error code
    link(self, inode) -> dterr_t
    
    @param inode: inode_t

ida_dirtree.dirtree_t.load (method)
    load(self) -> bool
    Load the tree structure from the netnode. If dirspec_t::id is empty, the
    operation will be considered a success. In addition, calling load() more than
    once will not do anything, and will be considered a success.
    
    @return: success
    @see: dirspec_t::id.

ida_dirtree.dirtree_t.mkdir (method)
    mkdir(self, path) -> dterr_t
    Create a directory.
    
    @param path: (C++: const char *) directory to create
    @return: dterr_t error code

ida_dirtree.dirtree_t.notify_dirtree (method)
    notify_dirtree(self, added, inode)
    Notify dirtree about a change of an inode.
    
    @param added: (C++: bool) are we adding or deleting an inode?
    @param inode: (C++: inode_t) inode in question

ida_dirtree.dirtree_t.rename (method)
    rename(self, _from, to) -> dterr_t
    Rename a directory entry.
    
    @param from: (C++: const char *) source path
    @param to: (C++: const char *) destination path
    @return: dterr_t error code
    @note: This function can also rename the item

ida_dirtree.dirtree_t.resolve_cursor (method)
    resolve_cursor(self, cursor) -> direntry_t
    Resolve cursor
    
    @param cursor: (C++: const dirtree_cursor_t &) to analyze
    @return: directory entry; if the cursor is bad, the resolved entry will be
             invalid.
    @note: see also get_abspath()

ida_dirtree.dirtree_t.resolve_path (method)
    resolve_path(self, path) -> direntry_t
    Resolve path
    
    @param path: (C++: const char *) to analyze
    @return: directory entry

ida_dirtree.dirtree_t.rmdir (method)
    rmdir(self, path) -> dterr_t
    Remove a directory.
    
    @param path: (C++: const char *) directory to delete
    @return: dterr_t error code

ida_dirtree.dirtree_t.save (method)
    save(self) -> bool
    Save the tree structure to the netnode.
    
    @return: success
    @see: dirspec_t::id.

ida_dirtree.dirtree_t.set_id (method)
    set_id(self, nm)
    
    @param nm: char const *

ida_dirtree.dirtree_t.set_natural_order (method)
    set_natural_order(self, diridx, enable) -> bool
    Enable/disable natural inode order in a directory.
    
    @param diridx: (C++: diridx_t) directory index
    @param enable: (C++: bool) action to do TRUE - enable ordering: re-order existing entries so
                   that all subdirs are at the to beginning of the list, file
                   entries are sorted and placed after the subdirs FALSE - disable
                   ordering, no changes to existing entries
    @return: SUCCESS

ida_dirtree.dirtree_t.traverse (method)
    traverse(self, v) -> ssize_t
    Traverse dirtree, and be notified at each entry If the the visitor returns
    anything other than 0, iteration will stop, and that value returned. The tree is
    traversed using a depth-first algorithm. It is forbidden to modify the dirtree_t
    during traversal; doing so will result in undefined behavior.
    
    @param v: (C++: dirtree_visitor_t &) the callback
    @return: 0, or whatever the visitor returned

ida_dirtree.dirtree_t.unlink (method)
    unlink(self, path) -> dterr_t
    Remove an inode from the current directory
    
    @param path: char const *
    
    @return: dterr_t error code
    unlink(self, inode) -> dterr_t
    
    @param inode: inode_t

ida_dirtree.dirtree_t_errstr (function)
    dirtree_t_errstr(err) -> char const *
    
    @param err: enum dterr_t

ida_dirtree.dirtree_visitor_t (class)
    Proxy of C++ dirtree_visitor_t class.

ida_dirtree.dirtree_visitor_t.__disown__ (method)

ida_dirtree.dirtree_visitor_t.__init__ (method)
    __init__(self) -> dirtree_visitor_t
    
    @param self: PyObject *

ida_dirtree.dirtree_visitor_t.visit (method)
    visit(self, c, de) -> ssize_t
    Will be called for each entry in the dirtree_t If something other than 0 is
    returned, iteration will stop.
    
    @param c: (C++: const dirtree_cursor_t &) the current cursor
    @param de: (C++: const direntry_t &) the current entry
    @return: 0 to keep iterating, or anything else to stop

ida_dirtree.get_std_dirtree (function)
    get_std_dirtree(id) -> dirtree_t
    
    @param id: enum dirtree_id_t

ida_entry (module)
    Functions that deal with entry points.
    
    Exported functions are considered as entry points as well.
    
    IDA maintains list of entry points to the program. Each entry point:
    * has an address
    * has a name
    * may have an ordinal number

ida_entry.AEF_IDBENC (variable)
    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly. Specifying AEF_IDBENC also implies AEF_NODUMMY

ida_entry.AEF_NODUMMY (variable)
    automatically prepend the name with '_' if it begins with a dummy suffix. See
    also AEF_IDBENC

ida_entry.AEF_UTF8 (variable)
    the name is given in UTF-8 (default)

ida_entry.add_entry (function)
    add_entry(ord, ea, name, makecode, flags=0) -> bool
    Add an entry point to the list of entry points.
    
    @param ord: (C++: uval_t) ordinal number if ordinal number is equal to 'ea' then ordinal is
                not used
    @param ea: (C++: ea_t) linear address
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to the regular comment. If name ==
                 nullptr, then the old name will be retained.
    @param makecode: (C++: bool) should the kernel convert bytes at the entry point to
                     instruction(s)
    @param flags: (C++: int) See AEF_*
    @return: success (currently always true)

ida_entry.get_entry (function)
    get_entry(ord) -> ea_t
    Get entry point address by its ordinal
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: address or BADADDR

ida_entry.get_entry_forwarder (function)
    get_entry_forwarder(ord) -> str
    Get forwarder name for the entry point by its ordinal.
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: size of entry forwarder name or -1

ida_entry.get_entry_name (function)
    get_entry_name(ord) -> str
    Get name of the entry point by its ordinal.
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: size of entry name or -1

ida_entry.get_entry_ordinal (function)
    get_entry_ordinal(idx) -> uval_t
    Get ordinal number of an entry point.
    
    @param idx: (C++: size_t) internal number of entry point. Should be in the range
                0..get_entry_qty()-1
    @return: ordinal number or 0.

ida_entry.get_entry_qty (function)
    get_entry_qty() -> size_t
    Get number of entry points.

ida_entry.rename_entry (function)
    rename_entry(ord, name, flags=0) -> bool
    Rename entry point.
    
    @param ord: (C++: uval_t) ordinal number of the entry point
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to a repeatable comment.
    @param flags: (C++: int) See AEF_*
    @return: success

ida_entry.set_entry_forwarder (function)
    set_entry_forwarder(ord, name, flags=0) -> bool
    Set forwarder name for ordinal.
    
    @param ord: (C++: uval_t) ordinal number of the entry point
    @param name: (C++: const char *) forwarder name for entry point.
    @param flags: (C++: int) See AEF_*
    @return: success

ida_enum (module)
    Assembly level enum management.
    
    Enums and bitfields are represented as enum_t.

ida_enum.DEFMASK (variable)
    default bitmask

ida_enum.ENFL_REGEX (variable)
    apply regular expressions to beautify the name

ida_enum.ENUM_MEMBER_ERROR_ENUM (variable)
    bad enum id

ida_enum.ENUM_MEMBER_ERROR_ILLV (variable)
    bad bmask and value combination (~bmask & value != 0)

ida_enum.ENUM_MEMBER_ERROR_MASK (variable)
    bad bmask

ida_enum.ENUM_MEMBER_ERROR_NAME (variable)
    already have member with this name (bad name)

ida_enum.ENUM_MEMBER_ERROR_VALUE (variable)
    already have 256 members with this value

ida_enum.MAX_ENUM_SERIAL (variable)
    Max number of identical constants allowed for one enum type.

ida_enum.add_enum (function)
    add_enum(idx, name, flag) -> enum_t
    Add new enum type.
    * if idx==BADADDR then add as the last idx
    * if name==nullptr then generate a unique name "enum_%d"
    
    @param idx: (C++: size_t)
    @param name: (C++: const char *) char const *
    @param flag: (C++: flags64_t)

ida_enum.add_enum_member (function)
    add_enum_member(id, name, value, bmask=(bmask_t(-1))) -> int
    Add member to enum type.
    
    @param id: (C++: enum_t)
    @param name: (C++: const char *) char const *
    @param value: (C++: uval_t)
    @param bmask: (C++: bmask_t)
    @return: 0 if ok, otherwise one of Add enum member result codes

ida_enum.del_enum (function)
    del_enum(id)
    Delete an enum type.
    
    @param id: (C++: enum_t)

ida_enum.del_enum_member (function)
    del_enum_member(id, value, serial, bmask) -> bool
    Delete member of enum type.
    
    @param id: (C++: enum_t)
    @param value: (C++: uval_t)
    @param serial: (C++: uchar)
    @param bmask: (C++: bmask_t)

ida_enum.enum_member_visitor_t (class)
    Proxy of C++ enum_member_visitor_t class.

ida_enum.enum_member_visitor_t.__disown__ (method)

ida_enum.enum_member_visitor_t.__init__ (method)
    __init__(self) -> enum_member_visitor_t
    
    @param self: PyObject *

ida_enum.enum_member_visitor_t.visit_enum_member (method)
    visit_enum_member(self, cid, value) -> int
    Implements action to take when enum member is visited.
    
    @param cid: (C++: const_t)
    @param value: (C++: uval_t)
    @return: nonzero to stop the iteration

ida_enum.for_all_enum_members (function)
    for_all_enum_members(id, cv) -> int
    Visit all members of a given enum.
    
    @param id: (C++: enum_t)
    @param cv: (C++: enum_member_visitor_t &)

ida_enum.get_bmask_cmt (function)
    get_bmask_cmt(id, bmask, repeatable) -> str
    
    @param id: enum_t
    @param bmask: bmask_t
    @param repeatable: bool

ida_enum.get_bmask_name (function)
    get_bmask_name(id, bmask) -> str
    
    @param id: enum_t
    @param bmask: bmask_t

ida_enum.get_enum (function)
    get_enum(name) -> enum_t
    Get enum by name.
    
    @param name: (C++: const char *) char const *

ida_enum.get_enum_cmt (function)
    get_enum_cmt(id, repeatable) -> str
    Get enum comment.
    
    @param id: (C++: enum_t)
    @param repeatable: (C++: bool)

ida_enum.get_enum_flag (function)
    get_enum_flag(id) -> flags64_t
    Get flags determining the representation of the enum. (currently they define the
    numeric base: octal, decimal, hex, bin) and signness.
    
    @param id: (C++: enum_t)

ida_enum.get_enum_idx (function)
    get_enum_idx(id) -> uval_t
    Get the index in the list of enums.
    
    @param id: (C++: enum_t)

ida_enum.get_enum_member (function)
    get_enum_member(id, value, serial, mask) -> const_t
    Find an enum member by enum, value and bitmask
    @note: if serial -1, return a member with any serial
    
    @param id: (C++: enum_t)
    @param value: (C++: uval_t)
    @param serial: (C++: int)
    @param mask: (C++: bmask_t)

ida_enum.get_enum_member_bmask (function)
    get_enum_member_bmask(id) -> bmask_t
    Get bitmask of an enum member.
    
    @param id: (C++: const_t)

ida_enum.get_enum_member_by_name (function)
    get_enum_member_by_name(name) -> const_t
    Get a reference to an enum member by its name.
    
    @param name: (C++: const char *) char const *

ida_enum.get_enum_member_cmt (function)
    get_enum_member_cmt(id, repeatable) -> str
    Get enum member's comment.
    
    @param id: (C++: const_t)
    @param repeatable: (C++: bool)

ida_enum.get_enum_member_enum (function)
    get_enum_member_enum(id) -> enum_t
    Get the parent enum of an enum member.
    
    @param id: (C++: const_t)

ida_enum.get_enum_member_name (function)
    get_enum_member_name(id) -> str
    Get name of an enum member by const_t.
    
    @param id: (C++: const_t)

ida_enum.get_enum_member_serial (function)
    get_enum_member_serial(cid) -> uchar
    Get serial number of an enum member.
    
    @param cid: (C++: const_t)

ida_enum.get_enum_member_value (function)
    get_enum_member_value(id) -> uval_t
    Get value of an enum member.
    
    @param id: (C++: const_t)

ida_enum.get_enum_name (function)
    get_enum_name(id) -> str
    
    @param id: enum_t

ida_enum.get_enum_name2 (function)
    get_enum_name2(id, flags=0) -> str
    Get name of enum
    
    @param id: (C++: enum_t) enum id
    @param flags: (C++: int) Enum name flags

ida_enum.get_enum_qty (function)
    get_enum_qty() -> size_t
    Get number of declared enum_t types.

ida_enum.get_enum_size (function)
    get_enum_size(id) -> size_t
    Get the number of the members of the enum.
    
    @param id: (C++: enum_t)

ida_enum.get_enum_type_ordinal (function)
    get_enum_type_ordinal(id) -> int32
    Get corresponding type ordinal number.
    
    @param id: (C++: enum_t)

ida_enum.get_enum_width (function)
    get_enum_width(id) -> size_t
    Get the width of a enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
    
    @param id: (C++: enum_t)

ida_enum.get_first_bmask (function)
    get_first_bmask(enum_id) -> bmask_t
    Get first bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum (bitfield)
    @return: the smallest bitmask for enum, or DEFMASK

ida_enum.get_first_enum_member (function)
    get_first_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param bmask: bmask_t

ida_enum.get_first_serial_enum_member (function)
    get_first_serial_enum_member(id, value, bmask) -> const_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

ida_enum.get_last_bmask (function)
    get_last_bmask(enum_id) -> bmask_t
    Get last bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @return: the biggest bitmask for enum, or DEFMASK

ida_enum.get_last_enum_member (function)
    get_last_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param bmask: bmask_t

ida_enum.get_last_serial_enum_member (function)
    get_last_serial_enum_member(id, value, bmask) -> const_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

ida_enum.get_next_bmask (function)
    get_next_bmask(enum_id, bmask) -> bmask_t
    Get next bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value higher than the specified value, or
             DEFMASK

ida_enum.get_next_enum_member (function)
    get_next_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

ida_enum.get_next_serial_enum_member (function)
    get_next_serial_enum_member(in_out_serial, first_cid) -> const_t
    
    @param in_out_serial: uchar *
    @param first_cid: const_t

ida_enum.get_prev_bmask (function)
    get_prev_bmask(enum_id, bmask) -> bmask_t
    Get prev bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value lower than the specified value, or
             DEFMASK

ida_enum.get_prev_enum_member (function)
    get_prev_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

ida_enum.get_prev_serial_enum_member (function)
    get_prev_serial_enum_member(in_out_serial, first_cid) -> const_t
    
    @param in_out_serial: uchar *
    @param first_cid: const_t

ida_enum.getn_enum (function)
    getn_enum(idx) -> enum_t
    Get enum by its index in the list of enums (0..get_enum_qty()-1).
    
    @param idx: (C++: size_t)

ida_enum.is_bf (function)
    is_bf(id) -> bool
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for DEFMASK are
    allowed)
    
    @param id: (C++: enum_t)

ida_enum.is_enum_fromtil (function)
    is_enum_fromtil(id) -> bool
    Does enum come from type library?
    
    @param id: (C++: enum_t)

ida_enum.is_enum_hidden (function)
    is_enum_hidden(id) -> bool
    Is enum collapsed?
    
    @param id: (C++: enum_t)

ida_enum.is_ghost_enum (function)
    is_ghost_enum(id) -> bool
    Is a ghost copy of a local type?
    
    @param id: (C++: enum_t)

ida_enum.is_one_bit_mask (function)
    is_one_bit_mask(mask) -> bool
    Is bitmask one bit?
    
    @param mask: (C++: bmask_t)

ida_enum.set_bmask_cmt (function)
    set_bmask_cmt(id, bmask, cmt, repeatable) -> bool
    
    @param id: enum_t
    @param bmask: bmask_t
    @param cmt: char const *
    @param repeatable: bool

ida_enum.set_bmask_name (function)
    set_bmask_name(id, bmask, name) -> bool
    
    @param id: enum_t
    @param bmask: bmask_t
    @param name: char const *

ida_enum.set_enum_bf (function)
    set_enum_bf(id, bf) -> bool
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    @param id: (C++: enum_t)
    @param bf: (C++: bool)

ida_enum.set_enum_cmt (function)
    set_enum_cmt(id, cmt, repeatable) -> bool
    Set comment for enum type.
    
    @param id: (C++: enum_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

ida_enum.set_enum_flag (function)
    set_enum_flag(id, flag) -> bool
    Set data representation flags.
    
    @param id: (C++: enum_t)
    @param flag: (C++: flags64_t)

ida_enum.set_enum_fromtil (function)
    set_enum_fromtil(id, fromtil) -> bool
    Specify that enum comes from a type library.
    
    @param id: (C++: enum_t)
    @param fromtil: (C++: bool)

ida_enum.set_enum_ghost (function)
    set_enum_ghost(id, ghost) -> bool
    Specify that enum is a ghost copy of a local type.
    
    @param id: (C++: enum_t)
    @param ghost: (C++: bool)

ida_enum.set_enum_hidden (function)
    set_enum_hidden(id, hidden) -> bool
    Collapse enum.
    
    @param id: (C++: enum_t)
    @param hidden: (C++: bool)

ida_enum.set_enum_idx (function)
    set_enum_idx(id, idx) -> bool
    Set serial number of enum. Also see get_enum_idx().
    
    @param id: (C++: enum_t)
    @param idx: (C++: size_t)

ida_enum.set_enum_member_cmt (function)
    set_enum_member_cmt(id, cmt, repeatable) -> bool
    Set comment for enum member.
    
    @param id: (C++: const_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

ida_enum.set_enum_member_name (function)
    set_enum_member_name(id, name) -> bool
    Set name of enum member.
    
    @param id: (C++: const_t)
    @param name: (C++: const char *) char const *

ida_enum.set_enum_name (function)
    set_enum_name(id, name) -> bool
    Set name of enum type.
    
    @param id: (C++: enum_t)
    @param name: (C++: const char *) char const *

ida_enum.set_enum_type_ordinal (function)
    set_enum_type_ordinal(id, ord)
    Set corresponding type ordinal number.
    
    @param id: (C++: enum_t)
    @param ord: (C++: int32)

ida_enum.set_enum_width (function)
    set_enum_width(id, width) -> bool
    See comment for get_enum_width()
    
    @param id: (C++: enum_t)
    @param width: (C++: int)

ida_expr (module)
    Functions that deal with C-like expressions and built-in IDC language.
    
    Functions marked THREAD_SAFE may be called from any thread. No simultaneous
    calls should be made for the same variable. We protect only global structures,
    individual variables must be protected manually.

ida_expr.CPL_DEL_MACROS (variable)
    delete macros at the end of compilation

ida_expr.CPL_ONLY_SAFE (variable)
    allow calls of only thread-safe functions

ida_expr.CPL_USE_LABELS (variable)
    allow program labels in the script

ida_expr.EXTFUN_BASE (variable)
    requires open database.

ida_expr.EXTFUN_NORET (variable)
    does not return. the interpreter may clean up its state before calling it.

ida_expr.EXTFUN_SAFE (variable)
    thread safe function. may be called from any thread.

ida_expr.IDC_LANG_EXT (variable)
    IDC script extension.

ida_expr.VARSLICE_SINGLE (variable)
    return single index (i2 is ignored)

ida_expr.VREF_COPY (variable)
    copy the result to the input var (v)

ida_expr.VREF_LOOP (variable)
    dereference until we get a non VT_REF

ida_expr.VREF_ONCE (variable)
    dereference only once, do not loop

ida_expr.VT_FLOAT (variable)
    Floating point (see idc_value_t::e)

ida_expr.VT_FUNC (variable)
    Function (see idc_value_t::funcidx)

ida_expr.VT_INT64 (variable)
    i64

ida_expr.VT_LONG (variable)
    Integer (see idc_value_t::num)

ida_expr.VT_OBJ (variable)
    Object (see idc_value_t::obj)

ida_expr.VT_PVOID (variable)
    void *

ida_expr.VT_REF (variable)
    Reference.

ida_expr.VT_STR (variable)
    String (see qstr() and similar functions)

ida_expr.VT_WILD (variable)
    Function with arbitrary number of arguments. The actual number of arguments will
    be passed in idc_value_t::num. This value should not be used for idc_value_t.

ida_expr._IdcFunction (class)
    Internal class that calls pyw_call_idc_func() with a context

ida_expr._IdcFunction.__call__ (method)

ida_expr._IdcFunction.__init__ (method)

ida_expr.add_idc_class (function)
    add_idc_class(name, super=None) -> idc_class_t *
    Create a new IDC class.
    
    @param name: (C++: const char *) name of the new class
    @param super: (C++: const idc_class_t *) the base class for the new class. if the new class is not based on
                  any other class, pass nullptr
    @return: pointer to the created class. If such a class already exists, a pointer
             to it will be returned. Pointers to other existing classes may be
             invalidated by this call.

ida_expr.add_idc_func (function)
    Extends the IDC language by exposing a new IDC function that is backed up by a Python function
    
    Add an IDC function. This function does not modify the predefined kernel
    functions. Example:
    static error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
    {
    msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
    res->num = 5;     // let's return 5
    return eOk;
    }
    static const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
    static const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args,
    nullptr, 0, EXTFUN_BASE };
    // after this:
    add_idc_func(myfunc_desc);
    // there is a new IDC function which can be called like this:
    MyFunc5(0x123, "test");
    
    @note: If the function already exists, it will be replaced by the new function
    @return: success

ida_expr.add_idc_gvar (function)
    add_idc_gvar(name) -> idc_value_t
    Add global IDC variable.
    
    @param name: (C++: const char *) name of the global variable
    @return: pointer to the created variable or existing variable. NB: the returned
             pointer is valid until a new global var is added.

ida_expr.call_idc_func__ (function)

ida_expr.compile_idc_file (function)
    compile_idc_file(nonnul_line) -> str
    
    @param nonnul_line: char const *

ida_expr.compile_idc_snippet (function)
    compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> str
    Compile text with IDC statements.
    
    @param func: (C++: const char *) name of the function to create out of the snippet
    @param text: (C++: const char *) text to compile
    @param resolver: (C++: idc_resolver_t *) callback object to get values of undefined variables This
                     object will be called if IDC function contains references to
                     undefined variables. May be nullptr.
    @param only_safe_funcs: (C++: bool) if true, any calls to functions without EXTFUN_SAFE flag
                            will lead to a compilation error.
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.compile_idc_text (function)
    compile_idc_text(nonnul_line) -> str
    
    @param nonnul_line: char const *

ida_expr.copy_idcv (function)
    copy_idcv(dst, src) -> error_t
    Copy 'src' to 'dst'. For idc objects only a reference is copied.
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: const idc_value_t &) idc_value_t const &

ida_expr.create_idcv_ref (function)
    create_idcv_ref(ref, v) -> bool
    Create a variable reference. Currently only references to global variables can
    be created.
    
    @param ref: (C++: idc_value_t *) ptr to the result
    @param v: (C++: const idc_value_t *) variable to reference
    @return: success

ida_expr.deep_copy_idcv (function)
    deep_copy_idcv(dst, src) -> error_t
    Deep copy an IDC object. This function performs deep copy of idc objects. If
    'src' is not an object, copy_idcv() will be called
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: const idc_value_t &) idc_value_t const &

ida_expr.del_idc_func (function)
    Unregisters the specified IDC function
    
    Delete an IDC function

ida_expr.del_idcv_attr (function)
    del_idcv_attr(obj, attr) -> error_t
    Delete an object attribute.
    
    @param obj: (C++: idc_value_t *) variable that holds an object reference
    @param attr: (C++: const char *) attribute name
    @return: error code, eOk on success

ida_expr.deref_idcv (function)
    deref_idcv(v, vref_flags) -> idc_value_t
    Dereference a VT_REF variable.
    
    @param v: (C++: idc_value_t *) variable to dereference
    @param vref_flags: (C++: int) Dereference IDC variable flags
    @return: pointer to the dereference result or nullptr. If returns nullptr,
             qerrno is set to eExecBadRef "Illegal variable reference"

ida_expr.eExecThrow (variable)
    See return value of idc_func_t.

ida_expr.eval_expr (function)
    eval_expr(rv, where, line) -> str
    Compile and calculate an expression.
    
    @param rv: (C++: idc_value_t *) pointer to the result
    @param where: (C++: ea_t) the current linear address in the addressing space of the program
                  being disassembled. If will be used to resolve names of local
                  variables etc. if not applicable, then should be BADADDR.
    @param line: (C++: const char *) the expression to evaluate
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.eval_idc_expr (function)
    eval_idc_expr(rv, where, line) -> str
    Same as eval_expr(), but will always use the IDC interpreter regardless of the
    currently installed extlang.
    
    @param rv: (C++: idc_value_t *)
    @param where: (C++: ea_t)
    @param line: char const *

ida_expr.exec_idc_script (function)
    exec_idc_script(result, path, func, args, argsnum) -> str
    Compile and execute IDC function(s) from file.
    
    @param result: (C++: idc_value_t *) ptr to idc_value_t to hold result of the function. If execution
                   fails, this variable will contain the exception information. You
                   may pass nullptr if you are not interested in the returned value.
    @param path: (C++: const char *) text file containing text of IDC functions
    @param func: (C++: const char *) function name to execute
    @param args: (C++: const idc_value_t) array of parameters
    @param argsnum: (C++: size_t) number of parameters to pass to 'fname' This number should be
                    equal to number of parameters the function expects.
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.exec_system_script (function)
    exec_system_script(file, complain_if_no_file=True) -> bool
    Compile and execute "main" function from system file.
    
    @param file: (C++: const char *) file name with IDC function(s). The file will be searched using
                 get_idc_filename().
    @param complain_if_no_file: (C++: bool) * 1: display warning if the file is not found
    * 0: don't complain if file doesn't exist
    @retval 1: ok, file is compiled and executed
    @retval 0: failure, compilation or execution error, warning is displayed

ida_expr.find_idc_class (function)
    find_idc_class(name) -> idc_class_t *
    Find an existing IDC class by its name.
    
    @param name: (C++: const char *) name of the class
    @return: pointer to the class or nullptr. The returned pointer is valid until a
             new call to add_idc_class()

ida_expr.find_idc_func (function)
    find_idc_func(prefix, n=0) -> str
    
    @param prefix: char const *
    @param n: int

ida_expr.find_idc_gvar (function)
    find_idc_gvar(name) -> idc_value_t
    Find an existing global IDC variable by its name.
    
    @param name: (C++: const char *) name of the global variable
    @return: pointer to the variable or nullptr. NB: the returned pointer is valid
             until a new global var is added. FIXME: it is difficult to use this
             function in a thread safe manner

ida_expr.first_idcv_attr (function)
    first_idcv_attr(obj) -> char const *
    
    @param obj: idc_value_t const *

ida_expr.free_idcv (function)
    free_idcv(v)
    Free storage used by VT_STR/VT_OBJ IDC variables. After this call the variable
    has a numeric value 0
    
    @param v: (C++: idc_value_t *)

ida_expr.get_idc_filename (function)
    get_idc_filename(file) -> str
    Get full name of IDC file name. Search for file in list of include directories,
    IDCPATH directory and system directories.
    
    @param file: (C++: const char *) file name without full path
    @return: nullptr is file not found. otherwise returns pointer to buf

ida_expr.get_idcv_attr (function)
    get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t
    Get an object attribute.
    
    @param res: (C++: idc_value_t *) buffer for the attribute value
    @param obj: (C++: const idc_value_t *) variable that holds an object reference. if obj is nullptr it
                searches global variables, then user functions
    @param attr: (C++: const char *) attribute name
    @param may_use_getattr: (C++: bool) may call getattr functions to calculate the attribute if
                            it does not exist
    @return: error code, eOk on success

ida_expr.get_idcv_class_name (function)
    get_idcv_class_name(obj) -> str
    Retrieves the IDC object class name.
    
    @param obj: (C++: const idc_value_t *) class instance variable
    @return: error code, eOk on success

ida_expr.get_idcv_slice (function)
    get_idcv_slice(res, v, i1, i2, flags=0) -> error_t
    Get slice.
    
    @param res: (C++: idc_value_t *) output variable that will contain the slice
    @param v: (C++: const idc_value_t *) input variable (string or object)
    @param i1: (C++: uval_t) slice start index
    @param i2: (C++: uval_t) slice end index (excluded)
    @param flags: (C++: int) IDC variable slice flags or 0
    @return: eOk if success

ida_expr.highlighter_cbs_t (class)
    Proxy of C++ highlighter_cbs_t class.

ida_expr.highlighter_cbs_t.__disown__ (method)

ida_expr.highlighter_cbs_t.__init__ (method)
    __init__(self) -> highlighter_cbs_t
    
    @param self: PyObject *

ida_expr.highlighter_cbs_t.cur_block_state (method)
    cur_block_state(self) -> int32

ida_expr.highlighter_cbs_t.prev_block_state (method)
    prev_block_state(self) -> int32

ida_expr.highlighter_cbs_t.set_block_state (method)
    set_block_state(self, arg0)
    
    @param arg0: int32

ida_expr.highlighter_cbs_t.set_style (method)
    set_style(self, arg0, arg1, arg2)
    
    @param arg0: int32
    @param arg1: int32
    @param arg2: enum syntax_highlight_style

ida_expr.idc_global_t (class)
    Proxy of C++ idc_global_t class.

ida_expr.idc_global_t.__init__ (method)
    __init__(self) -> idc_global_t
    __init__(self, n) -> idc_global_t
    
    @param n: char const *

ida_expr.idc_value_t (class)
    Proxy of C++ idc_value_t class.

ida_expr.idc_value_t.__init__ (method)
    __init__(self, n=0) -> idc_value_t
    
    @param n: sval_t
    
    __init__(self, r) -> idc_value_t
    
    @param r: idc_value_t const &
    
    __init__(self, _str) -> idc_value_t
    
    @param _str: char const *

ida_expr.idc_value_t._create_empty_string (method)
    _create_empty_string(self)

ida_expr.idc_value_t.c_str (method)
    c_str(self) -> char const *
    VT_STR

ida_expr.idc_value_t.clear (method)
    clear(self)
    See free_idcv()

ida_expr.idc_value_t.create_empty_string (method)
    create_empty_string(self)

ida_expr.idc_value_t.e (variable)
    VT_FLOAT

ida_expr.idc_value_t.funcidx (variable)
    VT_FUNC

ida_expr.idc_value_t.i64 (variable)
    VT_INT64

ida_expr.idc_value_t.is_convertible (method)
    is_convertible(self) -> bool
    Convertible types are VT_LONG, VT_FLOAT, VT_INT64, and VT_STR.

ida_expr.idc_value_t.is_integral (method)
    is_integral(self) -> bool
    Does value represent a whole number?

ida_expr.idc_value_t.is_zero (method)
    is_zero(self) -> bool
    Does value represent the integer 0?

ida_expr.idc_value_t.num (variable)
    VT_LONG

ida_expr.idc_value_t.pvoid (variable)
    VT_PVOID

ida_expr.idc_value_t.qstr (method)
    qstr(self) -> qstring
    VT_STR
    qstr(self) -> qstring const &

ida_expr.idc_value_t.reserve (variable)
    internal housekeeping: 64-bit qstring is bigger than 12 bytes

ida_expr.idc_value_t.set_float (method)
    set_float(self, f)
    
    @param f: fpvalue_t const &

ida_expr.idc_value_t.set_int64 (method)
    set_int64(self, v)
    
    @param v: int64

ida_expr.idc_value_t.set_long (method)
    set_long(self, v)
    
    @param v: sval_t

ida_expr.idc_value_t.set_pvoid (method)
    set_pvoid(self, p)
    
    @param p: void *

ida_expr.idc_value_t.set_string (method)
    set_string(self, _str, len)
    
    @param _str: char const *
    @param len: size_t
    
    set_string(self, _str)
    
    @param _str: char const *

ida_expr.idc_value_t.swap (method)
    swap(self, v)
    Set this = r and v = this.
    
    @param v: (C++: idc_value_t &)

ida_expr.idc_value_t.u_str (method)
    u_str(self) -> uchar const *
    VT_STR

ida_expr.idc_value_t.vtype (variable)
    IDC value types

ida_expr.idc_values_t (class)
    Proxy of C++ qvector< idc_value_t > class.

ida_expr.idc_values_t.__getitem__ (method)
    __getitem__(self, i) -> idc_value_t
    
    @param i: size_t

ida_expr.idc_values_t.__init__ (method)
    __init__(self) -> idc_values_t
    __init__(self, x) -> idc_values_t
    
    @param x: qvector< idc_value_t > const &

ida_expr.idc_values_t.__len__ (method)
    __len__(self) -> size_t

ida_expr.idc_values_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: idc_value_t const &

ida_expr.idc_values_t.at (method)
    at(self, _idx) -> idc_value_t
    
    @param _idx: size_t

ida_expr.idc_values_t.begin (method)
    begin(self) -> idc_value_t

ida_expr.idc_values_t.capacity (method)
    capacity(self) -> size_t

ida_expr.idc_values_t.clear (method)
    clear(self)

ida_expr.idc_values_t.empty (method)
    empty(self) -> bool

ida_expr.idc_values_t.end (method)
    end(self) -> idc_value_t

ida_expr.idc_values_t.erase (method)
    erase(self, it) -> idc_value_t
    
    @param it: qvector< idc_value_t >::iterator
    
    erase(self, first, last) -> idc_value_t
    
    @param first: qvector< idc_value_t >::iterator
    @param last: qvector< idc_value_t >::iterator

ida_expr.idc_values_t.extract (method)
    extract(self) -> idc_value_t

ida_expr.idc_values_t.grow (method)
    grow(self, x=idc_value_t())
    
    @param x: idc_value_t const &

ida_expr.idc_values_t.inject (method)
    inject(self, s, len)
    
    @param s: idc_value_t *
    @param len: size_t

ida_expr.idc_values_t.insert (method)
    insert(self, it, x) -> idc_value_t
    
    @param it: qvector< idc_value_t >::iterator
    @param x: idc_value_t const &

ida_expr.idc_values_t.pop_back (method)
    pop_back(self)

ida_expr.idc_values_t.push_back (method)
    push_back(self, x)
    
    @param x: idc_value_t const &
    
    push_back(self) -> idc_value_t

ida_expr.idc_values_t.qclear (method)
    qclear(self)

ida_expr.idc_values_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_expr.idc_values_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: idc_value_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_expr.idc_values_t.size (method)
    size(self) -> size_t

ida_expr.idc_values_t.swap (method)
    swap(self, r)
    
    @param r: qvector< idc_value_t > &

ida_expr.idc_values_t.truncate (method)
    truncate(self)

ida_expr.idcv_float (function)
    idcv_float(v) -> error_t
    Convert IDC variable to a floating point.
    
    @param v: (C++: idc_value_t *)

ida_expr.idcv_int64 (function)
    idcv_int64(v) -> error_t
    Convert IDC variable to a 64bit number.
    
    @param v: (C++: idc_value_t *)
    @return: v = 0 if impossible to convert to int64

ida_expr.idcv_long (function)
    idcv_long(v) -> error_t
    Convert IDC variable to a long (32/64bit) number.
    
    @param v: (C++: idc_value_t *)
    @return: v = 0 if impossible to convert to long

ida_expr.idcv_num (function)
    idcv_num(v) -> error_t
    Convert IDC variable to a long number.
    
    @param v: (C++: idc_value_t *)
    @return: * v = 0 if IDC variable = "false" string
    * v = 1 if IDC variable = "true" string
    * v = number if IDC variable is number or string containing a number
    * eTypeConflict if IDC variable = empty string

ida_expr.idcv_object (function)
    idcv_object(v, icls=None) -> error_t
    Create an IDC object. The original value of 'v' is discarded (freed).
    
    @param v: (C++: idc_value_t *) variable to hold the object. any previous value will be cleaned
    @param icls: (C++: const idc_class_t *) ptr to the desired class. nullptr means "object" class this ptr
                 must be returned by add_idc_class() or find_idc_class()
    @return: always eOk

ida_expr.idcv_string (function)
    idcv_string(v) -> error_t
    Convert IDC variable to a text string.
    
    @param v: (C++: idc_value_t *)

ida_expr.last_idcv_attr (function)
    last_idcv_attr(obj) -> char const *
    
    @param obj: idc_value_t const *

ida_expr.move_idcv (function)
    move_idcv(dst, src) -> error_t
    Move 'src' to 'dst'. This function is more effective than copy_idcv since it
    never copies big amounts of data.
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: idc_value_t *)

ida_expr.next_idcv_attr (function)
    next_idcv_attr(obj, attr) -> char const *
    
    @param obj: idc_value_t const *
    @param attr: char const *

ida_expr.prev_idcv_attr (function)
    prev_idcv_attr(obj, attr) -> char const *
    
    @param obj: idc_value_t const *
    @param attr: char const *

ida_expr.print_idcv (function)
    print_idcv(v, name=None, indent=0) -> str
    Get text representation of idc_value_t.
    
    @param v: (C++: const idc_value_t &) idc_value_t const &
    @param name: (C++: const char *) char const *
    @param indent: (C++: int)

ida_expr.py_add_idc_func (function)
    py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool
    
    @param name: char const *
    @param fp_ptr: size_t
    @param args: char const *
    @param defvals: idc_values_t const &
    @param flags: int

ida_expr.py_get_call_idc_func (function)
    py_get_call_idc_func() -> size_t

ida_expr.pyw_convert_defvals (function)
    pyw_convert_defvals(out, py_seq) -> bool
    
    @param out: idc_values_t *
    @param py_seq: PyObject *

ida_expr.pyw_register_idc_func (function)
    pyw_register_idc_func(name, args, py_fp) -> size_t
    
    @param name: char const *
    @param args: char const *
    @param py_fp: PyObject *

ida_expr.pyw_unregister_idc_func (function)
    pyw_unregister_idc_func(ctxptr) -> bool
    
    @param ctxptr: size_t

ida_expr.set_header_path (function)
    set_header_path(path, add) -> bool
    Set or append a header path. IDA looks for the include files in the appended
    header paths, then in the ida executable directory.
    
    @param path: (C++: const char *) list of directories to add (separated by ';') may be nullptr, in
                 this case nothing is added
    @param add: (C++: bool) true: append. false: remove old paths.
    @retval true: success
    @retval false: no memory

ida_expr.set_idcv_attr (function)
    set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t
    Set an object attribute.
    
    @param obj: (C++: idc_value_t *) variable that holds an object reference. if obj is nullptr then it
                tries to modify a global variable with the attribute name
    @param attr: (C++: const char *) attribute name
    @param value: (C++: const idc_value_t &) new attribute value
    @param may_use_setattr: (C++: bool) may call setattr functions for the class
    @return: error code, eOk on success

ida_expr.set_idcv_slice (function)
    set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t
    Set slice.
    
    @param v: (C++: idc_value_t *) variable to modify (string or object)
    @param i1: (C++: uval_t) slice start index
    @param i2: (C++: uval_t) slice end index (excluded)
    @param in: (C++: const idc_value_t &) new value for the slice
    @param flags: (C++: int) IDC variable slice flags or 0
    @return: eOk on success

ida_expr.swap_idcvs (function)
    swap_idcvs(v1, v2)
    Swap 2 variables.
    
    @param v1: (C++: idc_value_t *)
    @param v2: (C++: idc_value_t *)

ida_expr.throw_idc_exception (function)
    throw_idc_exception(r, desc) -> error_t
    Create an idc execution exception object. This helper function can be used to
    return an exception from C++ code to IDC. In other words this function can be
    called from idc_func_t() callbacks. Sample usage: if ( !ok ) return
    throw_idc_exception(r, "detailed error msg");
    
    @param r: (C++: idc_value_t *) object to hold the exception object
    @param desc: (C++: const char *) exception description
    @return: eExecThrow

ida_fixup (module)
    Functions that deal with fixup information.
    
    A loader should setup fixup information using set_fixup().

ida_fixup.FIXUPF_CREATED (variable)
    fixup was not present in the input file

ida_fixup.FIXUPF_EXTDEF (variable)
    target is a location (otherwise - segment). Use this bit if the target is a
    symbol rather than an offset from the beginning of a segment.

ida_fixup.FIXUPF_LOADER_MASK (variable)
    additional flags. The bits from this mask are not stored in the database and can
    be used by the loader at its discretion.

ida_fixup.FIXUPF_REL (variable)
    fixup is relative to the linear address `base'. Otherwise fixup is relative to
    the start of the segment with `sel' selector.

ida_fixup.FIXUPF_UNUSED (variable)
    fixup is ignored by IDA
    * disallows the kernel to convert operands
    * this fixup is not used during output

ida_fixup.FIXUP_CUSTOM (variable)
    start of the custom types range

ida_fixup.FIXUP_HI16 (variable)
    high 16 bits of 32bit offset

ida_fixup.FIXUP_HI8 (variable)
    high 8 bits of 16bit offset

ida_fixup.FIXUP_LOW16 (variable)
    low 16 bits of 32bit offset

ida_fixup.FIXUP_LOW8 (variable)
    low 8 bits of 16bit offset

ida_fixup.FIXUP_OFF16 (variable)
    16-bit offset

ida_fixup.FIXUP_OFF16S (variable)
    16-bit signed offset

ida_fixup.FIXUP_OFF32 (variable)
    32-bit offset

ida_fixup.FIXUP_OFF32S (variable)
    32-bit signed offset

ida_fixup.FIXUP_OFF64 (variable)
    64-bit offset

ida_fixup.FIXUP_OFF8 (variable)
    8-bit offset

ida_fixup.FIXUP_OFF8S (variable)
    8-bit signed offset

ida_fixup.FIXUP_PTR16 (variable)
    32-bit long pointer (16-bit base:16-bit offset)

ida_fixup.FIXUP_PTR32 (variable)
    48-bit pointer (16-bit base:32-bit offset)

ida_fixup.FIXUP_SEG16 (variable)
    16-bit base-logical segment base (selector)

ida_fixup.V695_FIXUP_VHIGH (variable)
    obsolete

ida_fixup.V695_FIXUP_VLOW (variable)
    obsolete

ida_fixup.calc_fixup_size (function)
    calc_fixup_size(type) -> int
    Calculate size of fixup in bytes (the number of bytes the fixup patches)
    @retval -1: means error
    
    @param type: (C++: fixup_type_t)

ida_fixup.contains_fixups (function)
    contains_fixups(ea, size) -> bool
    Does the specified address range contain any fixup information?
    
    @param ea: (C++: ea_t)
    @param size: (C++: asize_t)

ida_fixup.del_fixup (function)
    del_fixup(source)
    Delete fixup information.
    
    @param source: (C++: ea_t)

ida_fixup.exists_fixup (function)
    exists_fixup(source) -> bool
    Check that a fixup exists at the given address.
    
    @param source: (C++: ea_t)

ida_fixup.find_custom_fixup (function)
    find_custom_fixup(name) -> fixup_type_t
    Get id of a custom fixup handler.
    
    @param name: (C++: const char *) name of the custom fixup handler
    @return: id with FIXUP_CUSTOM bit set or 0

ida_fixup.fixup_data_t (class)
    Proxy of C++ fixup_data_t class.

ida_fixup.fixup_data_t.__init__ (method)
    __init__(self) -> fixup_data_t
    __init__(self, type_, flags_=0) -> fixup_data_t
    
    @param type_: fixup_type_t
    @param flags_: uint32

ida_fixup.fixup_data_t.calc_size (method)
    calc_size(self) -> int
    calc_fixup_size()

ida_fixup.fixup_data_t.clr_extdef (method)
    clr_extdef(self)

ida_fixup.fixup_data_t.clr_unused (method)
    clr_unused(self)

ida_fixup.fixup_data_t.displacement (variable)
    displacement (offset from the target)

ida_fixup.fixup_data_t.get (method)
    get(self, source) -> bool
    get_fixup()
    
    @param source: (C++: ea_t)

ida_fixup.fixup_data_t.get_base (method)
    get_base(self) -> ea_t
    Get base of fixup.
    @note: The target is calculated as `get_base() + off`.
    @see: FIXUPF_REL

ida_fixup.fixup_data_t.get_desc (method)
    get_desc(self, source) -> char const *
    get_fixup_desc()
    
    @param source: (C++: ea_t)

ida_fixup.fixup_data_t.get_flags (method)
    get_flags(self) -> uint32
    Fixup flags Fixup flags.

ida_fixup.fixup_data_t.get_handler (method)
    get_handler(self) -> fixup_handler_t const *
    get_fixup_handler()

ida_fixup.fixup_data_t.get_type (method)
    get_type(self) -> fixup_type_t
    Fixup type Types of fixups.

ida_fixup.fixup_data_t.get_value (method)
    get_value(self, ea) -> uval_t
    get_fixup_value()
    
    @param ea: (C++: ea_t)

ida_fixup.fixup_data_t.has_base (method)
    has_base(self) -> bool
    Is fixup relative?

ida_fixup.fixup_data_t.is_custom (method)
    is_custom(self) -> bool
    is_fixup_custom()

ida_fixup.fixup_data_t.is_extdef (method)
    is_extdef(self) -> bool

ida_fixup.fixup_data_t.is_unused (method)
    is_unused(self) -> bool

ida_fixup.fixup_data_t.off (variable)
    target offset
    @note: The target is calculated as `get_base() + off`.

ida_fixup.fixup_data_t.patch_value (method)
    patch_value(self, ea) -> bool
    patch_fixup_value()
    
    @param ea: (C++: ea_t)

ida_fixup.fixup_data_t.sel (variable)
    selector of the target segment. BADSEL means an absolute (zero based) target.
    @see: FIXUPF_REL

ida_fixup.fixup_data_t.set (method)
    set(self, source)
    set_fixup()
    
    @param source: (C++: ea_t)

ida_fixup.fixup_data_t.set_base (method)
    set_base(self, new_base)
    Set base of fixup. The target should be set before a call of this function.
    
    @param new_base: (C++: ea_t)

ida_fixup.fixup_data_t.set_extdef (method)
    set_extdef(self)

ida_fixup.fixup_data_t.set_sel (method)
    set_sel(self, seg)
    
    @param seg: segment_t const *

ida_fixup.fixup_data_t.set_target_sel (method)
    set_target_sel(self)
    Set selector of fixup to the target. The target should be set before a call of
    this function.

ida_fixup.fixup_data_t.set_type (method)
    set_type(self, type_)
    
    @param type_: fixup_type_t

ida_fixup.fixup_data_t.set_type_and_flags (method)
    set_type_and_flags(self, type_, flags_=0)
    
    @param type_: fixup_type_t
    @param flags_: uint32

ida_fixup.fixup_data_t.set_unused (method)
    set_unused(self)

ida_fixup.fixup_data_t.was_created (method)
    was_created(self) -> bool
    Is fixup artificial?

ida_fixup.fixup_info_t (class)
    Proxy of C++ fixup_info_t class.

ida_fixup.fixup_info_t.__init__ (method)
    __init__(self) -> fixup_info_t

ida_fixup.gen_fix_fixups (function)
    gen_fix_fixups(_from, to, size)
    Relocate the bytes with fixup information once more (generic function). This
    function may be called from loader_t::move_segm() if it suits the goal. If
    loader_t::move_segm is not defined then this function will be called
    automatically when moving segments or rebasing the entire program. Special
    parameter values (from = BADADDR, size = 0, to = delta) are used when the
    function is called from rebase_program(delta).
    
    @param from: (C++: ea_t)
    @param to: (C++: ea_t)
    @param size: (C++: asize_t)

ida_fixup.get_first_fixup_ea (function)
    get_first_fixup_ea() -> ea_t

ida_fixup.get_fixup (function)
    get_fixup(fd, source) -> bool
    Get fixup information.
    
    @param fd: (C++: fixup_data_t *)
    @param source: (C++: ea_t)

ida_fixup.get_fixup_desc (function)
    get_fixup_desc(source, fd) -> str
    Get FIXUP description comment.
    
    @param source: (C++: ea_t)
    @param fd: (C++: const fixup_data_t &) fixup_data_t const &

ida_fixup.get_fixup_handler (function)
    get_fixup_handler(type) -> fixup_handler_t const *
    Get handler of standard or custom fixup.
    
    @param type: (C++: fixup_type_t)

ida_fixup.get_fixup_value (function)
    get_fixup_value(ea, type) -> uval_t
    Get the operand value. This function get fixup bytes from data or an instruction
    at `ea' and convert them to the operand value (maybe partially). It is opposite
    in meaning to the `patch_fixup_value()`. For example, FIXUP_HI8 read a byte at
    `ea' and shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low 26
    bits of the insn at `ea' and shifts it left by 2 bits. This function is mainly
    used to get a relocation addend.
    
    @param ea: (C++: ea_t) address to get fixup bytes from, the size of the fixup bytes depends
               on the fixup type.
    @see: fixup_handler_t::size
    @param type: (C++: fixup_type_t) fixup type
    @retval operand: value

ida_fixup.get_fixups (function)
    get_fixups(out, ea, size) -> bool
    
    @param out: fixups_t *
    @param ea: ea_t
    @param size: asize_t

ida_fixup.get_next_fixup_ea (function)
    get_next_fixup_ea(ea) -> ea_t
    Find next address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the next address with fixup information, or BADADDR

ida_fixup.get_prev_fixup_ea (function)
    get_prev_fixup_ea(ea) -> ea_t
    Find previous address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the previous address with fixup information, or BADADDR

ida_fixup.handle_fixups_in_macro (function)
    handle_fixups_in_macro(ri, ea, other, macro_reft_and_flags) -> bool
    Handle two fixups in a macro. We often combine two instruction that load parts
    of a value into one macro instruction. For example:
    ARM:   ADRP  X0, #var@PAGE
    ADD   X0, X0, #var@PAGEOFF  --> ADRL X0, var
    MIPS:  lui   $v0, %hi(var)
    addiu $v0, $v0, %lo(var)    --> la   $v0, var
    When applying the fixups that fall inside such a macro, we should convert them
    to one refinfo. This function does exactly that. It should be called from the
    apply() callback of a custom fixup.
    
    @param ri: (C++: refinfo_t *)
    @param ea: (C++: ea_t)
    @param other: (C++: fixup_type_t)
    @param macro_reft_and_flags: (C++: uint32)
    @return: success ('false' means that RI was not changed)

ida_fixup.is_fixup_custom (function)
    is_fixup_custom(type) -> bool
    Is fixup processed by processor module?
    
    @param type: (C++: fixup_type_t)

ida_fixup.patch_fixup_value (function)
    patch_fixup_value(ea, fd) -> bool
    Patch the fixup bytes. This function updates data or an instruction at `ea' to
    the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea' to the high byte
    of `fd->off', or AArch64's custom fixup BRANCH26 updates low 26 bits of the insn
    at `ea' to the value of `fd->off' shifted right by 2.
    
    @param ea: (C++: ea_t) address where data are changed, the size of the changed data depends
               on the fixup type.
    @see: fixup_handler_t::size
    @param fd: (C++: const fixup_data_t &) fixup data
    @retval false: the fixup bytes do not fit (e.g. `fd->off' is greater than
                   0xFFFFFFC for BRANCH26). The database is changed even in this
                   case.

ida_fixup.set_fixup (function)
    set_fixup(source, fd)
    Set fixup information. You should fill fixup_data_t and call this function and
    the kernel will remember information in the database.
    
    @param source: (C++: ea_t) the fixup source address, i.e. the address modified by the fixup
    @param fd: (C++: const fixup_data_t &) fixup data

ida_fpro (module)
    System independent counterparts of FILE* related functions from Clib.
    
    You should not use C standard I/O functions in your modules. The reason: Each
    module compiled with Borland (and statically linked to Borland's library) will
    host a copy of the FILE * information.
    
    So, if you open a file in the plugin and pass the handle to the kernel, the
    kernel will not be able to use it.
    
    If you really need to use the standard functions, define
    USE_STANDARD_FILE_FUNCTIONS. In this case do not mix them with q... functions.

ida_fpro.qfile_t (class)
    A helper class to work with FILE related functions.

ida_fpro.qfile_t.__init__ (method)
    __init__(self, rhs) -> qfile_t
    
    @param rhs: qfile_t const &
    
    __init__(self, pycapsule=None) -> qfile_t
    
    @param pycapsule: PyObject *

ida_fpro.qfile_t.close (method)
    close(self)
    Closes the file

ida_fpro.qfile_t.filename (method)
    filename(self) -> PyObject *

ida_fpro.qfile_t.flush (method)
    flush(self) -> int

ida_fpro.qfile_t.from_capsule (method)
    from_capsule(pycapsule) -> qfile_t
    
    @param pycapsule: PyObject *

ida_fpro.qfile_t.from_fp (method)
    from_fp(fp) -> qfile_t
    
    @param fp: FILE *

ida_fpro.qfile_t.get_byte (method)
    get_byte(self) -> PyObject *
    Reads a single byte from the file. Returns None if EOF or the read byte

ida_fpro.qfile_t.get_fp (method)
    get_fp(self) -> FILE *

ida_fpro.qfile_t.gets (method)
    gets(self, size) -> PyObject *
    Reads a line from the input file. Returns the read line or None
    
    @param size: int

ida_fpro.qfile_t.open (method)
    open(self, filename, mode) -> bool
    Opens a file
    
    @param filename: the file name
    @param mode: The mode string, ala fopen() style
    @return: Boolean

ida_fpro.qfile_t.opened (method)
    opened(self) -> bool
    Checks if the file is opened or not

ida_fpro.qfile_t.put_byte (method)
    put_byte(self, chr) -> int
    Writes a single byte to the file
    
    @param chr: int

ida_fpro.qfile_t.puts (method)
    puts(self, str) -> int
    
    @param str: char const *

ida_fpro.qfile_t.read (method)
    read(self, size) -> PyObject *
    Reads from the file. Returns the buffer or None
    
    @param size: int

ida_fpro.qfile_t.readbytes (method)
    readbytes(self, size, big_endian) -> PyObject *
    Similar to read() but it respect the endianness
    
    @param size: int
    @param big_endian: bool

ida_fpro.qfile_t.seek (method)
    seek(self, offset, whence=SEEK_SET) -> int
    Set input source position
    
    @param offset: int64
    @param whence: int
    @return: the new position (not 0 as fseek!)

ida_fpro.qfile_t.size (method)
    size(self) -> int64

ida_fpro.qfile_t.tell (method)
    tell(self) -> int64
    Returns the current position

ida_fpro.qfile_t.tmpfile (method)
    tmpfile() -> qfile_t
    A static method to construct an instance using a temporary file

ida_fpro.qfile_t.write (method)
    write(self, py_buf) -> int
    Writes to the file. Returns 0 or the number of bytes written
    
    @param py_buf: PyObject *

ida_fpro.qfile_t.writebytes (method)
    writebytes(self, py_buf, big_endian) -> int
    Similar to write() but it respect the endianness
    
    @param py_buf: PyObject *
    @param big_endian: bool

ida_fpro.qfile_t_from_capsule (function)
    qfile_t_from_capsule(pycapsule) -> qfile_t
    
    @param pycapsule: PyObject *

ida_fpro.qfile_t_from_fp (function)
    qfile_t_from_fp(fp) -> qfile_t
    
    @param fp: FILE *

ida_fpro.qfile_t_tmpfile (function)
    qfile_t_tmpfile() -> qfile_t

ida_frame (module)
    Routines to manipulate function stack frames, stack variables, register
    variables and local labels.
    
    The frame is represented as a structure:
    +------------------------------------------------+
      | function arguments                             |
      +------------------------------------------------+
      | return address (isn't stored in func_t)        |
      +------------------------------------------------+
      | saved registers (SI, DI, etc - func_t::frregs) |
      +------------------------------------------------+ <- typical BP
      |                                                |  |
      |                                                |  | func_t::fpd
      |                                                |  |
      |                                                | <- real BP
      | local variables (func_t::frsize)               |
      |                                                |
      |                                                |
      +------------------------------------------------+ <- SP
    
    To access the structure of a function frame, use:
    * get_struc() (use func_t::frame as structure ID)
    * get_frame(const func_t *pfn)
    * get_frame(ea_t ea)

ida_frame.REGVAR_ERROR_ARG (variable)
    function arguments are bad

ida_frame.REGVAR_ERROR_NAME (variable)
    the provided name(s) can't be accepted

ida_frame.REGVAR_ERROR_OK (variable)
    all ok

ida_frame.REGVAR_ERROR_RANGE (variable)
    the definition range is bad

ida_frame.STKVAR_VALID_SIZE (variable)
    x.dtyp contains correct variable type (for insns like 'lea' this bit must be
    off). In general, dr_O references do not allow to determine the variable size

ida_frame.add_auto_stkpnt (function)
    add_auto_stkpnt(pfn, ea, delta) -> bool
    Add automatic SP register change point.
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address where SP changes. usually this is the end of the
               instruction which modifies the stack pointer ( insn_t::ea+
               insn_t::size)
    @param delta: (C++: sval_t) difference between old and new values of SP
    @return: success

ida_frame.add_frame (function)
    add_frame(pfn, frsize, frregs, argsize) -> bool
    Add function frame.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param frsize: (C++: sval_t) size of function local variables
    @param frregs: (C++: ushort) size of saved registers
    @param argsize: (C++: asize_t) size of function arguments range which will be purged upon
                    return. this parameter is used for __stdcall and __pascal
                    calling conventions. for other calling conventions please pass
                    0.
    @retval 1: ok
    @retval 0: failed (no function, frame already exists)

ida_frame.add_regvar (function)
    add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int
    Define a register variable.
    
    @param pfn: (C++: func_t *) function in which the definition will be created
    @param ea1: (C++: ea_t) ,ea2: range of addresses within the function where the definition will
                    be used
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @param user: (C++: const char *) user-defined name for the register
    @param cmt: (C++: const char *) comment for the definition
    @return: Register variable error codes

ida_frame.add_user_stkpnt (function)
    add_user_stkpnt(ea, delta) -> bool
    Add user-defined SP register change point.
    
    @param ea: (C++: ea_t) linear address where SP changes
    @param delta: (C++: sval_t) difference between old and new values of SP
    @return: success

ida_frame.build_stkvar_name (function)
    build_stkvar_name(pfn, v) -> str
    Build automatic stack variable name.
    
    @param pfn: (C++: const func_t *) pointer to function (can't be nullptr!)
    @param v: (C++: sval_t) value of variable offset
    @return: length of stack variable name or -1

ida_frame.build_stkvar_xrefs (function)
    build_stkvar_xrefs(out, pfn, mptr)
    Fill 'out' with a list of all the xrefs made from function 'pfn', to the
    argument or variable 'mptr' in 'pfn's stack frame.
    
    @param out: (C++: xreflist_t *) the list of xrefs to fill.
    @param pfn: (C++: func_t *) the function to scan.
    @param mptr: (C++: const member_t *) the argument/variable in pfn's stack frame.

ida_frame.calc_stkvar_struc_offset (function)
    calc_stkvar_struc_offset(pfn, insn, n) -> ea_t
    Calculate offset of stack variable in the frame structure.
    
    @param pfn: (C++: func_t *) pointer to function (can't be nullptr!)
    @param insn: (C++: const insn_t &) the instruction
    @param n: (C++: int) 0..UA_MAXOP-1 operand number -1 if error, return BADADDR
    @return: BADADDR if some error (issue a warning if stack frame is bad)

ida_frame.define_stkvar (function)
    define_stkvar(pfn, name, off, flags, ti, nbytes) -> bool
    Define/redefine a stack variable.
    
    @param pfn: (C++: func_t *) pointer to function
    @param name: (C++: const char *) variable name, nullptr means autogenerate a name
    @param off: (C++: sval_t) offset of the stack variable in the frame. negative values denote
                local variables, positive - function arguments.
    @param flags: (C++: flags64_t) variable type flags (byte_flag() for a byte variable, for example)
    @param ti: (C++: const opinfo_t *) additional type information (like offsets, structs, etc)
    @param nbytes: (C++: asize_t) number of bytes occupied by the variable
    @return: success

ida_frame.del_frame (function)
    del_frame(pfn) -> bool
    Delete a function frame.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @return: success

ida_frame.del_regvar (function)
    del_regvar(pfn, ea1, ea2, canon) -> int
    Delete a register variable definition.
    
    @param pfn: (C++: func_t *) function in question
    @param ea1: (C++: ea_t) ,ea2: range of addresses within the function where the definition
                    holds
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @return: Register variable error codes

ida_frame.del_stkpnt (function)
    del_stkpnt(pfn, ea) -> bool
    Delete SP register change point.
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: success

ida_frame.delete_unreferenced_stkvars (function)
    delete_unreferenced_stkvars(pfn) -> int
    
    @param pfn: func_t *

ida_frame.delete_wrong_stkvar_ops (function)
    delete_wrong_stkvar_ops(pfn) -> int
    
    @param pfn: func_t *

ida_frame.find_regvar (function)
    find_regvar(pfn, ea1, ea2, canon, user) -> regvar_t
    Find a register variable definition.
    
    @param pfn: (C++: func_t *) function in question
    @param ea1: ea_t
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @param user: char const *
    
    @return: nullptr-not found, otherwise ptr to regvar_t
    find_regvar(pfn, ea, canon) -> regvar_t
    
    @param pfn: func_t *
    @param ea: ea_t
    @param canon: char const *

ida_frame.frame_off_args (function)
    frame_off_args(pfn) -> ea_t
    Get starting address of arguments section.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_frame.frame_off_lvars (function)
    frame_off_lvars(pfn) -> ea_t
    Get start address of local variables section.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_frame.frame_off_retaddr (function)
    frame_off_retaddr(pfn) -> ea_t
    Get starting address of return address section.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_frame.frame_off_savregs (function)
    frame_off_savregs(pfn) -> ea_t
    Get starting address of saved registers section.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_frame.free_regvar (function)
    free_regvar(v)
    
    @param v: regvar_t *

ida_frame.get_effective_spd (function)
    get_effective_spd(pfn, ea) -> sval_t
    Get effective difference between the initial and current values of ESP. This
    function returns the sp-diff used by the instruction. The difference between
    get_spd() and get_effective_spd() is present only for instructions like "pop
    [esp+N]": they modify sp and use the modified value.
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: 0 or the difference, usually a negative number

ida_frame.get_frame (function)
    get_frame(pfn) -> struc_t *
    Get pointer to function frame.
    
    @param pfn: func_t const *

ida_frame.get_frame_member_by_id (function)
    get_frame_member_by_id(out_mname, out_fptr, mid) -> member_t *
    Check if the specified member id points to a frame member.
    
    @param out_mname: (C++: qstring *)
    @param out_fptr: (C++: struc_t **)
    @param mid: (C++: tid_t)

ida_frame.get_frame_part (function)
    get_frame_part(range, pfn, part)
    Get offsets of the frame part in the frame.
    
    @param range: (C++: range_t *) pointer to the output buffer with the frame part
                  start/end(exclusive) offsets, can't be nullptr
    @param pfn: (C++: const func_t *) pointer to function structure, can't be nullptr
    @param part: (C++: frame_part_t) frame part

ida_frame.get_frame_retsize (function)
    get_frame_retsize(pfn) -> int
    Get size of function return address.
    
    @param pfn: (C++: const func_t *) pointer to function structure, can't be nullptr

ida_frame.get_frame_size (function)
    get_frame_size(pfn) -> asize_t
    Get full size of a function frame. This function takes into account size of
    local variables + size of saved registers + size of return address + number of
    purged bytes. The purged bytes correspond to the arguments of the functions with
    __stdcall and __fastcall calling conventions.
    
    @param pfn: (C++: const func_t *) pointer to function structure, may be nullptr
    @return: size of frame in bytes or zero

ida_frame.get_func_by_frame (function)
    get_func_by_frame(frame_id) -> ea_t
    Get function by its frame id.
    @warning: this function works only with databases created by IDA > 5.6
    
    @param frame_id: (C++: tid_t) id of the function frame
    @return: start address of the function or BADADDR

ida_frame.get_min_spd_ea (function)
    get_min_spd_ea(pfn) -> ea_t
    
    @param pfn: func_t *

ida_frame.get_sp_delta (function)
    get_sp_delta(pfn, ea) -> sval_t
    Get modification of SP made at the specified location
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: 0 if the specified location doesn't contain a SP change point.
             otherwise return delta of SP modification.

ida_frame.get_spd (function)
    get_spd(pfn, ea) -> sval_t
    Get difference between the initial and current values of ESP.
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address of the instruction
    @return: 0 or the difference, usually a negative number. returns the sp-diff
             before executing the instruction.

ida_frame.get_stkvar (function)
    get_stkvar(insn, op, v) -> (member_t, int) or None
    Get pointer to stack variable
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: reference to instruction operand
    @param v: immediate value in the operand (usually op.addr)
    @return:     - None on failure
        - tuple(member_t, actval)
          where actval: actual value used to fetch stack variable

ida_frame.has_regvar (function)
    has_regvar(pfn, ea) -> bool
    Is there a register variable definition?
    
    @param pfn: (C++: func_t *) function in question
    @param ea: (C++: ea_t) current address

ida_frame.is_funcarg_off (function)
    is_funcarg_off(pfn, frameoff) -> bool
    
    @param pfn: func_t const *
    @param frameoff: uval_t

ida_frame.lvar_off (function)
    lvar_off(pfn, frameoff) -> sval_t
    
    @param pfn: func_t const *
    @param frameoff: uval_t

ida_frame.recalc_spd (function)
    recalc_spd(cur_ea) -> bool
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to recalculate
    SP for the next instruction.
    
    This function will create a new automatic SP register change point if necessary.
    It should be called from the emulator (emu.cpp) when auto_state == AU_USED if
    the current instruction doesn't pass the execution flow to the next instruction.
    
    @param cur_ea: (C++: ea_t) linear address of the current instruction
    @retval 1: new stkpnt is added
    @retval 0: nothing is changed

ida_frame.recalc_spd_for_basic_block (function)
    recalc_spd_for_basic_block(pfn, cur_ea) -> bool
    Recalculate SP delta for the current instruction. The typical code snippet to
    calculate SP delta in a proc module is:
    
    if ( may_trace_sp() && pfn != nullptr )
      if ( !recalc_spd_for_basic_block(pfn, insn.ea) )
        trace_sp(pfn, insn);
    
    where trace_sp() is a typical name for a function that emulates the SP change of
    an instruction.
    
    @param pfn: (C++: func_t *) pointer to the function
    @param cur_ea: (C++: ea_t) linear address of the current instruction
    @retval true: the cumulative SP delta is set
    @retval false: the instruction at CUR_EA passes flow to the next instruction. SP
                   delta must be set as a result of emulating the current
                   instruction.

ida_frame.regvar_t (class)
    Proxy of C++ regvar_t class.

ida_frame.regvar_t.__init__ (method)
    __init__(self) -> regvar_t
    __init__(self, r) -> regvar_t
    
    @param r: regvar_t const &

ida_frame.regvar_t.canon (variable)
    canonical register name (case-insensitive)

ida_frame.regvar_t.cmt (variable)
    comment to appear near definition

ida_frame.regvar_t.swap (method)
    swap(self, r)
    
    @param r: regvar_t &

ida_frame.regvar_t.user (variable)
    user-defined register name

ida_frame.rename_regvar (function)
    rename_regvar(pfn, v, user) -> int
    Rename a register variable.
    
    @param pfn: (C++: func_t *) function in question
    @param v: (C++: regvar_t *) variable to rename
    @param user: (C++: const char *) new user-defined name for the register
    @return: Register variable error codes

ida_frame.set_auto_spd (function)
    set_auto_spd(pfn, ea, new_spd) -> bool
    Add such an automatic SP register change point so that at EA the new cumulative
    SP delta (that is, the difference between the initial and current values of SP)
    would be equal to NEW_SPD.
    
    @param pfn: (C++: func_t *) pointer to the function. may be nullptr.
    @param ea: (C++: ea_t) linear address of the instruction
    @param new_spd: (C++: sval_t) new value of the cumulative SP delta
    @return: success

ida_frame.set_frame_size (function)
    set_frame_size(pfn, frsize, frregs, argsize) -> bool
    Set size of function frame. Note: The returned size may not include all stack
    arguments. It does so only for __stdcall and __fastcall calling conventions. To
    get the entire frame size for all cases use get_struc_size(get_frame(pfn)).
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param frsize: (C++: asize_t) size of function local variables
    @param frregs: (C++: ushort) size of saved registers
    @param argsize: (C++: asize_t) size of function arguments that will be purged from the stack
                    upon return
    @return: success

ida_frame.set_purged (function)
    set_purged(ea, nbytes, override_old_value) -> bool
    Set the number of purged bytes for a function or data item (funcptr). This
    function will update the database and plan to reanalyze items referencing the
    specified address. It works only for processors with PR_PURGING bit in 16 and 32
    bit modes.
    
    @param ea: (C++: ea_t) address of the function of item
    @param nbytes: (C++: int) number of purged bytes
    @param override_old_value: (C++: bool) may overwrite old information about purged bytes
    @return: success

ida_frame.set_regvar_cmt (function)
    set_regvar_cmt(pfn, v, cmt) -> int
    Set comment for a register variable.
    
    @param pfn: (C++: func_t *) function in question
    @param v: (C++: regvar_t *) variable to rename
    @param cmt: (C++: const char *) new comment
    @return: Register variable error codes

ida_frame.soff_to_fpoff (function)
    soff_to_fpoff(pfn, soff) -> sval_t
    Convert struct offsets into fp-relative offsets. This function converts the
    offsets inside the struc_t object into the frame pointer offsets (for example,
    EBP-relative).
    
    @param pfn: (C++: func_t *)
    @param soff: (C++: uval_t)

ida_frame.stkpnt_t (class)
    Proxy of C++ stkpnt_t class.

ida_frame.stkpnt_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.__init__ (method)
    __init__(self) -> stkpnt_t

ida_frame.stkpnt_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: stkpnt_t const &

ida_frame.stkpnt_t.compare (method)
    compare(self, r) -> int
    
    @param r: stkpnt_t const &

ida_frame.stkpnts_t (class)
    Proxy of C++ stkpnts_t class.

ida_frame.stkpnts_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.__init__ (method)
    __init__(self) -> stkpnts_t

ida_frame.stkpnts_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: stkpnts_t const &

ida_frame.stkpnts_t.compare (method)
    compare(self, r) -> int
    
    @param r: stkpnts_t const &

ida_frame.update_fpd (function)
    update_fpd(pfn, fpd) -> bool
    Update frame pointer delta.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param fpd: (C++: asize_t) new fpd value. cannot be bigger than the local variable range size.
    @return: success

ida_frame.xreflist_entry_t (class)
    Proxy of C++ xreflist_entry_t class.

ida_frame.xreflist_entry_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.__init__ (method)
    __init__(self) -> xreflist_entry_t

ida_frame.xreflist_entry_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.compare (method)
    compare(self, r) -> int
    
    @param r: xreflist_entry_t const &

ida_frame.xreflist_entry_t.ea (variable)
    Location of the insn referencing the stack frame member.

ida_frame.xreflist_entry_t.opnum (variable)
    Number of the operand of that instruction.

ida_frame.xreflist_entry_t.type (variable)
    The type of xref (cref_t & dref_t)

ida_frame.xreflist_t (class)
    Proxy of C++ qvector< xreflist_entry_t > class.

ida_frame.xreflist_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< xreflist_entry_t > const &

ida_frame.xreflist_t.__getitem__ (method)
    __getitem__(self, i) -> xreflist_entry_t
    
    @param i: size_t

ida_frame.xreflist_t.__init__ (method)
    __init__(self) -> xreflist_t
    __init__(self, x) -> xreflist_t
    
    @param x: qvector< xreflist_entry_t > const &

ida_frame.xreflist_t.__len__ (method)
    __len__(self) -> size_t

ida_frame.xreflist_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< xreflist_entry_t > const &

ida_frame.xreflist_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: xreflist_entry_t const &

ida_frame.xreflist_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: xreflist_entry_t const &

ida_frame.xreflist_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: xreflist_entry_t const &

ida_frame.xreflist_t.at (method)
    at(self, _idx) -> xreflist_entry_t
    
    @param _idx: size_t

ida_frame.xreflist_t.begin (method)
    begin(self) -> xreflist_entry_t

ida_frame.xreflist_t.capacity (method)
    capacity(self) -> size_t

ida_frame.xreflist_t.clear (method)
    clear(self)

ida_frame.xreflist_t.empty (method)
    empty(self) -> bool

ida_frame.xreflist_t.end (method)
    end(self) -> xreflist_entry_t

ida_frame.xreflist_t.erase (method)
    erase(self, it) -> xreflist_entry_t
    
    @param it: qvector< xreflist_entry_t >::iterator
    
    erase(self, first, last) -> xreflist_entry_t
    
    @param first: qvector< xreflist_entry_t >::iterator
    @param last: qvector< xreflist_entry_t >::iterator

ida_frame.xreflist_t.extract (method)
    extract(self) -> xreflist_entry_t

ida_frame.xreflist_t.find (method)
    find(self, x) -> xreflist_entry_t
    
    @param x: xreflist_entry_t const &

ida_frame.xreflist_t.grow (method)
    grow(self, x=xreflist_entry_t())
    
    @param x: xreflist_entry_t const &

ida_frame.xreflist_t.has (method)
    has(self, x) -> bool
    
    @param x: xreflist_entry_t const &

ida_frame.xreflist_t.inject (method)
    inject(self, s, len)
    
    @param s: xreflist_entry_t *
    @param len: size_t

ida_frame.xreflist_t.insert (method)
    insert(self, it, x) -> xreflist_entry_t
    
    @param it: qvector< xreflist_entry_t >::iterator
    @param x: xreflist_entry_t const &

ida_frame.xreflist_t.pop_back (method)
    pop_back(self)

ida_frame.xreflist_t.push_back (method)
    push_back(self, x)
    
    @param x: xreflist_entry_t const &
    
    push_back(self) -> xreflist_entry_t

ida_frame.xreflist_t.qclear (method)
    qclear(self)

ida_frame.xreflist_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_frame.xreflist_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: xreflist_entry_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_frame.xreflist_t.size (method)
    size(self) -> size_t

ida_frame.xreflist_t.swap (method)
    swap(self, r)
    
    @param r: qvector< xreflist_entry_t > &

ida_frame.xreflist_t.truncate (method)
    truncate(self)

ida_funcs (module)
    Routines for working with functions within the disassembled program.
    
    This file also contains routines for working with library signatures (e.g.
    FLIRT).
    
    Each function consists of function chunks. At least one function chunk must be
    present in the function definition - the function entry chunk. Other chunks are
    called function tails. There may be several of them for a function.
    
    A function tail is a continuous range of addresses. It can be used in the
    definition of one or more functions. One function using the tail is singled out
    and called the tail owner. This function is considered as 'possessing' the tail.
    get_func() on a tail address will return the function possessing the tail. You
    can enumerate the functions using the tail by using func_parent_iterator_t.
    
    Each function chunk in the disassembly is represented as an "range" (a range of
    addresses, see range.hpp for details) with characteristics.
    
    A function entry must start with an instruction (code) byte.

ida_funcs.FIND_FUNC_DEFINE (variable)
    create instruction if undefined byte is encountered

ida_funcs.FIND_FUNC_EXIST (variable)
    function exists already. its bounds are returned in 'nfn'.

ida_funcs.FIND_FUNC_IGNOREFN (variable)
    ignore existing function boundaries. by default the function returns function
    boundaries if ea belongs to a function.

ida_funcs.FIND_FUNC_KEEPBD (variable)
    do not modify incoming function boundaries, just create instructions inside the
    boundaries.

ida_funcs.FIND_FUNC_NORMAL (variable)
    stop processing if undefined byte is encountered

ida_funcs.FIND_FUNC_OK (variable)
    ok, 'nfn' is ready for add_func()

ida_funcs.FIND_FUNC_UNDEF (variable)
    function has instructions that pass execution flow to unexplored bytes.
    nfn->end_ea will have the address of the unexplored byte.

ida_funcs.FUNC_BOTTOMBP (variable)
    BP points to the bottom of the stack frame.

ida_funcs.FUNC_FAR (variable)
    Far function.

ida_funcs.FUNC_FRAME (variable)
    Function uses frame pointer (BP)

ida_funcs.FUNC_FUZZY_SP (variable)
    Function changes SP in untraceable way, for example: and esp, 0FFFFFFF0h

ida_funcs.FUNC_HIDDEN (variable)
    A hidden function chunk.

ida_funcs.FUNC_LIB (variable)
    Library function.

ida_funcs.FUNC_LUMINA (variable)
    Function info is provided by Lumina.

ida_funcs.FUNC_NORET (variable)
    Function doesn't return.

ida_funcs.FUNC_NORET_PENDING (variable)
    Function 'non-return' analysis must be performed. This flag is verified upon
    func_does_return()

ida_funcs.FUNC_OUTLINE (variable)
    Outlined code, not a real function.

ida_funcs.FUNC_PROLOG_OK (variable)
    Prolog analysis has been performed by last SP-analysis

ida_funcs.FUNC_PURGED_OK (variable)
    'argsize' field has been validated. If this bit is clear and 'argsize' is 0,
    then we do not known the real number of bytes removed from the stack. This bit
    is handled by the processor module.

ida_funcs.FUNC_REANALYZE (variable)
    Function frame changed, request to reanalyze the function after the last insn is
    analyzed.

ida_funcs.FUNC_SP_READY (variable)
    SP-analysis has been performed. If this flag is on, the stack change points
    should not be not modified anymore. Currently this analysis is performed only
    for PC

ida_funcs.FUNC_STATICDEF (variable)
    Static function.

ida_funcs.FUNC_TAIL (variable)
    This is a function tail. Other bits must be clear (except FUNC_HIDDEN).

ida_funcs.FUNC_THUNK (variable)
    Thunk (jump) function.

ida_funcs.FUNC_USERFAR (variable)
    User has specified far-ness of the function

ida_funcs.IDASGN_APPLIED (variable)
    signature is already applied

ida_funcs.IDASGN_BADARG (variable)
    bad number of signature

ida_funcs.IDASGN_CURRENT (variable)
    signature is currently being applied

ida_funcs.IDASGN_OK (variable)
    ok

ida_funcs.IDASGN_PLANNED (variable)
    signature is planned to be applied

ida_funcs.LIBFUNC_DELAY (variable)
    no decision because of lack of information

ida_funcs.LIBFUNC_FOUND (variable)
    ok, library function is found

ida_funcs.LIBFUNC_NONE (variable)
    no, this is not a library function

ida_funcs.MOVE_FUNC_BADSTART (variable)
    bad new start address

ida_funcs.MOVE_FUNC_NOCODE (variable)
    no instruction at 'newstart'

ida_funcs.MOVE_FUNC_NOFUNC (variable)
    no function at 'ea'

ida_funcs.MOVE_FUNC_OK (variable)
    ok

ida_funcs.MOVE_FUNC_REFUSED (variable)
    a plugin refused the action

ida_funcs.add_func (function)
    add_func(ea1, ea2=BADADDR) -> bool
    Add a new function. If the function end address is BADADDR, then IDA will try to
    determine the function bounds by calling find_func_bounds(...,
    FIND_FUNC_DEFINE).
    
    @param ea1: (C++: ea_t) start address
    @param ea2: (C++: ea_t) end address
    @return: success

ida_funcs.add_func_ex (function)
    add_func_ex(pfn) -> bool
    Add a new function. If the fn->end_ea is BADADDR, then IDA will try to determine
    the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE).
    
    @param pfn: (C++: func_t *) ptr to filled function structure
    @return: success

ida_funcs.add_regarg (function)
    add_regarg(pfn, reg, tif, name)
    
    @param pfn: func_t *
    @param reg: int
    @param tif: tinfo_t const &
    @param name: char const *

ida_funcs.append_func_tail (function)
    append_func_tail(pfn, ea1, ea2) -> bool
    Append a new tail chunk to the function definition. If the tail already exists,
    then it will simply be added to the function tail list Otherwise a new tail will
    be created and its owner will be set to be our function If a new tail cannot be
    created, then this function will fail.
    
    @param pfn: (C++: func_t *) pointer to the function
    @param ea1: (C++: ea_t) start of the tail. If a tail already exists at the specified address
                it must start at 'ea1'
    @param ea2: (C++: ea_t) end of the tail. If a tail already exists at the specified address
                it must end at 'ea2'. If specified as BADADDR, IDA will determine
                the end address itself.

ida_funcs.apply_idasgn_to (function)
    apply_idasgn_to(signame, ea, is_startup) -> int
    Apply a signature file to the specified address.
    
    @param signame: (C++: const char *) short name of signature file (the file name without path)
    @param ea: (C++: ea_t) address to apply the signature
    @param is_startup: (C++: bool) if set, then the signature is treated as a startup one for
                       startup signature ida doesn't rename the first function of
                       the applied module.
    @return: Library function codes

ida_funcs.apply_startup_sig (function)
    apply_startup_sig(ea, startup) -> bool
    Apply a startup signature file to the specified address.
    
    @param ea: (C++: ea_t) address to apply the signature to; usually idainfo::start_ea
    @param startup: (C++: const char *) the name of the signature file without path and extension
    @return: true if successfully applied the signature

ida_funcs.calc_func_size (function)
    calc_func_size(pfn) -> asize_t
    Calculate function size. This function takes into account all fragments of the
    function.
    
    @param pfn: (C++: func_t *) ptr to function structure

ida_funcs.calc_idasgn_state (function)
    calc_idasgn_state(n) -> int
    Get state of a signature in the list of planned signatures
    
    @param n: (C++: int) number of signature in the list (0..get_idasgn_qty()-1)
    @return: state of signature or IDASGN_BADARG

ida_funcs.calc_thunk_func_target (function)
    calc_thunk_func_target(pfn) -> ea_t
    Calculate target of a thunk function.
    
    @param pfn: (C++: func_t *) pointer to function (may not be nullptr)
    @return: the target function or BADADDR

ida_funcs.calc_thunk_func_target (function)

ida_funcs.del_func (function)
    del_func(ea) -> bool
    Delete a function.
    
    @param ea: (C++: ea_t) any address in the function entry chunk
    @return: success

ida_funcs.del_idasgn (function)
    del_idasgn(n) -> int
    Remove signature from the list of planned signatures.
    
    @param n: (C++: int) number of signature in the list (0..get_idasgn_qty()-1)
    @return: IDASGN_OK, IDASGN_BADARG, IDASGN_APPLIED

ida_funcs.dyn_ea_array (class)
    Proxy of C++ dynamic_wrapped_array_t< ea_t > class.

ida_funcs.dyn_ea_array.__getitem__ (method)
    __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
    
    @param i: size_t

ida_funcs.dyn_ea_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_ea_array
    
    @param _data: unsigned-ea-like-numeric-type *
    @param _count: size_t

ida_funcs.dyn_ea_array.__len__ (method)
    __len__(self) -> size_t

ida_funcs.dyn_ea_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned-ea-like-numeric-type const &

ida_funcs.dyn_range_array (class)
    Proxy of C++ dynamic_wrapped_array_t< range_t > class.

ida_funcs.dyn_range_array.__getitem__ (method)
    __getitem__(self, i) -> range_t
    
    @param i: size_t

ida_funcs.dyn_range_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_range_array
    
    @param _data: range_t *
    @param _count: size_t

ida_funcs.dyn_range_array.__len__ (method)
    __len__(self) -> size_t

ida_funcs.dyn_range_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: range_t const &

ida_funcs.dyn_regarg_array (class)
    Proxy of C++ dynamic_wrapped_array_t< regarg_t > class.

ida_funcs.dyn_regarg_array.__getitem__ (method)
    __getitem__(self, i) -> regarg_t
    
    @param i: size_t

ida_funcs.dyn_regarg_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_regarg_array
    
    @param _data: regarg_t *
    @param _count: size_t

ida_funcs.dyn_regarg_array.__len__ (method)
    __len__(self) -> size_t

ida_funcs.dyn_regarg_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: regarg_t const &

ida_funcs.dyn_regvar_array (class)
    Proxy of C++ dynamic_wrapped_array_t< regvar_t > class.

ida_funcs.dyn_regvar_array.__getitem__ (method)
    __getitem__(self, i) -> regvar_t const &
    
    @param i: size_t

ida_funcs.dyn_regvar_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_regvar_array
    
    @param _data: regvar_t *
    @param _count: size_t

ida_funcs.dyn_regvar_array.__len__ (method)
    __len__(self) -> size_t

ida_funcs.dyn_regvar_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: regvar_t const &

ida_funcs.dyn_stkpnt_array (class)
    Proxy of C++ dynamic_wrapped_array_t< stkpnt_t > class.

ida_funcs.dyn_stkpnt_array.__getitem__ (method)
    __getitem__(self, i) -> stkpnt_t const &
    
    @param i: size_t

ida_funcs.dyn_stkpnt_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_stkpnt_array
    
    @param _data: stkpnt_t *
    @param _count: size_t

ida_funcs.dyn_stkpnt_array.__len__ (method)
    __len__(self) -> size_t

ida_funcs.dyn_stkpnt_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: stkpnt_t const &

ida_funcs.f_any (function)
    f_any(arg1, arg2) -> bool
    Helper function to accept any address.
    
    @param arg1: flags64_t
    @param arg2: void *

ida_funcs.find_func_bounds (function)
    find_func_bounds(nfn, flags) -> int
    Determine the boundaries of a new function. This function tries to find the
    start and end addresses of a new function. It calls the module with
    processor_t::func_bounds in order to fine tune the function boundaries.
    
    @param nfn: (C++: func_t *) structure to fill with information \ nfn->start_ea points to the
                start address of the new function.
    @param flags: (C++: int) Find function bounds flags
    @return: Find function bounds result codes

ida_funcs.free_regarg (function)
    free_regarg(v)
    
    @param v: regarg_t *

ida_funcs.func_contains (function)
    func_contains(pfn, ea) -> bool
    Does the given function contain the given address?
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

ida_funcs.func_does_return (function)
    func_does_return(callee) -> bool
    Does the function return?. To calculate the answer, FUNC_NORET flag and
    is_noret() are consulted The latter is required for imported functions in the
    .idata section. Since in .idata we have only function pointers but not
    functions, we have to introduce a special flag for them.
    
    @param callee: (C++: ea_t)

ida_funcs.func_item_iterator_t (class)
    Proxy of C++ func_item_iterator_t class.

ida_funcs.func_item_iterator_t.__init__ (method)
    __init__(self) -> func_item_iterator_t
    __init__(self, pfn, _ea=BADADDR) -> func_item_iterator_t
    
    @param pfn: func_t *
    @param _ea: ea_t

ida_funcs.func_item_iterator_t.__iter__ (method)
    Provide an iterator on code items

ida_funcs.func_item_iterator_t.__next__ (method)
    __next__(self, func) -> bool
    
    @param func: testf_t *

ida_funcs.func_item_iterator_t.addresses (method)
    Provide an iterator on addresses contained within the function

ida_funcs.func_item_iterator_t.chunk (method)
    chunk(self) -> range_t

ida_funcs.func_item_iterator_t.code_items (method)
    Provide an iterator on code items contained within the function

ida_funcs.func_item_iterator_t.current (method)
    current(self) -> ea_t

ida_funcs.func_item_iterator_t.data_items (method)
    Provide an iterator on data items contained within the function

ida_funcs.func_item_iterator_t.decode_preceding_insn (method)
    decode_preceding_insn(self, visited, p_farref, out) -> bool
    
    @param visited: eavec_t *
    @param p_farref: bool *
    @param out: insn_t *

ida_funcs.func_item_iterator_t.decode_prev_insn (method)
    decode_prev_insn(self, out) -> bool
    
    @param out: insn_t *

ida_funcs.func_item_iterator_t.first (method)
    first(self) -> bool

ida_funcs.func_item_iterator_t.head_items (method)
    Provide an iterator on item heads contained within the function

ida_funcs.func_item_iterator_t.last (method)
    last(self) -> bool

ida_funcs.func_item_iterator_t.next_addr (method)
    next_addr(self) -> bool

ida_funcs.func_item_iterator_t.next_code (method)
    next_code(self) -> bool

ida_funcs.func_item_iterator_t.next_data (method)
    next_data(self) -> bool

ida_funcs.func_item_iterator_t.next_head (method)
    next_head(self) -> bool

ida_funcs.func_item_iterator_t.next_not_tail (method)
    next_not_tail(self) -> bool

ida_funcs.func_item_iterator_t.not_tails (method)
    Provide an iterator on non-tail addresses contained within the function

ida_funcs.func_item_iterator_t.prev (method)
    prev(self, func) -> bool
    
    @param func: testf_t *

ida_funcs.func_item_iterator_t.prev_addr (method)
    prev_addr(self) -> bool

ida_funcs.func_item_iterator_t.prev_code (method)
    prev_code(self) -> bool

ida_funcs.func_item_iterator_t.prev_data (method)
    prev_data(self) -> bool

ida_funcs.func_item_iterator_t.prev_head (method)
    prev_head(self) -> bool

ida_funcs.func_item_iterator_t.prev_not_tail (method)
    prev_not_tail(self) -> bool

ida_funcs.func_item_iterator_t.set (method)
    set(self, pfn, _ea=BADADDR) -> bool
    Set a function range. if pfn == nullptr then a segment range will be set.
    
    @param pfn: (C++: func_t *)
    @param _ea: (C++: ea_t)

ida_funcs.func_item_iterator_t.set_range (method)
    set_range(self, ea1, ea2) -> bool
    Set an arbitrary range.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

ida_funcs.func_item_iterator_t.succ (method)
    succ(self, func) -> bool
    Similar to next(), but succ() iterates the chunks from low to high addresses,
    while next() iterates through chunks starting at the function entry chunk
    
    @param func: (C++: testf_t *)

ida_funcs.func_item_iterator_t.succ_code (method)
    succ_code(self) -> bool

ida_funcs.func_parent_iterator_set (function)
    func_parent_iterator_set(fpi, pfn) -> bool
    
    @param fpi: func_parent_iterator_t *
    @param pfn: func_t *

ida_funcs.func_parent_iterator_t (class)
    Proxy of C++ func_parent_iterator_t class.

ida_funcs.func_parent_iterator_t.__init__ (method)
    __init__(self) -> func_parent_iterator_t
    __init__(self, _fnt) -> func_parent_iterator_t
    
    @param _fnt: func_t *

ida_funcs.func_parent_iterator_t.__iter__ (method)
    Provide an iterator on function parents

ida_funcs.func_parent_iterator_t.__next__ (method)
    __next__(self) -> bool

ida_funcs.func_parent_iterator_t.first (method)
    first(self) -> bool

ida_funcs.func_parent_iterator_t.last (method)
    last(self) -> bool

ida_funcs.func_parent_iterator_t.parent (method)
    parent(self) -> ea_t

ida_funcs.func_parent_iterator_t.prev (method)
    prev(self) -> bool

ida_funcs.func_parent_iterator_t.reset_fnt (method)
    reset_fnt(self, _fnt)
    
    @param _fnt: func_t *

ida_funcs.func_parent_iterator_t.set (method)
    set(self, _fnt) -> bool
    
    @param _fnt: func_t *

ida_funcs.func_t (class)
    Proxy of C++ func_t class.

ida_funcs.func_t.__get_points__ (method)
    __get_points__(self) -> dyn_stkpnt_array

ida_funcs.func_t.__get_referers__ (method)
    __get_referers__(self) -> dyn_ea_array

ida_funcs.func_t.__get_regargs__ (method)
    __get_regargs__(self) -> dyn_regarg_array

ida_funcs.func_t.__get_regvars__ (method)
    __get_regvars__(self) -> dyn_regvar_array

ida_funcs.func_t.__get_tails__ (method)
    __get_tails__(self) -> dyn_range_array

ida_funcs.func_t.__init__ (method)
    __init__(self, start=0, end=0, f=0) -> func_t
    
    @param start: ea_t
    @param end: ea_t
    @param f: flags64_t

ida_funcs.func_t.__iter__ (method)
    Alias for func_item_iterator_t(self).__iter__()

ida_funcs.func_t.addresses (method)
    Alias for func_item_iterator_t(self).addresses()

ida_funcs.func_t.analyzed_sp (method)
    analyzed_sp(self) -> bool
    Has SP-analysis been performed?

ida_funcs.func_t.argsize (variable)
    number of bytes purged from the stack upon returning

ida_funcs.func_t.code_items (method)
    Alias for func_item_iterator_t(self).code_items()

ida_funcs.func_t.color (variable)
    user defined function color

ida_funcs.func_t.data_items (method)
    Alias for func_item_iterator_t(self).data_items()

ida_funcs.func_t.does_return (method)
    does_return(self) -> bool
    Does function return?

ida_funcs.func_t.flags (variable)
    Function flags

ida_funcs.func_t.fpd (variable)
    frame pointer delta. (usually 0, i.e. realBP==typicalBP) use update_fpd() to
    modify it.

ida_funcs.func_t.frame (variable)
    netnode id of frame structure - see frame.hpp

ida_funcs.func_t.frregs (variable)
    size of saved registers in frame. This range is immediately above the local
    variables range.

ida_funcs.func_t.frsize (variable)
    size of local variables part of frame in bytes. If FUNC_FRAME is set and fpd==0,
    the frame pointer (EBP) is assumed to point to the top of the local variables
    range.

ida_funcs.func_t.head_items (method)
    Alias for func_item_iterator_t(self).head_items()

ida_funcs.func_t.is_far (method)
    is_far(self) -> bool
    Is a far function?

ida_funcs.func_t.need_prolog_analysis (method)
    need_prolog_analysis(self) -> bool
    Needs prolog analysis?

ida_funcs.func_t.not_tails (method)
    Alias for func_item_iterator_t(self).not_tails()

ida_funcs.func_t.owner (variable)
    the address of the main function possessing this tail

ida_funcs.func_t.pntqty (variable)
    number of SP change points

ida_funcs.func_t.points (variable)
    array of SP change points. use ...stkpnt...() functions to access this array.

ida_funcs.func_t.referers (variable)
    array of referers (function start addresses). use func_parent_iterator_t to
    access the referers.

ida_funcs.func_t.refqty (variable)
    number of referers

ida_funcs.func_t.regargqty (variable)
    number of register arguments. During analysis IDA tries to guess the register
    arguments. It stores store the guessing outcome in this field. As soon as it
    determines the final function prototype, regargqty is set to zero.

ida_funcs.func_t.regargs (variable)
    unsorted array of register arguments. use ...regarg...() functions to access
    this array. regargs are destroyed when the full function type is determined.

ida_funcs.func_t.regvarqty (variable)
    number of register variables (-1-not read in yet) use find_regvar() to read
    register variables

ida_funcs.func_t.regvars (variable)
    array of register variables. this array is sorted by: start_ea. use
    ...regvar...() functions to access this array.

ida_funcs.func_t.tailqty (variable)
    number of function tails

ida_funcs.func_t.tails (variable)
    array of tails, sorted by ea. use func_tail_iterator_t to access function tails.

ida_funcs.func_t__from_ptrval__ (function)
    func_t__from_ptrval__(ptrval) -> func_t
    
    @param ptrval: size_t

ida_funcs.func_tail_iterator_set (function)
    func_tail_iterator_set(fti, pfn, ea) -> bool
    
    @param fti: func_tail_iterator_t *
    @param pfn: func_t *
    @param ea: ea_t

ida_funcs.func_tail_iterator_set_ea (function)
    func_tail_iterator_set_ea(fti, ea) -> bool
    
    @param fti: func_tail_iterator_t *
    @param ea: ea_t

ida_funcs.func_tail_iterator_t (class)
    Proxy of C++ func_tail_iterator_t class.

ida_funcs.func_tail_iterator_t.__init__ (method)
    __init__(self) -> func_tail_iterator_t
    __init__(self, _pfn, ea=BADADDR) -> func_tail_iterator_t
    
    @param _pfn: func_t *
    @param ea: ea_t

ida_funcs.func_tail_iterator_t.__iter__ (method)
    Provide an iterator on function tails

ida_funcs.func_tail_iterator_t.__next__ (method)
    __next__(self) -> bool

ida_funcs.func_tail_iterator_t.chunk (method)
    chunk(self) -> range_t

ida_funcs.func_tail_iterator_t.first (method)
    first(self) -> bool

ida_funcs.func_tail_iterator_t.last (method)
    last(self) -> bool

ida_funcs.func_tail_iterator_t.main (method)
    main(self) -> bool

ida_funcs.func_tail_iterator_t.prev (method)
    prev(self) -> bool

ida_funcs.func_tail_iterator_t.set (method)
    set(self, _pfn, ea=BADADDR) -> bool
    
    @param _pfn: func_t *
    @param ea: ea_t

ida_funcs.func_tail_iterator_t.set_ea (method)
    set_ea(self, ea) -> bool
    
    @param ea: ea_t

ida_funcs.func_tail_iterator_t.set_range (method)
    set_range(self, ea1, ea2) -> bool
    
    @param ea1: ea_t
    @param ea2: ea_t

ida_funcs.get_current_idasgn (function)
    get_current_idasgn() -> int
    Get number of the the current signature.
    
    @return: 0..n-1

ida_funcs.get_fchunk (function)
    get_fchunk(ea) -> func_t
    Get pointer to function chunk structure by address.
    
    @param ea: (C++: ea_t) any address in a function chunk
    @return: ptr to a function chunk or nullptr. This function may return a function
             entry as well as a function tail.

ida_funcs.get_fchunk_num (function)
    get_fchunk_num(ea) -> int
    Get ordinal number of a function chunk in the global list of function chunks.
    
    @param ea: (C++: ea_t) any address in the function chunk
    @return: number of function chunk (0..get_fchunk_qty()-1). -1 means 'no function
             chunk at the specified address'.

ida_funcs.get_fchunk_qty (function)
    get_fchunk_qty() -> size_t
    Get total number of function chunks in the program.

ida_funcs.get_fchunk_referer (function)
    get_fchunk_referer(ea, idx) -> ea_t
    
    @param ea: ea_t
    @param idx: size_t

ida_funcs.get_func (function)
    get_func(ea) -> func_t
    Get pointer to function structure by address.
    
    @param ea: (C++: ea_t) any address in a function
    @return: ptr to a function or nullptr. This function returns a function entry
             chunk.

ida_funcs.get_func_bitness (function)
    get_func_bitness(pfn) -> int
    Get function bitness (which is equal to the function segment bitness).
    pfn==nullptr => returns 0
    @retval 0: 16
    @retval 1: 32
    @retval 2: 64
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.get_func_bits (function)
    get_func_bits(pfn) -> int
    Get number of bits in the function addressing.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.get_func_bytes (function)
    get_func_bytes(pfn) -> int
    Get number of bytes in the function addressing.
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.get_func_chunknum (function)
    get_func_chunknum(pfn, ea) -> int
    Get the containing tail chunk of 'ea'.
    @retval -1: means 'does not contain ea'
    @retval 0: means the 'pfn' itself contains ea
    @retval >0: the number of the containing function tail chunk
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

ida_funcs.get_func_cmt (function)
    get_func_cmt(pfn, repeatable) -> str
    Get function comment.
    
    @param pfn: (C++: const func_t *) ptr to function structure
    @param repeatable: (C++: bool) get repeatable comment?
    @return: size of comment or -1 In fact this function works with function chunks
             too.

ida_funcs.get_func_name (function)
    get_func_name(ea) -> str
    Get function name.
    
    @param ea: (C++: ea_t) any address in the function
    @return: length of the function name

ida_funcs.get_func_num (function)
    get_func_num(ea) -> int
    Get ordinal number of a function.
    
    @param ea: (C++: ea_t) any address in the function
    @return: number of function (0..get_func_qty()-1). -1 means 'no function at the
             specified address'.

ida_funcs.get_func_qty (function)
    get_func_qty() -> size_t
    Get total number of functions in the program.

ida_funcs.get_func_ranges (function)
    get_func_ranges(ranges, pfn) -> ea_t
    Get function ranges.
    
    @param ranges: (C++: rangeset_t *) buffer to receive the range info
    @param pfn: (C++: func_t *) ptr to function structure
    @return: end address of the last function range (BADADDR-error)

ida_funcs.get_idasgn_desc (function)
    get_idasgn_desc(n) -> (str, str)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs)

ida_funcs.get_idasgn_desc_with_matches (function)
    get_idasgn_desc_with_matches(n) -> (str, str, int)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs, nmatches)

ida_funcs.get_idasgn_qty (function)
    get_idasgn_qty() -> int
    Get number of signatures in the list of planned and applied signatures.
    
    @return: 0..n

ida_funcs.get_idasgn_title (function)
    get_idasgn_title(name) -> str
    Get full description of the signature by its short name.
    
    @param name: (C++: const char *) short name of a signature
    @return: size of signature description or -1

ida_funcs.get_next_fchunk (function)
    get_next_fchunk(ea) -> func_t
    Get pointer to the next function chunk in the global list.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function chunk or nullptr if next function chunk doesn't exist

ida_funcs.get_next_func (function)
    get_next_func(ea) -> func_t
    Get pointer to the next function.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function or nullptr if next function doesn't exist

ida_funcs.get_next_func_addr (function)
    get_next_func_addr(pfn, ea) -> ea_t
    
    @param pfn: func_t *
    @param ea: ea_t

ida_funcs.get_prev_fchunk (function)
    get_prev_fchunk(ea) -> func_t
    Get pointer to the previous function chunk in the global list.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function chunk or nullptr if previous function chunk doesn't
             exist

ida_funcs.get_prev_func (function)
    get_prev_func(ea) -> func_t
    Get pointer to the previous function.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function or nullptr if previous function doesn't exist

ida_funcs.get_prev_func_addr (function)
    get_prev_func_addr(pfn, ea) -> ea_t
    
    @param pfn: func_t *
    @param ea: ea_t

ida_funcs.getn_fchunk (function)
    getn_fchunk(n) -> func_t
    Get pointer to function chunk structure by number.
    
    @param n: (C++: int) number of function chunk, is in range 0..get_fchunk_qty()-1
    @return: ptr to a function chunk or nullptr. This function may return a function
             entry as well as a function tail.

ida_funcs.getn_func (function)
    getn_func(n) -> func_t
    Get pointer to function structure by number.
    
    @param n: (C++: size_t) number of function, is in range 0..get_func_qty()-1
    @return: ptr to a function or nullptr. This function returns a function entry
             chunk.

ida_funcs.is_finally_visible_func (function)
    is_finally_visible_func(pfn) -> bool
    Is the function visible (event after considering SCF_SHHID_FUNC)?
    
    @param pfn: (C++: func_t *)

ida_funcs.is_func_entry (function)
    is_func_entry(pfn) -> bool
    Does function describe a function entry chunk?
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.is_func_locked (function)
    is_func_locked(pfn) -> bool
    Is the function pointer locked?
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.is_func_tail (function)
    is_func_tail(pfn) -> bool
    Does function describe a function tail chunk?
    
    @param pfn: (C++: const func_t *) func_t const *

ida_funcs.is_same_func (function)
    is_same_func(ea1, ea2) -> bool
    Do two addresses belong to the same function?
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

ida_funcs.is_visible_func (function)
    is_visible_func(pfn) -> bool
    Is the function visible (not hidden)?
    
    @param pfn: (C++: func_t *)

ida_funcs.lock_func (class)
    Proxy of C++ lock_func class.

ida_funcs.lock_func.__init__ (method)
    __init__(self, _pfn) -> lock_func
    
    @param _pfn: func_t const *

ida_funcs.lock_func_range (function)
    lock_func_range(pfn, lock)
    Lock function pointer Locked pointers are guaranteed to remain valid until they
    are unlocked. Ranges with locked pointers cannot be deleted or moved.
    
    @param pfn: (C++: const func_t *) func_t const *
    @param lock: (C++: bool)

ida_funcs.lock_func_with_tails_t (class)
    Proxy of C++ lock_func_with_tails_t class.

ida_funcs.lock_func_with_tails_t.__init__ (method)
    __init__(self, pfn) -> lock_func_with_tails_t
    
    @param pfn: func_t *

ida_funcs.plan_to_apply_idasgn (function)
    plan_to_apply_idasgn(fname) -> int
    Add a signature file to the list of planned signature files.
    
    @param fname: (C++: const char *) file name. should not contain directory part.
    @return: 0 if failed, otherwise number of planned (and applied) signatures

ida_funcs.read_regargs (function)
    read_regargs(pfn)
    
    @param pfn: func_t *

ida_funcs.reanalyze_function (function)
    reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)
    Reanalyze a function. This function plans to analyzes all chunks of the given
    function. Optional parameters (ea1, ea2) may be used to narrow the analyzed
    range.
    
    @param pfn: (C++: func_t *) pointer to a function
    @param ea1: (C++: ea_t) start of the range to analyze
    @param ea2: (C++: ea_t) end of range to analyze
    @param analyze_parents: (C++: bool) meaningful only if pfn points to a function tail. if
                            true, all tail parents will be reanalyzed. if false,
                            only the given tail will be reanalyzed.

ida_funcs.reanalyze_noret_flag (function)
    reanalyze_noret_flag(ea) -> bool
    Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is
    already present. It just plans to reanalysis.
    
    @param ea: (C++: ea_t)

ida_funcs.regarg_t (class)
    Proxy of C++ regarg_t class.

ida_funcs.regarg_t.__init__ (method)
    __init__(self) -> regarg_t
    __init__(self, r) -> regarg_t
    
    @param r: regarg_t const &

ida_funcs.regarg_t.swap (method)
    swap(self, r)
    
    @param r: regarg_t &

ida_funcs.remove_func_tail (function)
    remove_func_tail(pfn, tail_ea) -> bool
    Remove a function tail. If the tail belongs only to one function, it will be
    completely removed. Otherwise if the function was the tail owner, the first
    function using this tail becomes the owner of the tail.
    
    @param pfn: (C++: func_t *) pointer to the function
    @param tail_ea: (C++: ea_t) any address inside the tail to remove

ida_funcs.set_func_cmt (function)
    set_func_cmt(pfn, cmt, repeatable) -> bool
    Set function comment. This function works with function chunks too.
    
    @param pfn: (C++: const func_t *) ptr to function structure
    @param cmt: (C++: const char *) comment string, may be multiline (with '
    '). Use empty str ("") to delete comment
    @param repeatable: (C++: bool) set repeatable comment?

ida_funcs.set_func_end (function)
    set_func_end(ea, newend) -> bool
    Move function chunk end address.
    
    @param ea: (C++: ea_t) any address in the function
    @param newend: (C++: ea_t) new end address of the function
    @return: success

ida_funcs.set_func_name_if_jumpfunc (function)
    set_func_name_if_jumpfunc(pfn, oldname) -> int
    Give a meaningful name to function if it consists of only 'jump' instruction.
    
    @param pfn: (C++: func_t *) pointer to function (may be nullptr)
    @param oldname: (C++: const char *) old name of function. if old name was in "j_..." form, then we
                    may discard it and set a new name. if oldname is not known, you
                    may pass nullptr.
    @return: success

ida_funcs.set_func_start (function)
    set_func_start(ea, newstart) -> int
    Move function chunk start address.
    
    @param ea: (C++: ea_t) any address in the function
    @param newstart: (C++: ea_t) new end address of the function
    @return: Function move result codes

ida_funcs.set_noret_insn (function)
    set_noret_insn(insn_ea, noret) -> bool
    Signal a non-returning instruction. This function can be used by the processor
    module to tell the kernel about non-returning instructions (like call exit). The
    kernel will perform the global function analysis and find out if the function
    returns at all. This analysis will be done at the first call to
    func_does_return()
    
    @param insn_ea: (C++: ea_t)
    @param noret: (C++: bool)
    @return: true if the instruction 'noret' flag has been changed

ida_funcs.set_tail_owner (function)
    set_tail_owner(fnt, new_owner) -> bool
    Set a new owner of a function tail. The new owner function must be already
    referring to the tail (after append_func_tail).
    
    @param fnt: (C++: func_t *) pointer to the function tail
    @param new_owner: (C++: ea_t) the entry point of the new owner function

ida_funcs.set_visible_func (function)
    set_visible_func(pfn, visible)
    Set visibility of function.
    
    @param pfn: (C++: func_t *)
    @param visible: (C++: bool)

ida_funcs.try_to_add_libfunc (function)
    try_to_add_libfunc(ea) -> int
    Apply the currently loaded signature file to the specified address. If a library
    function is found, then create a function and name it accordingly.
    
    @param ea: (C++: ea_t) any address in the program
    @return: Library function codes

ida_funcs.update_func (function)
    update_func(pfn) -> bool
    Update information about a function in the database (func_t). You must not
    change the function start and end addresses using this function. Use
    set_func_start() and set_func_end() for it.
    
    @param pfn: (C++: func_t *) ptr to function structure
    @return: success

ida_gdl (module)
    Low level graph drawing operations.

ida_gdl.BasicBlock (class)
    Basic block class. It is returned by the Flowchart class

ida_gdl.BasicBlock.__init__ (method)
    Block type (check fc_block_type_t enum)

ida_gdl.BasicBlock.preds (method)
    Iterates the predecessors list

ida_gdl.BasicBlock.succs (method)
    Iterates the successors list

ida_gdl.CHART_FOLLOW_DIRECTION (variable)
    analyze references to added blocks only in the direction of the reference who
    discovered the current block

ida_gdl.CHART_GEN_DOT (variable)
    generate .dot file (file extension is forced to .dot)

ida_gdl.CHART_GEN_GDL (variable)
    generate .gdl file (file extension is forced to .gdl)

ida_gdl.CHART_IGNORE_LIB_FROM (variable)
    ignore references from library functions

ida_gdl.CHART_IGNORE_LIB_TO (variable)
    ignore references to library functions

ida_gdl.CHART_NOLIBFUNCS (variable)
    don't include library functions in the graph

ida_gdl.CHART_PRINT_DOTS (variable)
    print dots if xrefs exist outside of the range recursion depth

ida_gdl.CHART_PRINT_NAMES (variable)
    print labels for each block?

ida_gdl.CHART_RECURSIVE (variable)
    analyze added blocks

ida_gdl.CHART_REFERENCED (variable)
    references from the addresses in the list

ida_gdl.CHART_REFERENCING (variable)
    references to the addresses in the list

ida_gdl.CHART_WINGRAPH (variable)
    call grapher to display the graph

ida_gdl.FC_APPND (variable)
    multirange flowchart (set by append_to_flowchart)

ida_gdl.FC_CALL_ENDS (variable)
    call instructions terminate basic blocks

ida_gdl.FC_CHKBREAK (variable)
    build_qflow_chart() may be aborted by user

ida_gdl.FC_NOEXT (variable)
    do not compute external blocks. Use this to prevent jumps leaving the function
    from appearing in the flow chart. Unless specified, the targets of those
    outgoing jumps will be present in the flow chart under the form of one-
    instruction blocks

ida_gdl.FC_NOPREDS (variable)
    do not compute predecessor lists

ida_gdl.FC_OUTLINES (variable)
    include outlined code (with FUNC_OUTLINE)

ida_gdl.FC_PRINT (variable)
    print names (used only by display_flow_chart())

ida_gdl.FlowChart (class)
    Flowchart class used to determine basic blocks.
    Check ex_gdl_qflow_chart.py for sample usage.

ida_gdl.FlowChart.__getitem__ (method)
    Returns a basic block
    
    @return: BasicBlock

ida_gdl.FlowChart.__init__ (method)
    Constructor
    @param f: A func_t type, use get_func(ea) to get a reference
    @param bounds: A tuple of the form (start, end). Used if "f" is None
    @param flags: one of the FC_xxxx flags.

ida_gdl.FlowChart.__iter__ (method)

ida_gdl.FlowChart._getitem (method)

ida_gdl.FlowChart.refresh (method)
    Refreshes the flow chart

ida_gdl.FlowChart.size (variable)
    Number of blocks in the flow chart

ida_gdl.cancellable_graph_t (class)
    Proxy of C++ cancellable_graph_t class.

ida_gdl.cancellable_graph_t.__disown__ (method)

ida_gdl.cancellable_graph_t.__init__ (method)
    __init__(self) -> cancellable_graph_t
    
    @param self: PyObject *

ida_gdl.display_gdl (function)
    display_gdl(fname) -> int
    Display GDL file by calling wingraph32. The exact name of the grapher is taken
    from the configuration file and set up by setup_graph_subsystem(). The path
    should point to a temporary file: when wingraph32 succeeds showing the graph,
    the input file will be deleted.
    
    @param fname: (C++: const char *) char const *
    @return: error code from os, 0 if ok

ida_gdl.fcb_cndret (variable)
    conditional return block

ida_gdl.fcb_enoret (variable)
    external noreturn block (does not belong to the function)

ida_gdl.fcb_error (variable)
    block passes execution past the function end

ida_gdl.fcb_extern (variable)
    external normal block

ida_gdl.fcb_indjump (variable)
    block ends with indirect jump

ida_gdl.fcb_noret (variable)
    noreturn block

ida_gdl.fcb_normal (variable)
    normal block

ida_gdl.fcb_ret (variable)
    return block

ida_gdl.gdl_graph_t (class)
    Proxy of C++ gdl_graph_t class.

ida_gdl.gdl_graph_t.__disown__ (method)

ida_gdl.gdl_graph_t.__init__ (method)
    __init__(self) -> gdl_graph_t
    
    @param self: PyObject *

ida_gdl.gdl_graph_t.begin (method)
    begin(self) -> node_iterator

ida_gdl.gdl_graph_t.edge (method)
    edge(self, node, i, ispred) -> int
    
    @param node: int
    @param i: int
    @param ispred: bool

ida_gdl.gdl_graph_t.empty (method)
    empty(self) -> bool

ida_gdl.gdl_graph_t.end (method)
    end(self) -> node_iterator

ida_gdl.gdl_graph_t.entry (method)
    entry(self) -> int

ida_gdl.gdl_graph_t.exists (method)
    exists(self, node) -> bool
    
    @param node: int

ida_gdl.gdl_graph_t.exit (method)
    exit(self) -> int

ida_gdl.gdl_graph_t.front (method)
    front(self) -> int

ida_gdl.gdl_graph_t.get_edge_color (method)
    get_edge_color(self, i, j) -> bgcolor_t
    
    @param i: int
    @param j: int

ida_gdl.gdl_graph_t.get_node_color (method)
    get_node_color(self, n) -> bgcolor_t
    
    @param n: int

ida_gdl.gdl_graph_t.get_node_label (method)
    get_node_label(self, n) -> char *
    
    @param n: int

ida_gdl.gdl_graph_t.nedge (method)
    nedge(self, node, ispred) -> size_t
    
    @param node: int
    @param ispred: bool

ida_gdl.gdl_graph_t.node_qty (method)
    node_qty(self) -> int

ida_gdl.gdl_graph_t.npred (method)
    npred(self, node) -> int
    
    @param node: int

ida_gdl.gdl_graph_t.nsucc (method)
    nsucc(self, node) -> int
    
    @param node: int

ida_gdl.gdl_graph_t.pred (method)
    pred(self, node, i) -> int
    
    @param node: int
    @param i: int

ida_gdl.gdl_graph_t.print_edge (method)
    print_edge(self, fp, i, j) -> bool
    
    @param fp: FILE *
    @param i: int
    @param j: int

ida_gdl.gdl_graph_t.print_graph_attributes (method)
    print_graph_attributes(self, fp)
    
    @param fp: FILE *

ida_gdl.gdl_graph_t.print_node (method)
    print_node(self, fp, n) -> bool
    
    @param fp: FILE *
    @param n: int

ida_gdl.gdl_graph_t.print_node_attributes (method)
    print_node_attributes(self, fp, n)
    
    @param fp: FILE *
    @param n: int

ida_gdl.gdl_graph_t.size (method)
    size(self) -> int

ida_gdl.gdl_graph_t.succ (method)
    succ(self, node, i) -> int
    
    @param node: int
    @param i: int

ida_gdl.gen_complex_call_chart (function)
    gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool
    Build and display a complex xref graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param wait: (C++: const char *) message to display during graph building
    @param title: (C++: const char *) graph title
    @param ea1: (C++: ea_t) ,ea2: address range
    @param flags: (C++: int) combination of Call chart building flags and Flow graph building
                  flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                  specified, the function will return false.
    @param flags: (C++: int) combination of Call chart building flags and Flow graph building
                  flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                  specified, the function will return false.
    @param recursion_depth: (C++: int32) optional limit of recursion
    @return: success. if fails, a warning message is displayed on the screen

ida_gdl.gen_flow_graph (function)
    gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool
    Build and display a flow graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param title: (C++: const char *) graph title
    @param pfn: (C++: func_t *) function to graph
    @param ea1: (C++: ea_t) ,ea2: if pfn == nullptr, then the address range
    @param gflags: (C++: int) combination of Flow graph building flags. if none of
                   CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the
                   function will return false
    @param gflags: (C++: int) combination of Flow graph building flags. if none of
                   CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the
                   function will return false
    @return: success. if fails, a warning message is displayed on the screen

ida_gdl.gen_gdl (function)
    gen_gdl(g, fname)
    Create GDL file for graph.
    
    @param g: (C++: const gdl_graph_t *) gdl_graph_t const *
    @param fname: (C++: const char *) char const *

ida_gdl.gen_simple_call_chart (function)
    gen_simple_call_chart(filename, wait, title, gflags) -> bool
    Build and display a simple function call graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param wait: (C++: const char *) message to display during graph building
    @param title: (C++: const char *) graph title
    @param gflags: (C++: int) combination of CHART_NOLIBFUNCS and Flow graph building flags. if
                   none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                   specified, the function will return false.
    @return: success. if fails, a warning message is displayed on the screen

ida_gdl.is_noret_block (function)
    is_noret_block(btype) -> bool
    Does this block never return?
    
    @param btype: (C++: fc_block_type_t) enum fc_block_type_t

ida_gdl.is_ret_block (function)
    is_ret_block(btype) -> bool
    Does this block return?
    
    @param btype: (C++: fc_block_type_t) enum fc_block_type_t

ida_gdl.node_iterator (class)
    Proxy of C++ node_iterator class.

ida_gdl.node_iterator.__eq__ (method)
    __eq__(self, n) -> bool
    
    @param n: node_iterator const &

ida_gdl.node_iterator.__init__ (method)
    __init__(self, _g, n) -> node_iterator
    
    @param _g: gdl_graph_t const *
    @param n: int

ida_gdl.node_iterator.__ne__ (method)
    __ne__(self, n) -> bool
    
    @param n: node_iterator const &

ida_gdl.node_iterator.__ref__ (method)
    __ref__(self) -> int

ida_gdl.qbasic_block_t (class)
    Proxy of C++ qbasic_block_t class.

ida_gdl.qbasic_block_t.__init__ (method)
    __init__(self) -> qbasic_block_t

ida_gdl.qflow_chart_t (class)
    Proxy of C++ qflow_chart_t class.

ida_gdl.qflow_chart_t.__getitem__ (method)
    __getitem__(self, n) -> qbasic_block_t
    
    @param n: int

ida_gdl.qflow_chart_t.__init__ (method)
    __init__(self) -> qflow_chart_t
    __init__(self, _title, _pfn, _ea1, _ea2, _flags) -> qflow_chart_t
    
    @param _title: char const *
    @param _pfn: func_t *
    @param _ea1: ea_t
    @param _ea2: ea_t
    @param _flags: int

ida_gdl.qflow_chart_t.append_to_flowchart (method)
    append_to_flowchart(self, ea1, ea2)
    
    @param ea1: ea_t
    @param ea2: ea_t

ida_gdl.qflow_chart_t.bounds (variable)
    overall bounds of the qflow_chart_t instance

ida_gdl.qflow_chart_t.calc_block_type (method)
    calc_block_type(self, blknum) -> fc_block_type_t
    
    @param blknum: size_t

ida_gdl.qflow_chart_t.create (method)
    create(self, _title, _pfn, _ea1, _ea2, _flags)
    
    @param _title: char const *
    @param _pfn: func_t *
    @param _ea1: ea_t
    @param _ea2: ea_t
    @param _flags: int
    
    create(self, _title, ranges, _flags)
    
    @param _title: char const *
    @param ranges: rangevec_t const &
    @param _flags: int

ida_gdl.qflow_chart_t.flags (variable)
    flags. See Flow chart flags

ida_gdl.qflow_chart_t.get_node_label (method)
    get_node_label(self, n) -> char *
    
    @param n: int

ida_gdl.qflow_chart_t.is_noret_block (method)
    is_noret_block(self, blknum) -> bool
    
    @param blknum: size_t

ida_gdl.qflow_chart_t.is_ret_block (method)
    is_ret_block(self, blknum) -> bool
    
    @param blknum: size_t

ida_gdl.qflow_chart_t.npred (method)
    npred(self, node) -> int
    
    @param node: int

ida_gdl.qflow_chart_t.nproper (variable)
    number of basic blocks belonging to the specified range

ida_gdl.qflow_chart_t.nsucc (method)
    nsucc(self, node) -> int
    
    @param node: int

ida_gdl.qflow_chart_t.pfn (variable)
    the function this instance was built upon

ida_gdl.qflow_chart_t.pred (method)
    pred(self, node, i) -> int
    
    @param node: int
    @param i: int

ida_gdl.qflow_chart_t.print_names (method)
    print_names(self) -> bool

ida_gdl.qflow_chart_t.print_node_attributes (method)
    print_node_attributes(self, fp, n)
    
    @param fp: FILE *
    @param n: int

ida_gdl.qflow_chart_t.refresh (method)
    refresh(self)

ida_gdl.qflow_chart_t.size (method)
    size(self) -> int

ida_gdl.qflow_chart_t.succ (method)
    succ(self, node, i) -> int
    
    @param node: int
    @param i: int

ida_graph (module)
    Graph view management.

ida_graph.GLICTL_CENTER (variable)
    the gli should be set/get as center

ida_graph.GraphViewer (class)
    This class wraps the user graphing facility provided by the graph.hpp file

ida_graph.GraphViewer.AddCommand (method)

ida_graph.GraphViewer.AddEdge (method)
    Creates an edge between two given node ids

ida_graph.GraphViewer.AddNode (method)
    Creates a node associated with the given object and returns the node id

ida_graph.GraphViewer.Clear (method)
    Clears all the nodes and edges

ida_graph.GraphViewer.Close (method)
    Closes the graph.
    It is possible to call Show() again (which will recreate the graph)

ida_graph.GraphViewer.Count (method)
    Returns the node count

ida_graph.GraphViewer.OnCommand (method)

ida_graph.GraphViewer.OnPopup (method)

ida_graph.GraphViewer.OnRefresh (method)
    Event called when the graph is refreshed or first created.
    From this event you are supposed to create nodes and edges.
    This callback is mandatory.
    
    @note: ***It is important to clear previous nodes before adding nodes.***
    @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.

ida_graph.GraphViewer.Select (method)
    Selects a node on the graph

ida_graph.GraphViewer.Show (method)
    Shows an existing graph or creates a new one
    
    @return: Boolean

ida_graph.GraphViewer.UI_Hooks_Trampoline (class)

ida_graph.GraphViewer.UI_Hooks_Trampoline.__init__ (method)

ida_graph.GraphViewer.UI_Hooks_Trampoline.populating_widget_popup (method)

ida_graph.GraphViewer._OnBind (method)

ida_graph.GraphViewer.__getitem__ (method)
    Returns a reference to the object associated with this node id

ida_graph.GraphViewer.__init__ (method)
    Constructs the GraphView object.
    Please do not remove or rename the private fields
    
    @param title: The title of the graph window
    @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?

ida_graph.GraphViewer.__init__._qccb (function)

ida_graph.GraphViewer.__iter__ (method)

ida_graph.MTG_DOT_NODE (variable)
    is dot node?

ida_graph.MTG_GROUP_NODE (variable)
    is group node?

ida_graph.MTG_NON_DISPLAYABLE_NODE (variable)
    for disassembly graphs - non-displayable nodes have a visible area that is too
    large to generate disassembly lines for without IDA slowing down significantly
    (see MAX_VISIBLE_NODE_AREA)

ida_graph.NIF_BG_COLOR (variable)
    node_info_t::bg_color

ida_graph.NIF_EA (variable)
    node_info_t::ea

ida_graph.NIF_FLAGS (variable)
    node_info_t::flags

ida_graph.NIF_FRAME_COLOR (variable)
    node_info_t::frame_color

ida_graph.NIF_TEXT (variable)
    node_info_t::text

ida_graph.TPointDouble (class)
    Proxy of C++ TPointDouble class.

ida_graph.TPointDouble.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: TPointDouble const &

ida_graph.TPointDouble.__init__ (method)
    __init__(self) -> TPointDouble
    __init__(self, a, b) -> TPointDouble
    
    @param a: double
    @param b: double
    
    __init__(self, r) -> TPointDouble
    
    @param r: point_t const &

ida_graph.TPointDouble.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: TPointDouble const &

ida_graph.TPointDouble.add (method)
    add(self, r)
    
    @param r: TPointDouble const &

ida_graph.TPointDouble.negate (method)
    negate(self)

ida_graph.TPointDouble.sub (method)
    sub(self, r)
    
    @param r: TPointDouble const &

ida_graph.abstract_graph_t (class)
    Proxy of C++ abstract_graph_t class.

ida_graph.abstract_graph_t.__disown__ (method)

ida_graph.abstract_graph_t.__init__ (method)
    __init__(self) -> abstract_graph_t
    
    @param self: PyObject *

ida_graph.abstract_graph_t.callback_ud (variable)
    user data for callback

ida_graph.abstract_graph_t.circle_center (variable)
    for layout_circle

ida_graph.abstract_graph_t.circle_radius (variable)
    for layout_circle

ida_graph.abstract_graph_t.create_circle_layout (method)
    create_circle_layout(self, p, radius) -> bool
    
    @param p: point_t
    @param radius: int

ida_graph.abstract_graph_t.create_tree_layout (method)
    create_tree_layout(self) -> bool

ida_graph.abstract_graph_t.current_layout (variable)
    see Proximity view layouts

ida_graph.abstract_graph_t.get_edge (method)
    get_edge(self, e) -> edge_info_t
    
    @param e: edge_t

ida_graph.abstract_graph_t.grcall (method)
    grcall(self, code) -> ssize_t
    
    @param code: int

ida_graph.abstract_graph_t.nrect (method)
    nrect(self, n) -> rect_t
    
    @param n: int

ida_graph.abstract_graph_t.rect_edges_made (variable)
    have create rectangular edges?

ida_graph.abstract_graph_t.set_callback (method)
    set_callback(self, _callback, _ud)
    
    @param _callback: hook_cb_t *
    @param _ud: void *

ida_graph.abstract_graph_t.title (variable)
    graph title

ida_graph.calc_dist (function)
    calc_dist(p, q) -> double
    Calculate distance between p and q.
    
    @param p: (C++: point_t)
    @param q: (C++: point_t)

ida_graph.clr_node_info (function)
    clr_node_info(gid, node, flags)
    Clear node info for the given node.
    
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @param flags: (C++: uint32) combination of Node info flags, identifying which fields of
                  node_info_t will be cleared

ida_graph.create_disasm_graph (function)
    create_disasm_graph(ea) -> mutable_graph_t
    Create a graph using an arbitrary set of ranges.
    
    @param ea: ea_t
    
    create_disasm_graph(ranges) -> mutable_graph_t
    
    @param ranges: rangevec_t const &

ida_graph.create_graph_viewer (function)
    create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *
    Create a custom graph viewer.
    
    @param title: (C++: const char *) the widget title
    @param id: (C++: uval_t) graph id
    @param callback: (C++: hook_cb_t *) callback to handle graph notifications (graph_notification_t)
    @param ud: (C++: void *) user data passed to callback
    @param title_height: (C++: int) node title height
    @param parent: (C++: TWidget *) the parent widget of the graph viewer
    @return: new viewer

ida_graph.create_mutable_graph (function)
    create_mutable_graph(id) -> mutable_graph_t
    Create a new empty graph with given id.
    
    @param id: (C++: uval_t)

ida_graph.create_user_graph_place (function)
    create_user_graph_place(node, lnnum) -> user_graph_place_t
    Get a copy of a user_graph_place_t (returns a pointer to static storage)
    
    @param node: (C++: int)
    @param lnnum: (C++: int)

ida_graph.del_node_info (function)
    del_node_info(gid, node)
    Delete the node_info_t for the given node.
    
    @param gid: (C++: graph_id_t)
    @param node: (C++: int)

ida_graph.delete_mutable_graph (function)
    delete_mutable_graph(g)
    Delete graph object.
    @warning: use this only if you are dealing with mutable_graph_t instances that
              have not been used together with a graph_viewer_t. If you have called
              set_viewer_graph() with your graph, the graph's lifecycle will be
              managed by the viewer, and you shouldn't interfere with it
    
    @param g: (C++: mutable_graph_t *)

ida_graph.edge_info_t (class)
    Proxy of C++ edge_info_t class.

ida_graph.edge_info_t.__init__ (method)
    __init__(self) -> edge_info_t

ida_graph.edge_info_t.color (variable)
    edge color

ida_graph.edge_info_t.layout (variable)
    describes geometry of edge

ida_graph.edge_info_t.reverse_layout (method)
    reverse_layout(self)

ida_graph.edge_info_t.width (variable)
    edge width

ida_graph.edge_infos_wrapper_t (class)
    Proxy of C++ edge_infos_wrapper_t class.

ida_graph.edge_infos_wrapper_t.__init__ (method)

ida_graph.edge_infos_wrapper_t.clear (method)
    clear(self)

ida_graph.edge_layout_point_t (class)
    Proxy of C++ edge_layout_point_t class.

ida_graph.edge_layout_point_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: edge_layout_point_t const &

ida_graph.edge_layout_point_t.__init__ (method)
    __init__(self) -> edge_layout_point_t
    __init__(self, _e, _pidx) -> edge_layout_point_t
    
    @param _e: edge_t const &
    @param _pidx: int

ida_graph.edge_layout_point_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: edge_layout_point_t const &

ida_graph.edge_layout_point_t.compare (method)
    compare(self, r) -> int
    
    @param r: edge_layout_point_t const &

ida_graph.edge_layout_point_t.e (variable)
    parent edge

ida_graph.edge_layout_point_t.pidx (variable)
    index into edge_info_t::layout

ida_graph.edge_segment_t (class)
    Proxy of C++ edge_segment_t class.

ida_graph.edge_segment_t.__init__ (method)
    __init__(self) -> edge_segment_t

ida_graph.edge_segment_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: edge_segment_t const &

ida_graph.edge_segment_t.length (method)
    length(self) -> size_t

ida_graph.edge_segment_t.toright (method)
    toright(self) -> bool

ida_graph.edge_t (class)
    Proxy of C++ edge_t class.

ida_graph.edge_t.__eq__ (method)
    __eq__(self, y) -> bool
    
    @param y: edge_t const &

ida_graph.edge_t.__init__ (method)
    __init__(self) -> edge_t
    __init__(self, x, y) -> edge_t
    
    @param x: int
    @param y: int

ida_graph.edge_t.__lt__ (method)
    __lt__(self, y) -> bool
    
    @param y: edge_t const &

ida_graph.edge_t.__ne__ (method)
    __ne__(self, y) -> bool
    
    @param y: edge_t const &

ida_graph.edge_t.dst (variable)
    destination node number

ida_graph.edge_t.src (variable)
    source node number

ida_graph.get_graph_viewer (function)
    get_graph_viewer(parent) -> graph_viewer_t *
    Get custom graph viewer for given form.
    
    @param parent: (C++: TWidget *)

ida_graph.get_node_info (function)
    get_node_info(out, gid, node) -> bool
    Get node info.
    
    @param out: (C++: node_info_t *) result
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @return: success

ida_graph.get_viewer_graph (function)
    get_viewer_graph(gv) -> mutable_graph_t
    Get graph object for given custom graph viewer.
    
    @param gv: (C++: graph_viewer_t *)

ida_graph.git_edge (variable)
    edge (graph_item_t::e, graph_item_t::n. n is farthest edge endpoint)

ida_graph.git_elp (variable)
    edge layout point (graph_item_t::elp)

ida_graph.git_node (variable)
    node title (graph_item_t::n)

ida_graph.git_none (variable)
    nothing

ida_graph.git_text (variable)
    node text (graph_item_t::n, graph_item_t::p)

ida_graph.git_tool (variable)
    node title button (graph_item_t::n, graph_item_t::b)

ida_graph.graph_item_t (class)
    Proxy of C++ graph_item_t class.

ida_graph.graph_item_t.__init__ (method)
    __init__(self) -> graph_item_t

ida_graph.graph_item_t.b (variable)
    button number

ida_graph.graph_item_t.e (variable)
    edge source and destination

ida_graph.graph_item_t.elp (variable)
    edge layout point

ida_graph.graph_item_t.is_edge (method)
    is_edge(self) -> bool

ida_graph.graph_item_t.is_node (method)
    is_node(self) -> bool

ida_graph.graph_item_t.n (variable)
    node number

ida_graph.graph_item_t.p (variable)
    text coordinates in the node

ida_graph.graph_item_t.type (variable)
    type

ida_graph.graph_node_visitor_t (class)
    Proxy of C++ graph_node_visitor_t class.

ida_graph.graph_node_visitor_t.__disown__ (method)

ida_graph.graph_node_visitor_t.__init__ (method)
    __init__(self) -> graph_node_visitor_t
    
    @param self: PyObject *

ida_graph.graph_node_visitor_t.is_forbidden_edge (method)
    is_forbidden_edge(self, arg0, arg1) -> bool
    Should the edge between 'n' and 'm' be ignored?
    
    @param arg0: int
    @param arg1: int

ida_graph.graph_node_visitor_t.is_visited (method)
    is_visited(self, n) -> bool
    Have we already visited the given node?
    
    @param n: (C++: int)

ida_graph.graph_node_visitor_t.reinit (method)
    reinit(self)
    Reset visited nodes.

ida_graph.graph_node_visitor_t.set_visited (method)
    set_visited(self, n)
    Mark node as visited.
    
    @param n: (C++: int)

ida_graph.graph_node_visitor_t.visit_node (method)
    visit_node(self, arg0) -> int
    Implements action to take when a node is visited.
    
    @param arg0: int

ida_graph.graph_path_visitor_t (class)
    Proxy of C++ graph_path_visitor_t class.

ida_graph.graph_path_visitor_t.__disown__ (method)

ida_graph.graph_path_visitor_t.__init__ (method)
    __init__(self) -> graph_path_visitor_t
    
    @param self: PyObject *

ida_graph.graph_path_visitor_t.path (variable)
    current path

ida_graph.graph_path_visitor_t.prune (variable)
    walk_forward(): prune := true means to stop the current path

ida_graph.graph_path_visitor_t.walk_backward (method)
    walk_backward(self, arg0) -> int
    
    @param arg0: int

ida_graph.graph_path_visitor_t.walk_forward (method)
    walk_forward(self, arg0) -> int
    
    @param arg0: int

ida_graph.graph_visitor_t (class)
    Proxy of C++ graph_visitor_t class.

ida_graph.graph_visitor_t.__disown__ (method)

ida_graph.graph_visitor_t.__init__ (method)
    __init__(self) -> graph_visitor_t
    
    @param self: PyObject *

ida_graph.graph_visitor_t.visit_edge (method)
    visit_edge(self, arg2, arg3) -> int
    
    @param arg2: edge_t
    @param arg3: edge_info_t *

ida_graph.graph_visitor_t.visit_node (method)
    visit_node(self, arg2, arg3) -> int
    
    @param arg2: int
    @param arg3: rect_t &

ida_graph.grcode_calculating_layout (variable)
    calculating user-defined graph layout.
    
    @retval 0: not implemented
    @retval 1: graph layout calculated by the plugin

ida_graph.grcode_center_on (variable)
    use viewer_center_on()

ida_graph.grcode_change_group_visibility (variable)
    use mutable_graph_t::change_group_visibility()

ida_graph.grcode_changed_graph (variable)
    new graph has been set.
    
    @retval 0: must return 0

ida_graph.grcode_clear (variable)
    use mutable_graph_t::clear()

ida_graph.grcode_clicked (variable)
    graph is being clicked. this callback allows you to ignore some clicks. it
    occurs too early, internal graph variables are not updated yet. current_item1,
    current_item2 point to the same thing. item2 has more information. see also:
    custom_viewer_click_t
    
    @retval 0: ok
    @retval 1: ignore click

ida_graph.grcode_create_circle_layout (variable)
    use abstract_graph_t::create_circle_layout()

ida_graph.grcode_create_digraph_layout (variable)
    use mutable_graph_t::create_digraph_layout()

ida_graph.grcode_create_disasm_graph1 (variable)
    use create_disasm_graph(ea_t ea)

ida_graph.grcode_create_disasm_graph2 (variable)
    use create_disasm_graph(const rangevec_t &ranges)

ida_graph.grcode_create_graph_viewer (variable)
    use create_graph_viewer()

ida_graph.grcode_create_group (variable)
    use mutable_graph_t::create_group()

ida_graph.grcode_create_mutable_graph (variable)
    use create_mutable_graph()

ida_graph.grcode_create_tree_layout (variable)
    use abstract_graph_t::create_tree_layout()

ida_graph.grcode_create_user_graph_place (variable)
    use create_user_graph_place()

ida_graph.grcode_creating_group (variable)
    a group is being created. this provides an opportunity for the graph to forbid
    creation of the group. Note that groups management is done by the
    mutable_graph_t instance itself: there is no need to modify the graph in this
    callback.
    
    @retval 0: ok
    @retval 1: forbid group creation

ida_graph.grcode_dblclicked (variable)
    a graph node has been double clicked.
    
    @retval 0: ok
    @retval 1: ignore click

ida_graph.grcode_del_custom_layout (variable)
    use mutable_graph_t::del_custom_layout()

ida_graph.grcode_del_node_info (variable)
    use viewer_del_node_info()

ida_graph.grcode_delete_group (variable)
    use mutable_graph_t::delete_group()

ida_graph.grcode_delete_mutable_graph (variable)
    use delete_mutable_graph()

ida_graph.grcode_deleting_group (variable)
    a group is being deleted. this provides an opportunity for the graph to forbid
    deletion of the group. Note that groups management is done by the
    mutable_graph_t instance itself: there is no need to modify the graph in this
    callback.
    
    @retval 0: ok
    @retval 1: forbid group deletion

ida_graph.grcode_destroyed (variable)
    graph is being destroyed. Note that this doesn't mean the graph viewer is being
    destroyed; this only means that the graph that is being displayed by it is being
    destroyed, and that, e.g., any possibly cached data should be invalidated (this
    event can happen when, for example, the user decides to group nodes together:
    that operation will effectively create a new graph, that will replace the old
    one.) To be notified when the graph viewer itself is being destroyed, please see
    notification 'view_close', in kernwin.hpp
    
    @retval 0: must return 0

ida_graph.grcode_edge_infos_wrapper_clear (variable)
    use edge_infos_wrapper_t::clear()

ida_graph.grcode_edge_infos_wrapper_copy (variable)
    use edge_infos_wrapper_t::operator=()

ida_graph.grcode_empty (variable)
    use mutable_graph_t::empty()

ida_graph.grcode_find_subgraph_node (variable)
    use mutable_graph_t::_find_subgraph_node()

ida_graph.grcode_fit_window (variable)
    use viewer_fit_window()

ida_graph.grcode_get_curnode (variable)
    use viewer_get_curnode()

ida_graph.grcode_get_custom_layout (variable)
    use mutable_graph_t::get_custom_layout()

ida_graph.grcode_get_gli (variable)
    use viewer_get_gli()

ida_graph.grcode_get_graph_groups (variable)
    use mutable_graph_t::get_graph_groups()

ida_graph.grcode_get_graph_viewer (variable)
    use get_graph_viewer()

ida_graph.grcode_get_node_info (variable)
    use viewer_get_node_info()

ida_graph.grcode_get_node_representative (variable)
    use mutable_graph_t::get_node_representative()

ida_graph.grcode_get_selection (variable)
    use viewer_get_selection()

ida_graph.grcode_get_viewer_graph (variable)
    use get_viewer_graph()

ida_graph.grcode_gotfocus (variable)
    a graph viewer got focus.
    
    @retval 0: must return 0

ida_graph.grcode_group_visibility (variable)
    a group is being collapsed/uncollapsed this provides an opportunity for the
    graph to forbid changing the visibility of the group. Note that groups
    management is done by the mutable_graph_t instance itself: there is no need to
    modify the graph in this callback.
    
    @retval 0: ok
    @retval 1: forbid group modification

ida_graph.grcode_is_visible_node (variable)
    use mutable_graph_t::is_visible_node()

ida_graph.grcode_layout_calculated (variable)
    graph layout calculated.
    
    @retval 0: must return 0

ida_graph.grcode_lostfocus (variable)
    a graph viewer lost focus.
    
    @retval 0: must return 0

ida_graph.grcode_node_qty (variable)
    use mutable_graph_t::node_qty()

ida_graph.grcode_nrect (variable)
    use mutable_graph_t::nrect()

ida_graph.grcode_refresh_viewer (variable)
    use refresh_viewer()

ida_graph.grcode_set_custom_layout (variable)
    use mutable_graph_t::set_custom_layout()

ida_graph.grcode_set_edge (variable)
    use mutable_graph_t::set_edge()

ida_graph.grcode_set_gli (variable)
    use viewer_set_gli()

ida_graph.grcode_set_graph_groups (variable)
    use mutable_graph_t::set_graph_groups()

ida_graph.grcode_set_node_info (variable)
    use viewer_set_node_info()

ida_graph.grcode_set_titlebar_height (variable)
    use viewer_set_titlebar_height()

ida_graph.grcode_set_viewer_graph (variable)
    use set_viewer_graph()

ida_graph.grcode_user_draw (variable)
    render node of a user-defined graph. NB: draw only on the specified DC and
    nowhere else!
    
    @retval 0: not rendered
    @retval 1: rendered

ida_graph.grcode_user_hint (variable)
    retrieve hint for the user-defined graph.
    
    @retval 0: use default hint
    @retval 1: use proposed hint

ida_graph.grcode_user_refresh (variable)
    refresh user-defined graph nodes and edges This is called when the UI considers
    that it is necessary to recreate the graph layout, and thus has to ensure that
    the 'mutable_graph_t' instance it is using, is up-to-date. For example:
    * at graph creation-time
    * if a refresh_viewer() call was made
    
    @return: success

ida_graph.grcode_user_size (variable)
    calculate node size for user-defined graph.
    
    @retval 0: did not calculate. ida will use node text size
    @retval 1: calculated. ida will add node title to the size

ida_graph.grcode_user_text (variable)
    retrieve text for user-defined graph node. NB: do not use anything calling GDI!
    
    @return: success, result must be filled

ida_graph.grcode_user_title (variable)
    render node title of a user-defined graph.
    
    @retval 0: did not render, ida will fill it with title_bg_color
    @retval 1: rendered node title

ida_graph.grcode_viewer_create_groups_vec (variable)
    use viewer_create_groups()

ida_graph.grcode_viewer_delete_groups_vec (variable)
    use viewer_delete_groups()

ida_graph.grcode_viewer_groups_visibility_vec (variable)
    use viewer_set_groups_visibility()

ida_graph.group_crinfo_t (class)
    Proxy of C++ group_crinfo_t class.

ida_graph.group_crinfo_t.__init__ (method)
    __init__(self) -> group_crinfo_t

ida_graph.interval_t (class)
    Proxy of C++ interval_t class.

ida_graph.interval_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: interval_t const &

ida_graph.interval_t.__init__ (method)
    __init__(self) -> interval_t
    __init__(self, y0, y1) -> interval_t
    
    @param y0: int
    @param y1: int
    
    __init__(self, s) -> interval_t
    
    @param s: edge_segment_t const &

ida_graph.interval_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: interval_t const &

ida_graph.interval_t.contains (method)
    contains(self, x) -> bool
    
    @param x: int

ida_graph.interval_t.empty (method)
    empty(self) -> bool

ida_graph.interval_t.intersect (method)
    intersect(self, r)
    
    @param r: interval_t const &

ida_graph.interval_t.length (method)
    length(self) -> int

ida_graph.interval_t.make_union (method)
    make_union(self, r)
    
    @param r: interval_t const &

ida_graph.interval_t.move_by (method)
    move_by(self, shift)
    
    @param shift: int

ida_graph.mutable_graph_t (class)
    Proxy of C++ mutable_graph_t class.

ida_graph.mutable_graph_t.__init__ (method)

ida_graph.mutable_graph_t.add_edge (method)
    add_edge(self, i, j, ei) -> bool
    
    @param i: int
    @param j: int
    @param ei: edge_info_t const *

ida_graph.mutable_graph_t.add_node (method)
    add_node(self, r) -> int
    Add a node, possibly with a specific geometry
    
    @param r: (C++: const rect_t *) the node geometry (can be nullptr)
    @return: the new node

ida_graph.mutable_graph_t.belongs (variable)
    the subgraph the node belongs to INT_MAX means that the node doesn't exist sign
    bit means collapsed node

ida_graph.mutable_graph_t.calc_group_ea (method)
    calc_group_ea(self, arg2) -> ea_t
    
    @param arg2: intvec_t const &

ida_graph.mutable_graph_t.change_group_visibility (method)
    change_group_visibility(self, group, expand) -> bool
    Expand/collapse a group node
    
    @param group: (C++: int) the group node
    @param expand: (C++: bool) whether to expand or collapse
    @return: success

ida_graph.mutable_graph_t.create_digraph_layout (method)
    create_digraph_layout(self) -> bool

ida_graph.mutable_graph_t.create_group (method)
    create_group(self, nodes) -> int
    Create a new group node, that will contain all the nodes in 'nodes'.
    
    @param nodes: (C++: const intvec_t &) the nodes that will be part of the group
    @return: the group node, or -1 in case of error

ida_graph.mutable_graph_t.del_custom_layout (method)
    del_custom_layout(self)

ida_graph.mutable_graph_t.del_edge (method)
    del_edge(self, i, j) -> bool
    
    @param i: int
    @param j: int

ida_graph.mutable_graph_t.del_node (method)
    del_node(self, n) -> ssize_t
    Delete a node
    
    @param n: (C++: int) the node to delete
    @return: the number of deleted edges

ida_graph.mutable_graph_t.delete_group (method)
    delete_group(self, group) -> bool
    Delete a group node.
    
    This deletes the group node only; it does not delete nodes that are part of the
    group.
    
    @param group: (C++: int) the group node
    @return: success

ida_graph.mutable_graph_t.empty (method)
    empty(self) -> bool
    Is the graph (visually) empty?
    
    @return: true if there are no visible nodes

ida_graph.mutable_graph_t.exists (method)
    exists(self, node) -> bool
    Is the node visible?
    
    @param node: (C++: int) the node number
    @return: success

ida_graph.mutable_graph_t.get_custom_layout (method)
    get_custom_layout(self) -> bool

ida_graph.mutable_graph_t.get_first_subgraph_node (method)
    get_first_subgraph_node(self, group) -> int
    
    @param group: int

ida_graph.mutable_graph_t.get_graph_groups (method)
    get_graph_groups(self) -> bool

ida_graph.mutable_graph_t.get_next_subgraph_node (method)
    get_next_subgraph_node(self, group, current) -> int
    
    @param group: int
    @param current: int

ida_graph.mutable_graph_t.get_node_group (method)
    get_node_group(self, node) -> int
    
    @param node: int

ida_graph.mutable_graph_t.get_node_representative (method)
    get_node_representative(self, node) -> int
    Get the node that currently visually represents 'node'. This will find the
    "closest" parent group node that's visible, by attempting to walk up the group
    nodes that contain 'node', and will stop when it finds a node that is currently
    visible.
    
    See also get_group_node()
    
    @param node: (C++: int) the node
    @return: the node that represents 'node', or 'node' if it's not part of any
             group

ida_graph.mutable_graph_t.gid (variable)
    graph id - unique for the database for flowcharts it is equal to the function
    start_ea

ida_graph.mutable_graph_t.is_collapsed_node (method)
    is_collapsed_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_deleted_node (method)
    is_deleted_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_displayable_node (method)
    is_displayable_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_dot_node (method)
    is_dot_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_group_node (method)
    is_group_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_simple_node (method)
    is_simple_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_subgraph_node (method)
    is_subgraph_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_uncollapsed_node (method)
    is_uncollapsed_node(self, node) -> bool
    
    @param node: int

ida_graph.mutable_graph_t.is_user_graph (method)
    is_user_graph(self) -> bool

ida_graph.mutable_graph_t.is_visible_node (method)
    is_visible_node(self, node) -> bool
    Is the node currently visible?
    
    An invisible node is a node that's part of a group that's currently collapsed.
    
    @param node: (C++: int) the node
    @return: success

ida_graph.mutable_graph_t.node_flags (variable)
    node flags

ida_graph.mutable_graph_t.node_qty (method)
    node_qty(self) -> int
    Get the number of visible nodes (the list can be retrieved using gdl.hpp's
    node_iterator)
    
    See also size()
    
    @return: the number of visible nodes

ida_graph.mutable_graph_t.npred (method)
    npred(self, b) -> int
    
    @param b: int

ida_graph.mutable_graph_t.nsucc (method)
    nsucc(self, b) -> int
    
    @param b: int

ida_graph.mutable_graph_t.pred (method)
    pred(self, b, i) -> int
    
    @param b: int
    @param i: int

ida_graph.mutable_graph_t.predset (method)
    predset(self, b) -> intvec_t const &
    
    @param b: int

ida_graph.mutable_graph_t.redo_layout (method)
    redo_layout(self) -> bool
    Recompute the layout, according to the value of 'current_layout'.
    
    @return: success

ida_graph.mutable_graph_t.refresh (method)
    refresh(self) -> bool
    Refresh the graph
    
    A graph needs refreshing when it's "backing data". E.g., if the number (or
    contents) of the objects in the above example, change.
    
    Let's say the user's plugin ends up finding a 5th piece of scattered data. It
    should then add it to its internal list of known objects, and tell IDA that the
    graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
    * discard all its internal rendering information,
    * call mutable_graph_t::refresh() on the graph so that the user's plugin has a
    chance to "sync" the number of nodes & edges that this graph contains, to the
    information that the plugin has collected so far
    * re-create internal rendering information, and
    * repaint the view
    
    @return: success

ida_graph.mutable_graph_t.replace_edge (method)
    replace_edge(self, i, j, x, y) -> bool
    
    @param i: int
    @param j: int
    @param x: int
    @param y: int

ida_graph.mutable_graph_t.reset (method)
    reset(self)

ida_graph.mutable_graph_t.resize (method)
    resize(self, n)
    Resize the graph to 'n' nodes
    
    @param n: (C++: int) the new size

ida_graph.mutable_graph_t.set_custom_layout (method)
    set_custom_layout(self)

ida_graph.mutable_graph_t.set_deleted_node (method)
    set_deleted_node(self, node)
    
    @param node: int

ida_graph.mutable_graph_t.set_edge (method)
    set_edge(self, e, ei) -> bool
    
    @param e: edge_t
    @param ei: edge_info_t const *

ida_graph.mutable_graph_t.set_graph_groups (method)
    set_graph_groups(self)

ida_graph.mutable_graph_t.set_node_group (method)
    set_node_group(self, node, group)
    
    @param node: int
    @param group: int

ida_graph.mutable_graph_t.set_nrect (method)
    set_nrect(self, n, r) -> bool
    
    @param n: int
    @param r: rect_t const &

ida_graph.mutable_graph_t.size (method)
    size(self) -> int
    Get the total number of nodes (including group nodes, and including hidden
    nodes.)
    
    See also node_qty()
    
    @return: the total number of nodes in the graph

ida_graph.mutable_graph_t.succ (method)
    succ(self, b, i) -> int
    
    @param b: int
    @param i: int

ida_graph.mutable_graph_t.succset (method)
    succset(self, b) -> intvec_t const &
    
    @param b: int

ida_graph.node_info_t (class)
    Proxy of C++ node_info_t class.

ida_graph.node_info_t.__init__ (method)
    __init__(self) -> node_info_t

ida_graph.node_info_t.bg_color (variable)
    background color

ida_graph.node_info_t.ea (variable)
    address

ida_graph.node_info_t.flags (variable)
    flags

ida_graph.node_info_t.frame_color (variable)
    color of enclosing frame

ida_graph.node_info_t.get_flags_for_valid (method)
    get_flags_for_valid(self) -> uint32
    Get combination of Node info flags describing which attributes are valid.

ida_graph.node_info_t.text (variable)
    node contents

ida_graph.node_info_t.valid_bg_color (method)
    valid_bg_color(self) -> bool
    Has valid bg_color?

ida_graph.node_info_t.valid_ea (method)
    valid_ea(self) -> bool
    Has valid ea?

ida_graph.node_info_t.valid_flags (method)
    valid_flags(self) -> bool
    Has valid flags?

ida_graph.node_info_t.valid_frame_color (method)
    valid_frame_color(self) -> bool
    Has valid frame_color?

ida_graph.node_info_t.valid_text (method)
    valid_text(self) -> bool
    Has non-empty text?

ida_graph.node_layout_t (class)
    Proxy of C++ qvector< rect_t > class.

ida_graph.node_layout_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< rect_t > const &

ida_graph.node_layout_t.__getitem__ (method)
    __getitem__(self, i) -> rect_t
    
    @param i: size_t

ida_graph.node_layout_t.__init__ (method)
    __init__(self) -> node_layout_t
    __init__(self, x) -> node_layout_t
    
    @param x: qvector< rect_t > const &

ida_graph.node_layout_t.__len__ (method)
    __len__(self) -> size_t

ida_graph.node_layout_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< rect_t > const &

ida_graph.node_layout_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: rect_t const &

ida_graph.node_layout_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: rect_t const &

ida_graph.node_layout_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: rect_t const &

ida_graph.node_layout_t.at (method)
    at(self, _idx) -> rect_t
    
    @param _idx: size_t

ida_graph.node_layout_t.begin (method)
    begin(self) -> rect_t

ida_graph.node_layout_t.capacity (method)
    capacity(self) -> size_t

ida_graph.node_layout_t.clear (method)
    clear(self)

ida_graph.node_layout_t.empty (method)
    empty(self) -> bool

ida_graph.node_layout_t.end (method)
    end(self) -> rect_t

ida_graph.node_layout_t.erase (method)
    erase(self, it) -> rect_t
    
    @param it: qvector< rect_t >::iterator
    
    erase(self, first, last) -> rect_t
    
    @param first: qvector< rect_t >::iterator
    @param last: qvector< rect_t >::iterator

ida_graph.node_layout_t.extract (method)
    extract(self) -> rect_t

ida_graph.node_layout_t.find (method)
    find(self, x) -> rect_t
    
    @param x: rect_t const &

ida_graph.node_layout_t.grow (method)
    grow(self, x=rect_t())
    
    @param x: rect_t const &

ida_graph.node_layout_t.has (method)
    has(self, x) -> bool
    
    @param x: rect_t const &

ida_graph.node_layout_t.inject (method)
    inject(self, s, len)
    
    @param s: rect_t *
    @param len: size_t

ida_graph.node_layout_t.insert (method)
    insert(self, it, x) -> rect_t
    
    @param it: qvector< rect_t >::iterator
    @param x: rect_t const &

ida_graph.node_layout_t.pop_back (method)
    pop_back(self)

ida_graph.node_layout_t.push_back (method)
    push_back(self, x)
    
    @param x: rect_t const &
    
    push_back(self) -> rect_t

ida_graph.node_layout_t.qclear (method)
    qclear(self)

ida_graph.node_layout_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_graph.node_layout_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: rect_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_graph.node_layout_t.size (method)
    size(self) -> size_t

ida_graph.node_layout_t.swap (method)
    swap(self, r)
    
    @param r: qvector< rect_t > &

ida_graph.node_layout_t.truncate (method)
    truncate(self)

ida_graph.node_ordering_t (class)
    Proxy of C++ node_ordering_t class.

ida_graph.node_ordering_t.__init__ (method)
    __init__(self) -> node_ordering_t

ida_graph.node_ordering_t.clear (method)
    clear(self)

ida_graph.node_ordering_t.clr (method)
    clr(self, _node) -> bool
    
    @param _node: int

ida_graph.node_ordering_t.node (method)
    node(self, _order) -> int
    
    @param _order: size_t

ida_graph.node_ordering_t.order (method)
    order(self, _node) -> int
    
    @param _node: int

ida_graph.node_ordering_t.resize (method)
    resize(self, n)
    
    @param n: int

ida_graph.node_ordering_t.set (method)
    set(self, _node, num)
    
    @param _node: int
    @param num: int

ida_graph.node_ordering_t.size (method)
    size(self) -> size_t

ida_graph.point_t (class)
    Proxy of C++ point_t class.

ida_graph.point_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: point_t const &

ida_graph.point_t.__init__ (method)
    __init__(self) -> point_t
    __init__(self, _x, _y) -> point_t
    
    @param _x: int
    @param _y: int

ida_graph.point_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: point_t const &

ida_graph.point_t.add (method)
    add(self, r) -> point_t
    
    @param r: point_t const &

ida_graph.point_t.negate (method)
    negate(self)

ida_graph.point_t.sub (method)
    sub(self, r) -> point_t
    
    @param r: point_t const &

ida_graph.pointseq_t (class)
    Proxy of C++ pointseq_t class.

ida_graph.pointseq_t.__init__ (method)
    __init__(self) -> pointseq_t

ida_graph.pointvec_t (class)
    Proxy of C++ qvector< point_t > class.

ida_graph.pointvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< point_t > const &

ida_graph.pointvec_t.__getitem__ (method)
    __getitem__(self, i) -> point_t
    
    @param i: size_t

ida_graph.pointvec_t.__init__ (method)
    __init__(self) -> pointvec_t
    __init__(self, x) -> pointvec_t
    
    @param x: qvector< point_t > const &

ida_graph.pointvec_t.__len__ (method)
    __len__(self) -> size_t

ida_graph.pointvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< point_t > const &

ida_graph.pointvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: point_t const &

ida_graph.pointvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: point_t const &

ida_graph.pointvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: point_t const &

ida_graph.pointvec_t.at (method)
    at(self, _idx) -> point_t
    
    @param _idx: size_t

ida_graph.pointvec_t.begin (method)
    begin(self) -> point_t

ida_graph.pointvec_t.capacity (method)
    capacity(self) -> size_t

ida_graph.pointvec_t.clear (method)
    clear(self)

ida_graph.pointvec_t.empty (method)
    empty(self) -> bool

ida_graph.pointvec_t.end (method)
    end(self) -> point_t

ida_graph.pointvec_t.erase (method)
    erase(self, it) -> point_t
    
    @param it: qvector< point_t >::iterator
    
    erase(self, first, last) -> point_t
    
    @param first: qvector< point_t >::iterator
    @param last: qvector< point_t >::iterator

ida_graph.pointvec_t.extract (method)
    extract(self) -> point_t

ida_graph.pointvec_t.find (method)
    find(self, x) -> point_t
    
    @param x: point_t const &

ida_graph.pointvec_t.grow (method)
    grow(self, x=point_t())
    
    @param x: point_t const &

ida_graph.pointvec_t.has (method)
    has(self, x) -> bool
    
    @param x: point_t const &

ida_graph.pointvec_t.inject (method)
    inject(self, s, len)
    
    @param s: point_t *
    @param len: size_t

ida_graph.pointvec_t.insert (method)
    insert(self, it, x) -> point_t
    
    @param it: qvector< point_t >::iterator
    @param x: point_t const &

ida_graph.pointvec_t.pop_back (method)
    pop_back(self)

ida_graph.pointvec_t.push_back (method)
    push_back(self, x)
    
    @param x: point_t const &
    
    push_back(self) -> point_t

ida_graph.pointvec_t.qclear (method)
    qclear(self)

ida_graph.pointvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_graph.pointvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: point_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_graph.pointvec_t.size (method)
    size(self) -> size_t

ida_graph.pointvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< point_t > &

ida_graph.pointvec_t.truncate (method)
    truncate(self)

ida_graph.pyg_close (function)
    pyg_close(_self)
    
    @param self: PyObject *

ida_graph.pyg_select_node (function)
    pyg_select_node(_self, nid)
    
    @param self: PyObject *
    @param nid: int

ida_graph.pyg_show (function)
    pyg_show(_self) -> bool
    
    @param self: PyObject *

ida_graph.rect_t (class)
    Proxy of C++ rect_t class.

ida_graph.rect_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: rect_t const &

ida_graph.rect_t.__init__ (method)
    __init__(self) -> rect_t
    __init__(self, l, t, r, b) -> rect_t
    
    @param l: int
    @param t: int
    @param r: int
    @param b: int
    
    __init__(self, p0, p1) -> rect_t
    
    @param p0: point_t const &
    @param p1: point_t const &

ida_graph.rect_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: rect_t const &

ida_graph.rect_t.area (method)
    area(self) -> int

ida_graph.rect_t.bottomright (method)
    bottomright(self) -> point_t

ida_graph.rect_t.center (method)
    center(self) -> point_t

ida_graph.rect_t.contains (method)
    contains(self, p) -> bool
    
    @param p: point_t const &

ida_graph.rect_t.empty (method)
    empty(self) -> bool

ida_graph.rect_t.grow (method)
    grow(self, delta)
    
    @param delta: int

ida_graph.rect_t.height (method)
    height(self) -> int

ida_graph.rect_t.intersect (method)
    intersect(self, r)
    
    @param r: rect_t const &

ida_graph.rect_t.is_intersection_empty (method)
    is_intersection_empty(self, r) -> bool
    
    @param r: rect_t const &

ida_graph.rect_t.make_union (method)
    make_union(self, r)
    
    @param r: rect_t const &

ida_graph.rect_t.move_by (method)
    move_by(self, p)
    
    @param p: point_t const &

ida_graph.rect_t.move_to (method)
    move_to(self, p)
    
    @param p: point_t const &

ida_graph.rect_t.topleft (method)
    topleft(self) -> point_t

ida_graph.rect_t.width (method)
    width(self) -> int

ida_graph.refresh_viewer (function)
    refresh_viewer(gv)
    Redraw the graph in the given view.
    
    @param gv: (C++: graph_viewer_t *)

ida_graph.row_info_t (class)
    Proxy of C++ row_info_t class.

ida_graph.row_info_t.__init__ (method)
    __init__(self) -> row_info_t

ida_graph.row_info_t.bottom (variable)
    bottom y coord of the row

ida_graph.row_info_t.height (method)
    height(self) -> int

ida_graph.row_info_t.nodes (variable)
    list of nodes at the row

ida_graph.row_info_t.top (variable)
    top y coord of the row

ida_graph.screen_graph_selection_base_t (class)
    Proxy of C++ qvector< selection_item_t > class.

ida_graph.screen_graph_selection_base_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< selection_item_t > const &

ida_graph.screen_graph_selection_base_t.__getitem__ (method)
    __getitem__(self, i) -> selection_item_t
    
    @param i: size_t

ida_graph.screen_graph_selection_base_t.__init__ (method)
    __init__(self) -> screen_graph_selection_base_t
    __init__(self, x) -> screen_graph_selection_base_t
    
    @param x: qvector< selection_item_t > const &

ida_graph.screen_graph_selection_base_t.__len__ (method)
    __len__(self) -> size_t

ida_graph.screen_graph_selection_base_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< selection_item_t > const &

ida_graph.screen_graph_selection_base_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: selection_item_t const &

ida_graph.screen_graph_selection_base_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.at (method)
    at(self, _idx) -> selection_item_t
    
    @param _idx: size_t

ida_graph.screen_graph_selection_base_t.begin (method)
    begin(self) -> selection_item_t

ida_graph.screen_graph_selection_base_t.capacity (method)
    capacity(self) -> size_t

ida_graph.screen_graph_selection_base_t.clear (method)
    clear(self)

ida_graph.screen_graph_selection_base_t.empty (method)
    empty(self) -> bool

ida_graph.screen_graph_selection_base_t.end (method)
    end(self) -> selection_item_t

ida_graph.screen_graph_selection_base_t.erase (method)
    erase(self, it) -> selection_item_t
    
    @param it: qvector< selection_item_t >::iterator
    
    erase(self, first, last) -> selection_item_t
    
    @param first: qvector< selection_item_t >::iterator
    @param last: qvector< selection_item_t >::iterator

ida_graph.screen_graph_selection_base_t.extract (method)
    extract(self) -> selection_item_t

ida_graph.screen_graph_selection_base_t.find (method)
    find(self, x) -> selection_item_t
    
    @param x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.grow (method)
    grow(self, x=selection_item_t())
    
    @param x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.has (method)
    has(self, x) -> bool
    
    @param x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.inject (method)
    inject(self, s, len)
    
    @param s: selection_item_t *
    @param len: size_t

ida_graph.screen_graph_selection_base_t.insert (method)
    insert(self, it, x) -> selection_item_t
    
    @param it: qvector< selection_item_t >::iterator
    @param x: selection_item_t const &

ida_graph.screen_graph_selection_base_t.pop_back (method)
    pop_back(self)

ida_graph.screen_graph_selection_base_t.push_back (method)
    push_back(self, x)
    
    @param x: selection_item_t const &
    
    push_back(self) -> selection_item_t

ida_graph.screen_graph_selection_base_t.qclear (method)
    qclear(self)

ida_graph.screen_graph_selection_base_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_graph.screen_graph_selection_base_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: selection_item_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_graph.screen_graph_selection_base_t.size (method)
    size(self) -> size_t

ida_graph.screen_graph_selection_base_t.swap (method)
    swap(self, r)
    
    @param r: qvector< selection_item_t > &

ida_graph.screen_graph_selection_base_t.truncate (method)
    truncate(self)

ida_graph.screen_graph_selection_t (class)
    Proxy of C++ screen_graph_selection_t class.

ida_graph.screen_graph_selection_t.__init__ (method)
    __init__(self) -> screen_graph_selection_t

ida_graph.screen_graph_selection_t.add (method)
    add(self, s)
    
    @param s: screen_graph_selection_t const &

ida_graph.screen_graph_selection_t.add_node (method)
    add_node(self, node)
    
    @param node: int

ida_graph.screen_graph_selection_t.add_point (method)
    add_point(self, e, idx)
    
    @param e: edge_t
    @param idx: int

ida_graph.screen_graph_selection_t.del_node (method)
    del_node(self, node)
    
    @param node: int

ida_graph.screen_graph_selection_t.del_point (method)
    del_point(self, e, idx)
    
    @param e: edge_t
    @param idx: int

ida_graph.screen_graph_selection_t.has (method)
    has(self, item) -> bool
    
    @param item: selection_item_t const &

ida_graph.screen_graph_selection_t.items_count (method)
    items_count(self, look_for_nodes) -> size_t
    
    @param look_for_nodes: bool

ida_graph.screen_graph_selection_t.nodes_count (method)
    nodes_count(self) -> size_t

ida_graph.screen_graph_selection_t.points_count (method)
    points_count(self) -> size_t

ida_graph.screen_graph_selection_t.sub (method)
    sub(self, s)
    
    @param s: screen_graph_selection_t const &

ida_graph.selection_item_t (class)
    Proxy of C++ selection_item_t class.

ida_graph.selection_item_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: selection_item_t const &

ida_graph.selection_item_t.__init__ (method)
    __init__(self) -> selection_item_t
    __init__(self, n) -> selection_item_t
    
    @param n: int
    
    __init__(self, _elp) -> selection_item_t
    
    @param _elp: edge_layout_point_t &
    
    __init__(self, e, idx) -> selection_item_t
    
    @param e: edge_t
    @param idx: int

ida_graph.selection_item_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: selection_item_t const &

ida_graph.selection_item_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: selection_item_t const &

ida_graph.selection_item_t.compare (method)
    compare(self, r) -> int
    
    @param r: selection_item_t const &

ida_graph.selection_item_t.elp (variable)
    edge layout point (is_node = false)

ida_graph.selection_item_t.is_node (variable)
    represents a selected node?

ida_graph.selection_item_t.node (variable)
    node number (is_node = true)

ida_graph.set_node_info (function)
    set_node_info(gid, node, ni, flags)
    Set node info.
    
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @param ni: (C++: const node_info_t &) node info to use
    @param flags: (C++: uint32) combination of Node info flags, identifying which fields of 'ni'
                  will be used

ida_graph.set_viewer_graph (function)
    set_viewer_graph(gv, g)
    Set the underlying graph object for the given viewer.
    
    @param gv: (C++: graph_viewer_t *)
    @param g: (C++: mutable_graph_t *)

ida_graph.user_graph_place_t (class)
    Proxy of C++ user_graph_place_t class.

ida_graph.user_graph_place_t.__init__ (method)

ida_graph.viewer_attach_menu_item (function)
    viewer_attach_menu_item(g, name) -> bool
    Attach a previously-registered action to the view's context menu. See
    kernwin.hpp for how to register actions.
    
    @param g: (C++: graph_viewer_t *) graph viewer
    @param name: (C++: const char *) action name
    @return: success

ida_graph.viewer_center_on (function)
    viewer_center_on(gv, node)
    Center the graph view on the given node.
    
    @param gv: (C++: graph_viewer_t *)
    @param node: (C++: int)

ida_graph.viewer_create_groups (function)
    viewer_create_groups(gv, out_group_nodes, gi) -> bool
    This will perform an operation similar to what happens when a user manually
    selects a set of nodes, right-clicks and selects "Create group". This is a
    wrapper around mutable_graph_t::create_group that will, in essence:
    * clone the current graph
    * for each group_crinfo_t, attempt creating group in that new graph
    * if all were successful, animate to that new graph.
    @note: this accepts parameters that allow creating of multiple groups at once;
           which means only one graph animation will be triggered.
    
    @param gv: (C++: graph_viewer_t *)
    @param out_group_nodes: (C++: intvec_t *)
    @param gi: (C++: const groups_crinfos_t &) groups_crinfos_t const &

ida_graph.viewer_del_node_info (function)
    viewer_del_node_info(gv, n)
    Delete node info for node in given viewer (see del_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param n: (C++: int)

ida_graph.viewer_delete_groups (function)
    viewer_delete_groups(gv, groups, new_current=-1) -> bool
    Wrapper around mutable_graph_t::delete_group. This function will:
    * clone the current graph
    * attempt deleting the groups in that new graph
    * if successful, animate to that new graph.
    
    @param gv: (C++: graph_viewer_t *)
    @param groups: (C++: const intvec_t &) intvec_t const &
    @param new_current: (C++: int)

ida_graph.viewer_fit_window (function)
    viewer_fit_window(gv)
    Fit graph viewer to its parent form.
    
    @param gv: (C++: graph_viewer_t *)

ida_graph.viewer_get_curnode (function)
    viewer_get_curnode(gv) -> int
    Get number of currently selected node (-1 if none)
    
    @param gv: (C++: graph_viewer_t *)

ida_graph.viewer_get_gli (function)
    viewer_get_gli(out, gv, flags=0) -> bool
    Get location info for given graph view If flags contains GLICTL_CENTER, then the
    gli that will be retrieved, will be the one at the center of the view. Otherwise
    it will be the top-left.
    
    @param out: (C++: graph_location_info_t *)
    @param gv: (C++: graph_viewer_t *)
    @param flags: (C++: uint32)

ida_graph.viewer_get_node_info (function)
    viewer_get_node_info(gv, out, n) -> bool
    Get node info for node in given viewer (see get_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param out: (C++: node_info_t *)
    @param n: (C++: int)

ida_graph.viewer_get_selection (function)
    viewer_get_selection(gv, sgs) -> bool
    Get currently selected items for graph viewer.
    
    @param gv: (C++: graph_viewer_t *)
    @param sgs: (C++: screen_graph_selection_t *)

ida_graph.viewer_set_gli (function)
    viewer_set_gli(gv, gli, flags=0)
    Set location info for given graph view If flags contains GLICTL_CENTER, then the
    gli will be set to be the center of the view. Otherwise it will be the top-left.
    
    @param gv: (C++: graph_viewer_t *)
    @param gli: (C++: const graph_location_info_t *) graph_location_info_t const *
    @param flags: (C++: uint32)

ida_graph.viewer_set_groups_visibility (function)
    viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool
    Wrapper around mutable_graph_t::change_visibility. This function will:
    * clone the current graph
    * attempt changing visibility of the groups in that new graph
    * if successful, animate to that new graph.
    
    @param gv: (C++: graph_viewer_t *)
    @param groups: (C++: const intvec_t &) intvec_t const &
    @param expand: (C++: bool)
    @param new_current: (C++: int)

ida_graph.viewer_set_node_info (function)
    viewer_set_node_info(gv, n, ni, flags)
    Set node info for node in given viewer (see set_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param n: (C++: int)
    @param ni: (C++: const node_info_t &) node_info_t const &
    @param flags: (C++: uint32)

ida_graph.viewer_set_titlebar_height (function)
    viewer_set_titlebar_height(gv, height) -> int
    Set height of node title bars (grcode_set_titlebar_height)
    
    @param gv: (C++: graph_viewer_t *)
    @param height: (C++: int)

ida_ida (module)
    Contains the inf structure definition and some functions common to the whole IDA
    project.
    
    The inf structure is saved in the database and contains information specific to
    the current program being disassembled. Initially it is filled with values from
    ida.cfg.
    
    Although it is not a good idea to change values in inf structure (because you
    will overwrite values taken from ida.cfg), you are allowed to do it if you feel
    it necessary.

ida_ida.ABI_8ALIGN4 (variable)
    4 byte alignment for 8byte scalars (__int64/double) inside structures?

ida_ida.ABI_BIGARG_ALIGN (variable)
    use natural type alignment for argument if the alignment exceeds native word
    size. (e.g. __int64 argument should be 8byte aligned on some 32bit platforms)

ida_ida.ABI_GCC_LAYOUT (variable)
    use gcc layout for udts (used for mingw)

ida_ida.ABI_HARD_FLOAT (variable)
    use the floating-point register set

ida_ida.ABI_HUGEARG_ALIGN (variable)
    use natural type alignment for an argument even if its alignment exceeds double
    native word size (the default is to use double word max). e.g. if this bit is
    set, __int128 has 16-byte alignment. this bit is not used by ida yet

ida_ida.ABI_MAP_STKARGS (variable)
    register arguments are mapped to stack area (and consume stack slots)

ida_ida.ABI_PACK_STKARGS (variable)
    do not align stack arguments to stack slots

ida_ida.ABI_SET_BY_USER (variable)
    compiler/abi were set by user flag and require SETCOMP_BY_USER flag to be
    changed

ida_ida.ABI_STACK_LDBL (variable)
    long double arguments are passed on stack

ida_ida.ABI_STACK_VARARGS (variable)
    varargs are always passed on stack (even when there are free registers)

ida_ida.AF2_DOEH (variable)
    Handle EH information.

ida_ida.AF2_DORTTI (variable)
    Handle RTTI information.

ida_ida.AF2_MACRO (variable)
    Try to combine several instructions into a macro instruction

ida_ida.AF2_MERGESTR (variable)
    Merge string literals created using data xrefs

ida_ida.AF_ANORET (variable)
    Perform 'no-return' analysis.

ida_ida.AF_CHKUNI (variable)
    Check for unicode strings.

ida_ida.AF_CODE (variable)
    Trace execution flow.

ida_ida.AF_DATOFF (variable)
    Automatically convert data to offsets.

ida_ida.AF_DOCODE (variable)
    Coagulate code segs at the final pass.

ida_ida.AF_DODATA (variable)
    Coagulate data segs at the final pass.

ida_ida.AF_DREFOFF (variable)
    Create offset if data xref to seg32 exists.

ida_ida.AF_FINAL (variable)
    Final pass of analysis.

ida_ida.AF_FIXUP (variable)
    Create offsets and segments using fixup info.

ida_ida.AF_FLIRT (variable)
    Use flirt signatures.

ida_ida.AF_FTAIL (variable)
    Create function tails.

ida_ida.AF_HFLIRT (variable)
    Automatically hide library functions.

ida_ida.AF_IMMOFF (variable)
    Convert 32bit instruction operand to offset.

ida_ida.AF_JFUNC (variable)
    Rename jump functions as j_...

ida_ida.AF_JUMPTBL (variable)
    Locate and create jump tables.

ida_ida.AF_LVAR (variable)
    Create stack variables.

ida_ida.AF_MARKCODE (variable)
    Mark typical code sequences as code.

ida_ida.AF_MEMFUNC (variable)
    Try to guess member function types.

ida_ida.AF_NULLSUB (variable)
    Rename empty functions as nullsub_...

ida_ida.AF_PROC (variable)
    Create functions if call is present.

ida_ida.AF_PROCPTR (variable)
    Create function if data xref data->code32 exists.

ida_ida.AF_PURDAT (variable)
    Control flow to data segment is ignored.

ida_ida.AF_REGARG (variable)
    Propagate register argument information.

ida_ida.AF_SIGCMT (variable)
    Append a signature name comment for recognized anonymous library functions.

ida_ida.AF_SIGMLT (variable)
    Allow recognition of several copies of the same function.

ida_ida.AF_STKARG (variable)
    Propagate stack argument information.

ida_ida.AF_STRLIT (variable)
    Create string literal if data xref exists.

ida_ida.AF_TRACE (variable)
    Trace stack pointer.

ida_ida.AF_TRFUNC (variable)
    Truncate functions upon code deletion.

ida_ida.AF_UNK (variable)
    Delete instructions with no xrefs.

ida_ida.AF_USED (variable)
    Analyze and create all xrefs.

ida_ida.AF_VERSP (variable)
    Perform full SP-analysis. ( processor_t::verify_sp)

ida_ida.DEMNAM_CMNT (variable)
    display demangled names as comments

ida_ida.DEMNAM_FIRST (variable)
    override type info

ida_ida.DEMNAM_GCC3 (variable)
    assume gcc3 names (valid for gnu compiler)

ida_ida.DEMNAM_MASK (variable)
    mask for name form

ida_ida.DEMNAM_NAME (variable)
    display demangled names as regular names

ida_ida.DEMNAM_NONE (variable)
    don't display demangled names

ida_ida.IDAINFO_TAG_SIZE (variable)
    The database parameters. This structure is kept in the ida database. It contains
    the essential parameters for the current program

ida_ida.IDB_COMPRESSED (variable)
    compress & pack database components

ida_ida.IDB_PACKED (variable)
    pack database components into .idb

ida_ida.IDB_UNPACKED (variable)
    leave database components unpacked

ida_ida.INFFL_ALLASM (variable)
    may use constructs not supported by the target assembler

ida_ida.INFFL_AUTO (variable)
    Autoanalysis is enabled?

ida_ida.INFFL_CHKOPS (variable)
    check manual operands? (unused)

ida_ida.INFFL_GRAPH_VIEW (variable)
    currently using graph options ( text_options_t::graph)

ida_ida.INFFL_LOADIDC (variable)
    loading an idc file that contains database info

ida_ida.INFFL_NMOPS (variable)
    allow non-matched operands? (unused)

ida_ida.INFFL_NOUSER (variable)
    do not store user info in the database

ida_ida.INFFL_READONLY (variable)
    (internal) temporary interdiction to modify the database

ida_ida.INF_ABINAME (variable)
    ABI name (processor specific)

ida_ida.INF_ARCHIVE_PATH (variable)
    archive file path

ida_ida.INF_CRC32 (variable)
    input file crc32

ida_ida.INF_CTIME (variable)
    database creation timestamp

ida_ida.INF_C_MACROS (variable)
    C predefined macros.

ida_ida.INF_DBG_BINPATHS (variable)
    unused (20 indexes)

ida_ida.INF_DUALOP_GRAPH (variable)
    Graph text representation options.

ida_ida.INF_DUALOP_TEXT (variable)
    Text text representation options.

ida_ida.INF_ELAPSED (variable)
    seconds database stayed open

ida_ida.INF_FILE_FORMAT_NAME (variable)
    file format name for loader modules

ida_ida.INF_FSIZE (variable)
    input file size

ida_ida.INF_GROUPS (variable)
    segment group information (see init_groups())

ida_ida.INF_H_PATH (variable)
    C header path.

ida_ida.INF_IDA_VERSION (variable)
    version of ida which created the database

ida_ida.INF_IDSNODE (variable)
    ids modnode id (for import_module)

ida_ida.INF_IMAGEBASE (variable)
    image base

ida_ida.INF_INCLUDE (variable)
    assembler include file name

ida_ida.INF_INITIAL_VERSION (variable)
    initial version of database

ida_ida.INF_MD5 (variable)
    MD5 of the input file.

ida_ida.INF_NOPENS (variable)
    how many times the database is opened

ida_ida.INF_NOTEPAD (variable)
    notepad blob, occupies 1000 indexes (1MB of text)

ida_ida.INF_OUTFILEENC (variable)
    output file encoding index

ida_ida.INF_PROBLEMS (variable)
    problem lists

ida_ida.INF_SELECTORS (variable)
    2..63 are for selector_t blob (see init_selectors())

ida_ida.INF_SHA256 (variable)
    SHA256 of the input file.

ida_ida.INF_SRCDBG_PATHS (variable)
    source debug paths, occupies 20 indexes

ida_ida.INF_SRCDBG_UNDESIRED (variable)
    user-closed source files, occupies 20 indexes

ida_ida.INF_STR_ENCODINGS (variable)
    a list of encodings for the program strings

ida_ida.LFLG_64BIT (variable)
    64-bit program?

ida_ida.LFLG_COMPRESS (variable)
    compress the database?

ida_ida.LFLG_DBG_NOPATH (variable)
    do not store input full path in debugger process options

ida_ida.LFLG_FLAT_OFF32 (variable)
    treat REF_OFF32 as 32-bit offset for 16bit segments (otherwise try SEG16:OFF16)

ida_ida.LFLG_IS_DLL (variable)
    Is dynamic library?

ida_ida.LFLG_KERNMODE (variable)
    is kernel mode binary?

ida_ida.LFLG_MSF (variable)
    Byte order: is MSB first?

ida_ida.LFLG_PACK (variable)
    pack the database?

ida_ida.LFLG_PC_FLAT (variable)
    32-bit program (or higher)?

ida_ida.LFLG_PC_FPP (variable)
    decode floating point processor instructions?

ida_ida.LFLG_SNAPSHOT (variable)
    memory snapshot was taken?

ida_ida.LFLG_WIDE_HBF (variable)
    Bit order of wide bytes: high byte first? (wide bytes: processor_t::dnbits > 8)

ida_ida.LMT_EMPTY (variable)
    empty lines at the end of basic blocks

ida_ida.LMT_THICK (variable)
    thick borders

ida_ida.LMT_THIN (variable)
    thin borders

ida_ida.LN_AUTO (variable)
    include autogenerated names

ida_ida.LN_NORMAL (variable)
    include normal names

ida_ida.LN_PUBLIC (variable)
    include public names

ida_ida.LN_WEAK (variable)
    include weak names

ida_ida.OFLG_GEN_ASSUME (variable)
    Generate 'assume' directives?

ida_ida.OFLG_GEN_NULL (variable)
    Generate empty lines?

ida_ida.OFLG_GEN_ORG (variable)
    Generate 'org' directives?

ida_ida.OFLG_GEN_TRYBLKS (variable)
    Generate try/catch directives?

ida_ida.OFLG_LZERO (variable)
    generate leading zeroes in numbers

ida_ida.OFLG_PREF_SEG (variable)
    line prefixes with segment name?

ida_ida.OFLG_SHOW_AUTO (variable)
    Display autoanalysis indicator?

ida_ida.OFLG_SHOW_PREF (variable)
    Show line prefixes?

ida_ida.OFLG_SHOW_VOID (variable)
    Display void marks?

ida_ida.PREF_FNCOFF (variable)
    show function offsets?

ida_ida.PREF_PFXTRUNC (variable)
    truncate instruction bytes if they would need more than 1 line

ida_ida.PREF_SEGADR (variable)
    show segment addresses?

ida_ida.PREF_STACK (variable)
    show stack pointer?

ida_ida.SCF_ALLCMT (variable)
    comment all lines?

ida_ida.SCF_LINNUM (variable)
    show source line numbers

ida_ida.SCF_NOCMT (variable)
    no comments at all

ida_ida.SCF_RPTCMT (variable)
    show repeatable comments?

ida_ida.SCF_SHHID_FUNC (variable)
    show hidden functions

ida_ida.SCF_SHHID_ITEM (variable)
    show hidden instructions

ida_ida.SCF_SHHID_SEGM (variable)
    show hidden segments

ida_ida.SCF_TESTMODE (variable)
    testida.idc is running

ida_ida.STRF_AUTO (variable)
    names have 'autogenerated' bit?

ida_ida.STRF_COMMENT (variable)
    generate auto comment for string references?

ida_ida.STRF_GEN (variable)
    generate names?

ida_ida.STRF_SAVECASE (variable)
    preserve case of strings for identifiers

ida_ida.STRF_SERIAL (variable)
    generate serial names?

ida_ida.STRF_UNICODE (variable)
    unicode strings are present?

ida_ida.STT_CUR (variable)
    use current storage type (may be used only as a function argument)

ida_ida.STT_DBG (variable)
    memory map: temporary debugger storage. used internally

ida_ida.STT_MM (variable)
    memory map: sparse storage. useful for huge objects

ida_ida.STT_VA (variable)
    regular storage: virtual arrays, an explicit flag for each byte

ida_ida.SW_SEGXRF (variable)
    show segments in xrefs?

ida_ida.SW_XRFFNC (variable)
    show function offsets?

ida_ida.SW_XRFMRK (variable)
    show xref type marks?

ida_ida.SW_XRFVAL (variable)
    show xref values? (otherwise-"...")

ida_ida.UA_MAXOP (variable)
    max number of operands allowed for an instruction

ida_ida.VLD_AUTO_REPAIR (variable)
    automatically repair the database

ida_ida.VLD_DIALOG (variable)
    ask user to repair (this bit is mutually exclusive with VLD_AUTO_REPAIR)

ida_ida.VLD_SILENT (variable)
    no messages to the output window

ida_ida.__make_idainfo_accessors (function)

ida_ida.__make_idainfo_bound (function)

ida_ida.__make_idainfo_bound.__func (function)

ida_ida.__make_idainfo_getter (function)

ida_ida.__set_module_dynattrs (function)

ida_ida.__wrap_hooks_callback (function)

ida_ida.__wrap_hooks_callback.__wrapper (function)

ida_ida.calc_default_idaplace_flags (function)
    calc_default_idaplace_flags() -> int
    Get default disassembly line options.

ida_ida.compiler_info_t (class)
    Proxy of C++ compiler_info_t class.

ida_ida.compiler_info_t.__init__ (method)
    __init__(self) -> compiler_info_t

ida_ida.compiler_info_t.cm (variable)
    memory model and calling convention (see CM)

ida_ida.compiler_info_t.defalign (variable)
    default alignment for structures

ida_ida.compiler_info_t.id (variable)
    compiler id (see Compiler IDs)

ida_ida.compiler_info_t.size_b (variable)
    sizeof(bool)

ida_ida.compiler_info_t.size_e (variable)
    sizeof(enum)

ida_ida.compiler_info_t.size_i (variable)
    sizeof(int)

ida_ida.compiler_info_t.size_l (variable)
    long

ida_ida.compiler_info_t.size_ldbl (variable)
    longdouble (if different from processor_t::tbyte_size)

ida_ida.compiler_info_t.size_ll (variable)
    longlong

ida_ida.compiler_info_t.size_s (variable)
    short

ida_ida.delinf (function)
    delinf(tag) -> bool
    Undefine a program specific information
    
    @param tag: (C++: inftag_t) one of inftag_t constants
    @return: success

ida_ida.f_AIXAR (variable)
    AIX ar library.

ida_ida.f_AOUT (variable)
    Linux a.out (AOUT)

ida_ida.f_AR (variable)
    ar library

ida_ida.f_BIN (variable)
    Binary File.

ida_ida.f_COFF (variable)
    Common Object File Format (COFF)

ida_ida.f_COM (variable)
    MS DOS COM File.

ida_ida.f_COM_old (variable)
    MS DOS COM File.

ida_ida.f_DRV (variable)
    MS DOS Driver.

ida_ida.f_ELF (variable)
    Executable and Linkable Format (ELF)

ida_ida.f_EXE (variable)
    MS DOS EXE File.

ida_ida.f_EXE_old (variable)
    MS DOS EXE File.

ida_ida.f_HEX (variable)
    Intel Hex Object File.

ida_ida.f_LE (variable)
    Linear Executable (LE)

ida_ida.f_LOADER (variable)
    file is loaded using LOADER DLL

ida_ida.f_LX (variable)
    Linear Executable (LX)

ida_ida.f_MACHO (variable)
    Mac OS X Mach-O.

ida_ida.f_MEX (variable)
    MOS Technology Hex Object File.

ida_ida.f_NLM (variable)
    Netware Loadable Module (NLM)

ida_ida.f_OMF (variable)
    Object Module Format.

ida_ida.f_OMFLIB (variable)
    Library of OMF Modules.

ida_ida.f_PE (variable)
    Portable Executable (PE)

ida_ida.f_PRC (variable)
    PalmPilot program file.

ida_ida.f_PSXOBJ (variable)
    Sony Playstation PSX object file.

ida_ida.f_SREC (variable)
    Motorola SREC (S-record)

ida_ida.f_W32RUN (variable)
    Watcom DOS32 Extender (W32RUN)

ida_ida.f_WIN (variable)
    New Executable (NE)

ida_ida.f_ZIP (variable)
    ZIP file (this file is never loaded to IDA database)

ida_ida.get_dbctx_id (function)
    get_dbctx_id() -> ssize_t
    Get the current database context ID
    
    @return: the database context ID, or -1 if no current database

ida_ida.get_dbctx_qty (function)
    get_dbctx_qty() -> size_t
    Get number of database contexts
    
    @return: number of database contexts

ida_ida.getinf_str (function)
    getinf_str(tag) -> str
    Get program specific information (a non-scalar value)
    
    @param tag: (C++: inftag_t) one of inftag_t constants
    @return: number of bytes stored in the buffer (<0 - not defined)

ida_ida.idainfo (class)
    Proxy of C++ idainfo class.

ida_ida.idainfo.__init__ (method)

ida_ida.idainfo._get_lflags (method)
    _get_lflags(self) -> uint32

ida_ida.idainfo._set_lflags (method)
    _set_lflags(self, _f)
    
    Parameters
    ----------
    _f: uint32

ida_ida.idainfo.abibits (variable)
    ABI features. Depends on info returned by get_abi_name() Processor modules may
    modify them in set_compiler

ida_ida.idainfo.af (variable)
    Analysis flags

ida_ida.idainfo.af2 (variable)
    Analysis flags 2

ida_ida.idainfo.appcall_options (variable)
    appcall options, see idd.hpp

ida_ida.idainfo.apptype (variable)
    Application type bit definitions in libfuncs.hpp

ida_ida.idainfo.asmtype (variable)
    target assembler number

ida_ida.idainfo.baseaddr (variable)
    remaining 28 bits are reserved
    
    base address of the program (paragraphs)

ida_ida.idainfo.bin_prefix_size (variable)
    Number of instruction bytes (opcodes) to show in line prefix.

ida_ida.idainfo.cc (variable)
    COMPILER.
    
    Target compiler

ida_ida.idainfo.cmt_indent (variable)
    Indentation for comments.

ida_ida.idainfo.database_change_count (variable)
    incremented after each byte and regular segment modifications

ida_ida.idainfo.datatypes (variable)
    data types allowed in data carousel

ida_ida.idainfo.demnames (variable)
    Demangled name flags

ida_ida.idainfo.filetype (variable)
    The input file type.

ida_ida.idainfo.get_abiname (method)
    get_abiname(self) -> qstring

ida_ida.idainfo.highoff (variable)
    High limit for offsets (used in calculation of 'void' operands)

ida_ida.idainfo.indent (variable)
    DISASSEMBLY LISTING DETAILS.
    
    Indentation for instructions

ida_ida.idainfo.lenxref (variable)
    max length of line with xrefs

ida_ida.idainfo.lflags (variable)
    Misc. database flags

ida_ida.idainfo.listnames (variable)
    Name list options

ida_ida.idainfo.long_demnames (variable)
    long form of demangled names see demangle.h for definitions

ida_ida.idainfo.lowoff (variable)
    Low limit for offsets (used in calculation of 'void' operands)

ida_ida.idainfo.main (variable)
    address of main()

ida_ida.idainfo.margin (variable)
    max length of data lines

ida_ida.idainfo.max_autoname_len (variable)
    NAMES.
    
    max autogenerated name length (without zero byte)

ida_ida.idainfo.max_ea (variable)
    maxEA is excluded

ida_ida.idainfo.maxref (variable)
    Max tail for references.

ida_ida.idainfo.min_ea (variable)
    current limits of program

ida_ida.idainfo.nametype (variable)
    Dummy names representation types

ida_ida.idainfo.omax_ea (variable)
    original maxEA (is set after loading the input file)

ida_ida.idainfo.omin_ea (variable)
    original minEA (is set after loading the input file)

ida_ida.idainfo.ostype (variable)
    OS type the program is for bit definitions in libfuncs.hpp

ida_ida.idainfo.outflags (variable)
    output flags

ida_ida.idainfo.procname (variable)
    Name of the current processor (with \0)

ida_ida.idainfo.refcmtnum (variable)
    Number of comment lines to generate for refs to string literals or demangled
    names 0 - such comments won't be generated at all

ida_ida.idainfo.s_cmtflg (variable)
    Comment options

ida_ida.idainfo.s_genflags (variable)
    General idainfo flags

ida_ida.idainfo.s_limiter (variable)
    Delimiter options

ida_ida.idainfo.s_prefflag (variable)
    Line prefix options

ida_ida.idainfo.s_xrefflag (variable)
    Xref options

ida_ida.idainfo.short_demnames (variable)
    short form of demangled names

ida_ida.idainfo.specsegs (variable)
    What format do special segments use? 0-unspecified, 4-entries are 4 bytes, 8-
    entries are 8 bytes.

ida_ida.idainfo.start_cs (variable)
    selector of the segment with the main entry point

ida_ida.idainfo.start_ea (variable)
    Linear address of program entry point.

ida_ida.idainfo.start_ip (variable)
    IP register value at the start of program execution

ida_ida.idainfo.start_sp (variable)
    SP register value at the start of program execution

ida_ida.idainfo.start_ss (variable)
    selector of the initial stack segment

ida_ida.idainfo.strlit_break (variable)
    string literal line break symbol

ida_ida.idainfo.strlit_flags (variable)
    STRING LITERALS.
    
    string literal flags

ida_ida.idainfo.strlit_pref (variable)
    prefix for string literal names

ida_ida.idainfo.strlit_sernum (variable)
    serial number

ida_ida.idainfo.strlit_zeroes (variable)
    leading zeroes

ida_ida.idainfo.strtype (variable)
    current ascii string type see nalt.hpp for string types

ida_ida.idainfo.tag (variable)
    'IDA'

ida_ida.idainfo.type_xrefnum (variable)
    Number of references to generate in the struct & enum windows 0 - xrefs won't be
    generated at all

ida_ida.idainfo.version (variable)
    Version of database.

ida_ida.idainfo.xrefnum (variable)
    CROSS REFERENCES.
    
    Number of references to generate in the disassembly listing 0 - xrefs won't be
    generated at all

ida_ida.idainfo_is_32bit (function)

ida_ida.inf_abi_set_by_user (function)
    inf_abi_set_by_user() -> bool

ida_ida.inf_allow_non_matched_ops (function)
    inf_allow_non_matched_ops() -> bool

ida_ida.inf_allow_sigmulti (function)
    inf_allow_sigmulti() -> bool

ida_ida.inf_append_sigcmt (function)
    inf_append_sigcmt() -> bool

ida_ida.inf_big_arg_align (function)
    inf_big_arg_align(cc) -> bool
    
    @param cc: cm_t
    
    inf_big_arg_align() -> bool

ida_ida.inf_check_manual_ops (function)
    inf_check_manual_ops() -> bool

ida_ida.inf_check_unicode_strlits (function)
    inf_check_unicode_strlits() -> bool

ida_ida.inf_coagulate_code (function)
    inf_coagulate_code() -> bool

ida_ida.inf_coagulate_data (function)
    inf_coagulate_data() -> bool

ida_ida.inf_compress_idb (function)
    inf_compress_idb() -> bool

ida_ida.inf_create_all_xrefs (function)
    inf_create_all_xrefs() -> bool

ida_ida.inf_create_func_from_call (function)
    inf_create_func_from_call() -> bool

ida_ida.inf_create_func_from_ptr (function)
    inf_create_func_from_ptr() -> bool

ida_ida.inf_create_func_tails (function)
    inf_create_func_tails() -> bool

ida_ida.inf_create_jump_tables (function)
    inf_create_jump_tables() -> bool

ida_ida.inf_create_off_on_dref (function)
    inf_create_off_on_dref() -> bool

ida_ida.inf_create_off_using_fixup (function)
    inf_create_off_using_fixup() -> bool

ida_ida.inf_create_strlit_on_xref (function)
    inf_create_strlit_on_xref() -> bool

ida_ida.inf_data_offset (function)
    inf_data_offset() -> bool

ida_ida.inf_dbg_no_store_path (function)
    inf_dbg_no_store_path() -> bool

ida_ida.inf_decode_fpp (function)
    inf_decode_fpp() -> bool

ida_ida.inf_del_no_xref_insns (function)
    inf_del_no_xref_insns() -> bool

ida_ida.inf_final_pass (function)
    inf_final_pass() -> bool

ida_ida.inf_full_sp_ana (function)
    inf_full_sp_ana() -> bool

ida_ida.inf_gen_assume (function)
    inf_gen_assume() -> bool

ida_ida.inf_gen_lzero (function)
    inf_gen_lzero() -> bool

ida_ida.inf_gen_null (function)
    inf_gen_null() -> bool

ida_ida.inf_gen_org (function)
    inf_gen_org() -> bool

ida_ida.inf_gen_tryblks (function)
    inf_gen_tryblks() -> bool

ida_ida.inf_get_abibits (function)
    inf_get_abibits() -> uint32

ida_ida.inf_get_af (function)
    inf_get_af() -> uint32

ida_ida.inf_get_af2 (function)
    inf_get_af2() -> uint32

ida_ida.inf_get_af2_low (function)
    inf_get_af2_low() -> ushort
    Get/set low 16bit half of inf.af2.

ida_ida.inf_get_af_high (function)
    inf_get_af_high() -> ushort

ida_ida.inf_get_af_low (function)
    inf_get_af_low() -> ushort
    Get/set low/high 16bit halves of inf.af.

ida_ida.inf_get_app_bitness (function)
    inf_get_app_bitness() -> uint

ida_ida.inf_get_appcall_options (function)
    inf_get_appcall_options() -> uint32

ida_ida.inf_get_apptype (function)
    inf_get_apptype() -> ushort

ida_ida.inf_get_asmtype (function)
    inf_get_asmtype() -> uchar

ida_ida.inf_get_baseaddr (function)
    inf_get_baseaddr() -> uval_t

ida_ida.inf_get_bin_prefix_size (function)
    inf_get_bin_prefix_size() -> short

ida_ida.inf_get_cc (function)
    inf_get_cc(out) -> bool
    
    @param out: compiler_info_t *

ida_ida.inf_get_cc_cm (function)
    inf_get_cc_cm() -> cm_t

ida_ida.inf_get_cc_defalign (function)
    inf_get_cc_defalign() -> uchar

ida_ida.inf_get_cc_id (function)
    inf_get_cc_id() -> comp_t

ida_ida.inf_get_cc_size_b (function)
    inf_get_cc_size_b() -> uchar

ida_ida.inf_get_cc_size_e (function)
    inf_get_cc_size_e() -> uchar

ida_ida.inf_get_cc_size_i (function)
    inf_get_cc_size_i() -> uchar

ida_ida.inf_get_cc_size_l (function)
    inf_get_cc_size_l() -> uchar

ida_ida.inf_get_cc_size_ldbl (function)
    inf_get_cc_size_ldbl() -> uchar

ida_ida.inf_get_cc_size_ll (function)
    inf_get_cc_size_ll() -> uchar

ida_ida.inf_get_cc_size_s (function)
    inf_get_cc_size_s() -> uchar

ida_ida.inf_get_cmt_indent (function)
    inf_get_cmt_indent() -> uchar

ida_ida.inf_get_cmtflg (function)
    inf_get_cmtflg() -> uchar

ida_ida.inf_get_database_change_count (function)
    inf_get_database_change_count() -> uint32

ida_ida.inf_get_datatypes (function)
    inf_get_datatypes() -> uval_t

ida_ida.inf_get_demname_form (function)
    inf_get_demname_form() -> uchar
    Get DEMNAM_MASK bits of #demnames.

ida_ida.inf_get_demnames (function)
    inf_get_demnames() -> uchar

ida_ida.inf_get_filetype (function)
    inf_get_filetype() -> filetype_t

ida_ida.inf_get_genflags (function)
    inf_get_genflags() -> ushort

ida_ida.inf_get_highoff (function)
    inf_get_highoff() -> ea_t

ida_ida.inf_get_indent (function)
    inf_get_indent() -> uchar

ida_ida.inf_get_lenxref (function)
    inf_get_lenxref() -> ushort

ida_ida.inf_get_lflags (function)
    inf_get_lflags() -> uint32

ida_ida.inf_get_limiter (function)
    inf_get_limiter() -> uchar

ida_ida.inf_get_listnames (function)
    inf_get_listnames() -> uchar

ida_ida.inf_get_long_demnames (function)
    inf_get_long_demnames() -> uint32

ida_ida.inf_get_lowoff (function)
    inf_get_lowoff() -> ea_t

ida_ida.inf_get_main (function)
    inf_get_main() -> ea_t

ida_ida.inf_get_margin (function)
    inf_get_margin() -> ushort

ida_ida.inf_get_max_autoname_len (function)
    inf_get_max_autoname_len() -> ushort

ida_ida.inf_get_max_ea (function)
    inf_get_max_ea() -> ea_t

ida_ida.inf_get_maxref (function)
    inf_get_maxref() -> uval_t

ida_ida.inf_get_min_ea (function)
    inf_get_min_ea() -> ea_t

ida_ida.inf_get_nametype (function)
    inf_get_nametype() -> char

ida_ida.inf_get_netdelta (function)
    inf_get_netdelta() -> sval_t

ida_ida.inf_get_omax_ea (function)
    inf_get_omax_ea() -> ea_t

ida_ida.inf_get_omin_ea (function)
    inf_get_omin_ea() -> ea_t

ida_ida.inf_get_ostype (function)
    inf_get_ostype() -> ushort

ida_ida.inf_get_outflags (function)
    inf_get_outflags() -> uint32

ida_ida.inf_get_pack_mode (function)
    inf_get_pack_mode() -> int

ida_ida.inf_get_prefflag (function)
    inf_get_prefflag() -> uchar

ida_ida.inf_get_privrange (function)
    inf_get_privrange(out) -> bool
    
    @param out: range_t *
    
    inf_get_privrange() -> range_t

ida_ida.inf_get_privrange_end_ea (function)
    inf_get_privrange_end_ea() -> ea_t

ida_ida.inf_get_privrange_start_ea (function)
    inf_get_privrange_start_ea() -> ea_t

ida_ida.inf_get_procname (function)
    inf_get_procname() -> str

ida_ida.inf_get_refcmtnum (function)
    inf_get_refcmtnum() -> uchar

ida_ida.inf_get_short_demnames (function)
    inf_get_short_demnames() -> uint32

ida_ida.inf_get_specsegs (function)
    inf_get_specsegs() -> uchar

ida_ida.inf_get_start_cs (function)
    inf_get_start_cs() -> sel_t

ida_ida.inf_get_start_ea (function)
    inf_get_start_ea() -> ea_t

ida_ida.inf_get_start_ip (function)
    inf_get_start_ip() -> ea_t

ida_ida.inf_get_start_sp (function)
    inf_get_start_sp() -> ea_t

ida_ida.inf_get_start_ss (function)
    inf_get_start_ss() -> sel_t

ida_ida.inf_get_strlit_break (function)
    inf_get_strlit_break() -> uchar

ida_ida.inf_get_strlit_flags (function)
    inf_get_strlit_flags() -> uchar

ida_ida.inf_get_strlit_pref (function)
    inf_get_strlit_pref() -> str

ida_ida.inf_get_strlit_sernum (function)
    inf_get_strlit_sernum() -> uval_t

ida_ida.inf_get_strlit_zeroes (function)
    inf_get_strlit_zeroes() -> char

ida_ida.inf_get_strtype (function)
    inf_get_strtype() -> int32

ida_ida.inf_get_type_xrefnum (function)
    inf_get_type_xrefnum() -> uchar

ida_ida.inf_get_version (function)
    inf_get_version() -> ushort

ida_ida.inf_get_xrefflag (function)
    inf_get_xrefflag() -> uchar

ida_ida.inf_get_xrefnum (function)
    inf_get_xrefnum() -> uchar

ida_ida.inf_guess_func_type (function)
    inf_guess_func_type() -> bool

ida_ida.inf_handle_eh (function)
    inf_handle_eh() -> bool

ida_ida.inf_handle_rtti (function)
    inf_handle_rtti() -> bool

ida_ida.inf_hide_comments (function)
    inf_hide_comments() -> bool

ida_ida.inf_hide_libfuncs (function)
    inf_hide_libfuncs() -> bool

ida_ida.inf_huge_arg_align (function)
    inf_huge_arg_align(cc) -> bool
    
    @param cc: cm_t
    
    inf_huge_arg_align() -> bool

ida_ida.inf_inc_database_change_count (function)
    inf_inc_database_change_count(cnt=1)
    
    @param cnt: int

ida_ida.inf_is_16bit (function)
    inf_is_16bit() -> bool

ida_ida.inf_is_32bit_exactly (function)
    inf_is_32bit_exactly() -> bool

ida_ida.inf_is_32bit_or_higher (function)
    inf_is_32bit_or_higher() -> bool

ida_ida.inf_is_64bit (function)
    inf_is_64bit() -> bool

ida_ida.inf_is_auto_enabled (function)
    inf_is_auto_enabled() -> bool

ida_ida.inf_is_be (function)
    inf_is_be() -> bool

ida_ida.inf_is_dll (function)
    inf_is_dll() -> bool

ida_ida.inf_is_flat_off32 (function)
    inf_is_flat_off32() -> bool

ida_ida.inf_is_graph_view (function)
    inf_is_graph_view() -> bool

ida_ida.inf_is_hard_float (function)
    inf_is_hard_float() -> bool

ida_ida.inf_is_kernel_mode (function)
    inf_is_kernel_mode() -> bool

ida_ida.inf_is_limiter_empty (function)
    inf_is_limiter_empty() -> bool

ida_ida.inf_is_limiter_thick (function)
    inf_is_limiter_thick() -> bool

ida_ida.inf_is_limiter_thin (function)
    inf_is_limiter_thin() -> bool

ida_ida.inf_is_mem_aligned4 (function)
    inf_is_mem_aligned4() -> bool

ida_ida.inf_is_snapshot (function)
    inf_is_snapshot() -> bool

ida_ida.inf_is_wide_high_byte_first (function)
    inf_is_wide_high_byte_first() -> bool

ida_ida.inf_like_binary (function)
    inf_like_binary() -> bool

ida_ida.inf_line_pref_with_seg (function)
    inf_line_pref_with_seg() -> bool

ida_ida.inf_loading_idc (function)
    inf_loading_idc() -> bool

ida_ida.inf_macros_enabled (function)
    inf_macros_enabled() -> bool

ida_ida.inf_map_stkargs (function)
    inf_map_stkargs() -> bool

ida_ida.inf_mark_code (function)
    inf_mark_code() -> bool

ida_ida.inf_merge_strlits (function)
    inf_merge_strlits() -> bool

ida_ida.inf_no_store_user_info (function)
    inf_no_store_user_info() -> bool

ida_ida.inf_noflow_to_data (function)
    inf_noflow_to_data() -> bool

ida_ida.inf_noret_ana (function)
    inf_noret_ana() -> bool

ida_ida.inf_op_offset (function)
    inf_op_offset() -> bool

ida_ida.inf_pack_idb (function)
    inf_pack_idb() -> bool

ida_ida.inf_pack_stkargs (function)
    inf_pack_stkargs(cc) -> bool
    
    @param cc: cm_t
    
    inf_pack_stkargs() -> bool

ida_ida.inf_postinc_strlit_sernum (function)
    inf_postinc_strlit_sernum(cnt=1) -> uval_t
    
    @param cnt: uval_t

ida_ida.inf_prefix_show_funcoff (function)
    inf_prefix_show_funcoff() -> bool

ida_ida.inf_prefix_show_segaddr (function)
    inf_prefix_show_segaddr() -> bool

ida_ida.inf_prefix_show_stack (function)
    inf_prefix_show_stack() -> bool

ida_ida.inf_prefix_truncate_opcode_bytes (function)
    inf_prefix_truncate_opcode_bytes() -> bool

ida_ida.inf_propagate_regargs (function)
    inf_propagate_regargs() -> bool

ida_ida.inf_propagate_stkargs (function)
    inf_propagate_stkargs() -> bool

ida_ida.inf_readonly_idb (function)
    inf_readonly_idb() -> bool

ida_ida.inf_rename_jumpfunc (function)
    inf_rename_jumpfunc() -> bool

ida_ida.inf_rename_nullsub (function)
    inf_rename_nullsub() -> bool

ida_ida.inf_set_32bit (function)
    inf_set_32bit(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_64bit (function)
    inf_set_64bit(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_abi_set_by_user (function)
    inf_set_abi_set_by_user(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_abibits (function)
    inf_set_abibits(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_af (function)
    inf_set_af(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_af2 (function)
    inf_set_af2(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_af2_low (function)
    inf_set_af2_low(saf)
    
    @param saf: ushort

ida_ida.inf_set_af_high (function)
    inf_set_af_high(saf2)
    
    @param saf2: ushort

ida_ida.inf_set_af_low (function)
    inf_set_af_low(saf)
    
    @param saf: ushort

ida_ida.inf_set_allow_non_matched_ops (function)
    inf_set_allow_non_matched_ops(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_allow_sigmulti (function)
    inf_set_allow_sigmulti(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_app_bitness (function)
    inf_set_app_bitness(bitness)
    
    @param bitness: uint

ida_ida.inf_set_appcall_options (function)
    inf_set_appcall_options(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_append_sigcmt (function)
    inf_set_append_sigcmt(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_apptype (function)
    inf_set_apptype(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_asmtype (function)
    inf_set_asmtype(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_auto_enabled (function)
    inf_set_auto_enabled(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_baseaddr (function)
    inf_set_baseaddr(_v) -> bool
    
    @param _v: uval_t

ida_ida.inf_set_be (function)
    inf_set_be(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_big_arg_align (function)
    inf_set_big_arg_align(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_bin_prefix_size (function)
    inf_set_bin_prefix_size(_v) -> bool
    
    @param _v: short

ida_ida.inf_set_cc (function)
    inf_set_cc(_v) -> bool
    
    @param _v: compiler_info_t const &

ida_ida.inf_set_cc_cm (function)
    inf_set_cc_cm(_v) -> bool
    
    @param _v: cm_t

ida_ida.inf_set_cc_defalign (function)
    inf_set_cc_defalign(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_id (function)
    inf_set_cc_id(_v) -> bool
    
    @param _v: comp_t

ida_ida.inf_set_cc_size_b (function)
    inf_set_cc_size_b(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_e (function)
    inf_set_cc_size_e(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_i (function)
    inf_set_cc_size_i(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_l (function)
    inf_set_cc_size_l(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_ldbl (function)
    inf_set_cc_size_ldbl(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_ll (function)
    inf_set_cc_size_ll(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cc_size_s (function)
    inf_set_cc_size_s(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_check_manual_ops (function)
    inf_set_check_manual_ops(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_check_unicode_strlits (function)
    inf_set_check_unicode_strlits(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_cmt_indent (function)
    inf_set_cmt_indent(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_cmtflg (function)
    inf_set_cmtflg(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_coagulate_code (function)
    inf_set_coagulate_code(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_coagulate_data (function)
    inf_set_coagulate_data(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_compress_idb (function)
    inf_set_compress_idb(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_all_xrefs (function)
    inf_set_create_all_xrefs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_func_from_call (function)
    inf_set_create_func_from_call(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_func_from_ptr (function)
    inf_set_create_func_from_ptr(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_func_tails (function)
    inf_set_create_func_tails(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_jump_tables (function)
    inf_set_create_jump_tables(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_off_on_dref (function)
    inf_set_create_off_on_dref(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_off_using_fixup (function)
    inf_set_create_off_using_fixup(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_create_strlit_on_xref (function)
    inf_set_create_strlit_on_xref(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_data_offset (function)
    inf_set_data_offset(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_database_change_count (function)
    inf_set_database_change_count(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_datatypes (function)
    inf_set_datatypes(_v) -> bool
    
    @param _v: uval_t

ida_ida.inf_set_dbg_no_store_path (function)
    inf_set_dbg_no_store_path(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_decode_fpp (function)
    inf_set_decode_fpp(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_del_no_xref_insns (function)
    inf_set_del_no_xref_insns(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_demnames (function)
    inf_set_demnames(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_dll (function)
    inf_set_dll(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_filetype (function)
    inf_set_filetype(_v) -> bool
    
    @param _v: enum filetype_t

ida_ida.inf_set_final_pass (function)
    inf_set_final_pass(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_flat_off32 (function)
    inf_set_flat_off32(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_full_sp_ana (function)
    inf_set_full_sp_ana(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_gen_assume (function)
    inf_set_gen_assume(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_gen_lzero (function)
    inf_set_gen_lzero(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_gen_null (function)
    inf_set_gen_null(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_gen_org (function)
    inf_set_gen_org(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_gen_tryblks (function)
    inf_set_gen_tryblks(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_genflags (function)
    inf_set_genflags(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_graph_view (function)
    inf_set_graph_view(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_guess_func_type (function)
    inf_set_guess_func_type(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_handle_eh (function)
    inf_set_handle_eh(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_handle_rtti (function)
    inf_set_handle_rtti(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_hard_float (function)
    inf_set_hard_float(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_hide_comments (function)
    inf_set_hide_comments(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_hide_libfuncs (function)
    inf_set_hide_libfuncs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_highoff (function)
    inf_set_highoff(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_huge_arg_align (function)
    inf_set_huge_arg_align(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_indent (function)
    inf_set_indent(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_kernel_mode (function)
    inf_set_kernel_mode(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_lenxref (function)
    inf_set_lenxref(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_lflags (function)
    inf_set_lflags(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_limiter (function)
    inf_set_limiter(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_limiter_empty (function)
    inf_set_limiter_empty(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_limiter_thick (function)
    inf_set_limiter_thick(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_limiter_thin (function)
    inf_set_limiter_thin(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_line_pref_with_seg (function)
    inf_set_line_pref_with_seg(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_listnames (function)
    inf_set_listnames(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_loading_idc (function)
    inf_set_loading_idc(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_long_demnames (function)
    inf_set_long_demnames(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_lowoff (function)
    inf_set_lowoff(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_macros_enabled (function)
    inf_set_macros_enabled(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_main (function)
    inf_set_main(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_map_stkargs (function)
    inf_set_map_stkargs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_margin (function)
    inf_set_margin(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_mark_code (function)
    inf_set_mark_code(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_max_autoname_len (function)
    inf_set_max_autoname_len(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_max_ea (function)
    inf_set_max_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_maxref (function)
    inf_set_maxref(_v) -> bool
    
    @param _v: uval_t

ida_ida.inf_set_mem_aligned4 (function)
    inf_set_mem_aligned4(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_merge_strlits (function)
    inf_set_merge_strlits(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_min_ea (function)
    inf_set_min_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_nametype (function)
    inf_set_nametype(_v) -> bool
    
    @param _v: char

ida_ida.inf_set_netdelta (function)
    inf_set_netdelta(_v) -> bool
    
    @param _v: sval_t

ida_ida.inf_set_no_store_user_info (function)
    inf_set_no_store_user_info(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_noflow_to_data (function)
    inf_set_noflow_to_data(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_noret_ana (function)
    inf_set_noret_ana(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_omax_ea (function)
    inf_set_omax_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_omin_ea (function)
    inf_set_omin_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_op_offset (function)
    inf_set_op_offset(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_ostype (function)
    inf_set_ostype(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_outflags (function)
    inf_set_outflags(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_pack_idb (function)
    inf_set_pack_idb(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_pack_mode (function)
    inf_set_pack_mode(pack_mode) -> int
    
    @param pack_mode: int

ida_ida.inf_set_pack_stkargs (function)
    inf_set_pack_stkargs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_prefflag (function)
    inf_set_prefflag(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_prefix_show_funcoff (function)
    inf_set_prefix_show_funcoff(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_prefix_show_segaddr (function)
    inf_set_prefix_show_segaddr(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_prefix_show_stack (function)
    inf_set_prefix_show_stack(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_prefix_truncate_opcode_bytes (function)
    inf_set_prefix_truncate_opcode_bytes(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_privrange (function)
    inf_set_privrange(_v) -> bool
    
    @param _v: range_t const &

ida_ida.inf_set_privrange_end_ea (function)
    inf_set_privrange_end_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_privrange_start_ea (function)
    inf_set_privrange_start_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_procname (function)
    inf_set_procname(_v, len=size_t(-1)) -> bool
    
    @param _v: char const *
    @param len: size_t

ida_ida.inf_set_propagate_regargs (function)
    inf_set_propagate_regargs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_propagate_stkargs (function)
    inf_set_propagate_stkargs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_readonly_idb (function)
    inf_set_readonly_idb(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_refcmtnum (function)
    inf_set_refcmtnum(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_rename_jumpfunc (function)
    inf_set_rename_jumpfunc(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_rename_nullsub (function)
    inf_set_rename_nullsub(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_short_demnames (function)
    inf_set_short_demnames(_v) -> bool
    
    @param _v: uint32

ida_ida.inf_set_should_create_stkvars (function)
    inf_set_should_create_stkvars(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_should_trace_sp (function)
    inf_set_should_trace_sp(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_all_comments (function)
    inf_set_show_all_comments(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_auto (function)
    inf_set_show_auto(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_hidden_funcs (function)
    inf_set_show_hidden_funcs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_hidden_insns (function)
    inf_set_show_hidden_insns(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_hidden_segms (function)
    inf_set_show_hidden_segms(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_line_pref (function)
    inf_set_show_line_pref(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_repeatables (function)
    inf_set_show_repeatables(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_src_linnum (function)
    inf_set_show_src_linnum(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_void (function)
    inf_set_show_void(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_xref_fncoff (function)
    inf_set_show_xref_fncoff(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_xref_seg (function)
    inf_set_show_xref_seg(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_xref_tmarks (function)
    inf_set_show_xref_tmarks(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_show_xref_val (function)
    inf_set_show_xref_val(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_snapshot (function)
    inf_set_snapshot(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_specsegs (function)
    inf_set_specsegs(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_stack_ldbl (function)
    inf_set_stack_ldbl(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_stack_varargs (function)
    inf_set_stack_varargs(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_start_cs (function)
    inf_set_start_cs(_v) -> bool
    
    @param _v: sel_t

ida_ida.inf_set_start_ea (function)
    inf_set_start_ea(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_start_ip (function)
    inf_set_start_ip(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_start_sp (function)
    inf_set_start_sp(_v) -> bool
    
    @param _v: ea_t

ida_ida.inf_set_start_ss (function)
    inf_set_start_ss(_v) -> bool
    
    @param _v: sel_t

ida_ida.inf_set_strlit_autocmt (function)
    inf_set_strlit_autocmt(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_strlit_break (function)
    inf_set_strlit_break(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_strlit_flags (function)
    inf_set_strlit_flags(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_strlit_name_bit (function)
    inf_set_strlit_name_bit(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_strlit_names (function)
    inf_set_strlit_names(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_strlit_pref (function)
    inf_set_strlit_pref(_v, len=size_t(-1)) -> bool
    
    @param _v: char const *
    @param len: size_t

ida_ida.inf_set_strlit_savecase (function)
    inf_set_strlit_savecase(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_strlit_serial_names (function)
    inf_set_strlit_serial_names(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_strlit_sernum (function)
    inf_set_strlit_sernum(_v) -> bool
    
    @param _v: uval_t

ida_ida.inf_set_strlit_zeroes (function)
    inf_set_strlit_zeroes(_v) -> bool
    
    @param _v: char

ida_ida.inf_set_strtype (function)
    inf_set_strtype(_v) -> bool
    
    @param _v: int32

ida_ida.inf_set_trace_flow (function)
    inf_set_trace_flow(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_truncate_on_del (function)
    inf_set_truncate_on_del(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_type_xrefnum (function)
    inf_set_type_xrefnum(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_unicode_strlits (function)
    inf_set_unicode_strlits(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_use_allasm (function)
    inf_set_use_allasm(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_use_flirt (function)
    inf_set_use_flirt(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_use_gcc_layout (function)
    inf_set_use_gcc_layout(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_version (function)
    inf_set_version(_v) -> bool
    
    @param _v: ushort

ida_ida.inf_set_wide_high_byte_first (function)
    inf_set_wide_high_byte_first(_v=True) -> bool
    
    @param _v: bool

ida_ida.inf_set_xrefflag (function)
    inf_set_xrefflag(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_set_xrefnum (function)
    inf_set_xrefnum(_v) -> bool
    
    @param _v: uchar

ida_ida.inf_should_create_stkvars (function)
    inf_should_create_stkvars() -> bool

ida_ida.inf_should_trace_sp (function)
    inf_should_trace_sp() -> bool

ida_ida.inf_show_all_comments (function)
    inf_show_all_comments() -> bool

ida_ida.inf_show_auto (function)
    inf_show_auto() -> bool

ida_ida.inf_show_hidden_funcs (function)
    inf_show_hidden_funcs() -> bool

ida_ida.inf_show_hidden_insns (function)
    inf_show_hidden_insns() -> bool

ida_ida.inf_show_hidden_segms (function)
    inf_show_hidden_segms() -> bool

ida_ida.inf_show_line_pref (function)
    inf_show_line_pref() -> bool

ida_ida.inf_show_repeatables (function)
    inf_show_repeatables() -> bool

ida_ida.inf_show_src_linnum (function)
    inf_show_src_linnum() -> bool

ida_ida.inf_show_void (function)
    inf_show_void() -> bool

ida_ida.inf_show_xref_fncoff (function)
    inf_show_xref_fncoff() -> bool

ida_ida.inf_show_xref_seg (function)
    inf_show_xref_seg() -> bool

ida_ida.inf_show_xref_tmarks (function)
    inf_show_xref_tmarks() -> bool

ida_ida.inf_show_xref_val (function)
    inf_show_xref_val() -> bool

ida_ida.inf_stack_ldbl (function)
    inf_stack_ldbl() -> bool

ida_ida.inf_stack_varargs (function)
    inf_stack_varargs() -> bool

ida_ida.inf_strlit_autocmt (function)
    inf_strlit_autocmt() -> bool

ida_ida.inf_strlit_name_bit (function)
    inf_strlit_name_bit() -> bool

ida_ida.inf_strlit_names (function)
    inf_strlit_names() -> bool

ida_ida.inf_strlit_savecase (function)
    inf_strlit_savecase() -> bool

ida_ida.inf_strlit_serial_names (function)
    inf_strlit_serial_names() -> bool

ida_ida.inf_test_mode (function)
    inf_test_mode() -> bool

ida_ida.inf_trace_flow (function)
    inf_trace_flow() -> bool

ida_ida.inf_truncate_on_del (function)
    inf_truncate_on_del() -> bool

ida_ida.inf_unicode_strlits (function)
    inf_unicode_strlits() -> bool

ida_ida.inf_use_allasm (function)
    inf_use_allasm() -> bool

ida_ida.inf_use_flirt (function)
    inf_use_flirt() -> bool

ida_ida.inf_use_gcc_layout (function)
    inf_use_gcc_layout() -> bool

ida_ida.is_database_busy (function)
    is_database_busy() -> bool
    Check if the database is busy (e.g. performing some critical operations and
    cannot be safely accessed)

ida_ida.is_filetype_like_binary (function)
    is_filetype_like_binary(ft) -> bool
    Is unstructured input file?
    
    @param ft: (C++: filetype_t) enum filetype_t

ida_ida.move_privrange (function)
    move_privrange(new_privrange_start) -> bool
    Move privrange to the specified address
    
    @param new_privrange_start: (C++: ea_t) new start address of the privrange
    @return: success

ida_ida.switch_dbctx (function)
    switch_dbctx(idx) -> dbctx_t *
    Switch to the database with the provided context ID
    
    @param idx: (C++: size_t) the index of the database to switch to
    @return: the current dbctx_t instance or nullptr

ida_ida.to_ea (function)
    to_ea(reg_cs, reg_ip) -> ea_t
    Convert (sel,off) value to a linear address.
    
    @param reg_cs: (C++: sel_t)
    @param reg_ip: (C++: uval_t)

ida_ida.validate_idb (function)
    validate_idb(vld_flags=0) -> size_t
    Validate the database
    
    @param vld_flags: (C++: uint32) combination of VLD_.. constants
    @return: number of corrupted/fixed records

ida_idaapi (module)

ida_idaapi.IDAPython_ExecScript (function)
    Run the specified script.
    
    This function is used by the low-level plugin code.

ida_idaapi.IDAPython_ExecSystem (function)
    Executes a command with popen().

ida_idaapi.IDAPython_FormatExc (function)
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()

ida_idaapi.IDAPython_LoadProcMod (function)
    Load processor module.

ida_idaapi.IDAPython_UnLoadProcMod (function)
    Unload processor module.

ida_idaapi.IDAPython_displayhook (class)

ida_idaapi.IDAPython_displayhook.__init__ (method)

ida_idaapi.IDAPython_displayhook._print_hex (method)

ida_idaapi.IDAPython_displayhook.displayhook (method)

ida_idaapi.IDAPython_displayhook.format_item (method)

ida_idaapi.IDAPython_displayhook.format_seq (method)

ida_idaapi.NW_CLOSEIDB (variable)
    Notify when the database is closed. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.NW_INITIDA (variable)
    Notify when the IDA starts. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.NW_OPENIDB (variable)
    Notify when the database is opened. Its callback is of the form: def notify_when_callback(nw_code, is_old_database)

ida_idaapi.NW_REMOVE (variable)
    Use this flag with other flags to uninstall a notifywhen callback

ida_idaapi.NW_TERMIDA (variable)
    Notify when the IDA terminates. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.PY_ICID_BYREF (variable)
    byref object

ida_idaapi.PY_ICID_INT64 (variable)
    int64 object

ida_idaapi.PY_ICID_OPAQUE (variable)
    opaque object

ida_idaapi.PyIdc_cvt_int64__ (class)
    Helper class for explicitly representing VT_INT64 values

ida_idaapi.PyIdc_cvt_int64__.__add__ (method)

ida_idaapi.PyIdc_cvt_int64__.__div__ (method)

ida_idaapi.PyIdc_cvt_int64__.__init__ (method)

ida_idaapi.PyIdc_cvt_int64__.__mul__ (method)

ida_idaapi.PyIdc_cvt_int64__.__op (method)

ida_idaapi.PyIdc_cvt_int64__.__radd__ (method)

ida_idaapi.PyIdc_cvt_int64__.__rdiv__ (method)

ida_idaapi.PyIdc_cvt_int64__.__rmul__ (method)

ida_idaapi.PyIdc_cvt_int64__.__rsub__ (method)

ida_idaapi.PyIdc_cvt_int64__.__sub__ (method)

ida_idaapi.PyIdc_cvt_refclass__ (class)
    Helper class for representing references to immutable objects

ida_idaapi.PyIdc_cvt_refclass__.__init__ (method)

ida_idaapi.PyIdc_cvt_refclass__.cstr (method)
    Returns the string as a C string (up to the zero termination)

ida_idaapi.ST_OVER_DEBUG_SEG (variable)
    step tracing will be disabled when IP is in a debugger segment

ida_idaapi.ST_OVER_LIB_FUNC (variable)
    step tracing will be disabled when IP is in a library function

ida_idaapi.TRUNC (function)
    Truncate EA for the current application bitness

ida_idaapi.__IDAPython_Completion_Util (class)
    Internal utility class for auto-completion support

ida_idaapi.__IDAPython_Completion_Util.__call__ (method)

ida_idaapi.__IDAPython_Completion_Util.__init__ (method)

ida_idaapi.__IDAPython_Completion_Util.debug (method)

ida_idaapi.__IDAPython_Completion_Util.dir_namespace (method)

ida_idaapi.__IDAPython_Completion_Util.get_candidates (method)

ida_idaapi.__IDAPython_Completion_Util.maybe_extend_syntactically (method)

ida_idaapi.__install_excepthook (function)

ida_idaapi._bounded_getitem_iterator (function)
    Helper function, to be set as __iter__ method for qvector-, or array-based classes.

ida_idaapi._listify_types (function)

ida_idaapi._make_missed_695bwcompat_property (function)

ida_idaapi._make_missed_695bwcompat_property._getter (function)

ida_idaapi._make_missed_695bwcompat_property._setter (function)

ida_idaapi._make_one_time_warning_message (function)

ida_idaapi._make_one_time_warning_message.f (function)

ida_idaapi._qvector_back (function)

ida_idaapi._qvector_front (function)

ida_idaapi._replace_module_function (function)

ida_idaapi.as_UTF16 (function)
    Convenience function to convert a string into appropriate unicode format

ida_idaapi.as_cstr (function)
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first \x00 and returns the string value up to that point.

ida_idaapi.as_int32 (function)
    Returns a number as a signed int32 number

ida_idaapi.as_signed (function)
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.

ida_idaapi.as_uint32 (function)
    Returns a number as an unsigned int32 number

ida_idaapi.copy_bits (function)
    Copy bits from a value
    @param v: the value
    @param s: starting bit (0-based)
    @param e: ending bit

ida_idaapi.disable_script_timeout (function)
    disable_script_timeout()
    Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    @return: None

ida_idaapi.enable_extlang_python (function)
    enable_extlang_python(enable)
    Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    
    @param enable: Set to True to enable, False otherwise

ida_idaapi.enable_python_cli (function)
    enable_python_cli(enable)
    
    @param enable: bool

ida_idaapi.format_basestring (function)
    format_basestring(_in) -> str
    
    @param _in: PyObject *

ida_idaapi.get_inf_structure (function)
    get_inf_structure() -> idainfo
    Returns the global variable 'inf' (an instance of idainfo structure, see ida.hpp)

ida_idaapi.loader_input_t (class)
    A helper class to work with linput_t related functions.
    This class is also used by file loaders scripts.

ida_idaapi.loader_input_t.__init__ (method)
    __init__(self, pycapsule=None) -> loader_input_t
    
    @param pycapsule: PyObject *

ida_idaapi.loader_input_t.close (method)
    close(self)
    Closes the file

ida_idaapi.loader_input_t.file2base (method)
    file2base(self, pos, ea1, ea2, patchable) -> int
    Load portion of file into the database
    This function will include (ea1..ea2) into the addressing space of the
    program (make it enabled)
    
    @param pos: position in the file
    @param ea1: ..ea2): range of destination linear addresses
    @param ea1: ..ea2): range of destination linear addresses
    @param patchable: should the kernel remember correspondance of
                      file offsets to linear addresses.
    @return: 1-ok,0-read error, a warning is displayed

ida_idaapi.loader_input_t.filename (method)
    filename(self) -> PyObject *

ida_idaapi.loader_input_t.from_capsule (method)
    from_capsule(pycapsule) -> loader_input_t
    
    @param pycapsule: PyObject *

ida_idaapi.loader_input_t.from_fp (method)
    from_fp(fp) -> loader_input_t
    A static method to construct an instance from a FILE*
    
    @param fp: FILE *

ida_idaapi.loader_input_t.from_linput (method)
    from_linput(linput) -> loader_input_t
    
    @param linput: linput_t *

ida_idaapi.loader_input_t.get_byte (method)
    get_byte(self) -> PyObject *
    Reads a single byte from the file. Returns None if EOF or the read byte

ida_idaapi.loader_input_t.get_linput (method)
    get_linput(self) -> linput_t *

ida_idaapi.loader_input_t.gets (method)
    gets(self, len) -> str
    Reads a line from the input file. Returns the read line or None
    
    @param len: size_t

ida_idaapi.loader_input_t.getz (method)
    getz(self, sz, fpos=-1) -> PyObject *
    Returns a zero terminated string at the given position
    
    @param sz: maximum size of the string
    @param fpos: if != -1 then seek will be performed before reading
    @return: The string or None on failure.

ida_idaapi.loader_input_t.open (method)
    open(self, filename, remote=False) -> bool
    Opens a file (or a remote file)
    
    @param filename: char const *
    @param remote: bool
    @return: Boolean

ida_idaapi.loader_input_t.open_memory (method)
    open_memory(self, start, size=0) -> bool
    Create a linput for process memory (By internally calling idaapi.create_memory_linput())
    This linput will use dbg->read_memory() to read data
    
    @param start: starting address of the input
    @param size: size of the memory range to represent as linput
                if unknown, may be passed as 0

ida_idaapi.loader_input_t.opened (method)
    opened(self) -> bool
    Checks if the file is opened or not

ida_idaapi.loader_input_t.read (method)
    read(self, size) -> bytes or None
    Reads from the file. Returns the buffer or None
    
    @param size: size_t

ida_idaapi.loader_input_t.readbytes (method)
    readbytes(self, size, big_endian) -> PyObject *
    Similar to read() but it respect the endianness
    
    @param size: size_t
    @param big_endian: bool

ida_idaapi.loader_input_t.seek (method)
    seek(self, pos, whence=SEEK_SET) -> int64
    Set input source position
    
    @param pos: int64
    @param whence: int
    @return: the new position (not 0 as fseek!)

ida_idaapi.loader_input_t.set_linput (method)
    set_linput(self, linput)
    Links the current loader_input_t instance to a linput_t instance
    
    @param linput: linput_t *

ida_idaapi.loader_input_t.size (method)
    size(self) -> int64

ida_idaapi.loader_input_t.tell (method)
    tell(self) -> int64
    Returns the current position

ida_idaapi.loader_input_t_from_capsule (function)
    loader_input_t_from_capsule(pycapsule) -> loader_input_t
    
    @param pycapsule: PyObject *

ida_idaapi.loader_input_t_from_fp (function)
    loader_input_t_from_fp(fp) -> loader_input_t
    
    @param fp: FILE *

ida_idaapi.loader_input_t_from_linput (function)
    loader_input_t_from_linput(linput) -> loader_input_t
    
    @param linput: linput_t *

ida_idaapi.notify_when (function)
    Register a callback that will be called when an event happens.
    @param when: one of NW_XXXX constants
    @param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    @return: Boolean

ida_idaapi.object_t (class)
    Helper class used to initialize empty objects

ida_idaapi.object_t.__getitem__ (method)
    Allow access to object attributes by index (like dictionaries)

ida_idaapi.object_t.__init__ (method)

ida_idaapi.parse_command_line3 (function)
    parse_command_line3(cmdline) -> PyObject *
    
    @param cmdline: char const *

ida_idaapi.plugin_t (class)
    Base class for all scripted plugins.

ida_idaapi.plugin_t.run (method)

ida_idaapi.plugin_t.term (method)

ida_idaapi.plugmod_t (class)
    Base class for all scripted multi-plugins.

ida_idaapi.py_clinked_object_t (class)
    This is a utility and base class for C linked objects

ida_idaapi.py_clinked_object_t.__del__ (method)
    Delete the link upon object destruction (only if not static)

ida_idaapi.py_clinked_object_t.__init__ (method)

ida_idaapi.py_clinked_object_t._create_clink (method)
    Overwrite me.
    Creates a new clink
    @return: PyCapsule representing the C link

ida_idaapi.py_clinked_object_t._del_clink (method)
    Overwrite me.
    This method deletes the link

ida_idaapi.py_clinked_object_t._free (method)
    Explicitly delete the link (only if not static)

ida_idaapi.py_clinked_object_t._get_clink_ptr (method)
    Overwrite me.
    Returns the C link pointer as a 64bit number

ida_idaapi.py_clinked_object_t.assign (method)
    Overwrite me.
    This method allows you to assign an instance contents to anothers
    @return: Boolean

ida_idaapi.py_clinked_object_t.clink (variable)
    Returns the C link as a PyObject

ida_idaapi.py_clinked_object_t.clink_ptr (variable)
    Returns the C link pointer as a number

ida_idaapi.py_clinked_object_t.copy (method)
    Returns a new copy of this class

ida_idaapi.pycim_get_widget (function)
    pycim_get_widget(_self) -> TWidget *
    
    @param self: PyObject *

ida_idaapi.pycim_view_close (function)
    pycim_view_close(_self)
    
    @param self: PyObject *

ida_idaapi.pygc_create_groups (function)
    pygc_create_groups(_self, groups_infos) -> [int, ...] or None
    
    @param self: PyObject *
    @param groups_infos: PyObject *

ida_idaapi.pygc_delete_groups (function)
    pygc_delete_groups(_self, groups, new_current) -> bool
    
    @param self: PyObject *
    @param groups: PyObject *
    @param new_current: PyObject *

ida_idaapi.pygc_refresh (function)
    pygc_refresh(_self)
    
    @param self: PyObject *

ida_idaapi.pygc_set_groups_visibility (function)
    pygc_set_groups_visibility(_self, groups, expand, new_current) -> bool
    
    @param self: PyObject *
    @param groups: PyObject *
    @param expand: PyObject *
    @param new_current: PyObject *

ida_idaapi.pyidc_cvt_helper__ (class)
    This is a special helper object that helps detect which kind
    of object is this python object wrapping and how to convert it
    back and from IDC.
    This object is characterized by its special attribute and its value

ida_idaapi.pyidc_cvt_helper__.__get_value (method)

ida_idaapi.pyidc_cvt_helper__.__init__ (method)

ida_idaapi.pyidc_cvt_helper__.__set_value (method)

ida_idaapi.pyidc_opaque_object_t (class)
    This is the base class for all Python<->IDC opaque objects

ida_idaapi.replfun (function)

ida_idaapi.require (function)
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.

ida_idaapi.set_script_timeout (function)
    set_script_timeout(timeout) -> int
    Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    @param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    @return: Returns the old timeout value

ida_idaapi.struct_unpack (function)
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.

ida_idc (module)

ida_idc.get_mark_comment (function)
    get_mark_comment(slot) -> PyObject *
    
    @param slot: int32

ida_idc.get_marked_pos (function)
    get_marked_pos(slot) -> ea_t
    
    @param slot: int32

ida_idc.mark_position (function)
    mark_position(ea, lnnum, x, y, slot, comment)
    
    @param ea: ea_t
    @param lnnum: int
    @param x: short
    @param y: short
    @param slot: int32
    @param comment: char const *

ida_idd (module)
    Contains definition of the interface to IDD modules.
    
    The interface consists of structures describing the target debugged processor
    and a debugging API.

ida_idd.APPCALL_DEBEV (variable)
    Return debug event information.

ida_idd.APPCALL_MANUAL (variable)
    Only set up the appcall, do not run. debugger_t::cleanup_appcall will not be
    generated by ida!

ida_idd.APPCALL_TIMEOUT (variable)
    Appcall with timeout. If timed out, errbuf will contain "timeout". See
    SET_APPCALL_TIMEOUT and GET_APPCALL_TIMEOUT

ida_idd.Appcall__ (class)

ida_idd.Appcall__.APPCALL_DEBEV (variable)
    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception

ida_idd.Appcall__.APPCALL_MANUAL (variable)
    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished

ida_idd.Appcall__.APPCALL_TIMEOUT (variable)
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".

ida_idd.Appcall__.Consts (variable)
    Use Appcall.Consts.CONST_NAME to access constants

ida_idd.Appcall__.UTF16 (method)

ida_idd.Appcall__.__get_consts (method)

ida_idd.Appcall__.__getattr__ (method)
    Allows you to call functions as if they were member functions (by returning a callable object)

ida_idd.Appcall__.__getitem__ (method)
    Use self[func_name] syntax if the function name contains invalid characters for an attribute name
    See __getattr___

ida_idd.Appcall__.__init__ (method)

ida_idd.Appcall__.__name_or_ea (method)
    Function that accepts a name or an ea and checks if the address is enabled.
    If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
    @return:     - Returns the resolved EA or
        - Raises an exception if the address is not enabled

ida_idd.Appcall__.__typedecl_or_tinfo (method)
    Function that accepts a tinfo_t object or type declaration as a string
    If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
    @return:     - Returns the tinfo_t object
        - Raises an exception if the declaration cannot be parsed

ida_idd.Appcall__.array (method)
    Defines an array type. Later you need to pack() / unpack()

ida_idd.Appcall__.buffer (method)
    Creates a string buffer. The returned value (r) will be a byref object.
    Use r.value to get the contents and r.size to get the buffer's size

ida_idd.Appcall__.byref (method)
    Method to create references to immutable objects
    Currently we support references to int/strings
    Objects need not be passed by reference (this will be done automatically)

ida_idd.Appcall__.cleanup_appcall (method)
    Equivalent to IDC's CleanupAppcall()

ida_idd.Appcall__.cstr (method)

ida_idd.Appcall__.get_appcall_options (method)
    Return the global Appcall options

ida_idd.Appcall__.int64 (method)
    Whenever a 64bit number is needed use this method to construct an object

ida_idd.Appcall__.obj (method)
    Returns an empty object or objects with attributes as passed via its keywords arguments

ida_idd.Appcall__.proto (method)
    Allows you to instantiate an appcall (callable object) with the desired prototype
    @param name_or_ea: The name of the function (will be resolved with LocByName())
    @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
    @return:     - On failure it raises an exception if the prototype could not be parsed
          or the address is not resolvable
        - Returns a callbable Appcall instance with the given prototypes and flags

ida_idd.Appcall__.set_appcall_options (method)
    Method to change the Appcall options globally (not per Appcall)

ida_idd.Appcall__.typedobj (method)
    Returns an appcall object for a type (can be given as tinfo_t object or
    as a string declaration)
    One can then use retrieve() member method
    @param ea: Optional parameter that later can be used to retrieve the type
    @return: Appcall object or raises ValueError exception

ida_idd.Appcall__.valueof (method)
    Returns the numeric value of a given name string.
    If the name could not be resolved then the default value will be returned

ida_idd.Appcall_array__ (class)
    This class is used with Appcall.array() method

ida_idd.Appcall_array__.__init__ (method)

ida_idd.Appcall_array__.pack (method)
    Packs a list or tuple into a byref buffer

ida_idd.Appcall_array__.try_to_convert_to_list (method)
    Is this object a list? We check for the existance of attribute zero and attribute self.size-1

ida_idd.Appcall_array__.unpack (method)
    Unpacks an array back into a list or an object

ida_idd.Appcall_callable__ (class)
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)

ida_idd.Appcall_callable__.__call__ (method)
    Make object callable. We redirect execution to idaapi.appcall()

ida_idd.Appcall_callable__.__get_ea (method)

ida_idd.Appcall_callable__.__get_fields (method)

ida_idd.Appcall_callable__.__get_options (method)

ida_idd.Appcall_callable__.__get_size (method)

ida_idd.Appcall_callable__.__get_tif (method)

ida_idd.Appcall_callable__.__get_timeout (method)

ida_idd.Appcall_callable__.__get_type (method)

ida_idd.Appcall_callable__.__init__ (method)
    Initializes an appcall with a given function ea

ida_idd.Appcall_callable__.__set_ea (method)

ida_idd.Appcall_callable__.__set_options (method)

ida_idd.Appcall_callable__.__set_timeout (method)

ida_idd.Appcall_callable__.ea (variable)
    Returns or sets the EA associated with this object

ida_idd.Appcall_callable__.fields (variable)
    Returns the field names

ida_idd.Appcall_callable__.options (variable)
    Sets the Appcall options locally to this Appcall instance

ida_idd.Appcall_callable__.retrieve (method)
    Unpacks a typed object from the database if an ea is given or from a string if a string was passed
    @param src: the address of the object or a string
    @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).

ida_idd.Appcall_callable__.size (variable)
    Returns the size of the type

ida_idd.Appcall_callable__.store (method)
    Packs an object into a given ea if provided or into a string if no address was passed.
    @param obj: The object to pack
    @param dest_ea: If packing to idb this will be the store location
    @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
    
    @return:     - If packing to a string then a Tuple(Boolean, packed_string or error code)
        - If packing to the database then a return code is returned (0 is success)

ida_idd.Appcall_callable__.tif (variable)
    Returns the tinfo_t object

ida_idd.Appcall_callable__.timeout (variable)
    An Appcall instance can change its timeout value with this attribute

ida_idd.Appcall_callable__.type (variable)
    Returns the typestring

ida_idd.Appcall_consts__ (class)
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access

ida_idd.Appcall_consts__.__getattr__ (method)

ida_idd.Appcall_consts__.__init__ (method)

ida_idd.BPT_BAD_ADDR (variable)
    ea is invalid

ida_idd.BPT_BAD_ALIGN (variable)
    alignment is invalid

ida_idd.BPT_BAD_LEN (variable)
    bpt len is invalid

ida_idd.BPT_BAD_TYPE (variable)
    bpt type is not supported

ida_idd.BPT_DEFAULT (variable)
    Choose bpt type automatically.

ida_idd.BPT_EXEC (variable)
    Execute instruction.

ida_idd.BPT_INTERNAL_ERR (variable)
    interr occurred when verifying breakpoint

ida_idd.BPT_OK (variable)
    breakpoint can be set

ida_idd.BPT_PAGE_OK (variable)
    update_bpts(): ok, added a page bpt

ida_idd.BPT_RDWR (variable)
    Read/write access.

ida_idd.BPT_READ (variable)
    Read access.

ida_idd.BPT_READ_ERROR (variable)
    failed to read memory at bpt ea

ida_idd.BPT_SKIP (variable)
    update_bpts(): do not process bpt

ida_idd.BPT_SOFT (variable)
    Software breakpoint.

ida_idd.BPT_TOO_MANY (variable)
    reached max number of supported breakpoints

ida_idd.BPT_WRITE (variable)
    Write access.

ida_idd.BPT_WRITE_ERROR (variable)
    failed to write memory at bpt ea

ida_idd.BREAKPOINT (variable)
    Breakpoint has been reached. IDA will complain about unknown breakpoints, they
    should be reported as exceptions.

ida_idd.DBG_FLAG_ADD_ENVS (variable)
    The debugger supports launching processes with environment variables.

ida_idd.DBG_FLAG_ANYSIZE_HWBPT (variable)
    The debugger supports arbitrary size hardware breakpoints.

ida_idd.DBG_FLAG_CAN_CONT_BPT (variable)
    Debugger knows to continue from a bpt. This flag also means that the debugger
    module hides breakpoints from ida upon read_memory

ida_idd.DBG_FLAG_CLEAN_EXIT (variable)
    IDA must suspend the application and remove all breakpoints before terminating
    the application. Usually this is not required because the application memory
    disappears upon termination.

ida_idd.DBG_FLAG_CONNSTRING (variable)
    Display "Connection string" instead of "Hostname" and hide the "Port" field.

ida_idd.DBG_FLAG_DEBTHREAD (variable)
    Supports creation of a separate thread in ida for the debugger (the debthread).
    Most debugger functions will be called from debthread (exceptions are marked
    below) The debugger module may directly call only THREAD_SAFE functions. To call
    other functions please use execute_sync(). The debthread significantly increases
    debugging speed, especially if debug events occur frequently.

ida_idd.DBG_FLAG_DEBUG_DLL (variable)
    Can debug standalone DLLs. For example, Bochs debugger can debug any snippet of
    code

ida_idd.DBG_FLAG_DONT_DISTURB (variable)
    Debugger can handle only get_debug_event(), request_pause(), exit_process() when
    the debugged process is running. The kernel may also call service functions
    (file I/O, map_address, etc)

ida_idd.DBG_FLAG_EXITSHOTOK (variable)
    IDA may take a memory snapshot at PROCESS_EXITED event.

ida_idd.DBG_FLAG_FAKE_ATTACH (variable)
    PROCESS_ATTACHED is a fake event and does not suspend the execution

ida_idd.DBG_FLAG_FAKE_MEMORY (variable)
    get_memory_info()/read_memory()/write_memory() work with the idb. (there is no
    real process to read from, as for the replayer module) the kernel will not call
    these functions if this flag is set. however, third party plugins may call them,
    they must be implemented.

ida_idd.DBG_FLAG_FAST_STEP (variable)
    Do not refresh memory layout info after single stepping.

ida_idd.DBG_FLAG_HWDATBPT_ONE (variable)
    Hardware data breakpoints are one byte size by default

ida_idd.DBG_FLAG_LAZY_WATCHPTS (variable)
    Watchpoints are triggered before the offending instruction is executed. The
    debugger must temporarily disable the watchpoint and single-step before
    resuming.

ida_idd.DBG_FLAG_LOWCNDS (variable)
    Low level breakpoint conditions are supported.

ida_idd.DBG_FLAG_MANMEMINFO (variable)
    If set, manual memory region manipulation commands will be available. Use this
    bit for debugger modules that cannot return memory layout information

ida_idd.DBG_FLAG_MERGE_ENVS (variable)
    The debugger supports merge or replace setting for environment variables (only
    makes sense if DBG_FLAG_ADD_ENVS is set)

ida_idd.DBG_FLAG_NEEDPORT (variable)
    Remote debugger requires port number (to be used with DBG_FLAG_NOHOST)

ida_idd.DBG_FLAG_NOHOST (variable)
    Remote debugger with does not require network params (host/port/pass). (a unique
    device connected to the machine)

ida_idd.DBG_FLAG_NOPARAMETERS (variable)
    Debugger module doesn't use commandline parameters.

ida_idd.DBG_FLAG_NOPASSWORD (variable)
    Remote debugger doesn't use password.

ida_idd.DBG_FLAG_NOSTARTDIR (variable)
    Debugger module doesn't use startup directory.

ida_idd.DBG_FLAG_PREFER_SWBPTS (variable)
    Prefer to use software breakpoints.

ida_idd.DBG_FLAG_REMOTE (variable)
    Remote debugger (requires remote host name unless DBG_FLAG_NOHOST)

ida_idd.DBG_FLAG_SAFE (variable)
    The debugger is safe (probably because it just emulates the application without
    really running it)

ida_idd.DBG_FLAG_SMALLBLKS (variable)
    If set, IDA uses 256-byte blocks for caching memory contents. Otherwise,
    1024-byte blocks are used

ida_idd.DBG_FLAG_TRACER_MODULE (variable)
    The module is a tracer, not a full featured debugger module.

ida_idd.DBG_FLAG_USE_SREGS (variable)
    Take segment register values into account (non flat memory)

ida_idd.DBG_FLAG_VIRTHREADS (variable)
    Thread IDs may be shuffled after each debug event. (to be used for virtual
    threads that represent cpus for windbg kmode)

ida_idd.DBG_HAS_APPCALL (variable)
    supports ev_appcall, ev_cleanup_appcall

ida_idd.DBG_HAS_ATTACH_PROCESS (variable)
    supports ev_attach_process

ida_idd.DBG_HAS_CHECK_BPT (variable)
    supports ev_check_bpt

ida_idd.DBG_HAS_DETACH_PROCESS (variable)
    supports ev_detach_process

ida_idd.DBG_HAS_GET_PROCESSES (variable)
    supports ev_get_processes

ida_idd.DBG_HAS_MAP_ADDRESS (variable)
    supports ev_map_address. Avoid using this bit, especially together with
    DBG_FLAG_DEBTHREAD because it may cause big slow downs

ida_idd.DBG_HAS_OPEN_FILE (variable)
    supports ev_open_file, ev_close_file, ev_read_file, ev_write_file

ida_idd.DBG_HAS_REQUEST_PAUSE (variable)
    supports ev_request_pause

ida_idd.DBG_HAS_REXEC (variable)
    supports ev_rexec

ida_idd.DBG_HAS_SET_EXCEPTION_INFO (variable)
    supports ev_set_exception_info

ida_idd.DBG_HAS_SET_RESUME_MODE (variable)
    supports ev_set_resume_mode. Cannot be set inside the
    debugger_t::init_debugger()

ida_idd.DBG_HAS_THREAD_CONTINUE (variable)
    supports ev_thread_continue

ida_idd.DBG_HAS_THREAD_GET_SREG_BASE (variable)
    supports ev_thread_get_sreg_base

ida_idd.DBG_HAS_THREAD_SUSPEND (variable)
    supports ev_thread_suspend

ida_idd.DBG_HAS_UPDATE_CALL_STACK (variable)
    supports ev_update_call_stack

ida_idd.DBG_HIDE_WINDOW (variable)
    application should be hidden on startup (windows)

ida_idd.DBG_NO_ASLR (variable)
    disable ASLR (linux)

ida_idd.DBG_NO_TRACE (variable)
    do not trace the application (mac/linux)

ida_idd.DBG_PROC_32BIT (variable)
    application is 32-bit

ida_idd.DBG_PROC_64BIT (variable)
    application is 64-bit

ida_idd.DBG_PROC_IS_DLL (variable)
    database contains a dll (not exe)

ida_idd.DBG_PROC_IS_GUI (variable)
    using gui version of ida

ida_idd.DBG_RESMOD_STEP_HANDLE (variable)
    RESMOD_HANDLE is available

ida_idd.DBG_RESMOD_STEP_INTO (variable)
    RESMOD_INTO is available

ida_idd.DBG_RESMOD_STEP_OUT (variable)
    RESMOD_OUT is available

ida_idd.DBG_RESMOD_STEP_OVER (variable)
    RESMOD_OVER is available

ida_idd.DBG_RESMOD_STEP_SRCINTO (variable)
    RESMOD_SRCINTO is available

ida_idd.DBG_RESMOD_STEP_SRCOUT (variable)
    RESMOD_SRCOUT is available

ida_idd.DBG_RESMOD_STEP_SRCOVER (variable)
    RESMOD_SRCOVER is available

ida_idd.DBG_RESMOD_STEP_USER (variable)
    RESMOD_USER is available

ida_idd.DBG_SUSPENDED (variable)
    application should be suspended on startup (mac)

ida_idd.DEBUGGER_ID_6811_EMULATOR (variable)
    MC6812 emulator (beta)

ida_idd.DEBUGGER_ID_ARM_IPHONE_USER (variable)
    iPhone 1.x

ida_idd.DEBUGGER_ID_ARM_LINUX_USER (variable)
    Userland arm linux.

ida_idd.DEBUGGER_ID_ARM_MACOS_USER (variable)
    Userland arm MAC OS.

ida_idd.DEBUGGER_ID_DALVIK_USER (variable)
    Dalvik.

ida_idd.DEBUGGER_ID_GDB_USER (variable)
    GDB remote.

ida_idd.DEBUGGER_ID_TRACE_REPLAYER (variable)
    Fake debugger to replay recorded traces.

ida_idd.DEBUGGER_ID_WINDBG (variable)
    WinDBG using Microsoft Debug engine.

ida_idd.DEBUGGER_ID_X86_DOSBOX_EMULATOR (variable)
    Dosbox MS-DOS emulator.

ida_idd.DEBUGGER_ID_X86_IA32_BOCHS (variable)
    BochsDbg.exe 32.

ida_idd.DEBUGGER_ID_X86_IA32_LINUX_USER (variable)
    Userland linux processes (ptrace())

ida_idd.DEBUGGER_ID_X86_IA32_MACOSX_USER (variable)
    Userland MAC OS X processes.

ida_idd.DEBUGGER_ID_X86_IA32_WIN32_USER (variable)
    Userland win32 processes (win32 debugging APIs)

ida_idd.DEBUGGER_ID_X86_PIN_TRACER (variable)
    PIN Tracer module.

ida_idd.DEBUGGER_ID_XNU_USER (variable)
    XNU Kernel.

ida_idd.DRC_CRC (variable)
    success, but the input file crc does not match

ida_idd.DRC_ERROR (variable)
    unclassified error, may be complemented by errbuf

ida_idd.DRC_EVENTS (variable)
    success, there are pending events

ida_idd.DRC_FAILED (variable)
    failed or false

ida_idd.DRC_IDBSEG (variable)
    use idb segmentation

ida_idd.DRC_NETERR (variable)
    network error

ida_idd.DRC_NOCHG (variable)
    no changes

ida_idd.DRC_NOFILE (variable)
    file not found

ida_idd.DRC_NONE (variable)
    reaction to the event not implemented

ida_idd.DRC_NOPROC (variable)
    the process does not exist anymore

ida_idd.DRC_OK (variable)
    success

ida_idd.EXCEPTION (variable)
    Exception.

ida_idd.EXC_BREAK (variable)
    break on the exception

ida_idd.EXC_HANDLE (variable)
    should be handled by the debugger?

ida_idd.EXC_MSG (variable)
    instead of a warning, log the exception to the output window

ida_idd.EXC_SILENT (variable)
    do not warn or log to the output window

ida_idd.IDD_INTERFACE_VERSION (variable)
    The IDD interface version number.

ida_idd.INFORMATION (variable)
    User-defined information. This event can be used to return empty information
    This will cause IDA to call get_debug_event() immediately once more.

ida_idd.LIB_LOADED (variable)
    New library has been loaded.

ida_idd.LIB_UNLOADED (variable)
    Library has been unloaded.

ida_idd.NO_EVENT (variable)
    Not an interesting event. This event can be used if the debugger module needs to
    return an event but there are no valid events.

ida_idd.NO_PROCESS (variable)
    No process.

ida_idd.NO_THREAD (variable)
    No thread. in PROCESS_STARTED this value can be used to specify that the main
    thread has not been created. It will be initialized later by a THREAD_STARTED
    event.

ida_idd.PROCESS_ATTACHED (variable)
    Successfully attached to running process.

ida_idd.PROCESS_DETACHED (variable)
    Successfully detached from process.

ida_idd.PROCESS_EXITED (variable)
    Process has been stopped.

ida_idd.PROCESS_STARTED (variable)
    New process has been started.

ida_idd.PROCESS_SUSPENDED (variable)
    Process has been suspended. This event can be used by the debugger module to
    signal if the process spontaneously gets suspended (not because of an exception,
    breakpoint, or single step). IDA will silently switch to the 'suspended process'
    mode without displaying any messages.

ida_idd.REGISTER_ADDRESS (variable)
    may contain an address

ida_idd.REGISTER_CS (variable)
    code segment

ida_idd.REGISTER_CUSTFMT (variable)
    register should be displayed using a custom data format. the format name is in
    bit_strings[0]; the corresponding regval_t will use bytevec_t

ida_idd.REGISTER_FP (variable)
    frame pointer

ida_idd.REGISTER_IP (variable)
    instruction pointer

ida_idd.REGISTER_NOLF (variable)
    displays this register without returning to the next line, allowing the next
    register to be displayed to its right (on the same line)

ida_idd.REGISTER_READONLY (variable)
    the user can't modify the current value of this register

ida_idd.REGISTER_SP (variable)
    stack pointer

ida_idd.REGISTER_SS (variable)
    stack segment

ida_idd.RESMOD_HANDLE (variable)
    step into the exception handler

ida_idd.RESMOD_INTO (variable)
    step into call (the most typical single stepping)

ida_idd.RESMOD_NONE (variable)
    no stepping, run freely

ida_idd.RESMOD_OUT (variable)
    step out of the current function (run until return)

ida_idd.RESMOD_OVER (variable)
    step over call

ida_idd.RESMOD_SRCINTO (variable)
    until control reaches a different source line

ida_idd.RESMOD_SRCOUT (variable)
    next source line in the previous stack frame

ida_idd.RESMOD_SRCOVER (variable)
    next source line in the current stack frame

ida_idd.RESMOD_USER (variable)
    step out to the user code

ida_idd.RVT_FLOAT (variable)
    floating point

ida_idd.RVT_INT (variable)
    integer

ida_idd.RVT_UNAVAILABLE (variable)
    unavailable; other values mean custom data type

ida_idd.STEP (variable)
    One instruction has been executed. Spurious events of this kind are silently
    ignored by IDA.

ida_idd.THREAD_EXITED (variable)
    Thread has been stopped.

ida_idd.THREAD_STARTED (variable)
    New thread has been started.

ida_idd.TRACE_FULL (variable)
    The trace buffer of the tracer module is full and IDA needs to read it before
    continuing

ida_idd.appcall (function)
    appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *
    
    @param func_ea: ea_t
    @param tid: thid_t
    @param _type_or_none: bytevec_t const &
    @param _fields: bytevec_t const &
    @param arg_list: PyObject *

ida_idd.bptaddr_t (class)
    Proxy of C++ bptaddr_t class.

ida_idd.bptaddr_t.__init__ (method)
    __init__(self) -> bptaddr_t

ida_idd.bptaddr_t.hea (variable)
    Possible address referenced by hardware breakpoints.

ida_idd.bptaddr_t.kea (variable)
    Address of the triggered bpt from the kernel's point of view. (for some systems
    with special memory mappings, the triggered ea might be different from event
    ea). Use to BADADDR for flat memory model.

ida_idd.call_stack_info_t (class)
    Proxy of C++ call_stack_info_t class.

ida_idd.call_stack_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: call_stack_info_t const &

ida_idd.call_stack_info_t.__init__ (method)
    __init__(self) -> call_stack_info_t

ida_idd.call_stack_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: call_stack_info_t const &

ida_idd.call_stack_info_t.callea (variable)
    the address of the call instruction. for the 0th frame this is usually just the
    current value of EIP.

ida_idd.call_stack_info_t.fp (variable)
    the value of the frame pointer of the called function

ida_idd.call_stack_info_t.funcea (variable)
    the address of the called function

ida_idd.call_stack_info_t.funcok (variable)
    is the function present?

ida_idd.call_stack_info_vec_t (class)
    Proxy of C++ qvector< call_stack_info_t > class.

ida_idd.call_stack_info_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< call_stack_info_t > const &

ida_idd.call_stack_info_vec_t.__getitem__ (method)
    __getitem__(self, i) -> call_stack_info_t
    
    @param i: size_t

ida_idd.call_stack_info_vec_t.__init__ (method)
    __init__(self) -> call_stack_info_vec_t
    __init__(self, x) -> call_stack_info_vec_t
    
    @param x: qvector< call_stack_info_t > const &

ida_idd.call_stack_info_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_idd.call_stack_info_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< call_stack_info_t > const &

ida_idd.call_stack_info_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: call_stack_info_t const &

ida_idd.call_stack_info_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.at (method)
    at(self, _idx) -> call_stack_info_t
    
    @param _idx: size_t

ida_idd.call_stack_info_vec_t.begin (method)
    begin(self) -> call_stack_info_t

ida_idd.call_stack_info_vec_t.capacity (method)
    capacity(self) -> size_t

ida_idd.call_stack_info_vec_t.clear (method)
    clear(self)

ida_idd.call_stack_info_vec_t.empty (method)
    empty(self) -> bool

ida_idd.call_stack_info_vec_t.end (method)
    end(self) -> call_stack_info_t

ida_idd.call_stack_info_vec_t.erase (method)
    erase(self, it) -> call_stack_info_t
    
    @param it: qvector< call_stack_info_t >::iterator
    
    erase(self, first, last) -> call_stack_info_t
    
    @param first: qvector< call_stack_info_t >::iterator
    @param last: qvector< call_stack_info_t >::iterator

ida_idd.call_stack_info_vec_t.extract (method)
    extract(self) -> call_stack_info_t

ida_idd.call_stack_info_vec_t.find (method)
    find(self, x) -> call_stack_info_t
    
    @param x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.grow (method)
    grow(self, x=call_stack_info_t())
    
    @param x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: call_stack_info_t *
    @param len: size_t

ida_idd.call_stack_info_vec_t.insert (method)
    insert(self, it, x) -> call_stack_info_t
    
    @param it: qvector< call_stack_info_t >::iterator
    @param x: call_stack_info_t const &

ida_idd.call_stack_info_vec_t.pop_back (method)
    pop_back(self)

ida_idd.call_stack_info_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: call_stack_info_t const &
    
    push_back(self) -> call_stack_info_t

ida_idd.call_stack_info_vec_t.qclear (method)
    qclear(self)

ida_idd.call_stack_info_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idd.call_stack_info_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: call_stack_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idd.call_stack_info_vec_t.size (method)
    size(self) -> size_t

ida_idd.call_stack_info_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< call_stack_info_t > &

ida_idd.call_stack_info_vec_t.truncate (method)
    truncate(self)

ida_idd.call_stack_t (class)
    Proxy of C++ call_stack_t class.

ida_idd.call_stack_t.__init__ (method)
    __init__(self) -> call_stack_t

ida_idd.can_exc_continue (function)
    can_exc_continue(ev) -> bool
    
    @param ev: debug_event_t const *

ida_idd.cleanup_appcall (function)
    cleanup_appcall(tid) -> error_t
    Cleanup after manual appcall.
    
    @param tid: (C++: thid_t) thread to use. NO_THREAD means to use the current thread The
                application state is restored as it was before calling the last
                appcall(). Nested appcalls are supported.
    @return: eOk if successful, otherwise an error code

ida_idd.dbg_appcall (function)
    dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
    Call a function from the debugged application.
    
    @param retval: (C++: idc_value_t *) function return value
    * for APPCALL_MANUAL, r will hold the new stack point value
    * for APPCALL_DEBEV, r will hold the exception information upon failure and the
    return code will be eExecThrow
    @param func_ea: (C++: ea_t) address to call
    @param tid: (C++: thid_t) thread to use. NO_THREAD means to use the current thread
    @param ptif: (C++: const tinfo_t *) pointer to type of the function to call
    @param argv: (C++: idc_value_t *) array of arguments
    @param argnum: (C++: size_t) number of actual arguments
    @return: eOk if successful, otherwise an error code

ida_idd.dbg_get_memory_info (function)
    dbg_get_memory_info() -> PyObject *
    This function returns the memory configuration of a debugged process.
    
    @return:     None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)

ida_idd.dbg_get_name (function)
    dbg_get_name() -> PyObject *
    This function returns the current debugger's name.
    
    @return: Debugger name or None if no debugger is active

ida_idd.dbg_get_registers (function)
    dbg_get_registers() -> PyObject *
    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    
    @return:     None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)

ida_idd.dbg_get_thread_sreg_base (function)
    dbg_get_thread_sreg_base(tid, sreg_value) -> PyObject *
    Returns the segment register base value
    
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:     - The base as an 'ea'
        - Or None on failure

ida_idd.dbg_read_memory (function)
    dbg_read_memory(ea, sz) -> PyObject *
    Reads from the debugee's memory at the specified ea
    
    @param ea: ea_t
    @param sz: size_t
    @return:     - The read buffer (as a string)
        - Or None on failure

ida_idd.dbg_write_memory (function)
    dbg_write_memory(ea, buf) -> bool
    Writes a buffer to the debugee's memory
    
    @param ea: ea_t
    @param buf: bytevec_t const &
    @return: Boolean

ida_idd.debapp_attrs_t (class)
    Proxy of C++ debapp_attrs_t class.

ida_idd.debapp_attrs_t.__init__ (method)
    __init__(self) -> debapp_attrs_t

ida_idd.debapp_attrs_t.addrsize (variable)
    address size of the process. Since 64-bit debuggers usually can debug 32-bit
    applications, we cannot rely on sizeof(ea_t) to detect the current address size.
    The following variable should be used instead. It is initialized with 8 for
    64-bit debuggers but they should adjust it as soon as they learn that a 32-bit
    application is being debugged. For 32-bit debuggers it is initialized with 4.

ida_idd.debapp_attrs_t.cbsize (variable)
    control field: size of this structure

ida_idd.debapp_attrs_t.platform (variable)
    platform name process is running/debugging under. (is used as a key value in
    exceptions.cfg)

ida_idd.debug_event_t (class)
    Proxy of C++ debug_event_t class.

ida_idd.debug_event_t.__init__ (method)
    __init__(self) -> debug_event_t
    __init__(self, r) -> debug_event_t
    
    @param r: debug_event_t const &

ida_idd.debug_event_t.bpt (method)
    bpt(self) -> bptaddr_t

ida_idd.debug_event_t.bpt_ea (method)
    bpt_ea(self) -> ea_t
    On some systems with special memory mappings the triggered ea might be different
    from the actual ea. Calculate the address to use.

ida_idd.debug_event_t.clear (method)
    clear(self)
    clear the dependent information (see below), set event code to NO_EVENT

ida_idd.debug_event_t.clear_all (method)
    clear_all(self)

ida_idd.debug_event_t.copy (method)
    copy(self, r) -> debug_event_t
    
    @param r: debug_event_t const &

ida_idd.debug_event_t.ea (variable)
    Address where the event occurred.

ida_idd.debug_event_t.eid (method)
    eid(self) -> event_id_t
    Event code.

ida_idd.debug_event_t.exc (method)
    exc(self) -> excinfo_t

ida_idd.debug_event_t.exit_code (method)
    exit_code(self) -> int const &

ida_idd.debug_event_t.handled (variable)
    Is event handled by the debugger?. (from the system's point of view) Meaningful
    for EXCEPTION events

ida_idd.debug_event_t.info (method)
    info(self) -> qstring
    info(self) -> qstring const &

ida_idd.debug_event_t.modinfo (method)
    modinfo(self) -> modinfo_t

ida_idd.debug_event_t.pid (variable)
    Process where the event occurred.

ida_idd.debug_event_t.set_bpt (method)
    set_bpt(self) -> bptaddr_t

ida_idd.debug_event_t.set_eid (method)
    set_eid(self, id)
    Set event code. If the new event code is compatible with the old one then the
    dependent information (see below) will be preserved. Otherwise the event will be
    cleared and the new event code will be set.
    
    @param id: (C++: event_id_t) enum event_id_t

ida_idd.debug_event_t.set_exception (method)
    set_exception(self) -> excinfo_t

ida_idd.debug_event_t.set_exit_code (method)
    set_exit_code(self, id, code)
    
    @param id: enum event_id_t
    @param code: int

ida_idd.debug_event_t.set_info (method)
    set_info(self, id) -> qstring &
    
    @param id: enum event_id_t

ida_idd.debug_event_t.set_modinfo (method)
    set_modinfo(self, id) -> modinfo_t
    
    @param id: enum event_id_t

ida_idd.debug_event_t.tid (variable)
    Thread where the event occurred.

ida_idd.debugger_t (class)
    Proxy of C++ debugger_t class.

ida_idd.debugger_t.__get_bpt_bytes (method)
    __get_bpt_bytes(self) -> bytevec_t

ida_idd.debugger_t.__get_nregs (method)
    __get_nregs(self) -> int

ida_idd.debugger_t.__get_regclasses (method)
    __get_regclasses(self) -> PyObject *

ida_idd.debugger_t.__get_registers (method)
    __get_registers(self) -> dyn_register_info_array

ida_idd.debugger_t.__init__ (method)
    __init__(self) -> debugger_t

ida_idd.debugger_t.attach_process (method)
    attach_process(self, pid, event_id, dbg_proc_flags) -> drc_t
    
    @param pid: pid_t
    @param event_id: int
    @param dbg_proc_flags: uint32

ida_idd.debugger_t.bin_search (method)
    bin_search(self, start_ea, end_ea, data, srch_flags) -> drc_t
    
    @param start_ea: ea_t
    @param end_ea: ea_t
    @param data: compiled_binpat_vec_t const &
    @param srch_flags: int

ida_idd.debugger_t.bpt_bytes (variable)
    A software breakpoint instruction.

ida_idd.debugger_t.bpt_size (variable)
    Size of the software breakpoint instruction in bytes.

ida_idd.debugger_t.cache_block_size (method)
    cache_block_size(self) -> size_t

ida_idd.debugger_t.can_continue_from_bpt (method)
    can_continue_from_bpt(self) -> bool

ida_idd.debugger_t.can_debug_standalone_dlls (method)
    can_debug_standalone_dlls(self) -> bool

ida_idd.debugger_t.check_bpt (method)
    check_bpt(self, bptvc, type, ea, len) -> drc_t
    
    @param bptvc: int *
    @param type: bpttype_t
    @param ea: ea_t
    @param len: int

ida_idd.debugger_t.cleanup_appcall (method)
    cleanup_appcall(self, tid) -> drc_t
    
    @param tid: thid_t

ida_idd.debugger_t.close_file (method)
    close_file(self, fn)
    
    @param fn: int

ida_idd.debugger_t.dbg_enable_trace (method)
    dbg_enable_trace(self, tid, enable, trace_flags) -> bool
    
    @param tid: thid_t
    @param enable: bool
    @param trace_flags: int

ida_idd.debugger_t.default_regclasses (variable)
    Mask of default printed register classes.

ida_idd.debugger_t.detach_process (method)
    detach_process(self) -> drc_t

ida_idd.debugger_t.ev_appcall (variable)
    Call application function. This event calls a function from the debugged
    application. This event is generated in debthread Available if HAS_APPCALL is
    set
    
    @retval DRC_NONE
    @retval DRC_OK,see: BLOB_EA

ida_idd.debugger_t.ev_attach_process (variable)
    Attach to an existing running process. event_id should be equal to -1 if not
    attaching to a crashed process. This event is generated in debthread. Available
    if DBG_HAS_ATTACH_PROCESS is set
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_bin_search (variable)
    Search for a binary pattern in the program.
    
    @return: DRC_OK EA contains the binary pattern address
    @retval DRC_FAILED: not found
    @retval DRC_NONE: not implemented
    @retval DRC_NETERR,DRC_ERROR

ida_idd.debugger_t.ev_check_bpt (variable)
    Is it possible to set breakpoint? This event is generated in debthread or in the
    main thread if debthread is not running yet. It is generated to verify hardware
    breakpoints. Available if DBG_HAS_CHECK_BPT is set
    
    @return: DRC_OK, DRC_NONE

ida_idd.debugger_t.ev_cleanup_appcall (variable)
    Cleanup after appcall(). The debugger module must keep the stack blob in the
    memory until this event is generated. It will be generated by the kernel for
    each successful appcall(). There is an exception: if APPCALL_MANUAL, IDA may not
    call cleanup_appcall. If the user selects to terminate a manual appcall, then
    cleanup_appcall will be generated. Otherwise, the debugger module should
    terminate the appcall when the generated event returns. This event is generated
    in debthread. Available if HAS_APPCALL is set
    
    @retval DRC_EVENTS: success, there are pending events
    @retval DRC_OK: success
    @retval DRC_FAILED: failed
    @retval DRC_NETERR: network error

ida_idd.debugger_t.ev_close_file (variable)
    @return: ignored

ida_idd.debugger_t.ev_dbg_enable_trace (variable)
    Enable/Disable tracing. The kernel will generated this event if the debugger
    plugin set DBG_FLAG_TRACER_MODULE. TRACE_FLAGS can be a set of #STEP_TRACE,
    #INSN_TRACE, #BBLK_TRACE or #FUNC_TRACE. This event is generated in the main
    thread.
    
    @return: DRC_OK, DRC_FAILED, DRC_NONE

ida_idd.debugger_t.ev_detach_process (variable)
    Detach from the debugged process. May be generated while the process is running
    or suspended. Must detach from the process in any case. The kernel will
    repeatedly call get_debug_event() until PROCESS_DETACHED is received. In this
    mode, all other events will be automatically handled and process will be
    resumed. This event is generated from debthread. Available if
    DBG_HAS_DETACH_PROCESS is set
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_eval_lowcnd (variable)
    Evaluate a low level breakpoint condition at 'ea'. Other evaluation errors are
    displayed in a dialog box. This call is used by IDA when the process has already
    been temporarily suspended for some reason and IDA has to decide whether the
    process should be resumed or definitely suspended because of a breakpoint with a
    low level condition. This event is generated in debthread.
    
    @retval DRC_OK: condition is satisfied
    @retval DRC_FAILED: not satisfied
    @retval DRC_NETERR: network error

ida_idd.debugger_t.ev_exit_process (variable)
    Stop the process. May be generated while the process is running or suspended.
    Must terminate the process in any case. The kernel will repeatedly call
    get_debug_event() until PROCESS_EXITED is received. In this mode, all other
    events will be automatically handled and process will be resumed. This event is
    generated in debthread. Must be implemented.
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_get_debapp_attrs (variable)
    Retrieve process- and debugger-specific runtime attributes. This event is
    generated in the main thread.
    
    @return: DRC_NONE, DRC_OK

ida_idd.debugger_t.ev_get_debmod_extensions (variable)
    Get pointer to debugger specific events. This event returns a pointer to a
    structure that holds pointers to debugger module specific events. For
    information on the structure layout, please check the corresponding debugger
    module. Most debugger modules return nullptr because they do not have any
    extensions. Available extensions may be generated from plugins. This event is
    generated in the main thread.
    
    @return: DRC_NONE, DRC_OK see EXT

ida_idd.debugger_t.ev_get_debug_event (variable)
    Get a pending debug event and suspend the process. This event will be generated
    regularly by IDA. This event is generated in debthread. IMPORTANT: the
    BREAKPOINT/EXCEPTION/STEP events must be reported only after reporting other
    pending events for a thread. Must be implemented.
    
    @retval ignored

ida_idd.debugger_t.ev_get_memory_info (variable)
    Get information on the memory ranges. The debugger module fills 'ranges'. The
    returned vector must be sorted. This event is generated in debthread. Must be
    implemented.
    
    @retval DRC_OK: new memory layout is returned
    @retval DRC_FAILED,DRC_NETERR,DRC_NOPROC,DRC_NOCHG,DRC_IDBSEG

ida_idd.debugger_t.ev_get_processes (variable)
    Return information about the running processes. This event is generated in the
    main thread. Available if DBG_HAS_GET_PROCESSES is set
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_get_srcinfo_path (variable)
    Get the path to a file containing source debug info for the given module. This
    allows srcinfo providers to call into the debugger when looking for debug info.
    It is useful in certain cases like the iOS debugger, which is a remote debugger
    but the remote debugserver does not provide dwarf info. So, we allow the
    debugger client to decide where to look for debug info locally.
    
    @return: DRC_NONE, DRC_OK result stored in PATH

ida_idd.debugger_t.ev_init_debugger (variable)
    Initialize debugger. This event is generated in the main thread.
    
    @return: DRC_OK, DRC_FAILED

ida_idd.debugger_t.ev_is_tracing_enabled (variable)
    Is tracing enabled? The kernel will generated this event if the debugger plugin
    set DBG_FLAG_TRACER_MODULE. TRACE_BIT can be one of the following: #STEP_TRACE,
    #INSN_TRACE, #BBLK_TRACE or #FUNC_TRACE
    
    @retval DRC_OK: bit is set
    @retval DRC_NONE: bit is not set or not implemented

ida_idd.debugger_t.ev_map_address (variable)
    Map process address. The debugger module may ignore this event. This event is
    generated in debthread. IDA will generate this event only if DBG_HAS_MAP_ADDRESS
    is set.
    
    @return: DRC_NONE, DRC_OK see MAPPED

ida_idd.debugger_t.ev_open_file (variable)
    @retval (int): handle
    @retval -1: error

ida_idd.debugger_t.ev_read_file (variable)
    @retval number: of read bytes

ida_idd.debugger_t.ev_read_memory (variable)
    Read process memory. This event is generated in debthread.
    
    @return: DRC_OK, DRC_FAILED, DRC_NOPROC

ida_idd.debugger_t.ev_read_registers (variable)
    Read thread registers. This event is generated in debthread. Must be
    implemented.
    
    @return: DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_rebase_if_required_to (variable)
    Rebase database if the debugged program has been rebased by the system. This
    event is generated in the main thread.
    
    @return: DRC_NONE, DRC_OK

ida_idd.debugger_t.ev_request_pause (variable)
    Prepare to pause the process. Normally the next get_debug_event() will pause the
    process If the process is sleeping, then the pause will not occur until the
    process wakes up. If the debugger module does not react to this event, then it
    will be impossible to pause the program. This event is generated in debthread.
    Available if DBG_HAS_REQUEST_PAUSE is set
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_resume (variable)
    Continue after handling the event. This event is generated in debthread. Must be
    implemented.
    
    @return: DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_rexec (variable)
    Execute a command on the remote computer. Available if DBG_HAS_REXEC is set
    
    @return: (int) exit code

ida_idd.debugger_t.ev_send_ioctl (variable)
    Perform a debugger-specific event. This event is generated in debthread
    
    @retval DRC_...

ida_idd.debugger_t.ev_set_exception_info (variable)
    Set exception handling. This event is generated in debthread or the main thread.
    Available if DBG_HAS_SET_EXCEPTION_INFO is set
    
    @return: DRC_NONE, DRC_OK

ida_idd.debugger_t.ev_set_resume_mode (variable)
    Specify resume action Available if DBG_HAS_SET_RESUME_MODE is set

ida_idd.debugger_t.ev_start_process (variable)
    Start an executable to debug. This event is generated in debthread. Must be
    implemented.
    
    @return: DRC_OK, DRC_CRC, DRC_FAILED, DRC_NETERR, DRC_NOFILE

ida_idd.debugger_t.ev_suspended (variable)
    This event will be generated by the kernel each time it has suspended the
    debuggee process and refreshed the database. The debugger module may add
    information to the database if necessary.
    
    The reason for introducing this event is that when an event like LOAD_DLL
    happens, the database does not reflect the memory state yet and therefore we
    can't add information about the dll into the database in the get_debug_event()
    function. Only when the kernel has adjusted the database we can do it. Example:
    for loaded PE DLLs we can add the exported function names to the list of debug
    names (see set_debug_names()).
    
    This event is generated in the main thread.
    
    @return: DRC_NONE, DRC_OK

ida_idd.debugger_t.ev_term_debugger (variable)
    Terminate debugger. This event is generated in the main thread.
    
    @return: DRC_OK, DRC_FAILED

ida_idd.debugger_t.ev_thread_continue (variable)
    Resume a suspended thread Available if DBG_HAS_THREAD_CONTINUE is set

ida_idd.debugger_t.ev_thread_get_sreg_base (variable)
    Get information about the base of a segment register. Currently used by the IBM
    PC module to resolve references like fs:0. This event is generated in debthread.
    Available if DBG_HAS_THREAD_GET_SREG_BASE is set
    
    @return: DRC_NONE, DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_thread_suspend (variable)
    Suspend a running thread Available if DBG_HAS_THREAD_SUSPEND is set

ida_idd.debugger_t.ev_update_bpts (variable)
    Add/del breakpoints. bpts array contains nadd bpts to add, followed by ndel bpts
    to del. This event is generated in debthread.
    
    @return: DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.ev_update_call_stack (variable)
    Calculate the call stack trace for the given thread. This event is generated
    when the process is suspended and should fill the 'trace' object with the
    information about the current call stack. If this event returns DRC_NONE, IDA
    will try to invoke a processor-specific mechanism (see
    processor_t::ev_update_call_stack). If the current processor module does not
    implement stack tracing, then IDA will fall back to a generic algorithm (based
    on the frame pointer chain) to calculate the trace. This event is ideal if the
    debugging targets manage stack frames in a peculiar way, requiring special
    analysis. This event is generated in the main thread. Available if
    DBG_HAS_UPDATE_CALL_STACK is set
    
    @retval DRC_NONE: false or not implemented
    @return: DRC_OK success

ida_idd.debugger_t.ev_update_lowcnds (variable)
    Update low-level (server side) breakpoint conditions. This event is generated in
    debthread.
    
    @return: DRC_OK, DRC_NETERR

ida_idd.debugger_t.ev_write_file (variable)
    @retval number: of written bytes

ida_idd.debugger_t.ev_write_memory (variable)
    Write process memory. This event is generated in debthread.
    
    @retval DRC_OK,DRC_FAILED,DRC_NOPROC

ida_idd.debugger_t.ev_write_register (variable)
    Write one thread register. This event is generated in debthread. Must be
    implemented.
    
    @return: DRC_OK, DRC_FAILED, DRC_NETERR

ida_idd.debugger_t.eval_lowcnd (method)
    eval_lowcnd(self, tid, ea) -> drc_t
    
    @param tid: thid_t
    @param ea: ea_t

ida_idd.debugger_t.exit_process (method)
    exit_process(self) -> drc_t

ida_idd.debugger_t.fake_memory (method)
    fake_memory(self) -> bool

ida_idd.debugger_t.filetype (variable)
    Input file type for the instant debugger. This value will be used after
    attaching to a new process.

ida_idd.debugger_t.flags2 (variable)
    Debugger module features

ida_idd.debugger_t.get_debapp_attrs (method)
    get_debapp_attrs(self, out_pattrs) -> bool
    
    @param out_pattrs: debapp_attrs_t *

ida_idd.debugger_t.get_debmod_extensions (method)
    get_debmod_extensions(self) -> void const *

ida_idd.debugger_t.get_debug_event (method)
    get_debug_event(self, event, timeout_ms) -> gdecode_t
    
    @param event: debug_event_t *
    @param timeout_ms: int

ida_idd.debugger_t.get_memory_info (method)
    get_memory_info(self, ranges) -> drc_t
    
    @param ranges: meminfo_vec_t &

ida_idd.debugger_t.get_processes (method)
    get_processes(self, procs) -> drc_t
    
    @param procs: procinfo_vec_t *

ida_idd.debugger_t.get_srcinfo_path (method)
    get_srcinfo_path(self, path, base) -> bool
    
    @param path: qstring *
    @param base: ea_t

ida_idd.debugger_t.has_appcall (method)
    has_appcall(self) -> bool

ida_idd.debugger_t.has_attach_process (method)
    has_attach_process(self) -> bool

ida_idd.debugger_t.has_check_bpt (method)
    has_check_bpt(self) -> bool

ida_idd.debugger_t.has_detach_process (method)
    has_detach_process(self) -> bool

ida_idd.debugger_t.has_get_processes (method)
    has_get_processes(self) -> bool

ida_idd.debugger_t.has_map_address (method)
    has_map_address(self) -> bool

ida_idd.debugger_t.has_open_file (method)
    has_open_file(self) -> bool

ida_idd.debugger_t.has_request_pause (method)
    has_request_pause(self) -> bool

ida_idd.debugger_t.has_rexec (method)
    has_rexec(self) -> bool

ida_idd.debugger_t.has_set_exception_info (method)
    has_set_exception_info(self) -> bool

ida_idd.debugger_t.has_set_resume_mode (method)
    has_set_resume_mode(self) -> bool

ida_idd.debugger_t.has_soft_bpt (method)
    has_soft_bpt(self) -> bool

ida_idd.debugger_t.has_thread_continue (method)
    has_thread_continue(self) -> bool

ida_idd.debugger_t.has_thread_get_sreg_base (method)
    has_thread_get_sreg_base(self) -> bool

ida_idd.debugger_t.has_thread_suspend (method)
    has_thread_suspend(self) -> bool

ida_idd.debugger_t.has_update_call_stack (method)
    has_update_call_stack(self) -> bool

ida_idd.debugger_t.id (variable)
    one of Debugger API module id

ida_idd.debugger_t.init_debugger (method)
    init_debugger(self, hostname, portnum, password) -> bool
    
    @param hostname: char const *
    @param portnum: int
    @param password: char const *

ida_idd.debugger_t.is_remote (method)
    is_remote(self) -> bool

ida_idd.debugger_t.is_resmod_avail (method)
    is_resmod_avail(self, resmod) -> bool
    
    @param resmod: int

ida_idd.debugger_t.is_safe (method)
    is_safe(self) -> bool

ida_idd.debugger_t.is_tracing_enabled (method)
    is_tracing_enabled(self, tid, tracebit) -> bool
    
    @param tid: thid_t
    @param tracebit: int

ida_idd.debugger_t.map_address (method)
    map_address(self, off, regs, regnum) -> ea_t
    
    @param off: ea_t
    @param regs: regval_t const *
    @param regnum: int

ida_idd.debugger_t.may_disturb (method)
    may_disturb(self) -> bool

ida_idd.debugger_t.may_take_exit_snapshot (method)
    may_take_exit_snapshot(self) -> bool

ida_idd.debugger_t.memory_page_size (variable)
    Size of a memory page. Usually 4K.

ida_idd.debugger_t.must_have_hostname (method)
    must_have_hostname(self) -> bool

ida_idd.debugger_t.name (variable)
    Short debugger name like win32 or linux.

ida_idd.debugger_t.nregs (variable)
    Number of registers.

ida_idd.debugger_t.open_file (method)
    open_file(self, file, fsize, readonly) -> int
    
    @param file: char const *
    @param fsize: uint64 *
    @param readonly: bool

ida_idd.debugger_t.processor (variable)
    Required processor name. Used for instant debugging to load the correct
    processor module

ida_idd.debugger_t.read_file (method)
    read_file(self, fn, off, buf, size) -> ssize_t
    
    @param fn: int
    @param off: qoff64_t
    @param buf: void *
    @param size: size_t

ida_idd.debugger_t.read_memory (method)
    read_memory(self, nbytes, ea, buffer, size) -> drc_t
    
    @param nbytes: size_t *
    @param ea: ea_t
    @param buffer: void *
    @param size: size_t

ida_idd.debugger_t.read_registers (method)
    read_registers(self, tid, clsmask, values) -> drc_t
    
    @param tid: thid_t
    @param clsmask: int
    @param values: regval_t *

ida_idd.debugger_t.rebase_if_required_to (method)
    rebase_if_required_to(self, new_base)
    
    @param new_base: ea_t

ida_idd.debugger_t.regclasses (variable)
    Array of register class names.

ida_idd.debugger_t.registers (variable)
    Array of registers. Use regs() to access it.

ida_idd.debugger_t.regs (method)
    regs(self, idx) -> register_info_t
    
    @param idx: int

ida_idd.debugger_t.request_pause (method)
    request_pause(self) -> drc_t

ida_idd.debugger_t.resume (method)
    resume(self, event) -> drc_t
    
    @param event: debug_event_t const *

ida_idd.debugger_t.resume_modes (variable)
    Resume modes

ida_idd.debugger_t.rexec (method)
    rexec(self, cmdline) -> int
    
    @param cmdline: char const *

ida_idd.debugger_t.send_ioctl (method)
    send_ioctl(self, fn, buf, poutbuf, poutsize) -> drc_t
    
    @param fn: int
    @param buf: void const *
    @param poutbuf: void **
    @param poutsize: ssize_t *

ida_idd.debugger_t.set_exception_info (method)
    set_exception_info(self, info, qty)
    
    @param info: exception_info_t const *
    @param qty: int

ida_idd.debugger_t.set_resume_mode (method)
    set_resume_mode(self, tid, resmod) -> drc_t
    
    @param tid: thid_t
    @param resmod: enum resume_mode_t

ida_idd.debugger_t.start_process (method)
    start_process(self, path, args, envs, startdir, dbg_proc_flags, input_path, input_file_crc32) -> drc_t
    
    @param path: char const *
    @param args: char const *
    @param envs: launch_env_t *
    @param startdir: char const *
    @param dbg_proc_flags: uint32
    @param input_path: char const *
    @param input_file_crc32: uint32

ida_idd.debugger_t.supports_debthread (method)
    supports_debthread(self) -> bool

ida_idd.debugger_t.supports_lowcnds (method)
    supports_lowcnds(self) -> bool

ida_idd.debugger_t.suspended (method)
    suspended(self, dlls_added, thr_names=None)
    
    @param dlls_added: bool
    @param thr_names: thread_name_vec_t *

ida_idd.debugger_t.term_debugger (method)
    term_debugger(self) -> bool

ida_idd.debugger_t.thread_continue (method)
    thread_continue(self, tid) -> drc_t
    
    @param tid: thid_t

ida_idd.debugger_t.thread_get_sreg_base (method)
    thread_get_sreg_base(self, answer, tid, sreg_value) -> drc_t
    
    @param answer: ea_t *
    @param tid: thid_t
    @param sreg_value: int

ida_idd.debugger_t.thread_suspend (method)
    thread_suspend(self, tid) -> drc_t
    
    @param tid: thid_t

ida_idd.debugger_t.update_bpts (method)
    update_bpts(self, nbpts, bpts, nadd, ndel) -> drc_t
    
    @param nbpts: int *
    @param bpts: update_bpt_info_t *
    @param nadd: int
    @param ndel: int

ida_idd.debugger_t.update_call_stack (method)
    update_call_stack(self, tid, trace) -> drc_t
    
    @param tid: thid_t
    @param trace: call_stack_t *

ida_idd.debugger_t.update_lowcnds (method)
    update_lowcnds(self, nupdated, lowcnds, nlowcnds) -> drc_t
    
    @param nupdated: int *
    @param lowcnds: lowcnd_t const *
    @param nlowcnds: int

ida_idd.debugger_t.use_memregs (method)
    use_memregs(self) -> bool

ida_idd.debugger_t.use_sregs (method)
    use_sregs(self) -> bool

ida_idd.debugger_t.version (variable)
    Expected kernel version, should be IDD_INTERFACE_VERSION

ida_idd.debugger_t.virtual_threads (method)
    virtual_threads(self) -> bool

ida_idd.debugger_t.write_file (method)
    write_file(self, fn, off, buf) -> ssize_t
    
    @param fn: int
    @param off: qoff64_t
    @param buf: void const *

ida_idd.debugger_t.write_memory (method)
    write_memory(self, nbytes, ea, buffer, size) -> drc_t
    
    @param nbytes: size_t *
    @param ea: ea_t
    @param buffer: void const *
    @param size: size_t

ida_idd.debugger_t.write_register (method)
    write_register(self, tid, regidx, value) -> drc_t
    
    @param tid: thid_t
    @param regidx: int
    @param value: regval_t const *

ida_idd.dyn_register_info_array (class)
    Proxy of C++ dynamic_wrapped_array_t< register_info_t > class.

ida_idd.dyn_register_info_array.__getitem__ (method)
    __getitem__(self, i) -> register_info_t
    
    @param i: size_t

ida_idd.dyn_register_info_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_register_info_array
    
    @param _data: register_info_t *
    @param _count: size_t

ida_idd.dyn_register_info_array.__len__ (method)
    __len__(self) -> size_t

ida_idd.dyn_register_info_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: register_info_t const &

ida_idd.exception_info_t (class)
    Proxy of C++ exception_info_t class.

ida_idd.exception_info_t.__init__ (method)
    __init__(self) -> exception_info_t
    __init__(self, _code, _flags, _name, _desc) -> exception_info_t
    
    @param _code: uint
    @param _flags: uint32
    @param _name: char const *
    @param _desc: char const *

ida_idd.exception_info_t.break_on (method)
    break_on(self) -> bool
    Should we break on the exception?

ida_idd.exception_info_t.code (variable)
    exception code

ida_idd.exception_info_t.desc (variable)
    Long message used to display info about the exception.

ida_idd.exception_info_t.flags (variable)
    Exception info flags

ida_idd.exception_info_t.handle (method)
    handle(self) -> bool
    Should we handle the exception?

ida_idd.exception_info_t.name (variable)
    Exception standard name.

ida_idd.excinfo_t (class)
    Proxy of C++ excinfo_t class.

ida_idd.excinfo_t.__init__ (method)
    __init__(self) -> excinfo_t

ida_idd.excinfo_t.can_cont (variable)
    Execution of the process can continue after this exception?

ida_idd.excinfo_t.code (variable)
    Exception code.

ida_idd.excinfo_t.ea (variable)
    Possible address referenced by the exception.

ida_idd.excinfo_t.info (variable)
    Exception message.

ida_idd.excvec_t (class)
    Proxy of C++ qvector< exception_info_t > class.

ida_idd.excvec_t.__getitem__ (method)
    __getitem__(self, i) -> exception_info_t
    
    @param i: size_t

ida_idd.excvec_t.__init__ (method)
    __init__(self) -> excvec_t
    __init__(self, x) -> excvec_t
    
    @param x: qvector< exception_info_t > const &

ida_idd.excvec_t.__len__ (method)
    __len__(self) -> size_t

ida_idd.excvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: exception_info_t const &

ida_idd.excvec_t.at (method)
    at(self, _idx) -> exception_info_t
    
    @param _idx: size_t

ida_idd.excvec_t.begin (method)
    begin(self) -> exception_info_t

ida_idd.excvec_t.capacity (method)
    capacity(self) -> size_t

ida_idd.excvec_t.clear (method)
    clear(self)

ida_idd.excvec_t.empty (method)
    empty(self) -> bool

ida_idd.excvec_t.end (method)
    end(self) -> exception_info_t

ida_idd.excvec_t.erase (method)
    erase(self, it) -> exception_info_t
    
    @param it: qvector< exception_info_t >::iterator
    
    erase(self, first, last) -> exception_info_t
    
    @param first: qvector< exception_info_t >::iterator
    @param last: qvector< exception_info_t >::iterator

ida_idd.excvec_t.extract (method)
    extract(self) -> exception_info_t

ida_idd.excvec_t.grow (method)
    grow(self, x=exception_info_t())
    
    @param x: exception_info_t const &

ida_idd.excvec_t.inject (method)
    inject(self, s, len)
    
    @param s: exception_info_t *
    @param len: size_t

ida_idd.excvec_t.insert (method)
    insert(self, it, x) -> exception_info_t
    
    @param it: qvector< exception_info_t >::iterator
    @param x: exception_info_t const &

ida_idd.excvec_t.pop_back (method)
    pop_back(self)

ida_idd.excvec_t.push_back (method)
    push_back(self, x)
    
    @param x: exception_info_t const &
    
    push_back(self) -> exception_info_t

ida_idd.excvec_t.qclear (method)
    qclear(self)

ida_idd.excvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idd.excvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: exception_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idd.excvec_t.size (method)
    size(self) -> size_t

ida_idd.excvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< exception_info_t > &

ida_idd.excvec_t.truncate (method)
    truncate(self)

ida_idd.get_dbg (function)
    get_dbg() -> debugger_t

ida_idd.get_event_bpt_hea (function)
    get_event_bpt_hea(ev) -> ea_t
    
    @param ev: debug_event_t const *

ida_idd.get_event_exc_code (function)
    get_event_exc_code(ev) -> uint
    
    @param ev: debug_event_t const *

ida_idd.get_event_exc_ea (function)
    get_event_exc_ea(ev) -> ea_t
    
    @param ev: debug_event_t const *

ida_idd.get_event_exc_info (function)
    get_event_exc_info(ev) -> str
    
    @param ev: debug_event_t const *

ida_idd.get_event_info (function)
    get_event_info(ev) -> str
    
    @param ev: debug_event_t const *

ida_idd.get_event_module_base (function)
    get_event_module_base(ev) -> ea_t
    
    @param ev: debug_event_t const *

ida_idd.get_event_module_name (function)
    get_event_module_name(ev) -> str
    
    @param ev: debug_event_t const *

ida_idd.get_event_module_size (function)
    get_event_module_size(ev) -> asize_t
    
    @param ev: debug_event_t const *

ida_idd.launch_env_t (class)
    Proxy of C++ launch_env_t class.

ida_idd.launch_env_t.__init__ (method)
    __init__(self) -> launch_env_t

ida_idd.meminfo_vec_t (class)
    Proxy of C++ meminfo_vec_t class.

ida_idd.meminfo_vec_t.__init__ (method)
    __init__(self) -> meminfo_vec_t

ida_idd.meminfo_vec_template_t (class)
    Proxy of C++ qvector< memory_info_t > class.

ida_idd.meminfo_vec_template_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< memory_info_t > const &

ida_idd.meminfo_vec_template_t.__getitem__ (method)
    __getitem__(self, i) -> memory_info_t
    
    @param i: size_t

ida_idd.meminfo_vec_template_t.__init__ (method)
    __init__(self) -> meminfo_vec_template_t
    __init__(self, x) -> meminfo_vec_template_t
    
    @param x: qvector< memory_info_t > const &

ida_idd.meminfo_vec_template_t.__len__ (method)
    __len__(self) -> size_t

ida_idd.meminfo_vec_template_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< memory_info_t > const &

ida_idd.meminfo_vec_template_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: memory_info_t const &

ida_idd.meminfo_vec_template_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: memory_info_t const &

ida_idd.meminfo_vec_template_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: memory_info_t const &

ida_idd.meminfo_vec_template_t.at (method)
    at(self, _idx) -> memory_info_t
    
    @param _idx: size_t

ida_idd.meminfo_vec_template_t.begin (method)
    begin(self) -> memory_info_t

ida_idd.meminfo_vec_template_t.capacity (method)
    capacity(self) -> size_t

ida_idd.meminfo_vec_template_t.clear (method)
    clear(self)

ida_idd.meminfo_vec_template_t.empty (method)
    empty(self) -> bool

ida_idd.meminfo_vec_template_t.end (method)
    end(self) -> memory_info_t

ida_idd.meminfo_vec_template_t.erase (method)
    erase(self, it) -> memory_info_t
    
    @param it: qvector< memory_info_t >::iterator
    
    erase(self, first, last) -> memory_info_t
    
    @param first: qvector< memory_info_t >::iterator
    @param last: qvector< memory_info_t >::iterator

ida_idd.meminfo_vec_template_t.extract (method)
    extract(self) -> memory_info_t

ida_idd.meminfo_vec_template_t.find (method)
    find(self, x) -> memory_info_t
    
    @param x: memory_info_t const &

ida_idd.meminfo_vec_template_t.grow (method)
    grow(self, x=memory_info_t())
    
    @param x: memory_info_t const &

ida_idd.meminfo_vec_template_t.has (method)
    has(self, x) -> bool
    
    @param x: memory_info_t const &

ida_idd.meminfo_vec_template_t.inject (method)
    inject(self, s, len)
    
    @param s: memory_info_t *
    @param len: size_t

ida_idd.meminfo_vec_template_t.insert (method)
    insert(self, it, x) -> memory_info_t
    
    @param it: qvector< memory_info_t >::iterator
    @param x: memory_info_t const &

ida_idd.meminfo_vec_template_t.pop_back (method)
    pop_back(self)

ida_idd.meminfo_vec_template_t.push_back (method)
    push_back(self, x)
    
    @param x: memory_info_t const &
    
    push_back(self) -> memory_info_t

ida_idd.meminfo_vec_template_t.qclear (method)
    qclear(self)

ida_idd.meminfo_vec_template_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idd.meminfo_vec_template_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: memory_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idd.meminfo_vec_template_t.size (method)
    size(self) -> size_t

ida_idd.meminfo_vec_template_t.swap (method)
    swap(self, r)
    
    @param r: qvector< memory_info_t > &

ida_idd.meminfo_vec_template_t.truncate (method)
    truncate(self)

ida_idd.memory_info_t (class)
    Proxy of C++ memory_info_t class.

ida_idd.memory_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: memory_info_t const &

ida_idd.memory_info_t.__init__ (method)
    __init__(self) -> memory_info_t

ida_idd.memory_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: memory_info_t const &

ida_idd.memory_info_t.bitness (variable)
    Number of bits in segment addresses (0-16bit, 1-32bit, 2-64bit)

ida_idd.memory_info_t.name (variable)
    Memory range name.

ida_idd.memory_info_t.perm (variable)
    Memory range permissions (0-no information): see segment.hpp.

ida_idd.memory_info_t.sbase (variable)
    Segment base (meaningful only for segmented architectures, e.g. 16-bit x86) The
    base is specified in paragraphs (i.e. shifted to the right by 4)

ida_idd.memory_info_t.sclass (variable)
    Memory range class name.

ida_idd.modinfo_t (class)
    Proxy of C++ modinfo_t class.

ida_idd.modinfo_t.__init__ (method)
    __init__(self) -> modinfo_t

ida_idd.modinfo_t.base (variable)
    module base address. if unknown pass BADADDR

ida_idd.modinfo_t.name (variable)
    full name of the module

ida_idd.modinfo_t.rebase_to (variable)
    if not BADADDR, then rebase the program to the specified address

ida_idd.modinfo_t.size (variable)
    module size. if unknown pass 0

ida_idd.process_info_t (class)
    Proxy of C++ process_info_t class.

ida_idd.process_info_t.__init__ (method)
    __init__(self) -> process_info_t

ida_idd.process_info_t.name (variable)
    process name

ida_idd.process_info_t.pid (variable)
    process id

ida_idd.procinfo_vec_t (class)
    Proxy of C++ qvector< process_info_t > class.

ida_idd.procinfo_vec_t.__getitem__ (method)
    __getitem__(self, i) -> process_info_t
    
    @param i: size_t

ida_idd.procinfo_vec_t.__init__ (method)
    __init__(self) -> procinfo_vec_t
    __init__(self, x) -> procinfo_vec_t
    
    @param x: qvector< process_info_t > const &

ida_idd.procinfo_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_idd.procinfo_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: process_info_t const &

ida_idd.procinfo_vec_t.at (method)
    at(self, _idx) -> process_info_t
    
    @param _idx: size_t

ida_idd.procinfo_vec_t.begin (method)
    begin(self) -> process_info_t

ida_idd.procinfo_vec_t.capacity (method)
    capacity(self) -> size_t

ida_idd.procinfo_vec_t.clear (method)
    clear(self)

ida_idd.procinfo_vec_t.empty (method)
    empty(self) -> bool

ida_idd.procinfo_vec_t.end (method)
    end(self) -> process_info_t

ida_idd.procinfo_vec_t.erase (method)
    erase(self, it) -> process_info_t
    
    @param it: qvector< process_info_t >::iterator
    
    erase(self, first, last) -> process_info_t
    
    @param first: qvector< process_info_t >::iterator
    @param last: qvector< process_info_t >::iterator

ida_idd.procinfo_vec_t.extract (method)
    extract(self) -> process_info_t

ida_idd.procinfo_vec_t.grow (method)
    grow(self, x=process_info_t())
    
    @param x: process_info_t const &

ida_idd.procinfo_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: process_info_t *
    @param len: size_t

ida_idd.procinfo_vec_t.insert (method)
    insert(self, it, x) -> process_info_t
    
    @param it: qvector< process_info_t >::iterator
    @param x: process_info_t const &

ida_idd.procinfo_vec_t.pop_back (method)
    pop_back(self)

ida_idd.procinfo_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: process_info_t const &
    
    push_back(self) -> process_info_t

ida_idd.procinfo_vec_t.qclear (method)
    qclear(self)

ida_idd.procinfo_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idd.procinfo_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: process_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idd.procinfo_vec_t.size (method)
    size(self) -> size_t

ida_idd.procinfo_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< process_info_t > &

ida_idd.procinfo_vec_t.truncate (method)
    truncate(self)

ida_idd.register_info_t (class)
    Proxy of C++ register_info_t class.

ida_idd.register_info_t.__get_bit_strings (method)
    __get_bit_strings(self) -> PyObject *

ida_idd.register_info_t.__init__ (method)
    __init__(self) -> register_info_t

ida_idd.register_info_t.bit_strings (variable)
    strings corresponding to each bit of the register. (nullptr = no bit, same name
    = multi-bits mask)

ida_idd.register_info_t.default_bit_strings_mask (variable)
    mask of default bits

ida_idd.register_info_t.dtype (variable)
    Register size (see Operand value types)

ida_idd.register_info_t.flags (variable)
    Register info attribute flags

ida_idd.register_info_t.name (variable)
    Register name.

ida_idd.register_info_t.register_class (variable)
    segment, mmx, etc.

ida_idd.regval_t (class)
    Proxy of C++ regval_t class.

ida_idd.regval_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: regval_t const &

ida_idd.regval_t.__init__ (method)
    __init__(self) -> regval_t
    __init__(self, r) -> regval_t
    
    @param r: regval_t const &

ida_idd.regval_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: regval_t const &

ida_idd.regval_t.bytes (method)
    bytes(self) -> bytevec_t
    Get const custom value.
    bytes(self) -> bytevec_t const &

ida_idd.regval_t.clear (method)
    clear(self)
    Clear register value.

ida_idd.regval_t.fval (variable)
    12: floating point value in the internal representation (see ieee.h)

ida_idd.regval_t.get_data (method)
    get_data(self)
    Get const pointer to value.
    get_data(self) -> void const *

ida_idd.regval_t.get_data_size (method)
    get_data_size(self) -> size_t
    Get size of value.

ida_idd.regval_t.ival (variable)
    8: integer value

ida_idd.regval_t.pyval (method)
    pyval(self, dtype) -> PyObject *
    
    @param dtype: op_dtype_t

ida_idd.regval_t.rvtype (variable)
    one of Register value types

ida_idd.regval_t.set_bytes (method)
    set_bytes(self, data, size)
    Initialize this regval to an empty custom value.
    
    @param data: uchar const *
    @param size: size_t
    
    set_bytes(self, v)
    
    @param v: bytevec_t const &
    
    set_bytes(self) -> bytevec_t &

ida_idd.regval_t.set_float (method)
    set_float(self, x)
    Set float value (fval)
    
    @param x: (C++: const fpvalue_t &) fpvalue_t const &

ida_idd.regval_t.set_int (method)
    set_int(self, x)
    
    @param x: uint64

ida_idd.regval_t.set_pyval (method)
    set_pyval(self, o, dtype) -> bool
    
    @param o: PyObject *
    @param dtype: op_dtype_t

ida_idd.regval_t.set_unavailable (method)
    set_unavailable(self)
    Mark as unavailable.

ida_idd.regval_t.swap (method)
    swap(self, r)
    Set this = r and r = this.
    
    @param r: (C++: regval_t &)

ida_idd.regvals_t (class)
    Proxy of C++ qvector< regval_t > class.

ida_idd.regvals_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< regval_t > const &

ida_idd.regvals_t.__getitem__ (method)
    __getitem__(self, i) -> regval_t
    
    @param i: size_t

ida_idd.regvals_t.__init__ (method)
    __init__(self) -> regvals_t
    __init__(self, x) -> regvals_t
    
    @param x: qvector< regval_t > const &

ida_idd.regvals_t.__len__ (method)
    __len__(self) -> size_t

ida_idd.regvals_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< regval_t > const &

ida_idd.regvals_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: regval_t const &

ida_idd.regvals_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: regval_t const &

ida_idd.regvals_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: regval_t const &

ida_idd.regvals_t.at (method)
    at(self, _idx) -> regval_t
    
    @param _idx: size_t

ida_idd.regvals_t.begin (method)
    begin(self) -> regval_t

ida_idd.regvals_t.capacity (method)
    capacity(self) -> size_t

ida_idd.regvals_t.clear (method)
    clear(self)

ida_idd.regvals_t.empty (method)
    empty(self) -> bool

ida_idd.regvals_t.end (method)
    end(self) -> regval_t

ida_idd.regvals_t.erase (method)
    erase(self, it) -> regval_t
    
    @param it: qvector< regval_t >::iterator
    
    erase(self, first, last) -> regval_t
    
    @param first: qvector< regval_t >::iterator
    @param last: qvector< regval_t >::iterator

ida_idd.regvals_t.extract (method)
    extract(self) -> regval_t

ida_idd.regvals_t.find (method)
    find(self, x) -> regval_t
    
    @param x: regval_t const &

ida_idd.regvals_t.grow (method)
    grow(self, x=regval_t())
    
    @param x: regval_t const &

ida_idd.regvals_t.has (method)
    has(self, x) -> bool
    
    @param x: regval_t const &

ida_idd.regvals_t.inject (method)
    inject(self, s, len)
    
    @param s: regval_t *
    @param len: size_t

ida_idd.regvals_t.insert (method)
    insert(self, it, x) -> regval_t
    
    @param it: qvector< regval_t >::iterator
    @param x: regval_t const &

ida_idd.regvals_t.pop_back (method)
    pop_back(self)

ida_idd.regvals_t.push_back (method)
    push_back(self, x)
    
    @param x: regval_t const &
    
    push_back(self) -> regval_t

ida_idd.regvals_t.qclear (method)
    qclear(self)

ida_idd.regvals_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idd.regvals_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: regval_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idd.regvals_t.size (method)
    size(self) -> size_t

ida_idd.regvals_t.swap (method)
    swap(self, r)
    
    @param r: qvector< regval_t > &

ida_idd.regvals_t.truncate (method)
    truncate(self)

ida_idd.scattered_segm_t (class)
    Proxy of C++ scattered_segm_t class.

ida_idd.scattered_segm_t.__init__ (method)
    __init__(self) -> scattered_segm_t

ida_idd.scattered_segm_t.name (variable)
    name of the segment

ida_idd.set_debug_event_code (function)
    set_debug_event_code(ev, id)
    
    @param ev: debug_event_t *
    @param id: enum event_id_t

ida_idd.thread_name_t (class)
    Proxy of C++ thread_name_t class.

ida_idd.thread_name_t.__init__ (method)
    __init__(self) -> thread_name_t

ida_idd.thread_name_t.name (variable)
    new thread name

ida_idd.thread_name_t.tid (variable)
    thread

ida_idp (module)
    Contains definition of the interface to IDP modules.
    
    The interface consists of two structures:
    * definition of target assembler: ::ash
    * definition of current processor: ::ph
    
    These structures contain information about target processor and assembler
    features.
    
    It also defines two groups of kernel events:
    * processor_t::event_t processor related events
    * idb_event:event_code_t database related events
    
    The processor related events are used to communicate with the processor module.
    The database related events are used to inform any interested parties, like
    plugins or processor modules, about the changes in the database.

ida_idp.AS2_BRACE (variable)
    Use braces for all expressions.

ida_idp.AS2_BYTE1CHAR (variable)
    One symbol per processor byte. Meaningful only for wide byte processors

ida_idp.AS2_COLONSUF (variable)
    addresses may have ":xx" suffix; this suffix must be ignored when extracting the
    address under the cursor

ida_idp.AS2_IDEALDSCR (variable)
    Description of struc/union is in the 'reverse' form (keyword before name), the
    same as in borland tasm ideal

ida_idp.AS2_STRINV (variable)
    Invert meaning of idainfo::wide_high_byte_first for text strings (for processors
    with bytes bigger than 8 bits)

ida_idp.AS2_TERSESTR (variable)
    'terse' structure initialization form; NAME<fld,fld,...> is supported

ida_idp.AS2_YWORD (variable)
    a_yword field is present and valid

ida_idp.AS2_ZWORD (variable)
    a_zword field is present and valid

ida_idp.ASB_BINF0 (variable)
    010101b

ida_idp.ASB_BINF1 (variable)
    ^B010101

ida_idp.ASB_BINF2 (variable)
    %010101

ida_idp.ASB_BINF3 (variable)
    0b1010101

ida_idp.ASB_BINF4 (variable)
    b'1010101

ida_idp.ASB_BINF5 (variable)
    b'1010101'

ida_idp.ASD_DECF0 (variable)
    34

ida_idp.ASD_DECF1 (variable)
    #34

ida_idp.ASD_DECF2 (variable)
    34.

ida_idp.ASD_DECF3 (variable)
    .34

ida_idp.ASH_HEXF0 (variable)
    34h

ida_idp.ASH_HEXF1 (variable)
    h'34

ida_idp.ASH_HEXF2 (variable)
    34

ida_idp.ASH_HEXF3 (variable)
    0x34

ida_idp.ASH_HEXF4 (variable)
    $34

ida_idp.ASH_HEXF5 (variable)
    <^R > (radix)

ida_idp.ASO_OCTF0 (variable)
    123o

ida_idp.ASO_OCTF1 (variable)
    0123

ida_idp.ASO_OCTF2 (variable)
    123

ida_idp.ASO_OCTF3 (variable)
    @123

ida_idp.ASO_OCTF4 (variable)
    o'123

ida_idp.ASO_OCTF5 (variable)
    123q

ida_idp.ASO_OCTF6 (variable)
    ~123

ida_idp.ASO_OCTF7 (variable)
    q'123

ida_idp.AS_1TEXT (variable)
    1 text per line, no bytes

ida_idp.AS_2CHRE (variable)
    double char constants are: "xy

ida_idp.AS_ALIGN2 (variable)
    .align directive expects an exponent rather than a power of 2 (.align 5 means to
    align at 32byte boundary)

ida_idp.AS_ASCIIC (variable)
    ascii directive accepts C-like escape sequences (\n,\x01 and similar)

ida_idp.AS_ASCIIZ (variable)
    ascii directive inserts implicit zero byte at the end

ida_idp.AS_BINFM (variable)
    mask - binary number format

ida_idp.AS_COLON (variable)
    create colons after data names ?

ida_idp.AS_DECFM (variable)
    mask - decimal number format

ida_idp.AS_HEXFM (variable)
    mask - hex number format

ida_idp.AS_LALIGN (variable)
    Labels at "align" keyword are supported.

ida_idp.AS_N2CHR (variable)
    can't have 2 byte char consts

ida_idp.AS_NCHRE (variable)
    char constants are: 'x

ida_idp.AS_NCMAS (variable)
    no commas in ascii directives

ida_idp.AS_NHIAS (variable)
    no characters with high bit

ida_idp.AS_NOCODECLN (variable)
    don't create colons after code names

ida_idp.AS_NOSPACE (variable)
    No spaces in expressions.

ida_idp.AS_NOXRF (variable)
    Disable xrefs during the output file generation.

ida_idp.AS_OCTFM (variable)
    mask - octal number format

ida_idp.AS_OFFST (variable)
    offsets are 'offset xxx' ?

ida_idp.AS_ONEDUP (variable)
    One array definition per line.

ida_idp.AS_RELSUP (variable)
    Checkarg: 'and','or','xor' operations with addresses are possible.

ida_idp.AS_UDATA (variable)
    can use '?' in data directives

ida_idp.AS_UNEQU (variable)
    replace undefined data items with EQU (for ANTA's A80)

ida_idp.AS_XTRNTYPE (variable)
    Assembler understands type of extern symbols as ":type" suffix.

ida_idp.AssembleLine (function)
    AssembleLine(ea, cs, ip, use32, nonnul_line) -> bytes
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment
    @param nonnul_line: char const *
    @return:     - None on failure
        - or a string containing the assembled instruction

ida_idp.CF_CALL (variable)
    CALL instruction (should make a procedure here)

ida_idp.CF_CHG1 (variable)
    The instruction modifies the first operand.

ida_idp.CF_CHG2 (variable)
    The instruction modifies the second operand.

ida_idp.CF_CHG3 (variable)
    The instruction modifies the third operand.

ida_idp.CF_CHG4 (variable)
    The instruction modifies the fourth operand.

ida_idp.CF_CHG5 (variable)
    The instruction modifies the fifth operand.

ida_idp.CF_CHG6 (variable)
    The instruction modifies the sixth operand.

ida_idp.CF_CHG7 (variable)
    The instruction modifies the seventh operand.

ida_idp.CF_CHG8 (variable)
    The instruction modifies the eighth operand.

ida_idp.CF_HLL (variable)
    Instruction may be present in a high level language function

ida_idp.CF_JUMP (variable)
    The instruction passes execution using indirect jump or call (thus needs
    additional analysis)

ida_idp.CF_SHFT (variable)
    Bit-shift instruction (shl,shr...)

ida_idp.CF_STOP (variable)
    Instruction doesn't pass execution to the next instruction

ida_idp.CF_USE1 (variable)
    The instruction uses value of the first operand.

ida_idp.CF_USE2 (variable)
    The instruction uses value of the second operand.

ida_idp.CF_USE3 (variable)
    The instruction uses value of the third operand.

ida_idp.CF_USE4 (variable)
    The instruction uses value of the fourth operand.

ida_idp.CF_USE5 (variable)
    The instruction uses value of the fifth operand.

ida_idp.CF_USE6 (variable)
    The instruction uses value of the sixth operand.

ida_idp.CF_USE7 (variable)
    The instruction uses value of the seventh operand.

ida_idp.CF_USE8 (variable)
    The instruction uses value of the eighth operand.

ida_idp.CUSTOM_INSN_ITYPE (variable)
    Custom instruction codes defined by processor extension plugins must be greater
    than or equal to this

ida_idp.HKCB_GLOBAL (variable)
    is global event listener? if true, the listener will survive database closing
    and opening. it will stay in the memory until explicitly unhooked. otherwise the
    kernel will delete it as soon as the owner is unloaded. should be used only with
    PLUGIN_FIX plugins.

ida_idp.IDB_Hooks (class)
    Proxy of C++ IDB_Hooks class.

ida_idp.IDB_Hooks.__disown__ (method)

ida_idp.IDB_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDB_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_idp.IDB_Hooks.adding_segm (method)
    adding_segm(self, s)
    A segment is being created.
    
    @param s: (segment_t *)

ida_idp.IDB_Hooks.allsegs_moved (method)
    allsegs_moved(self, info)
    Program rebasing is complete. This event is generated after series of segm_moved
    events
    
    @param info: (segm_move_infos_t *)

ida_idp.IDB_Hooks.auto_empty (method)
    auto_empty(self)

ida_idp.IDB_Hooks.auto_empty_finally (method)
    auto_empty_finally(self)

ida_idp.IDB_Hooks.bookmark_changed (method)
    bookmark_changed(self, index, pos, desc, operation)
    Boomarked position changed.
    
    @param index: (uint32)
    @param pos: (::const lochist_entry_t *)
    @param desc: (::const char *)
    @param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the
                      bookmark was deleted.

ida_idp.IDB_Hooks.byte_patched (method)
    byte_patched(self, ea, old_value)
    A byte has been patched.
    
    @param ea: (::ea_t)
    @param old_value: (uint32)

ida_idp.IDB_Hooks.callee_addr_changed (method)
    callee_addr_changed(self, ea, callee)
    Callee address has been updated by the user.
    
    @param ea: (::ea_t)
    @param callee: (::ea_t)

ida_idp.IDB_Hooks.changing_cmt (method)
    changing_cmt(self, ea, repeatable_cmt, newcmt)
    An item comment is to be changed.
    
    @param ea: (::ea_t)
    @param repeatable_cmt: (bool)
    @param newcmt: (const char *)

ida_idp.IDB_Hooks.changing_enum_bf (method)
    changing_enum_bf(self, id, new_bf)
    An enum type 'bitfield' attribute is to be changed.
    
    @param id: (enum_t)
    @param new_bf: (bool)

ida_idp.IDB_Hooks.changing_enum_cmt (method)
    changing_enum_cmt(self, id, repeatable, newcmt)
    An enum or member type comment is to be changed.
    
    @param id: (tid_t)
    @param repeatable: (bool)
    @param newcmt: (const char *)

ida_idp.IDB_Hooks.changing_op_ti (method)
    changing_op_ti(self, ea, n, new_type, new_fnames)
    An operand typestring (c/c++ prototype) is to be changed.
    
    @param ea: (::ea_t)
    @param n: (int)
    @param new_type: (const type_t *)
    @param new_fnames: (const p_list *)

ida_idp.IDB_Hooks.changing_op_type (method)
    changing_op_type(self, ea, n, opinfo)
    An operand type (offset, hex, etc...) is to be changed.
    
    @param ea: (::ea_t)
    @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
    @param opinfo: (const opinfo_t *) additional operand info

ida_idp.IDB_Hooks.changing_range_cmt (method)
    changing_range_cmt(self, kind, a, cmt, repeatable)
    Range comment is to be changed.
    
    @param kind: (range_kind_t)
    @param a: (const range_t *)
    @param cmt: (const char *)
    @param repeatable: (bool)

ida_idp.IDB_Hooks.changing_segm_class (method)
    changing_segm_class(self, s)
    Segment class is being changed.
    
    @param s: (segment_t *)

ida_idp.IDB_Hooks.changing_segm_end (method)
    changing_segm_end(self, s, new_end, segmod_flags)
    Segment end address is to be changed.
    
    @param s: (segment_t *)
    @param new_end: (::ea_t)
    @param segmod_flags: (int)

ida_idp.IDB_Hooks.changing_segm_name (method)
    changing_segm_name(self, s, oldname)
    Segment name is being changed.
    
    @param s: (segment_t *)
    @param oldname: (const char *)

ida_idp.IDB_Hooks.changing_segm_start (method)
    changing_segm_start(self, s, new_start, segmod_flags)
    Segment start address is to be changed.
    
    @param s: (segment_t *)
    @param new_start: (::ea_t)
    @param segmod_flags: (int)

ida_idp.IDB_Hooks.changing_struc_align (method)
    changing_struc_align(self, sptr)
    A structure type is being changed (the struct alignment).
    
    @param sptr: (struc_t *)

ida_idp.IDB_Hooks.changing_struc_cmt (method)
    changing_struc_cmt(self, struc_id, repeatable, newcmt)
    A structure type comment is to be changed.
    
    @param struc_id: (tid_t)
    @param repeatable: (bool)
    @param newcmt: (const char *)

ida_idp.IDB_Hooks.changing_struc_member (method)
    changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
    A structure member is to be changed.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)
    @param flag: (flags64_t)
    @param ti: (const opinfo_t *)
    @param nbytes: (::asize_t)

ida_idp.IDB_Hooks.changing_ti (method)
    changing_ti(self, ea, new_type, new_fnames)
    An item typestring (c/c++ prototype) is to be changed.
    
    @param ea: (::ea_t)
    @param new_type: (const type_t *)
    @param new_fnames: (const p_list *)

ida_idp.IDB_Hooks.closebase (method)
    closebase(self)
    The database will be closed now.

ida_idp.IDB_Hooks.cmt_changed (method)
    cmt_changed(self, ea, repeatable_cmt)
    An item comment has been changed.
    
    @param ea: (::ea_t)
    @param repeatable_cmt: (bool)

ida_idp.IDB_Hooks.compiler_changed (method)
    compiler_changed(self, adjust_inf_fields)
    The kernel has changed the compiler information. ( idainfo::cc structure;
    get_abi_name)
    
    @param adjust_inf_fields: (::bool) may change inf fields?

ida_idp.IDB_Hooks.deleting_enum (method)
    deleting_enum(self, id)
    An enum type is to be deleted.
    
    @param id: (enum_t)

ida_idp.IDB_Hooks.deleting_enum_member (method)
    deleting_enum_member(self, id, cid)
    An enum member is to be deleted.
    
    @param id: (enum_t)
    @param cid: (const_t)

ida_idp.IDB_Hooks.deleting_func (method)
    deleting_func(self, pfn)
    The kernel is about to delete a function.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.deleting_func_tail (method)
    deleting_func_tail(self, pfn, tail)
    A function tail chunk is to be removed.
    
    @param pfn: (func_t *)
    @param tail: (const range_t *)

ida_idp.IDB_Hooks.deleting_segm (method)
    deleting_segm(self, start_ea)
    A segment is to be deleted.
    
    @param start_ea: (::ea_t)

ida_idp.IDB_Hooks.deleting_struc (method)
    deleting_struc(self, sptr)
    A structure type is to be deleted.
    
    @param sptr: (struc_t *)

ida_idp.IDB_Hooks.deleting_struc_member (method)
    deleting_struc_member(self, sptr, mptr)
    A structure member is to be deleted.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)

ida_idp.IDB_Hooks.deleting_tryblks (method)
    deleting_tryblks(self, range)
    About to delete tryblk information in given range
    
    @param range: (const range_t *)

ida_idp.IDB_Hooks.destroyed_items (method)
    destroyed_items(self, ea1, ea2, will_disable_range)
    Instructions/data have been destroyed in [ea1,ea2).
    
    @param ea1: (::ea_t)
    @param ea2: (::ea_t)
    @param will_disable_range: (bool)

ida_idp.IDB_Hooks.determined_main (method)
    determined_main(self, main)
    The main() function has been determined.
    
    @param main: (::ea_t) address of the main() function

ida_idp.IDB_Hooks.dirtree_link (method)
    dirtree_link(self, dt, path, link)
    
    @param dt: (dirtree_t *)
    @param path: (::const char *)
    @param link: (::bool)

ida_idp.IDB_Hooks.dirtree_mkdir (method)
    dirtree_mkdir(self, dt, path)
    
    @param dt: (dirtree_t *)
    @param path: (::const char *)

ida_idp.IDB_Hooks.dirtree_move (method)
    dirtree_move(self, dt, _from, to)
    
    @param dt: (dirtree_t *)
    @param from: (::const char *)
    @param to: (::const char *)

ida_idp.IDB_Hooks.dirtree_rank (method)
    dirtree_rank(self, dt, path, rank)
    
    @param dt: (dirtree_t *)
    @param path: (::const char *)
    @param rank: (::size_t)

ida_idp.IDB_Hooks.dirtree_rmdir (method)
    dirtree_rmdir(self, dt, path)
    
    @param dt: (dirtree_t *)
    @param path: (::const char *)

ida_idp.IDB_Hooks.dirtree_rminode (method)
    dirtree_rminode(self, dt, inode)
    
    @param dt: (dirtree_t *)
    @param inode: (inode_t)

ida_idp.IDB_Hooks.dirtree_segm_moved (method)
    dirtree_segm_moved(self, dt)
    
    @param dt: (dirtree_t *)

ida_idp.IDB_Hooks.enum_bf_changed (method)
    enum_bf_changed(self, id)
    An enum type 'bitfield' attribute has been changed.
    
    @param id: (enum_t)

ida_idp.IDB_Hooks.enum_cmt_changed (method)
    enum_cmt_changed(self, id, repeatable)
    An enum or member type comment has been changed.
    
    @param id: (tid_t)
    @param repeatable: (bool)

ida_idp.IDB_Hooks.enum_created (method)
    enum_created(self, id)
    An enum type has been created.
    
    @param id: (enum_t)

ida_idp.IDB_Hooks.enum_deleted (method)
    enum_deleted(self, id)
    An enum type has been deleted.
    
    @param id: (enum_t)

ida_idp.IDB_Hooks.enum_flag_changed (method)
    enum_flag_changed(self, id, F)
    Enum flags have been changed.
    
    @param id: (enum_t)
    @param F: (flags64_t)

ida_idp.IDB_Hooks.enum_member_created (method)
    enum_member_created(self, id, cid)
    An enum member has been created.
    
    @param id: (enum_t)
    @param cid: (const_t)

ida_idp.IDB_Hooks.enum_member_deleted (method)
    enum_member_deleted(self, id, cid)
    An enum member has been deleted.
    
    @param id: (enum_t)
    @param cid: (const_t)

ida_idp.IDB_Hooks.enum_ordinal_changed (method)
    enum_ordinal_changed(self, id, ord)
    Enum mapping to a local type has been changed.
    
    @param id: (enum_t)
    @param ord: (int)

ida_idp.IDB_Hooks.enum_renamed (method)
    enum_renamed(self, id)
    An enum or member has been renamed.
    
    @param id: (tid_t)

ida_idp.IDB_Hooks.enum_width_changed (method)
    enum_width_changed(self, id, width)
    Enum width has been changed.
    
    @param id: (enum_t)
    @param width: (int)

ida_idp.IDB_Hooks.expanding_struc (method)
    expanding_struc(self, sptr, offset, delta)
    A structure type is to be expanded/shrunk.
    
    @param sptr: (struc_t *)
    @param offset: (::ea_t)
    @param delta: (::adiff_t)

ida_idp.IDB_Hooks.extlang_changed (method)
    extlang_changed(self, kind, el, idx)
    The list of extlangs or the default extlang was changed.
    
    @param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang
                 changed
    @param el: (extlang_t *) pointer to the extlang affected
    @param idx: (int) extlang index

ida_idp.IDB_Hooks.extra_cmt_changed (method)
    extra_cmt_changed(self, ea, line_idx, cmt)
    An extra comment has been changed.
    
    @param ea: (::ea_t)
    @param line_idx: (int)
    @param cmt: (const char *)

ida_idp.IDB_Hooks.flow_chart_created (method)
    flow_chart_created(self, fc)
    Gui has retrieved a function flow chart. Plugins may modify the flow chart in
    this callback.
    
    @param fc: (qflow_chart_t *)

ida_idp.IDB_Hooks.frame_deleted (method)
    frame_deleted(self, pfn)
    The kernel has deleted a function frame.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.func_added (method)
    func_added(self, pfn)
    The kernel has added a function.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.func_deleted (method)
    func_deleted(self, func_ea)
    A function has been deleted.
    
    @param func_ea: (::ea_t)

ida_idp.IDB_Hooks.func_noret_changed (method)
    func_noret_changed(self, pfn)
    FUNC_NORET bit has been changed.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.func_tail_appended (method)
    func_tail_appended(self, pfn, tail)
    A function tail chunk has been appended.
    
    @param pfn: (func_t *)
    @param tail: (func_t *)

ida_idp.IDB_Hooks.func_tail_deleted (method)
    func_tail_deleted(self, pfn, tail_ea)
    A function tail chunk has been removed.
    
    @param pfn: (func_t *)
    @param tail_ea: (::ea_t)

ida_idp.IDB_Hooks.func_updated (method)
    func_updated(self, pfn)
    The kernel has updated a function.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.hook (method)
    hook(self) -> bool

ida_idp.IDB_Hooks.idasgn_loaded (method)
    idasgn_loaded(self, short_sig_name)
    FLIRT signature has been loaded for normal processing (not for recognition of
    startup sequences).
    
    @param short_sig_name: (const char *)

ida_idp.IDB_Hooks.item_color_changed (method)
    item_color_changed(self, ea, color)
    An item color has been changed.
    
    @param ea: (::ea_t)
    @param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.

ida_idp.IDB_Hooks.kernel_config_loaded (method)
    kernel_config_loaded(self, pass_number)
    This event is issued when ida.cfg is parsed.
    
    @param pass_number: (int)

ida_idp.IDB_Hooks.loader_finished (method)
    loader_finished(self, li, neflags, filetypename)
    External file loader finished its work. Use this event to augment the existing
    loader functionality.
    
    @param li: (linput_t *)
    @param neflags: (uint16) Load file flags
    @param filetypename: (const char *)

ida_idp.IDB_Hooks.local_types_changed (method)
    local_types_changed(self, ltc, ordinal, name)
    Local types have been changed
    
    @param ltc: (::local_type_change_t)
    @param ordinal: (uint32) 0 means ordinal is unknown
    @param name: (const char *) nullptr means name is unknown

ida_idp.IDB_Hooks.make_code (method)
    make_code(self, insn)
    An instruction is being created.
    
    @param insn: (const insn_t*)

ida_idp.IDB_Hooks.make_data (method)
    make_data(self, ea, flags, tid, len)
    A data item is being created.
    
    @param ea: (::ea_t)
    @param flags: (flags64_t)
    @param tid: (tid_t)
    @param len: (::asize_t)

ida_idp.IDB_Hooks.op_ti_changed (method)
    op_ti_changed(self, ea, n, type, fnames)
    An operand typestring (c/c++ prototype) has been changed.
    
    @param ea: (::ea_t)
    @param n: (int)
    @param type: (const type_t *)
    @param fnames: (const p_list *)

ida_idp.IDB_Hooks.op_type_changed (method)
    op_type_changed(self, ea, n)
    An operand type (offset, hex, etc...) has been set or deleted.
    
    @param ea: (::ea_t)
    @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL

ida_idp.IDB_Hooks.range_cmt_changed (method)
    range_cmt_changed(self, kind, a, cmt, repeatable)
    Range comment has been changed.
    
    @param kind: (range_kind_t)
    @param a: (const range_t *)
    @param cmt: (const char *)
    @param repeatable: (bool)

ida_idp.IDB_Hooks.renamed (method)
    renamed(self, ea, new_name, local_name, old_name)
    The kernel has renamed a byte. See also the rename event
    
    @param ea: (::ea_t)
    @param new_name: (const char *) can be nullptr
    @param local_name: (bool)
    @param old_name: (const char *) can be nullptr

ida_idp.IDB_Hooks.renaming_enum (method)
    renaming_enum(self, id, is_enum, newname)
    An enum or enum member is to be renamed.
    
    @param id: (tid_t)
    @param is_enum: (bool)
    @param newname: (const char *)

ida_idp.IDB_Hooks.renaming_struc (method)
    renaming_struc(self, id, oldname, newname)
    A structure type is to be renamed.
    
    @param id: (tid_t)
    @param oldname: (const char *)
    @param newname: (const char *)

ida_idp.IDB_Hooks.renaming_struc_member (method)
    renaming_struc_member(self, sptr, mptr, newname)
    A structure member is to be renamed.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)
    @param newname: (const char *)

ida_idp.IDB_Hooks.savebase (method)
    savebase(self)
    The database is being saved.

ida_idp.IDB_Hooks.segm_added (method)
    segm_added(self, s)
    A new segment has been created.
    
    @param s: (segment_t *) See also adding_segm

ida_idp.IDB_Hooks.segm_attrs_updated (method)
    segm_attrs_updated(self, s)
    Segment attributes has been changed.
    
    @param s: (segment_t *) This event is generated for secondary segment attributes
              (examples: color, permissions, etc)

ida_idp.IDB_Hooks.segm_class_changed (method)
    segm_class_changed(self, s, sclass)
    Segment class has been changed.
    
    @param s: (segment_t *)
    @param sclass: (const char *)

ida_idp.IDB_Hooks.segm_deleted (method)
    segm_deleted(self, start_ea, end_ea, flags)
    A segment has been deleted.
    
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param flags: (int)

ida_idp.IDB_Hooks.segm_end_changed (method)
    segm_end_changed(self, s, oldend)
    Segment end address has been changed.
    
    @param s: (segment_t *)
    @param oldend: (::ea_t)

ida_idp.IDB_Hooks.segm_moved (method)
    segm_moved(self, _from, to, size, changed_netmap)
    Segment has been moved.
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @param size: (::asize_t)
    @param changed_netmap: (bool) See also idb_event::allsegs_moved

ida_idp.IDB_Hooks.segm_name_changed (method)
    segm_name_changed(self, s, name)
    Segment name has been changed.
    
    @param s: (segment_t *)
    @param name: (const char *)

ida_idp.IDB_Hooks.segm_start_changed (method)
    segm_start_changed(self, s, oldstart)
    Segment start address has been changed.
    
    @param s: (segment_t *)
    @param oldstart: (::ea_t)

ida_idp.IDB_Hooks.set_func_end (method)
    set_func_end(self, pfn, new_end)
    Function chunk end address will be changed.
    
    @param pfn: (func_t *)
    @param new_end: (::ea_t)

ida_idp.IDB_Hooks.set_func_start (method)
    set_func_start(self, pfn, new_start)
    Function chunk start address will be changed.
    
    @param pfn: (func_t *)
    @param new_start: (::ea_t)

ida_idp.IDB_Hooks.sgr_changed (method)
    sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
    The kernel has changed a segment register value.
    
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param regnum: (int)
    @param value: (::sel_t)
    @param old_value: (::sel_t)
    @param tag: (uchar) Segment register range tags

ida_idp.IDB_Hooks.sgr_deleted (method)
    sgr_deleted(self, start_ea, end_ea, regnum)
    The kernel has deleted a segment register value.
    
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param regnum: (int)

ida_idp.IDB_Hooks.stkpnts_changed (method)
    stkpnts_changed(self, pfn)
    Stack change points have been modified.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.struc_align_changed (method)
    struc_align_changed(self, sptr)
    A structure type has been changed (the struct alignment).
    
    @param sptr: (struc_t *)

ida_idp.IDB_Hooks.struc_cmt_changed (method)
    struc_cmt_changed(self, struc_id, repeatable_cmt)
    A structure type comment has been changed.
    
    @param struc_id: (tid_t)
    @param repeatable_cmt: (bool)

ida_idp.IDB_Hooks.struc_created (method)
    struc_created(self, struc_id)
    A new structure type has been created.
    
    @param struc_id: (tid_t)

ida_idp.IDB_Hooks.struc_deleted (method)
    struc_deleted(self, struc_id)
    A structure type has been deleted.
    
    @param struc_id: (tid_t)

ida_idp.IDB_Hooks.struc_expanded (method)
    struc_expanded(self, sptr)
    A structure type has been expanded/shrank.
    
    @param sptr: (struc_t *)

ida_idp.IDB_Hooks.struc_member_changed (method)
    struc_member_changed(self, sptr, mptr)
    A structure member has been changed.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)

ida_idp.IDB_Hooks.struc_member_created (method)
    struc_member_created(self, sptr, mptr)
    A structure member has been created.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)

ida_idp.IDB_Hooks.struc_member_deleted (method)
    struc_member_deleted(self, sptr, member_id, offset)
    A structure member has been deleted.
    
    @param sptr: (struc_t *)
    @param member_id: (tid_t)
    @param offset: (::ea_t)

ida_idp.IDB_Hooks.struc_member_renamed (method)
    struc_member_renamed(self, sptr, mptr)
    A structure member has been renamed.
    
    @param sptr: (struc_t *)
    @param mptr: (member_t *)

ida_idp.IDB_Hooks.struc_renamed (method)
    struc_renamed(self, sptr, success)
    A structure type has been renamed.
    
    @param sptr: (struc_t *)
    @param success: (::bool) the structure was successfully renamed

ida_idp.IDB_Hooks.tail_owner_changed (method)
    tail_owner_changed(self, tail, owner_func, old_owner)
    A tail chunk owner has been changed.
    
    @param tail: (func_t *)
    @param owner_func: (::ea_t)
    @param old_owner: (::ea_t)

ida_idp.IDB_Hooks.thunk_func_created (method)
    thunk_func_created(self, pfn)
    A thunk bit has been set for a function.
    
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.ti_changed (method)
    ti_changed(self, ea, type, fnames)
    An item typestring (c/c++ prototype) has been changed.
    
    @param ea: (::ea_t)
    @param type: (const type_t *)
    @param fnames: (const p_list *)

ida_idp.IDB_Hooks.tryblks_updated (method)
    tryblks_updated(self, tbv)
    Updated tryblk information
    
    @param tbv: (const ::tryblks_t *)

ida_idp.IDB_Hooks.unhook (method)
    unhook(self) -> bool

ida_idp.IDB_Hooks.updating_tryblks (method)
    updating_tryblks(self, tbv)
    About to update tryblk information
    
    @param tbv: (const ::tryblks_t *)

ida_idp.IDB_Hooks.upgraded (method)
    upgraded(self, _from)
    The database has been upgraded and the receiver can upgrade its info as well
    
    @param from: (int) - old IDB version

ida_idp.IDP_Hooks (class)
    Proxy of C++ IDP_Hooks class.

ida_idp.IDP_Hooks.__disown__ (method)

ida_idp.IDP_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDP_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_idp.IDP_Hooks.ev_add_cref (method)
    ev_add_cref(self, _from, to, type) -> int
    A code reference is being created.
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @param type: (cref_t)
    @retval <0: cancel cref creation
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_add_dref (method)
    ev_add_dref(self, _from, to, type) -> int
    A data reference is being created.
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @param type: (dref_t)
    @retval <0: cancel dref creation
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_adjust_argloc (method)
    ev_adjust_argloc(self, argloc, optional_type, size) -> int
    Adjust argloc according to its type/size and platform endianess
    
    @param argloc: (argloc_t *), inout
    @param type: (const tinfo_t *), may be nullptr nullptr means primitive type of
                 given size
    @param size: (int) 'size' makes no sense if type != nullptr (type->get_size()
                 should be used instead)
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error

ida_idp.IDP_Hooks.ev_adjust_libfunc_ea (method)
    ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
    Called when a signature module has been matched against bytes in the database.
    This is used to compute the offset at which a particular module's libfunc should
    be applied.
    
    @param sig: (const idasgn_t *)
    @param libfun: (const libfunc_t *)
    @param ea: (::ea_t *)
    @note: 'ea' initially contains the ea_t of the start of the pattern match
    @retval 1: the ea_t pointed to by the third argument was modified.
    @retval <=0: not modified. use default algorithm.

ida_idp.IDP_Hooks.ev_adjust_refinfo (method)
    ev_adjust_refinfo(self, ri, ea, n, fd) -> int
    Called from apply_fixup before converting operand to reference. Can be used for
    changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some
    references)
    
    @param ri: (refinfo_t *)
    @param ea: (::ea_t) instruction address
    @param n: (int) operand number
    @param fd: (const fixup_data_t *)
    @retval <0: do not create an offset
    @retval 0: not implemented or refinfo adjusted

ida_idp.IDP_Hooks.ev_ana_insn (method)
    ev_ana_insn(self, out) -> bool
    Analyze one instruction and fill 'out' structure. This function shouldn't change
    the database, flags or anything else. All these actions should be performed only
    by emu_insn() function. insn_t::ea contains address of instruction to analyze.
    
    @param out: (insn_t *)
    @return: length of the instruction in bytes, 0 if instruction can't be decoded.
    @retval 0: if instruction can't be decoded.

ida_idp.IDP_Hooks.ev_analyze_prolog (method)
    ev_analyze_prolog(self, ea) -> int
    Analyzes function prolog, epilog, and updates purge, and function attributes
    
    @param ea: (::ea_t) start of function
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_arch_changed (method)
    ev_arch_changed(self) -> int
    The loader is done parsing arch-related information, which the processor module
    might want to use to finish its initialization.
    @retval 1: if success
    @retval 0: not implemented or failed

ida_idp.IDP_Hooks.ev_arg_addrs_ready (method)
    ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
    Argument address info is ready.
    
    @param caller: (::ea_t)
    @param n: (int) number of formal arguments
    @param tif: (tinfo_t *) call prototype
    @param addrs: (::ea_t *) argument intilization addresses
    @retval <0: do not save into idb; other values mean "ok to save"

ida_idp.IDP_Hooks.ev_asm_installed (method)
    ev_asm_installed(self, asmnum) -> int
    After setting a new assembler
    
    @param asmnum: (int) See also ev_newasm

ida_idp.IDP_Hooks.ev_assemble (method)
    ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
    Assemble an instruction. (display a warning if an error is found).
    
    @param ea: (::ea_t) linear address of instruction
    @param cs: (::ea_t) cs of instruction
    @param ip: (::ea_t) ip of instruction
    @param use32: (bool) is 32bit segment?
    @param line: (const char *) line to assemble
    @return: size of the instruction in bytes

ida_idp.IDP_Hooks.ev_auto_queue_empty (method)
    ev_auto_queue_empty(self, type) -> int
    One analysis queue is empty.
    
    @param type: (atype_t)
    @retval void: see also idb_event::auto_empty_finally

ida_idp.IDP_Hooks.ev_calc_arglocs (method)
    ev_calc_arglocs(self, fti) -> int
    Calculate function argument locations. This callback should fill retloc, all
    arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions.
    
    @param fti: (func_type_data_t *) points to the func type info
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error

ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes (method)
    ev_calc_cdecl_purged_bytes(self, ea) -> int
    Calculate number of purged bytes after call.
    
    @param ea: (::ea_t) address of the call instruction
    @return: number of purged bytes (usually add sp, N)

ida_idp.IDP_Hooks.ev_calc_next_eas (method)
    ev_calc_next_eas(self, res, insn, over) -> int
    Calculate list of addresses the instruction in 'insn' may pass control to. This
    callback is required for source level debugging.
    
    @param res: (eavec_t *), out: array for the results.
    @param insn: (const insn_t*) the instruction
    @param over: (bool) calculate for step over (ignore call targets)
    @retval <0: incalculable (indirect jumps, for example)
    @retval >=0: number of addresses of called functions in the array. They must be
                 put at the beginning of the array (0 if over=true)

ida_idp.IDP_Hooks.ev_calc_purged_bytes (method)
    ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
    Calculate number of purged bytes by the given function type.
    
    @param p_purged_bytes: (int *) ptr to output
    @param fti: (const func_type_data_t *) func type details
    @retval 1
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_calc_retloc (method)
    ev_calc_retloc(self, retloc, rettype, cc) -> int
    Calculate return value location.
    
    @param retloc: (argloc_t *)
    @param rettype: (const tinfo_t *)
    @param cc: (cm_t)
    @retval 0: not implemented
    @retval 1: ok,
    @retval -1: error

ida_idp.IDP_Hooks.ev_calc_spdelta (method)
    ev_calc_spdelta(self, spdelta, insn) -> int
    Calculate amount of change to sp for the given insn. This event is required to
    decompile code snippets.
    
    @param spdelta: (sval_t *)
    @param insn: (const insn_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_calc_step_over (method)
    ev_calc_step_over(self, target, ip) -> int
    Calculate the address of the instruction which will be executed after "step
    over". The kernel will put a breakpoint there. If the step over is equal to step
    into or we cannot calculate the address, return BADADDR.
    
    @param target: (::ea_t *) pointer to the answer
    @param ip: (::ea_t) instruction address
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_calc_switch_cases (method)
    ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
    Calculate case values and targets for a custom jump table.
    
    @param casevec: (::casevec_t *) vector of case values (may be nullptr)
    @param targets: (eavec_t *) corresponding target addresses (my be nullptr)
    @param insn_ea: (::ea_t) address of the 'indirect jump' instruction
    @param si: (switch_info_t *) switch information
    @retval 1: ok
    @retval <=0: failed

ida_idp.IDP_Hooks.ev_calc_varglocs (method)
    ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
    Calculate locations of the arguments that correspond to '...'.
    
    @param ftd: (func_type_data_t *), inout: info about all arguments (including
                varargs)
    @param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be
                     nullptr
    @param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be
                        nullptr
    @param nfixed: (int) number of fixed arguments
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error On some platforms variadic calls require passing additional
                information: for example, number of floating variadic arguments must
                be passed in rax on gcc-x64. The locations and values that
                constitute this additional information are returned in the buffers
                pointed by aux_regs and aux_stkargs

ida_idp.IDP_Hooks.ev_calcrel (method)
    ev_calcrel(self) -> int
    Reserved.

ida_idp.IDP_Hooks.ev_can_have_type (method)
    ev_can_have_type(self, op) -> int
    Can the operand have a type as offset, segment, decimal, etc? (for example, a
    register AX can't have a type, meaning that the user can't change its
    representation. see bytes.hpp for information about types and flags)
    
    @param op: (const op_t *)
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_clean_tbit (method)
    ev_clean_tbit(self, ea, getreg, regvalues) -> int
    Clear the TF bit after an insn like pushf stored it in memory.
    
    @param ea: (::ea_t) instruction address
    @param getreg: (::processor_t::regval_getter_t *) function to get register
                   values
    @param regvalues: (const regval_t *) register values array
    @retval 1: ok
    @retval 0: failed

ida_idp.IDP_Hooks.ev_cmp_operands (method)
    ev_cmp_operands(self, op1, op2) -> int
    Compare instruction operands
    
    @param op1: (const op_t*)
    @param op2: (const op_t*)
    @retval 1: equal
    @retval -1: not equal
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_coagulate (method)
    ev_coagulate(self, start_ea) -> int
    Try to define some unexplored bytes. This notification will be called if the
    kernel tried all possibilities and could not find anything more useful than to
    convert to array of bytes. The module can help the kernel and convert the bytes
    into something more useful.
    
    @param start_ea: (::ea_t)
    @return: number of converted bytes

ida_idp.IDP_Hooks.ev_coagulate_dref (method)
    ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
    Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb
    mode refs, we clear the last bit)
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @param may_define: (bool)
    @param code_ea: (::ea_t *)
    @retval <0: failed dref analysis, >0 done dref analysis
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_create_flat_group (method)
    ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
    Create special segment representing the flat group.
    
    @param image_base: (::ea_t)
    @param bitness: (int)
    @param dataseg_sel: (::sel_t) return value is ignored

ida_idp.IDP_Hooks.ev_create_func_frame (method)
    ev_create_func_frame(self, pfn) -> int
    Create a function frame for a newly created function Set up frame size, its
    attributes etc
    
    @param pfn: (func_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_create_merge_handlers (method)
    ev_create_merge_handlers(self, md) -> int
    Create merge handlers, if needed
    
    @param md: (::merge_data_t *) This event is generated immediately after opening
               idbs.
    @return: must be 0

ida_idp.IDP_Hooks.ev_create_switch_xrefs (method)
    ev_create_switch_xrefs(self, jumpea, si) -> int
    Create xrefs for a custom jump table.
    
    @param jumpea: (::ea_t) address of the jump insn
    @param si: (const switch_info_t *) switch information
    @return: must return 1 Must be implemented if module uses custom jump tables,
             SWI_CUSTOM

ida_idp.IDP_Hooks.ev_creating_segm (method)
    ev_creating_segm(self, seg) -> int
    A new segment is about to be created.
    
    @param seg: (segment_t *)
    @retval 1: ok
    @retval <0: segment should not be created

ida_idp.IDP_Hooks.ev_cvt64_hashval (method)
    ev_cvt64_hashval(self, node, tag, name, data) -> int
    perform 32-64 conversion for a hash value
    
    @param node: (::nodeidx_t)
    @param tag: (uchar)
    @param name: (const ::char *)
    @param data: (const uchar *)
    @return: 0 nothing was done
    1 converted successfully
    -1 error (and message in errbuf)

ida_idp.IDP_Hooks.ev_cvt64_supval (method)
    ev_cvt64_supval(self, node, tag, idx, data) -> int
    perform 32-64 conversion for a netnode array element
    
    @param node: (::nodeidx_t)
    @param tag: (uchar)
    @param idx: (::nodeidx_t)
    @param data: (const uchar *)
    @return: 0 nothing was done
    1 converted successfully
    -1 error (and message in errbuf)

ida_idp.IDP_Hooks.ev_decorate_name (method)
    ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
    Decorate/undecorate a C symbol name.
    
    @param name: (const char *) name of symbol
    @param mangle: (bool) true-mangle, false-unmangle
    @param cc: (cm_t) calling convention
    @param optional_type: tinfo_t const *
    @retval 1: if success
    @retval 0: not implemented or failed

ida_idp.IDP_Hooks.ev_del_cref (method)
    ev_del_cref(self, _from, to, expand) -> int
    A code reference is being deleted.
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @param expand: (bool)
    @retval <0: cancel cref deletion
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_del_dref (method)
    ev_del_dref(self, _from, to) -> int
    A data reference is being deleted.
    
    @param from: (::ea_t)
    @param to: (::ea_t)
    @retval <0: cancel dref deletion
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_delay_slot_insn (method)
    ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
    Get delay slot instruction
    
    @param ea: (::ea_t *) in: instruction address in question, out: (if the answer
               is positive) if the delay slot contains valid insn: the address of
               the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
    @param bexec: (bool *) execute slot if jumping, initially set to 'true'
    @param fexec: (bool *) execute slot if not jumping, initally set to 'true'
    @retval 1: positive answer
    @retval <=0: ordinary insn
    @note: Input EA may point to the instruction with a delay slot or to the delay
           slot instruction itself.

ida_idp.IDP_Hooks.ev_demangle_name (method)
    ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
    Demangle a C++ (or another language) name into a user-readable string. This
    event is called by demangle_name()
    
    @param name: (const char *) mangled name
    @param disable_mask: (uint32) flags to inhibit parts of output or compiler
                         info/other (see MNG_)
    @param demreq: (demreq_type_t) operation to perform
    @retval 1: if success
    @retval 0: not implemented
    @note: if you call demangle_name() from the handler, protect against recursion!

ida_idp.IDP_Hooks.ev_emu_insn (method)
    ev_emu_insn(self, insn) -> bool
    Emulate instruction, create cross-references, plan to analyze subsequent
    instructions, modify flags etc. Upon entrance to this function, all information
    about the instruction is in 'insn' structure.
    
    @param insn: (const insn_t *)
    @retval 1: ok
    @retval -1: the kernel will delete the instruction

ida_idp.IDP_Hooks.ev_endbinary (method)
    ev_endbinary(self, ok) -> int
    IDA has loaded a binary file.
    
    @param ok: (bool) file loaded successfully?

ida_idp.IDP_Hooks.ev_ending_undo (method)
    ev_ending_undo(self, action_name, is_undo) -> int
    Ended undoing/redoing an action
    
    @param action_name: (const char *) action that we finished undoing/redoing. is
                        not nullptr.
    @param is_undo: (bool) true if performing undo, false if performing redo

ida_idp.IDP_Hooks.ev_equal_reglocs (method)
    ev_equal_reglocs(self, a1, a2) -> int
    Are 2 register arglocs the same?. We need this callback for the pc module.
    
    @param a1: (argloc_t *)
    @param a2: (argloc_t *)
    @retval 1: yes
    @retval -1: no
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_extract_address (method)
    ev_extract_address(self, out_ea, screen_ea, string, position) -> int
    Extract address from a string.
    
    @param out_ea: (ea_t *), out
    @param screen_ea: (ea_t)
    @param string: (const char *)
    @param position: (size_t)
    @retval 1: ok
    @retval 0: kernel should use the standard algorithm
    @retval -1: error

ida_idp.IDP_Hooks.ev_find_op_value (method)
    ev_find_op_value(self, pinsn, opn) -> PyObject *
    Find operand value via a register tracker. The returned value in 'out' is valid
    before executing the instruction.
    
    @param pinsn: (const insn_t *) instruction
    @param opn: (int) operand index
    @retval 1: if implemented, and value was found
    @retval 0: not implemented, -1 decoding failed, or no value found

ida_idp.IDP_Hooks.ev_find_reg_value (method)
    ev_find_reg_value(self, pinsn, reg) -> PyObject *
    Find register value via a register tracker. The returned value in 'out' is valid
    before executing the instruction.
    
    @param pinsn: (const insn_t *) instruction
    @param reg: (int) register index
    @retval 1: if implemented, and value was found
    @retval 0: not implemented, -1 decoding failed, or no value found

ida_idp.IDP_Hooks.ev_func_bounds (method)
    ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -> int
    find_func_bounds() finished its work. The module may fine tune the function
    bounds
    
    @param possible_return_code: (int *), in/out
    @param pfn: (func_t *)
    @param max_func_end_ea: (::ea_t) (from the kernel's point of view)
    @retval void

ida_idp.IDP_Hooks.ev_gen_asm_or_lst (method)
    ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
    
    @param starting: (bool) beginning listing generation
    @param fp: (FILE *) output file
    @param is_asm: (bool) true:assembler, false:listing
    @param flags: (int) flags passed to gen_file()
    @param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this
                    callback is defined for this code, it will be used by the kernel
                    to output the generated lines
    @retval void

ida_idp.IDP_Hooks.ev_gen_map_file (method)
    ev_gen_map_file(self, nlines, fp) -> int
    Generate map file. If not implemented the kernel itself will create the map
    file.
    
    @param nlines: (int *) number of lines in map file (-1 means write error)
    @param fp: (FILE *) output file
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: write error

ida_idp.IDP_Hooks.ev_gen_regvar_def (method)
    ev_gen_regvar_def(self, outctx, v) -> int
    Generate register variable definition line.
    
    @param outctx: (outctx_t *)
    @param v: (regvar_t *)
    @retval >0: ok, generated the definition text
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_gen_src_file_lnnum (method)
    ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
    
    @param outctx: (outctx_t *) output context
    @param file: (const char *) source file (may be nullptr)
    @param lnnum: (size_t) line number
    @retval 1: directive has been generated
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_gen_stkvar_def (method)
    ev_gen_stkvar_def(self, outctx, mptr, v) -> int
    Generate stack variable definition line Default line is varname = type ptr
    value, where 'type' is one of byte,word,dword,qword,tbyte
    
    @param outctx: (outctx_t *)
    @param mptr: (const member_t *)
    @param v: (sval_t)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_abi_info (method)
    ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
    Get all possible ABI names and optional extensions for given compiler
    abiname/option is a string entirely consisting of letters, digits and underscore
    
    @param abi_names: (qstrvec_t *) - all possible ABis each in form abiname-
                      opt1-opt2-...
    @param abi_opts: (qstrvec_t *) - array of all possible options in form
                     "opt:description" or opt:hint-line#description
    @param comp: (comp_t) - compiler ID
    @retval 0: not implemented
    @retval 1: ok

ida_idp.IDP_Hooks.ev_get_autocmt (method)
    ev_get_autocmt(self, insn) -> PyObject *
    
    @param insn: (const insn_t*) the instruction
    @retval 1: new comment has been generated
    @retval 0: callback has not been handled. the buffer must not be changed in this
               case

ida_idp.IDP_Hooks.ev_get_bg_color (method)
    ev_get_bg_color(self, color, ea) -> int
    Get item background color. Plugins can hook this callback to color disassembly
    lines dynamically
    
    @param color: (bgcolor_t *), out
    @param ea: (::ea_t)
    @retval 0: not implemented
    @retval 1: color set

ida_idp.IDP_Hooks.ev_get_cc_regs (method)
    ev_get_cc_regs(self, regs, cc) -> int
    Get register allocation convention for given calling convention
    
    @param regs: (callregs_t *), out
    @param cc: (cm_t)
    @retval 1
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_code16_mode (method)
    ev_get_code16_mode(self, ea) -> int
    Get ISA 16-bit mode
    
    @param ea: (ea_t) address to get the ISA mode
    @retval 1: 16-bit mode
    @retval 0: not implemented or 32-bit mode

ida_idp.IDP_Hooks.ev_get_dbr_opnum (method)
    ev_get_dbr_opnum(self, opnum, insn) -> int
    Get the number of the operand to be displayed in the debugger reference view
    (text mode).
    
    @param opnum: (int *) operand number (out, -1 means no such operand)
    @param insn: (const insn_t*) the instruction
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_get_default_enum_size (method)
    ev_get_default_enum_size(self) -> int
    Get default enum size. Not generated anymore. inf_get_cc_size_e() is used
    instead

ida_idp.IDP_Hooks.ev_get_frame_retsize (method)
    ev_get_frame_retsize(self, frsize, pfn) -> int
    Get size of function return address in bytes If this event is not implemented,
    the kernel will assume
    * 8 bytes for 64-bit function
    * 4 bytes for 32-bit function
    * 2 bytes otherwise
    
    @param frsize: (int *) frame size (out)
    @param pfn: (const func_t *), can't be nullptr
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_macro_insn_head (method)
    ev_get_macro_insn_head(self, head, ip) -> int
    Calculate the start of a macro instruction. This notification is called if IP
    points to the middle of an instruction
    
    @param head: (::ea_t *), out: answer, BADADDR means normal instruction
    @param ip: (::ea_t) instruction address
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_get_operand_string (method)
    ev_get_operand_string(self, insn, opnum) -> PyObject *
    Request text string for operand (cli, java, ...).
    
    @param insn: (const insn_t*) the instruction
    @param opnum: (int) operand number, -1 means any string operand
    @retval 0: no string (or empty string)
    @retval >0: original string length without terminating zero

ida_idp.IDP_Hooks.ev_get_procmod (method)
    ev_get_procmod(self) -> int
    Get pointer to the processor module object. All processor modules must implement
    this. The pointer is returned as size_t.

ida_idp.IDP_Hooks.ev_get_reg_accesses (method)
    ev_get_reg_accesses(self, accvec, insn, flags) -> int
    Get info about the registers that are used/changed by an instruction.
    
    @param accvec: (reg_accesses_t*) out: info about accessed registers
    @param insn: (const insn_t *) instruction in question
    @param flags: (int) reserved, must be 0
    @retval -1: if accvec is nullptr
    @retval 1: found the requested access (and filled accvec)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_reg_info (method)
    ev_get_reg_info(self, main_regname, bitrange, regname) -> int
    Get register information by its name. example: "ah" returns:
    * main_regname="eax"
    * bitrange_t = { offset==8, nbits==8 }
    
    This callback may be unimplemented if the register names are all present in
    processor_t::reg_names and they all have the same size
    
    @param main_regname: (const char **), out
    @param bitrange: (bitrange_t *), out: position and size of the value within
                     'main_regname' (empty bitrange == whole register)
    @param regname: (const char *)
    @retval 1: ok
    @retval -1: failed (not found)
    @retval 0: unimplemented

ida_idp.IDP_Hooks.ev_get_reg_name (method)
    ev_get_reg_name(self, reg, width, reghi) -> PyObject *
    Generate text representation of a register. Most processor modules do not need
    to implement this callback. It is useful only if processor_t::reg_names[reg]
    does not provide the correct register name.
    
    @param reg: (int) internal register number as defined in the processor module
    @param width: (size_t) register width in bytes
    @param reghi: (int) if not -1 then this function will return the register pair
    @retval -1: if error
    @retval strlen(buf): if success

ida_idp.IDP_Hooks.ev_get_simd_types (method)
    ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
    Get SIMD-related types according to given attributes ant/or argument location
    
    @param out: (::simd_info_vec_t *)
    @param simd_attrs: (const simd_info_t *), may be nullptr
    @param argloc: (const argloc_t *), may be nullptr
    @param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
    @retval number: of found types
    @retval -1: error If name==nullptr, initialize all SIMD types

ida_idp.IDP_Hooks.ev_get_stkarg_area_info (method)
    ev_get_stkarg_area_info(self, out, cc) -> int
    Get some metrics of the stack argument area.
    
    @param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
    @param cc: (cm_t) calling convention
    @retval 1: if success
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor (method)
    ev_get_stkvar_scale_factor(self) -> int
    Should stack variable references be multiplied by a coefficient before being
    used in the stack frame?. Currently used by TMS320C55 because the references
    into the stack should be multiplied by 2
    
    @return: scaling factor
    @retval 0: not implemented
    @note: PR_SCALE_STKVARS should be set to use this callback

ida_idp.IDP_Hooks.ev_getreg (method)
    ev_getreg(self, regval, regnum) -> int
    IBM PC only internal request, should never be used for other purpose Get
    register value by internal index
    
    @param regval: (uval_t *), out
    @param regnum: (int)
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: failed (undefined value or bad regnum)

ida_idp.IDP_Hooks.ev_init (method)
    ev_init(self, idp_modname) -> int
    The IDP module is just loaded.
    
    @param idp_modname: (const char *) processor module name
    @retval <0: on failure

ida_idp.IDP_Hooks.ev_insn_reads_tbit (method)
    ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
    Check if insn will read the TF bit.
    
    @param insn: (const insn_t*) the instruction
    @param getreg: (::processor_t::regval_getter_t *) function to get register
                   values
    @param regvalues: (const regval_t *) register values array
    @retval 2: yes, will generate 'step' exception
    @retval 1: yes, will store the TF bit in memory
    @retval 0: no

ida_idp.IDP_Hooks.ev_is_align_insn (method)
    ev_is_align_insn(self, ea) -> int
    Is the instruction created only for alignment purposes?. Do not directly call
    this function, use is_align_insn()
    
    @param ea: (ea_t) - instruction address
    @retval number: of bytes in the instruction

ida_idp.IDP_Hooks.ev_is_alloca_probe (method)
    ev_is_alloca_probe(self, ea) -> int
    Does the function at 'ea' behave as __alloca_probe?
    
    @param ea: (::ea_t)
    @retval 1: yes
    @retval 0: no

ida_idp.IDP_Hooks.ev_is_basic_block_end (method)
    ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
    Is the current instruction end of a basic block?. This function should be
    defined for processors with delayed jump slots.
    
    @param insn: (const insn_t*) the instruction
    @param call_insn_stops_block: (bool)
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_call_insn (method)
    ev_is_call_insn(self, insn) -> int
    Is the instruction a "call"?
    
    @param insn: (const insn_t *) instruction
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_cond_insn (method)
    ev_is_cond_insn(self, insn) -> int
    Is conditional instruction?
    
    @param insn: (const insn_t *) instruction address
    @retval 1: yes
    @retval -1: no
    @retval 0: not implemented or not instruction

ida_idp.IDP_Hooks.ev_is_control_flow_guard (method)
    ev_is_control_flow_guard(self, p_reg, insn) -> int
    Detect if an instruction is a "thunk call" to a flow guard function (equivalent
    to call reg/return/nop)
    
    @param p_reg: (int *) indirect register number, may be -1
    @param insn: (const insn_t *) call/jump instruction
    @retval -1: no thunk detected
    @retval 1: indirect call
    @retval 2: security check routine call (NOP)
    @retval 3: return thunk
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_is_far_jump (method)
    ev_is_far_jump(self, icode) -> int
    is indirect far jump or call instruction? meaningful only if the processor has
    'near' and 'far' reference types
    
    @param icode: (int)
    @retval 0: not implemented
    @retval 1: yes
    @retval -1: no

ida_idp.IDP_Hooks.ev_is_indirect_jump (method)
    ev_is_indirect_jump(self, insn) -> int
    Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all
    jump types jumps, please define this callback.
    
    @param insn: (const insn_t*) the instruction
    @retval 0: use CF_JUMP
    @retval 1: no
    @retval 2: yes

ida_idp.IDP_Hooks.ev_is_insn_table_jump (method)
    ev_is_insn_table_jump(self) -> int
    Reserved.

ida_idp.IDP_Hooks.ev_is_jump_func (method)
    ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
    Is the function a trivial "jump" function?.
    
    @param pfn: (func_t *)
    @param jump_target: (::ea_t *)
    @param func_pointer: (::ea_t *)
    @retval <0: no
    @retval 0: don't know
    @retval 1: yes, see 'jump_target' and 'func_pointer'

ida_idp.IDP_Hooks.ev_is_ret_insn (method)
    ev_is_ret_insn(self, insn, strict) -> int
    Is the instruction a "return"?
    
    @param insn: (const insn_t *) instruction
    @param strict: (bool) 1: report only ret instructions 0: include instructions
                   like "leave" which begins the function epilog
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_sane_insn (method)
    ev_is_sane_insn(self, insn, no_crefs) -> int
    Is the instruction sane for the current file type?.
    
    @param insn: (const insn_t*) the instruction
    @param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries
                     to convert unexplored bytes to an instruction (but there is no
                     other reason to convert them into an instruction) 0: the
                     instruction is created because of some coderef, user request or
                     another weighty reason.
    @retval >=0: ok
    @retval <0: no, the instruction isn't likely to appear in the program

ida_idp.IDP_Hooks.ev_is_sp_based (method)
    ev_is_sp_based(self, mode, insn, op) -> int
    Check whether the operand is relative to stack pointer or frame pointer This
    event is used to determine how to output a stack variable If not implemented,
    then all operands are sp based by default. Implement this event only if some
    stack references use frame pointer instead of stack pointer.
    
    @param mode: (int *) out, combination of SP/FP operand flags
    @param insn: (const insn_t *)
    @param op: (const op_t *)
    @retval 0: not implemented
    @retval 1: ok

ida_idp.IDP_Hooks.ev_is_switch (method)
    ev_is_switch(self, si, insn) -> int
    Find 'switch' idiom or override processor module's decision. It will be called
    for instructions marked with CF_JUMP.
    
    @param si: (switch_info_t *), out
    @param insn: (const insn_t *) instruction possibly belonging to a switch
    @retval 1: switch is found, 'si' is filled. IDA will create the switch using the
               filled 'si'
    @retval -1: no switch found. This value forbids switch creation by the processor
                module
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_last_cb_before_loader (method)
    ev_last_cb_before_loader(self) -> int

ida_idp.IDP_Hooks.ev_loader (method)
    ev_loader(self) -> int
    This code and higher ones are reserved for the loaders. The arguments and the
    return values are defined by the loaders

ida_idp.IDP_Hooks.ev_lower_func_type (method)
    ev_lower_func_type(self, argnums, fti) -> int
    Get function arguments which should be converted to pointers when lowering
    function prototype. The processor module can also modify 'fti' in order to make
    non-standard conversion of some arguments.
    
    @param argnums: (intvec_t *), out - numbers of arguments to be converted to
                    pointers in acsending order
    @param fti: (func_type_data_t *), inout func type details (special values -1/-2
                for return value - position of hidden 'retstr' argument: -1 - at the
                beginning, -2 - at the end)
    @retval 0: not implemented
    @retval 1: argnums was filled
    @retval 2: argnums was filled and made substantial changes to fti

ida_idp.IDP_Hooks.ev_max_ptr_size (method)
    ev_max_ptr_size(self) -> int
    Get maximal size of a pointer in bytes.
    
    @return: max possible size of a pointer

ida_idp.IDP_Hooks.ev_may_be_func (method)
    ev_may_be_func(self, insn, state) -> int
    Can a function start here?
    
    @param insn: (const insn_t*) the instruction
    @param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
    @return: probability 1..100
    @note: Actually IDA uses 3 intervals of a probability: 0..50 not a function,
           51..99 a function (IDA needs another proof), 100 a function (no other
           proofs needed)

ida_idp.IDP_Hooks.ev_may_show_sreg (method)
    ev_may_show_sreg(self, current_ea) -> int
    The kernel wants to display the segment registers in the messages window.
    
    @param current_ea: (::ea_t)
    @retval <0: if the kernel should not show the segment registers. (assuming that
                the module has done it)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_moving_segm (method)
    ev_moving_segm(self, seg, to, flags) -> int
    May the kernel move the segment?
    
    @param seg: (segment_t *) segment to move
    @param to: (::ea_t) new segment start address
    @param flags: (int) combination of Move segment flags
    @retval 0: yes
    @retval <0: the kernel should stop

ida_idp.IDP_Hooks.ev_newasm (method)
    ev_newasm(self, asmnum) -> int
    Before setting a new assembler.
    
    @param asmnum: (int) See also ev_asm_installed

ida_idp.IDP_Hooks.ev_newbinary (method)
    ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
    IDA is about to load a binary file.
    
    @param filename: (char *) binary file name
    @param fileoff: (qoff64_t) offset in the file
    @param basepara: (::ea_t) base loading paragraph
    @param binoff: (::ea_t) loader offset
    @param nbytes: (::uint64) number of bytes to load

ida_idp.IDP_Hooks.ev_newfile (method)
    ev_newfile(self, fname) -> int
    A new file has been loaded.
    
    @param fname: (char *) input file name

ida_idp.IDP_Hooks.ev_newprc (method)
    ev_newprc(self, pnum, keep_cfg) -> int
    Before changing processor type.
    
    @param pnum: (int) processor number in the array of processor names
    @param keep_cfg: (bool) true: do not modify kernel configuration
    @retval 1: ok
    @retval <0: prohibit

ida_idp.IDP_Hooks.ev_next_exec_insn (method)
    ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
    Get next address to be executed This function must return the next address to be
    executed. If the instruction following the current one is executed, then it must
    return BADADDR Usually the instructions to consider are: jumps, branches, calls,
    returns. This function is essential if the 'single step' is not supported in
    hardware.
    
    @param target: (::ea_t *), out: pointer to the answer
    @param ea: (::ea_t) instruction address
    @param tid: (int) current therad id
    @param getreg: (::processor_t::regval_getter_t *) function to get register
                   values
    @param regvalues: (const regval_t *) register values array
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_oldfile (method)
    ev_oldfile(self, fname) -> int
    An old file has been loaded.
    
    @param fname: (char *) input file name

ida_idp.IDP_Hooks.ev_out_assumes (method)
    ev_out_assumes(self, outctx) -> int
    Function to produce assume directives when segment register value changes.
    
    @param outctx: (outctx_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_data (method)
    ev_out_data(self, outctx, analyze_only) -> int
    Generate text representation of data items This function may change the database
    and create cross-references if analyze_only is set
    
    @param outctx: (outctx_t *)
    @param analyze_only: (bool)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_footer (method)
    ev_out_footer(self, outctx) -> int
    Function to produce end of disassembled text
    
    @param outctx: (outctx_t *)
    @retval void

ida_idp.IDP_Hooks.ev_out_header (method)
    ev_out_header(self, outctx) -> int
    Function to produce start of disassembled text
    
    @param outctx: (outctx_t *)
    @retval void

ida_idp.IDP_Hooks.ev_out_insn (method)
    ev_out_insn(self, outctx) -> bool
    Generate text representation of an instruction in 'ctx.insn' outctx_t provides
    functions to output the generated text. This function shouldn't change the
    database, flags or anything else. All these actions should be performed only by
    emu_insn() function.
    
    @param outctx: (outctx_t *)
    @retval void

ida_idp.IDP_Hooks.ev_out_label (method)
    ev_out_label(self, outctx, colored_name) -> int
    The kernel is going to generate an instruction label line or a function header.
    
    @param outctx: (outctx_t *)
    @param colored_name: (const char *)
    @retval <0: if the kernel should not generate the label
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_out_mnem (method)
    ev_out_mnem(self, outctx) -> int
    Generate instruction mnemonics. This callback should append the colored
    mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be
    called.
    
    @param outctx: (outctx_t *)
    @retval 1: if appended the mnemonics
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_operand (method)
    ev_out_operand(self, outctx, op) -> bool
    Generate text representation of an instruction operand outctx_t provides
    functions to output the generated text. All these actions should be performed
    only by emu_insn() function.
    
    @param outctx: (outctx_t *)
    @param op: (const op_t *)
    @retval 1: ok
    @retval -1: operand is hidden

ida_idp.IDP_Hooks.ev_out_segend (method)
    ev_out_segend(self, outctx, seg) -> int
    Function to produce end of segment
    
    @param outctx: (outctx_t *)
    @param seg: (segment_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_segstart (method)
    ev_out_segstart(self, outctx, seg) -> int
    Function to produce start of segment
    
    @param outctx: (outctx_t *)
    @param seg: (segment_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_special_item (method)
    ev_out_special_item(self, outctx, segtype) -> int
    Generate text representation of an item in a special segment i.e. absolute
    symbols, externs, communal definitions etc
    
    @param outctx: (outctx_t *)
    @param segtype: (uchar)
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: overflow

ida_idp.IDP_Hooks.ev_privrange_changed (method)
    ev_privrange_changed(self, old_privrange, delta) -> int
    Privrange interval has been moved to a new location. Most common actions to be
    done by module in this case: fix indices of netnodes used by module
    
    @param old_privrange: (const range_t *) - old privrange interval
    @param delta: (::adiff_t)
    @return: 0 Ok
    -1 error (and message in errbuf)

ida_idp.IDP_Hooks.ev_realcvt (method)
    ev_realcvt(self, m, e, swt) -> int
    Floating point -> IEEE conversion
    
    @param m: (void *) ptr to processor-specific floating point value
    @param e: (fpvalue_t *) IDA representation of a floating point value
    @param swt: (uint16) operation (see realcvt() in ieee.h)
    @retval 0: not implemented
    @retval 1: ok
    @retval unknown

ida_idp.IDP_Hooks.ev_rename (method)
    ev_rename(self, ea, new_name) -> int
    The kernel is going to rename a byte.
    
    @param ea: (::ea_t)
    @param new_name: (const char *)
    @retval <0: if the kernel should not rename it.
    @retval 2: to inhibit the notification. I.e., the kernel should not rename, but
               'set_name()' should return 'true'. also see renamed the return value
               is ignored when kernel is going to delete name

ida_idp.IDP_Hooks.ev_replaying_undo (method)
    ev_replaying_undo(self, action_name, vec, is_undo) -> int
    Replaying an undo/redo buffer
    
    @param action_name: (const char *) action that we perform undo/redo for. may be
                        nullptr for intermediary buffers.
    @param vec: (const undo_records_t *)
    @param is_undo: (bool) true if performing undo, false if performing redo This
                    event may be generated multiple times per undo/redo

ida_idp.IDP_Hooks.ev_set_code16_mode (method)
    ev_set_code16_mode(self, ea, code16) -> int
    Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set
    ISA 16-bit mode
    
    @param ea: (ea_t) address to set new ISA mode
    @param code16: (bool) true for 16-bit mode, false for 32-bit mode

ida_idp.IDP_Hooks.ev_set_idp_options (method)
    ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -> int
    Set IDP-specific configuration option Also see set_options_t in config.hpp
    
    @param keyword: (const char *)
    @param value_type: (int)
    @param value: (const void *)
    @param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been
                       generated
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: error (and message in errbuf)

ida_idp.IDP_Hooks.ev_set_proc_options (method)
    ev_set_proc_options(self, options, confidence) -> int
    Called if the user specified an option string in the command line: -p<processor
    name>:<options>. Can be used for setting a processor subtype. Also called if
    option string is passed to set_processor_type() and IDC's SetProcessorType().
    
    @param options: (const char *)
    @param confidence: (int) 0: loader's suggestion 1: user's decision
    @retval <0: if bad option string

ida_idp.IDP_Hooks.ev_setup_til (method)
    ev_setup_til(self) -> int
    Setup default type libraries. (called after loading a new file into the
    database). The processor module may load tils, setup memory model and perform
    other actions required to set up the type system. This is an optional callback.
    @retval void

ida_idp.IDP_Hooks.ev_str2reg (method)
    ev_str2reg(self, regname) -> int
    Convert a register name to a register number. The register number is the
    register index in the processor_t::reg_names array Most processor modules do not
    need to implement this callback It is useful only if processor_t::reg_names[reg]
    does not provide the correct register names
    
    @param regname: (const char *)
    @retval register: number + 1
    @retval 0: not implemented or could not be decoded

ida_idp.IDP_Hooks.ev_term (method)
    ev_term(self) -> int
    The IDP module is being unloaded.

ida_idp.IDP_Hooks.ev_treat_hindering_item (method)
    ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
    An item hinders creation of another item.
    
    @param hindering_item_ea: (::ea_t)
    @param new_item_flags: (flags64_t) (0 for code)
    @param new_item_ea: (::ea_t)
    @param new_item_length: (::asize_t)
    @retval 0: no reaction
    @retval !=0: the kernel may delete the hindering item

ida_idp.IDP_Hooks.ev_undefine (method)
    ev_undefine(self, ea) -> int
    An item in the database (insn or data) is being deleted.
    
    @param ea: (ea_t)
    @retval 1: do not delete srranges at the item end
    @retval 0: srranges can be deleted

ida_idp.IDP_Hooks.ev_update_call_stack (method)
    ev_update_call_stack(self, stack, tid, getreg, regvalues) -> int
    Calculate the call stack trace for the given thread. This callback is invoked
    when the process is suspended and should fill the 'trace' object with the
    information about the current call stack. Note that this callback is NOT invoked
    if the current debugger backend implements stack tracing via
    debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes
    priority. Implementing this callback in the processor module is useful when
    multiple debugging platforms follow similar patterns, and thus the same
    processor-specific algorithm can be used for different platforms.
    
    @param stack: (call_stack_t *) result
    @param tid: (int) thread id
    @param getreg: (::processor_t::regval_getter_t *) function to get register
                   values
    @param regvalues: (const regval_t *) register values array
    @retval 1: ok
    @retval -1: failed
    @retval 0: unimplemented

ida_idp.IDP_Hooks.ev_use_arg_types (method)
    ev_use_arg_types(self, ea, fti, rargs) -> int
    Use information about callee arguments.
    
    @param ea: (::ea_t) address of the call instruction
    @param fti: (func_type_data_t *) info about function type
    @param rargs: (funcargvec_t *) array of register arguments
    @retval 1: (and removes handled arguments from fti and rargs)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_use_regarg_type (method)
    ev_use_regarg_type(self, ea, rargs) -> PyObject *
    Use information about register argument.
    
    @param ea: (::ea_t) address of the instruction
    @param rargs: (const funcargvec_t *) vector of register arguments (including
                  regs extracted from scattered arguments)
    @retval 1
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_use_stkarg_type (method)
    ev_use_stkarg_type(self, ea, arg) -> int
    Use information about a stack argument.
    
    @param ea: (::ea_t) address of the push instruction which pushes the function
               argument into the stack
    @param arg: (const funcarg_t *) argument info
    @retval 1: ok
    @retval <=0: failed, the kernel will create a comment with the argument name or
                 type for the instruction

ida_idp.IDP_Hooks.ev_validate_flirt_func (method)
    ev_validate_flirt_func(self, start_ea, funcname) -> int
    Flirt has recognized a library function. This callback can be used by a plugin
    or proc module to intercept it and validate such a function.
    
    @param start_ea: (::ea_t)
    @param funcname: (const char *)
    @retval -1: do not create a function,
    @retval 0: function is validated

ida_idp.IDP_Hooks.ev_verify_noreturn (method)
    ev_verify_noreturn(self, pfn) -> int
    The kernel wants to set 'noreturn' flags for a function.
    
    @param pfn: (func_t *)
    @retval 0: ok. any other value: do not set 'noreturn' flag

ida_idp.IDP_Hooks.ev_verify_sp (method)
    ev_verify_sp(self, pfn) -> int
    All function instructions have been analyzed. Now the processor module can
    analyze the stack pointer for the whole function
    
    @param pfn: (func_t *)
    @retval 0: ok
    @retval <0: bad stack pointer

ida_idp.IDP_Hooks.hook (method)
    hook(self) -> bool

ida_idp.IDP_Hooks.unhook (method)
    unhook(self) -> bool

ida_idp.IDP_INTERFACE_VERSION (variable)
    The interface version number.
    @note: see also IDA_SDK_VERSION from pro.h

ida_idp.OP_FP_BASED (variable)
    operand is FP based

ida_idp.OP_SP_ADD (variable)
    operand value is added to the pointer

ida_idp.OP_SP_BASED (variable)
    operand is SP based

ida_idp.OP_SP_SUB (variable)
    operand value is subtracted from the pointer

ida_idp.PLFM_386 (variable)
    Intel 80x86.

ida_idp.PLFM_6502 (variable)
    6502

ida_idp.PLFM_65C816 (variable)
    65802/65816

ida_idp.PLFM_6800 (variable)
    Motorola 68xx.

ida_idp.PLFM_68K (variable)
    Motorola 680x0.

ida_idp.PLFM_80196 (variable)
    Intel 80196.

ida_idp.PLFM_8051 (variable)
    8051

ida_idp.PLFM_AD2106X (variable)
    Analog Devices ADSP 2106X.

ida_idp.PLFM_AD218X (variable)
    Analog Devices ADSP 218X.

ida_idp.PLFM_ALPHA (variable)
    DEC Alpha.

ida_idp.PLFM_ARC (variable)
    Argonaut RISC Core.

ida_idp.PLFM_ARM (variable)
    Advanced RISC Machines.

ida_idp.PLFM_AVR (variable)
    Atmel 8-bit RISC processor(s)

ida_idp.PLFM_C166 (variable)
    Siemens C166 family.

ida_idp.PLFM_C39 (variable)
    Rockwell C39.

ida_idp.PLFM_CR16 (variable)
    NSC CR16.

ida_idp.PLFM_DALVIK (variable)
    Android Dalvik Virtual Machine.

ida_idp.PLFM_DSP56K (variable)
    Motorola DSP5600x.

ida_idp.PLFM_DSP96K (variable)
    Motorola DSP96000.

ida_idp.PLFM_EBC (variable)
    EFI Bytecode.

ida_idp.PLFM_F2MC (variable)
    Fujistu F2MC-16.

ida_idp.PLFM_FR (variable)
    Fujitsu FR Family.

ida_idp.PLFM_H8 (variable)
    Hitachi H8/300, H8/2000.

ida_idp.PLFM_H8500 (variable)
    Hitachi H8/500.

ida_idp.PLFM_HPPA (variable)
    Hewlett-Packard PA-RISC.

ida_idp.PLFM_I860 (variable)
    Intel 860.

ida_idp.PLFM_I960 (variable)
    Intel 960.

ida_idp.PLFM_IA64 (variable)
    Intel Itanium IA64.

ida_idp.PLFM_JAVA (variable)
    Java.

ida_idp.PLFM_KR1878 (variable)
    Angstrem KR1878.

ida_idp.PLFM_M16C (variable)
    Renesas M16C.

ida_idp.PLFM_M32R (variable)
    Mitsubishi 32bit RISC.

ida_idp.PLFM_M740 (variable)
    Mitsubishi 8bit.

ida_idp.PLFM_M7700 (variable)
    Mitsubishi 16bit.

ida_idp.PLFM_M7900 (variable)
    Mitsubishi 7900.

ida_idp.PLFM_MC6812 (variable)
    Motorola 68HC12.

ida_idp.PLFM_MC6816 (variable)
    Motorola 68HC16.

ida_idp.PLFM_MIPS (variable)
    MIPS.

ida_idp.PLFM_MN102L00 (variable)
    Panasonic MN10200.

ida_idp.PLFM_MSP430 (variable)
    Texas Instruments MSP430.

ida_idp.PLFM_NEC_78K0 (variable)
    NEC 78K0.

ida_idp.PLFM_NEC_78K0S (variable)
    NEC 78K0S.

ida_idp.PLFM_NEC_V850X (variable)
    NEC V850 and V850ES/E1/E2.

ida_idp.PLFM_NET (variable)
    Microsoft Visual Studio.Net.

ida_idp.PLFM_OAKDSP (variable)
    Atmel OAK DSP.

ida_idp.PLFM_PDP (variable)
    PDP11.

ida_idp.PLFM_PIC (variable)
    Microchip's PIC.

ida_idp.PLFM_PIC16 (variable)
    Microchip's 16-bit PIC.

ida_idp.PLFM_PPC (variable)
    PowerPC.

ida_idp.PLFM_RISCV (variable)
    RISC-V.

ida_idp.PLFM_RL78 (variable)
    Renesas RL78.

ida_idp.PLFM_RX (variable)
    Renesas RX.

ida_idp.PLFM_S390 (variable)
    IBM's S390.

ida_idp.PLFM_SCR_ADPT (variable)
    Processor module adapter for processor modules written in scripting languages.

ida_idp.PLFM_SH (variable)
    Renesas (formerly Hitachi) SuperH.

ida_idp.PLFM_SPARC (variable)
    SPARC.

ida_idp.PLFM_SPC700 (variable)
    Sony SPC700.

ida_idp.PLFM_SPU (variable)
    Cell Broadband Engine Synergistic Processor Unit.

ida_idp.PLFM_ST20 (variable)
    SGS-Thomson ST20.

ida_idp.PLFM_ST7 (variable)
    SGS-Thomson ST7.

ida_idp.PLFM_ST9 (variable)
    ST9+.

ida_idp.PLFM_TLCS900 (variable)
    Toshiba TLCS-900.

ida_idp.PLFM_TMS (variable)
    Texas Instruments TMS320C5x.

ida_idp.PLFM_TMS320C1X (variable)
    Texas Instruments TMS320C1x.

ida_idp.PLFM_TMS320C28 (variable)
    Texas Instruments TMS320C28x.

ida_idp.PLFM_TMS320C3 (variable)
    Texas Instruments TMS320C3.

ida_idp.PLFM_TMS320C54 (variable)
    Texas Instruments TMS320C54xx.

ida_idp.PLFM_TMS320C55 (variable)
    Texas Instruments TMS320C55xx.

ida_idp.PLFM_TMSC6 (variable)
    Texas Instruments TMS320C6x.

ida_idp.PLFM_TRICORE (variable)
    Tasking Tricore.

ida_idp.PLFM_TRIMEDIA (variable)
    Trimedia.

ida_idp.PLFM_UNSP (variable)
    SunPlus unSP.

ida_idp.PLFM_XTENSA (variable)
    Tensilica Xtensa.

ida_idp.PLFM_Z8 (variable)
    Z8.

ida_idp.PLFM_Z80 (variable)
    8085, Z80

ida_idp.PR2_CODE16_BIT (variable)
    low bit of code addresses has special meaning e.g. ARM Thumb, MIPS16

ida_idp.PR2_FORCE_16BIT (variable)
    use 16-bit basic types despite of 32-bit segments (used by c166)

ida_idp.PR2_IDP_OPTS (variable)
    the module has processor-specific configuration options

ida_idp.PR2_MACRO (variable)
    processor supports macro instructions

ida_idp.PR2_MAPPINGS (variable)
    the processor module uses memory mapping

ida_idp.PR2_REALCVT (variable)
    the module has a custom 'ev_realcvt' implementation (otherwise IEEE-754 format
    is assumed)

ida_idp.PR2_REL_BITS (variable)
    (Lumina) calcrel info has bits granularity, not bytes - construction flag only

ida_idp.PR2_USE_CALCREL (variable)
    (Lumina) the module supports calcrel info

ida_idp.PRN_BIN (variable)
    binary

ida_idp.PRN_DEC (variable)
    decimal

ida_idp.PRN_HEX (variable)
    hex

ida_idp.PRN_OCT (variable)
    octal

ida_idp.PR_ADJSEGS (variable)
    IDA may adjust segments' starting/ending addresses.

ida_idp.PR_ALIGN (variable)
    All data items should be aligned properly.

ida_idp.PR_ALIGN_INSN (variable)
    allow ida to create alignment instructions arbitrarily. Since these instructions
    might lead to other wrong instructions and spoil the listing, IDA does not
    create them by default anymore

ida_idp.PR_ASSEMBLE (variable)
    Module has a built-in assembler and will react to ev_assemble.

ida_idp.PR_BINMEM (variable)
    the processor module provides correct segmentation for binary files (i.e. it
    creates additional segments). The kernel will not ask the user to specify the
    RAM/ROM sizes

ida_idp.PR_CHK_XREF (variable)
    don't allow near xrefs between segments with different bases

ida_idp.PR_CNDINSNS (variable)
    has conditional instructions

ida_idp.PR_DEFNUM (variable)
    mask - default number representation

ida_idp.PR_DEFSEG32 (variable)
    segments are 32-bit by default

ida_idp.PR_DEFSEG64 (variable)
    segments are 64-bit by default

ida_idp.PR_DELAYED (variable)
    has delayed jumps and calls. If this flag is set,
    processor_t::is_basic_block_end, processor_t::delay_slot_insn should be
    implemented

ida_idp.PR_NOCHANGE (variable)
    The user can't change segments and code/data attributes (display only)

ida_idp.PR_NO_SEGMOVE (variable)
    the processor module doesn't support move_segm() (i.e. the user can't move
    segments)

ida_idp.PR_OUTER (variable)
    has outer operands (currently only mc68k)

ida_idp.PR_PURGING (variable)
    there are calling conventions which may purge bytes from the stack

ida_idp.PR_RNAMESOK (variable)
    allow user register names for location names

ida_idp.PR_SCALE_STKVARS (variable)
    use processor_t::get_stkvar_scale callback

ida_idp.PR_SEGS (variable)
    has segment registers?

ida_idp.PR_SEGTRANS (variable)
    the processor module supports the segment translation feature (meaning it
    calculates the code addresses using the map_code_ea() function)

ida_idp.PR_SGROTHER (variable)
    the segment registers don't contain the segment selectors.

ida_idp.PR_STACK_UP (variable)
    the stack grows up

ida_idp.PR_TYPEINFO (variable)
    the processor module fully supports type information callbacks; without full
    support, function argument locations and other things will probably be wrong.

ida_idp.PR_USE32 (variable)
    supports 32-bit addressing?

ida_idp.PR_USE64 (variable)
    supports 64-bit addressing?

ida_idp.PR_USE_ARG_TYPES (variable)
    use processor_t::use_arg_types callback

ida_idp.PR_USE_TBYTE (variable)
    BTMT_SPECFLT means _TBYTE type

ida_idp.PR_WORD_INS (variable)
    instruction codes are grouped 2bytes in binary line prefix

ida_idp.REG_SPOIL (variable)
    processor_t::use_regarg_type uses this bit in the return value to indicate that
    the register value has been spoiled

ida_idp.SETPROC_IDB (variable)
    set processor type for old idb

ida_idp.SETPROC_LOADER (variable)
    set processor type for new idb; if the user has specified a compatible
    processor, return success without changing it. if failure, call loader_failure()

ida_idp.SETPROC_LOADER_NON_FATAL (variable)
    the same as SETPROC_LOADER but non-fatal failures.

ida_idp.SETPROC_USER (variable)
    set user-specified processor used for -p and manual processor change at later
    time

ida_idp.__ph (class)

ida_idp._idp_cvar_t (class)

ida_idp._notify_when_dispatcher_t (class)

ida_idp._notify_when_dispatcher_t._IDB_Hooks (class)

ida_idp._notify_when_dispatcher_t._IDB_Hooks.__init__ (method)

ida_idp._notify_when_dispatcher_t._IDB_Hooks.closebase (method)

ida_idp._notify_when_dispatcher_t._IDP_Hooks (class)

ida_idp._notify_when_dispatcher_t._IDP_Hooks.__init__ (method)

ida_idp._notify_when_dispatcher_t._IDP_Hooks.ev_newfile (method)

ida_idp._notify_when_dispatcher_t._IDP_Hooks.ev_oldfile (method)

ida_idp._notify_when_dispatcher_t.__init__ (method)

ida_idp._notify_when_dispatcher_t._callback_t (class)

ida_idp._notify_when_dispatcher_t._callback_t.__init__ (method)

ida_idp._notify_when_dispatcher_t._find (method)

ida_idp._notify_when_dispatcher_t.dispatch (method)

ida_idp._notify_when_dispatcher_t.notify_when (method)

ida_idp._processor_t (class)
    Proxy of C++ processor_t class.

ida_idp._processor_t.__init__ (method)
    __init__(self) -> _processor_t

ida_idp._processor_t.add_cref (method)
    add_cref(_from, to, type) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    type: enum cref_t

ida_idp._processor_t.add_dref (method)
    add_dref(_from, to, type) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    type: enum dref_t

ida_idp._processor_t.adjust_argloc (method)
    adjust_argloc(argloc, type, size) -> ssize_t
    
    Parameters
    ----------
    argloc: argloc_t *
    type: tinfo_t const *
    size: int

ida_idp._processor_t.adjust_libfunc_ea (method)
    adjust_libfunc_ea(sig, libfun, ea) -> ssize_t
    
    Parameters
    ----------
    sig: idasgn_t const &
    libfun: libfunc_t const &
    ea: ea_t *

ida_idp._processor_t.adjust_refinfo (method)
    adjust_refinfo(ri, ea, n, fd) -> ssize_t
    
    Parameters
    ----------
    ri: refinfo_t *
    ea: ea_t
    n: int
    fd: fixup_data_t const &

ida_idp._processor_t.ana_insn (method)
    ana_insn(out) -> ssize_t
    
    Parameters
    ----------
    out: insn_t *

ida_idp._processor_t.analyze_prolog (method)
    analyze_prolog(fct_ea) -> ssize_t
    
    Parameters
    ----------
    fct_ea: ea_t

ida_idp._processor_t.arch_changed (method)
    arch_changed() -> ssize_t

ida_idp._processor_t.arg_addrs_ready (method)
    arg_addrs_ready(caller, n, tif, addrs) -> ssize_t
    
    Parameters
    ----------
    caller: ea_t
    n: int
    tif: tinfo_t const &
    addrs: ea_t *

ida_idp._processor_t.asm_installed (method)
    asm_installed(asmnum) -> ssize_t
    
    Parameters
    ----------
    asmnum: int

ida_idp._processor_t.assemble (method)
    assemble(_bin, ea, cs, ip, _use32, line) -> ssize_t
    
    Parameters
    ----------
    _bin: uchar *
    ea: ea_t
    cs: ea_t
    ip: ea_t
    _use32: bool
    line: char const *

ida_idp._processor_t.auto_queue_empty (method)
    auto_queue_empty(type)
    
    Parameters
    ----------
    type: int

ida_idp._processor_t.calc_arglocs (method)
    calc_arglocs(fti) -> ssize_t
    
    Parameters
    ----------
    fti: func_type_data_t *

ida_idp._processor_t.calc_cdecl_purged_bytes (method)
    calc_cdecl_purged_bytes(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.calc_next_eas (method)
    calc_next_eas(res, insn, over) -> ssize_t
    
    Parameters
    ----------
    res: eavec_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    over: bool

ida_idp._processor_t.calc_purged_bytes (method)
    calc_purged_bytes(p_purged_bytes, fti) -> ssize_t
    
    Parameters
    ----------
    p_purged_bytes: int *
    fti: func_type_data_t const &

ida_idp._processor_t.calc_retloc (method)
    calc_retloc(retloc, rettype, cc) -> ssize_t
    
    Parameters
    ----------
    retloc: argloc_t *
    rettype: tinfo_t const &
    cc: cm_t

ida_idp._processor_t.calc_spdelta (method)
    calc_spdelta(spdelta, ins) -> ssize_t
    
    Parameters
    ----------
    spdelta: sval_t *
    ins: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.calc_step_over (method)
    calc_step_over(target, ip) -> ssize_t
    
    Parameters
    ----------
    target: ea_t *
    ip: ea_t

ida_idp._processor_t.calc_switch_cases (method)
    calc_switch_cases(casevec, targets, insn_ea, si) -> ssize_t
    
    Parameters
    ----------
    casevec: void *
    targets: eavec_t *
    insn_ea: ea_t
    si: switch_info_t const &

ida_idp._processor_t.calc_varglocs (method)
    calc_varglocs(ftd, regs, stkargs, nfixed) -> ssize_t
    
    Parameters
    ----------
    ftd: func_type_data_t *
    regs: regobjs_t *
    stkargs: relobj_t *
    nfixed: int

ida_idp._processor_t.calcrel (method)
    calcrel(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.calcrel_in_bits (method)
    calcrel_in_bits(self) -> bool

ida_idp._processor_t.can_have_type (method)
    can_have_type(op) -> ssize_t
    
    Parameters
    ----------
    op: op_t const &

ida_idp._processor_t.cbsize (method)
    cbsize(self) -> int

ida_idp._processor_t.clean_tbit (method)
    clean_tbit(ea, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t.cmp_operands (method)
    cmp_operands(op1, op2) -> ssize_t
    
    Parameters
    ----------
    op1: op_t const &
    op2: op_t const &

ida_idp._processor_t.coagulate (method)
    coagulate(start_ea) -> ssize_t
    
    Parameters
    ----------
    start_ea: ea_t

ida_idp._processor_t.coagulate_dref (method)
    coagulate_dref(_from, to, may_define, code_ea) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    may_define: bool
    code_ea: ea_t *

ida_idp._processor_t.create_flat_group (method)
    create_flat_group(image_base, bitness, dataseg_sel) -> ssize_t
    
    Parameters
    ----------
    image_base: ea_t
    bitness: int
    dataseg_sel: sel_t

ida_idp._processor_t.create_func_frame (method)
    create_func_frame(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp._processor_t.create_merge_handlers (method)
    create_merge_handlers(md) -> ssize_t
    
    Parameters
    ----------
    md: merge_data_t *

ida_idp._processor_t.create_switch_xrefs (method)
    create_switch_xrefs(jumpea, si) -> ssize_t
    
    Parameters
    ----------
    jumpea: ea_t
    si: switch_info_t const &

ida_idp._processor_t.creating_segm (method)
    creating_segm(seg) -> ssize_t
    
    Parameters
    ----------
    seg: segment_t *

ida_idp._processor_t.cvt64_hashval (method)
    cvt64_hashval(self, node, tag, name, data) -> ssize_t
    
    Parameters
    ----------
    node: nodeidx_t
    tag: uchar
    name: char const *
    data: uchar const *

ida_idp._processor_t.cvt64_supval (method)
    cvt64_supval(self, node, tag, idx, data) -> ssize_t
    
    Parameters
    ----------
    node: nodeidx_t
    tag: uchar
    idx: nodeidx_t
    data: uchar const *

ida_idp._processor_t.dbsize (method)
    dbsize(self) -> int

ida_idp._processor_t.decorate_name (method)
    decorate_name(outbuf, name, mangle, cc, type) -> ssize_t
    
    Parameters
    ----------
    outbuf: qstring *
    name: char const *
    mangle: bool
    cc: cm_t
    type: tinfo_t const &

ida_idp._processor_t.del_cref (method)
    del_cref(_from, to, expand) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    expand: bool

ida_idp._processor_t.del_dref (method)
    del_dref(_from, to) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t

ida_idp._processor_t.delay_slot_insn (method)
    delay_slot_insn(self, ea, bexec, fexec) -> bool
    
    Parameters
    ----------
    ea: ea_t *
    bexec: bool *
    fexec: bool *

ida_idp._processor_t.demangle_name (method)
    demangle_name(res, name, disable_mask, demreq) -> ssize_t
    
    Parameters
    ----------
    res: int32 *
    name: char const *
    disable_mask: uint32
    demreq: int

ida_idp._processor_t.emu_insn (method)
    emu_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.endbinary (method)
    endbinary(ok) -> ssize_t
    
    Parameters
    ----------
    ok: bool

ida_idp._processor_t.equal_reglocs (method)
    equal_reglocs(a1, a2) -> ssize_t
    
    Parameters
    ----------
    a1: argloc_t const &
    a2: argloc_t const &

ida_idp._processor_t.extract_address (method)
    extract_address(out_ea, screen_ea, string, x) -> ssize_t
    
    Parameters
    ----------
    out_ea: ea_t *
    screen_ea: ea_t
    string: char const *
    x: size_t

ida_idp._processor_t.find_op_value (method)
    find_op_value(insn, op) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    op: int

ida_idp._processor_t.find_reg_value (method)
    find_reg_value(insn, reg) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    reg: int

ida_idp._processor_t.func_bounds (method)
    func_bounds(possible_return_code, pfn, max_func_end_ea) -> ssize_t
    
    Parameters
    ----------
    possible_return_code: int *
    pfn: func_t *
    max_func_end_ea: ea_t

ida_idp._processor_t.gen_asm_or_lst (method)
    gen_asm_or_lst(starting, fp, is_asm, flags, outline) -> ssize_t
    
    Parameters
    ----------
    starting: bool
    fp: FILE *
    is_asm: bool
    flags: int
    outline: void *

ida_idp._processor_t.gen_map_file (method)
    gen_map_file(nlines, fp) -> ssize_t
    
    Parameters
    ----------
    nlines: int *
    fp: FILE *

ida_idp._processor_t.gen_regvar_def (method)
    gen_regvar_def(ctx, v) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    v: regvar_t *

ida_idp._processor_t.gen_src_file_lnnum (method)
    gen_src_file_lnnum(ctx, file, lnnum) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    file: char const *
    lnnum: size_t

ida_idp._processor_t.gen_stkvar_def (method)
    gen_stkvar_def(ctx, mptr, v) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    mptr: member_t const *
    v: sval_t

ida_idp._processor_t.get_abi_info (method)
    get_abi_info(abi_names, abi_opts, comp) -> ssize_t
    
    Parameters
    ----------
    abi_names: qstrvec_t *
    abi_opts: qstrvec_t *
    comp: comp_t

ida_idp._processor_t.get_autocmt (method)
    get_autocmt(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.get_bg_color (method)
    get_bg_color(color, ea) -> ssize_t
    
    Parameters
    ----------
    color: bgcolor_t *
    ea: ea_t

ida_idp._processor_t.get_canon_feature (method)
    get_canon_feature(self, itype) -> uint32
    
    Parameters
    ----------
    itype: uint16

ida_idp._processor_t.get_canon_mnem (method)
    get_canon_mnem(self, itype) -> char const *
    
    Parameters
    ----------
    itype: uint16

ida_idp._processor_t.get_cc_regs (method)
    get_cc_regs(regs, cc) -> ssize_t
    
    Parameters
    ----------
    regs: callregs_t *
    cc: cm_t

ida_idp._processor_t.get_code16_mode (method)
    get_code16_mode(ea) -> bool
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.get_dbr_opnum (method)
    get_dbr_opnum(opnum, insn) -> ssize_t
    
    Parameters
    ----------
    opnum: int *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.get_default_segm_bitness (method)
    get_default_segm_bitness(self, is_64bit_app) -> int
    
    Parameters
    ----------
    is_64bit_app: bool

ida_idp._processor_t.get_frame_retsize (method)
    get_frame_retsize(retsize, pfn) -> ssize_t
    
    Parameters
    ----------
    retsize: int *
    pfn: func_t const *

ida_idp._processor_t.get_idd_opinfo (method)
    get_idd_opinfo(opinf, ea, n, thread_id, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    opinf: idd_opinfo_t *
    ea: ea_t
    n: int
    thread_id: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t.get_macro_insn_head (method)
    get_macro_insn_head(head, ip) -> ssize_t
    
    Parameters
    ----------
    head: ea_t *
    ip: ea_t

ida_idp._processor_t.get_operand_string (method)
    get_operand_string(insn, opnum) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    opnum: int

ida_idp._processor_t.get_proc_index (method)
    get_proc_index(self) -> int

ida_idp._processor_t.get_reg_accesses (method)
    get_reg_accesses(accvec, insn, flags) -> ssize_t
    
    Parameters
    ----------
    accvec: reg_accesses_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    flags: int

ida_idp._processor_t.get_reg_info (method)
    get_reg_info(regname, bitrange) -> char const *
    
    Parameters
    ----------
    regname: char const *
    bitrange: bitrange_t *

ida_idp._processor_t.get_reg_name (method)
    get_reg_name(reg, width, reghi) -> ssize_t
    
    Parameters
    ----------
    reg: int
    width: size_t
    reghi: int

ida_idp._processor_t.get_simd_types (method)
    get_simd_types(out, simd_attrs, argloc, create_tifs) -> ssize_t
    
    Parameters
    ----------
    out: void *
    simd_attrs: simd_info_t const *
    argloc: argloc_t const *
    create_tifs: bool

ida_idp._processor_t.get_stkarg_area_info (method)
    get_stkarg_area_info(out, cc) -> ssize_t
    
    Parameters
    ----------
    out: stkarg_area_info_t *
    cc: cm_t

ida_idp._processor_t.get_stkvar_scale (method)
    get_stkvar_scale(self) -> int

ida_idp._processor_t.get_stkvar_scale_factor (method)
    get_stkvar_scale_factor() -> ssize_t

ida_idp._processor_t.getreg (method)
    getreg(rv, regnum) -> ssize_t
    
    Parameters
    ----------
    rv: uval_t *
    regnum: int

ida_idp._processor_t.has_code16_bit (method)
    has_code16_bit(self) -> bool

ida_idp._processor_t.has_idp_opts (method)
    has_idp_opts(self) -> bool

ida_idp._processor_t.has_realcvt (method)
    has_realcvt(self) -> bool

ida_idp._processor_t.has_segregs (method)
    has_segregs(self) -> bool

ida_idp._processor_t.init (method)
    init(idp_modname) -> ssize_t
    
    Parameters
    ----------
    idp_modname: char const *

ida_idp._processor_t.insn_reads_tbit (method)
    insn_reads_tbit(insn, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t.is_align_insn (method)
    is_align_insn(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.is_alloca_probe (method)
    is_alloca_probe(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.is_basic_block_end (method)
    is_basic_block_end(insn, call_insn_stops_block) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    call_insn_stops_block: bool

ida_idp._processor_t.is_call_insn (method)
    is_call_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.is_cond_insn (method)
    is_cond_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.is_control_flow_guard (method)
    is_control_flow_guard(p_reg, insn) -> ssize_t
    
    Parameters
    ----------
    p_reg: int *
    insn: insn_t const *

ida_idp._processor_t.is_far_jump (method)
    is_far_jump(icode) -> ssize_t
    
    Parameters
    ----------
    icode: int

ida_idp._processor_t.is_indirect_jump (method)
    is_indirect_jump(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.is_jump_func (method)
    is_jump_func(pfn, jump_target, func_pointer) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *
    jump_target: ea_t *
    func_pointer: ea_t *

ida_idp._processor_t.is_ret_insn (method)
    is_ret_insn(insn, strict) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    strict: bool

ida_idp._processor_t.is_sane_insn (method)
    is_sane_insn(insn, no_crefs) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    no_crefs: int

ida_idp._processor_t.is_sp_based (method)
    is_sp_based(insn, x) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    x: op_t const &

ida_idp._processor_t.is_switch (method)
    is_switch(si, insn) -> ssize_t
    
    Parameters
    ----------
    si: switch_info_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t.loader_elf_machine (method)
    loader_elf_machine(li, machine_type, p_procname, p_pd, ldr, reader) -> ssize_t
    
    Parameters
    ----------
    li: linput_t *
    machine_type: int
    p_procname: char const **
    p_pd: proc_def_t **
    ldr: elf_loader_t *
    reader: reader_t *

ida_idp._processor_t.lower_func_type (method)
    lower_func_type(argnums, fti) -> ssize_t
    
    Parameters
    ----------
    argnums: intvec_t *
    fti: func_type_data_t *

ida_idp._processor_t.max_ptr_size (method)
    max_ptr_size() -> ssize_t

ida_idp._processor_t.may_be_func (method)
    may_be_func(insn, state) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    state: int

ida_idp._processor_t.may_show_sreg (method)
    may_show_sreg(current_ea) -> ssize_t
    
    Parameters
    ----------
    current_ea: ea_t

ida_idp._processor_t.moving_segm (method)
    moving_segm(seg, to, flags) -> ssize_t
    
    Parameters
    ----------
    seg: segment_t *
    to: ea_t
    flags: int

ida_idp._processor_t.newasm (method)
    newasm(asmnum) -> ssize_t
    
    Parameters
    ----------
    asmnum: int

ida_idp._processor_t.newbinary (method)
    newbinary(filename, fileoff, basepara, binoff, nbytes) -> ssize_t
    
    Parameters
    ----------
    filename: char const *
    fileoff: qoff64_t
    basepara: ea_t
    binoff: ea_t
    nbytes: uint64

ida_idp._processor_t.newfile (method)
    newfile(fname) -> ssize_t
    
    Parameters
    ----------
    fname: char const *

ida_idp._processor_t.newprc (method)
    newprc(pnum, keep_cfg) -> ssize_t
    
    Parameters
    ----------
    pnum: int
    keep_cfg: bool

ida_idp._processor_t.next_exec_insn (method)
    next_exec_insn(target, ea, tid, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    target: ea_t *
    ea: ea_t
    tid: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t.notify (method)
    notify(event_code) -> ssize_t
    
    Parameters
    ----------
    event_code: enum processor_t::event_t

ida_idp._processor_t.oldfile (method)
    oldfile(fname) -> ssize_t
    
    Parameters
    ----------
    fname: char const *

ida_idp._processor_t.out_assumes (method)
    out_assumes(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t.out_data (method)
    out_data(ctx, analyze_only) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    analyze_only: bool

ida_idp._processor_t.out_footer (method)
    out_footer(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t.out_header (method)
    out_header(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t.out_insn (method)
    out_insn(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t.out_label (method)
    out_label(ctx, colored_name) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    colored_name: char const *

ida_idp._processor_t.out_mnem (method)
    out_mnem(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t.out_operand (method)
    out_operand(ctx, op) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    op: op_t const &

ida_idp._processor_t.out_segend (method)
    out_segend(ctx, seg) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    seg: segment_t *

ida_idp._processor_t.out_segstart (method)
    out_segstart(ctx, seg) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    seg: segment_t *

ida_idp._processor_t.out_special_item (method)
    out_special_item(ctx, segtype) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    segtype: uchar

ida_idp._processor_t.privrange_changed (method)
    privrange_changed(self, old_privrange, delta) -> ssize_t
    
    Parameters
    ----------
    old_privrange: range_t const &
    delta: adiff_t

ida_idp._processor_t.realcvt (method)
    realcvt(m, e, swt) -> fpvalue_error_t
    
    Parameters
    ----------
    m: void *
    e: fpvalue_t *
    swt: uint16

ida_idp._processor_t.rename (method)
    rename(ea, new_name, flags) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    new_name: char const *
    flags: int

ida_idp._processor_t.set_code16_mode (method)
    set_code16_mode(ea, code16=True) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    code16: bool

ida_idp._processor_t.set_idp_options (method)
    set_idp_options(keyword, vtype, value, idb_loaded=True) -> char const *
    
    Parameters
    ----------
    keyword: char const *
    vtype: int
    value: void const *
    idb_loaded: bool

ida_idp._processor_t.set_proc_options (method)
    set_proc_options(options, confidence) -> ssize_t
    
    Parameters
    ----------
    options: char const *
    confidence: int

ida_idp._processor_t.setup_til (method)
    setup_til() -> ssize_t

ida_idp._processor_t.sizeof_ldbl (method)
    sizeof_ldbl(self) -> size_t

ida_idp._processor_t.stkup (method)
    stkup(self) -> bool

ida_idp._processor_t.str2reg (method)
    str2reg(regname) -> ssize_t
    
    Parameters
    ----------
    regname: char const *

ida_idp._processor_t.supports_calcrel (method)
    supports_calcrel(self) -> bool

ida_idp._processor_t.supports_macros (method)
    supports_macros(self) -> bool

ida_idp._processor_t.term (method)
    term() -> ssize_t

ida_idp._processor_t.ti (method)
    ti(self) -> bool

ida_idp._processor_t.treat_hindering_item (method)
    treat_hindering_item(hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> ssize_t
    
    Parameters
    ----------
    hindering_item_ea: ea_t
    new_item_flags: flags64_t
    new_item_ea: ea_t
    new_item_length: asize_t

ida_idp._processor_t.undefine (method)
    undefine(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t.update_call_stack (method)
    update_call_stack(stack, tid, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    stack: call_stack_t *
    tid: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t.use32 (method)
    use32(self) -> bool

ida_idp._processor_t.use64 (method)
    use64(self) -> bool

ida_idp._processor_t.use_arg_types (method)
    use_arg_types(ea, fti, rargs) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    fti: func_type_data_t *
    rargs: void *

ida_idp._processor_t.use_mappings (method)
    use_mappings(self) -> bool

ida_idp._processor_t.use_regarg_type (method)
    use_regarg_type(idx, ea, rargs) -> ssize_t
    
    Parameters
    ----------
    idx: int *
    ea: ea_t
    rargs: void *

ida_idp._processor_t.use_stkarg_type (method)
    use_stkarg_type(ea, arg) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    arg: funcarg_t const &

ida_idp._processor_t.use_tbyte (method)
    use_tbyte(self) -> bool

ida_idp._processor_t.validate_flirt_func (method)
    validate_flirt_func(start_ea, funcname) -> ssize_t
    
    Parameters
    ----------
    start_ea: ea_t
    funcname: char const *

ida_idp._processor_t.verify_noreturn (method)
    verify_noreturn(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp._processor_t.verify_sp (method)
    verify_sp(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp._processor_t_Trampoline_IDB_Hooks (class)

ida_idp._processor_t_Trampoline_IDB_Hooks.__dummy (method)

ida_idp._processor_t_Trampoline_IDB_Hooks.__init__ (method)

ida_idp._processor_t_Trampoline_IDB_Hooks.__make_parent_caller (method)

ida_idp._processor_t_Trampoline_IDB_Hooks.__make_parent_caller.call_parent (function)

ida_idp._processor_t_add_cref (function)
    _processor_t_add_cref(_from, to, type) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    type: enum cref_t

ida_idp._processor_t_add_dref (function)
    _processor_t_add_dref(_from, to, type) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    type: enum dref_t

ida_idp._processor_t_adjust_argloc (function)
    _processor_t_adjust_argloc(argloc, type, size) -> ssize_t
    
    Parameters
    ----------
    argloc: argloc_t *
    type: tinfo_t const *
    size: int

ida_idp._processor_t_adjust_libfunc_ea (function)
    _processor_t_adjust_libfunc_ea(sig, libfun, ea) -> ssize_t
    
    Parameters
    ----------
    sig: idasgn_t const &
    libfun: libfunc_t const &
    ea: ea_t *

ida_idp._processor_t_adjust_refinfo (function)
    _processor_t_adjust_refinfo(ri, ea, n, fd) -> ssize_t
    
    Parameters
    ----------
    ri: refinfo_t *
    ea: ea_t
    n: int
    fd: fixup_data_t const &

ida_idp._processor_t_ana_insn (function)
    _processor_t_ana_insn(out) -> ssize_t
    
    Parameters
    ----------
    out: insn_t *

ida_idp._processor_t_analyze_prolog (function)
    _processor_t_analyze_prolog(fct_ea) -> ssize_t
    
    Parameters
    ----------
    fct_ea: ea_t

ida_idp._processor_t_arch_changed (function)
    _processor_t_arch_changed() -> ssize_t

ida_idp._processor_t_arg_addrs_ready (function)
    _processor_t_arg_addrs_ready(caller, n, tif, addrs) -> ssize_t
    
    Parameters
    ----------
    caller: ea_t
    n: int
    tif: tinfo_t const &
    addrs: ea_t *

ida_idp._processor_t_asm_installed (function)
    _processor_t_asm_installed(asmnum) -> ssize_t
    
    Parameters
    ----------
    asmnum: int

ida_idp._processor_t_assemble (function)
    _processor_t_assemble(_bin, ea, cs, ip, _use32, line) -> ssize_t
    
    Parameters
    ----------
    _bin: uchar *
    ea: ea_t
    cs: ea_t
    ip: ea_t
    _use32: bool
    line: char const *

ida_idp._processor_t_auto_queue_empty (function)
    _processor_t_auto_queue_empty(type)
    
    Parameters
    ----------
    type: int

ida_idp._processor_t_calc_arglocs (function)
    _processor_t_calc_arglocs(fti) -> ssize_t
    
    Parameters
    ----------
    fti: func_type_data_t *

ida_idp._processor_t_calc_cdecl_purged_bytes (function)
    _processor_t_calc_cdecl_purged_bytes(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_calc_next_eas (function)
    _processor_t_calc_next_eas(res, insn, over) -> ssize_t
    
    Parameters
    ----------
    res: eavec_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    over: bool

ida_idp._processor_t_calc_purged_bytes (function)
    _processor_t_calc_purged_bytes(p_purged_bytes, fti) -> ssize_t
    
    Parameters
    ----------
    p_purged_bytes: int *
    fti: func_type_data_t const &

ida_idp._processor_t_calc_retloc (function)
    _processor_t_calc_retloc(retloc, rettype, cc) -> ssize_t
    
    Parameters
    ----------
    retloc: argloc_t *
    rettype: tinfo_t const &
    cc: cm_t

ida_idp._processor_t_calc_spdelta (function)
    _processor_t_calc_spdelta(spdelta, ins) -> ssize_t
    
    Parameters
    ----------
    spdelta: sval_t *
    ins: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_calc_step_over (function)
    _processor_t_calc_step_over(target, ip) -> ssize_t
    
    Parameters
    ----------
    target: ea_t *
    ip: ea_t

ida_idp._processor_t_calc_switch_cases (function)
    _processor_t_calc_switch_cases(casevec, targets, insn_ea, si) -> ssize_t
    
    Parameters
    ----------
    casevec: void *
    targets: eavec_t *
    insn_ea: ea_t
    si: switch_info_t const &

ida_idp._processor_t_calc_varglocs (function)
    _processor_t_calc_varglocs(ftd, regs, stkargs, nfixed) -> ssize_t
    
    Parameters
    ----------
    ftd: func_type_data_t *
    regs: regobjs_t *
    stkargs: relobj_t *
    nfixed: int

ida_idp._processor_t_calcrel (function)
    _processor_t_calcrel(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_can_have_type (function)
    _processor_t_can_have_type(op) -> ssize_t
    
    Parameters
    ----------
    op: op_t const &

ida_idp._processor_t_clean_tbit (function)
    _processor_t_clean_tbit(ea, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t_cmp_operands (function)
    _processor_t_cmp_operands(op1, op2) -> ssize_t
    
    Parameters
    ----------
    op1: op_t const &
    op2: op_t const &

ida_idp._processor_t_coagulate (function)
    _processor_t_coagulate(start_ea) -> ssize_t
    
    Parameters
    ----------
    start_ea: ea_t

ida_idp._processor_t_coagulate_dref (function)
    _processor_t_coagulate_dref(_from, to, may_define, code_ea) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    may_define: bool
    code_ea: ea_t *

ida_idp._processor_t_create_flat_group (function)
    _processor_t_create_flat_group(image_base, bitness, dataseg_sel) -> ssize_t
    
    Parameters
    ----------
    image_base: ea_t
    bitness: int
    dataseg_sel: sel_t

ida_idp._processor_t_create_func_frame (function)
    _processor_t_create_func_frame(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp._processor_t_create_merge_handlers (function)
    _processor_t_create_merge_handlers(md) -> ssize_t
    
    Parameters
    ----------
    md: merge_data_t *

ida_idp._processor_t_create_switch_xrefs (function)
    _processor_t_create_switch_xrefs(jumpea, si) -> ssize_t
    
    Parameters
    ----------
    jumpea: ea_t
    si: switch_info_t const &

ida_idp._processor_t_creating_segm (function)
    _processor_t_creating_segm(seg) -> ssize_t
    
    Parameters
    ----------
    seg: segment_t *

ida_idp._processor_t_decorate_name (function)
    _processor_t_decorate_name(outbuf, name, mangle, cc, type) -> ssize_t
    
    Parameters
    ----------
    outbuf: qstring *
    name: char const *
    mangle: bool
    cc: cm_t
    type: tinfo_t const &

ida_idp._processor_t_del_cref (function)
    _processor_t_del_cref(_from, to, expand) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t
    expand: bool

ida_idp._processor_t_del_dref (function)
    _processor_t_del_dref(_from, to) -> ssize_t
    
    Parameters
    ----------
    from: ea_t
    to: ea_t

ida_idp._processor_t_demangle_name (function)
    _processor_t_demangle_name(res, name, disable_mask, demreq) -> ssize_t
    
    Parameters
    ----------
    res: int32 *
    name: char const *
    disable_mask: uint32
    demreq: int

ida_idp._processor_t_emu_insn (function)
    _processor_t_emu_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_endbinary (function)
    _processor_t_endbinary(ok) -> ssize_t
    
    Parameters
    ----------
    ok: bool

ida_idp._processor_t_equal_reglocs (function)
    _processor_t_equal_reglocs(a1, a2) -> ssize_t
    
    Parameters
    ----------
    a1: argloc_t const &
    a2: argloc_t const &

ida_idp._processor_t_extract_address (function)
    _processor_t_extract_address(out_ea, screen_ea, string, x) -> ssize_t
    
    Parameters
    ----------
    out_ea: ea_t *
    screen_ea: ea_t
    string: char const *
    x: size_t

ida_idp._processor_t_find_op_value (function)
    _processor_t_find_op_value(insn, op) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    op: int

ida_idp._processor_t_find_reg_value (function)
    _processor_t_find_reg_value(insn, reg) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    reg: int

ida_idp._processor_t_func_bounds (function)
    _processor_t_func_bounds(possible_return_code, pfn, max_func_end_ea) -> ssize_t
    
    Parameters
    ----------
    possible_return_code: int *
    pfn: func_t *
    max_func_end_ea: ea_t

ida_idp._processor_t_gen_asm_or_lst (function)
    _processor_t_gen_asm_or_lst(starting, fp, is_asm, flags, outline) -> ssize_t
    
    Parameters
    ----------
    starting: bool
    fp: FILE *
    is_asm: bool
    flags: int
    outline: void *

ida_idp._processor_t_gen_map_file (function)
    _processor_t_gen_map_file(nlines, fp) -> ssize_t
    
    Parameters
    ----------
    nlines: int *
    fp: FILE *

ida_idp._processor_t_gen_regvar_def (function)
    _processor_t_gen_regvar_def(ctx, v) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    v: regvar_t *

ida_idp._processor_t_gen_src_file_lnnum (function)
    _processor_t_gen_src_file_lnnum(ctx, file, lnnum) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    file: char const *
    lnnum: size_t

ida_idp._processor_t_gen_stkvar_def (function)
    _processor_t_gen_stkvar_def(ctx, mptr, v) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    mptr: member_t const *
    v: sval_t

ida_idp._processor_t_get_abi_info (function)
    _processor_t_get_abi_info(abi_names, abi_opts, comp) -> ssize_t
    
    Parameters
    ----------
    abi_names: qstrvec_t *
    abi_opts: qstrvec_t *
    comp: comp_t

ida_idp._processor_t_get_autocmt (function)
    _processor_t_get_autocmt(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_get_bg_color (function)
    _processor_t_get_bg_color(color, ea) -> ssize_t
    
    Parameters
    ----------
    color: bgcolor_t *
    ea: ea_t

ida_idp._processor_t_get_cc_regs (function)
    _processor_t_get_cc_regs(regs, cc) -> ssize_t
    
    Parameters
    ----------
    regs: callregs_t *
    cc: cm_t

ida_idp._processor_t_get_code16_mode (function)
    _processor_t_get_code16_mode(ea) -> bool
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_get_dbr_opnum (function)
    _processor_t_get_dbr_opnum(opnum, insn) -> ssize_t
    
    Parameters
    ----------
    opnum: int *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_get_frame_retsize (function)
    _processor_t_get_frame_retsize(retsize, pfn) -> ssize_t
    
    Parameters
    ----------
    retsize: int *
    pfn: func_t const *

ida_idp._processor_t_get_idd_opinfo (function)
    _processor_t_get_idd_opinfo(opinf, ea, n, thread_id, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    opinf: idd_opinfo_t *
    ea: ea_t
    n: int
    thread_id: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t_get_macro_insn_head (function)
    _processor_t_get_macro_insn_head(head, ip) -> ssize_t
    
    Parameters
    ----------
    head: ea_t *
    ip: ea_t

ida_idp._processor_t_get_operand_string (function)
    _processor_t_get_operand_string(insn, opnum) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    opnum: int

ida_idp._processor_t_get_reg_accesses (function)
    _processor_t_get_reg_accesses(accvec, insn, flags) -> ssize_t
    
    Parameters
    ----------
    accvec: reg_accesses_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    flags: int

ida_idp._processor_t_get_reg_info (function)
    _processor_t_get_reg_info(regname, bitrange) -> char const *
    
    Parameters
    ----------
    regname: char const *
    bitrange: bitrange_t *

ida_idp._processor_t_get_reg_name (function)
    _processor_t_get_reg_name(reg, width, reghi) -> ssize_t
    
    Parameters
    ----------
    reg: int
    width: size_t
    reghi: int

ida_idp._processor_t_get_simd_types (function)
    _processor_t_get_simd_types(out, simd_attrs, argloc, create_tifs) -> ssize_t
    
    Parameters
    ----------
    out: void *
    simd_attrs: simd_info_t const *
    argloc: argloc_t const *
    create_tifs: bool

ida_idp._processor_t_get_stkarg_area_info (function)
    _processor_t_get_stkarg_area_info(out, cc) -> ssize_t
    
    Parameters
    ----------
    out: stkarg_area_info_t *
    cc: cm_t

ida_idp._processor_t_get_stkvar_scale_factor (function)
    _processor_t_get_stkvar_scale_factor() -> ssize_t

ida_idp._processor_t_getreg (function)
    _processor_t_getreg(rv, regnum) -> ssize_t
    
    Parameters
    ----------
    rv: uval_t *
    regnum: int

ida_idp._processor_t_init (function)
    _processor_t_init(idp_modname) -> ssize_t
    
    Parameters
    ----------
    idp_modname: char const *

ida_idp._processor_t_insn_reads_tbit (function)
    _processor_t_insn_reads_tbit(insn, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t_is_align_insn (function)
    _processor_t_is_align_insn(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_is_alloca_probe (function)
    _processor_t_is_alloca_probe(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_is_basic_block_end (function)
    _processor_t_is_basic_block_end(insn, call_insn_stops_block) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    call_insn_stops_block: bool

ida_idp._processor_t_is_call_insn (function)
    _processor_t_is_call_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_is_cond_insn (function)
    _processor_t_is_cond_insn(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_is_control_flow_guard (function)
    _processor_t_is_control_flow_guard(p_reg, insn) -> ssize_t
    
    Parameters
    ----------
    p_reg: int *
    insn: insn_t const *

ida_idp._processor_t_is_far_jump (function)
    _processor_t_is_far_jump(icode) -> ssize_t
    
    Parameters
    ----------
    icode: int

ida_idp._processor_t_is_indirect_jump (function)
    _processor_t_is_indirect_jump(insn) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_is_jump_func (function)
    _processor_t_is_jump_func(pfn, jump_target, func_pointer) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *
    jump_target: ea_t *
    func_pointer: ea_t *

ida_idp._processor_t_is_ret_insn (function)
    _processor_t_is_ret_insn(insn, strict) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    strict: bool

ida_idp._processor_t_is_sane_insn (function)
    _processor_t_is_sane_insn(insn, no_crefs) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    no_crefs: int

ida_idp._processor_t_is_sp_based (function)
    _processor_t_is_sp_based(insn, x) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    x: op_t const &

ida_idp._processor_t_is_switch (function)
    _processor_t_is_switch(si, insn) -> ssize_t
    
    Parameters
    ----------
    si: switch_info_t *
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp._processor_t_loader_elf_machine (function)
    _processor_t_loader_elf_machine(li, machine_type, p_procname, p_pd, ldr, reader) -> ssize_t
    
    Parameters
    ----------
    li: linput_t *
    machine_type: int
    p_procname: char const **
    p_pd: proc_def_t **
    ldr: elf_loader_t *
    reader: reader_t *

ida_idp._processor_t_lower_func_type (function)
    _processor_t_lower_func_type(argnums, fti) -> ssize_t
    
    Parameters
    ----------
    argnums: intvec_t *
    fti: func_type_data_t *

ida_idp._processor_t_max_ptr_size (function)
    _processor_t_max_ptr_size() -> ssize_t

ida_idp._processor_t_may_be_func (function)
    _processor_t_may_be_func(insn, state) -> ssize_t
    
    Parameters
    ----------
    insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    state: int

ida_idp._processor_t_may_show_sreg (function)
    _processor_t_may_show_sreg(current_ea) -> ssize_t
    
    Parameters
    ----------
    current_ea: ea_t

ida_idp._processor_t_moving_segm (function)
    _processor_t_moving_segm(seg, to, flags) -> ssize_t
    
    Parameters
    ----------
    seg: segment_t *
    to: ea_t
    flags: int

ida_idp._processor_t_newasm (function)
    _processor_t_newasm(asmnum) -> ssize_t
    
    Parameters
    ----------
    asmnum: int

ida_idp._processor_t_newbinary (function)
    _processor_t_newbinary(filename, fileoff, basepara, binoff, nbytes) -> ssize_t
    
    Parameters
    ----------
    filename: char const *
    fileoff: qoff64_t
    basepara: ea_t
    binoff: ea_t
    nbytes: uint64

ida_idp._processor_t_newfile (function)
    _processor_t_newfile(fname) -> ssize_t
    
    Parameters
    ----------
    fname: char const *

ida_idp._processor_t_newprc (function)
    _processor_t_newprc(pnum, keep_cfg) -> ssize_t
    
    Parameters
    ----------
    pnum: int
    keep_cfg: bool

ida_idp._processor_t_next_exec_insn (function)
    _processor_t_next_exec_insn(target, ea, tid, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    target: ea_t *
    ea: ea_t
    tid: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t_notify (function)
    _processor_t_notify(event_code) -> ssize_t
    
    Parameters
    ----------
    event_code: enum processor_t::event_t

ida_idp._processor_t_oldfile (function)
    _processor_t_oldfile(fname) -> ssize_t
    
    Parameters
    ----------
    fname: char const *

ida_idp._processor_t_out_assumes (function)
    _processor_t_out_assumes(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t_out_data (function)
    _processor_t_out_data(ctx, analyze_only) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    analyze_only: bool

ida_idp._processor_t_out_footer (function)
    _processor_t_out_footer(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t_out_header (function)
    _processor_t_out_header(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t_out_insn (function)
    _processor_t_out_insn(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t_out_label (function)
    _processor_t_out_label(ctx, colored_name) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    colored_name: char const *

ida_idp._processor_t_out_mnem (function)
    _processor_t_out_mnem(ctx) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &

ida_idp._processor_t_out_operand (function)
    _processor_t_out_operand(ctx, op) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    op: op_t const &

ida_idp._processor_t_out_segend (function)
    _processor_t_out_segend(ctx, seg) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    seg: segment_t *

ida_idp._processor_t_out_segstart (function)
    _processor_t_out_segstart(ctx, seg) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    seg: segment_t *

ida_idp._processor_t_out_special_item (function)
    _processor_t_out_special_item(ctx, segtype) -> ssize_t
    
    Parameters
    ----------
    ctx: outctx_t &
    segtype: uchar

ida_idp._processor_t_realcvt (function)
    _processor_t_realcvt(m, e, swt) -> fpvalue_error_t
    
    Parameters
    ----------
    m: void *
    e: fpvalue_t *
    swt: uint16

ida_idp._processor_t_rename (function)
    _processor_t_rename(ea, new_name, flags) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    new_name: char const *
    flags: int

ida_idp._processor_t_set_code16_mode (function)
    _processor_t_set_code16_mode(ea, code16=True) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    code16: bool

ida_idp._processor_t_set_idp_options (function)
    _processor_t_set_idp_options(keyword, vtype, value, idb_loaded=True) -> char const *
    
    Parameters
    ----------
    keyword: char const *
    vtype: int
    value: void const *
    idb_loaded: bool

ida_idp._processor_t_set_proc_options (function)
    _processor_t_set_proc_options(options, confidence) -> ssize_t
    
    Parameters
    ----------
    options: char const *
    confidence: int

ida_idp._processor_t_setup_til (function)
    _processor_t_setup_til() -> ssize_t

ida_idp._processor_t_str2reg (function)
    _processor_t_str2reg(regname) -> ssize_t
    
    Parameters
    ----------
    regname: char const *

ida_idp._processor_t_term (function)
    _processor_t_term() -> ssize_t

ida_idp._processor_t_treat_hindering_item (function)
    _processor_t_treat_hindering_item(hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> ssize_t
    
    Parameters
    ----------
    hindering_item_ea: ea_t
    new_item_flags: flags64_t
    new_item_ea: ea_t
    new_item_length: asize_t

ida_idp._processor_t_undefine (function)
    _processor_t_undefine(ea) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t

ida_idp._processor_t_update_call_stack (function)
    _processor_t_update_call_stack(stack, tid, _getreg, regvalues) -> ssize_t
    
    Parameters
    ----------
    stack: call_stack_t *
    tid: int
    _getreg: processor_t::regval_getter_t *
    regvalues: regval_t const &

ida_idp._processor_t_use_arg_types (function)
    _processor_t_use_arg_types(ea, fti, rargs) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    fti: func_type_data_t *
    rargs: void *

ida_idp._processor_t_use_regarg_type (function)
    _processor_t_use_regarg_type(idx, ea, rargs) -> ssize_t
    
    Parameters
    ----------
    idx: int *
    ea: ea_t
    rargs: void *

ida_idp._processor_t_use_stkarg_type (function)
    _processor_t_use_stkarg_type(ea, arg) -> ssize_t
    
    Parameters
    ----------
    ea: ea_t
    arg: funcarg_t const &

ida_idp._processor_t_validate_flirt_func (function)
    _processor_t_validate_flirt_func(start_ea, funcname) -> ssize_t
    
    Parameters
    ----------
    start_ea: ea_t
    funcname: char const *

ida_idp._processor_t_verify_noreturn (function)
    _processor_t_verify_noreturn(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp._processor_t_verify_sp (function)
    _processor_t_verify_sp(pfn) -> ssize_t
    
    Parameters
    ----------
    pfn: func_t *

ida_idp.asm_t (class)
    Proxy of C++ asm_t class.

ida_idp.asm_t.__init__ (method)
    __init__(self) -> asm_t

ida_idp.asm_t.a_align (variable)
    "align" keyword

ida_idp.asm_t.a_ascii (variable)
    string literal directive

ida_idp.asm_t.a_band (variable)
    & bit and assembler time operation

ida_idp.asm_t.a_bnot (variable)
    ~ bit not assembler time operation

ida_idp.asm_t.a_bor (variable)
    | bit or assembler time operation

ida_idp.asm_t.a_bss (variable)
    uninitialized data directive should include 's' for the size of data

ida_idp.asm_t.a_byte (variable)
    byte directive

ida_idp.asm_t.a_comdef (variable)
    "comm" (communal variable)

ida_idp.asm_t.a_curip (variable)
    current IP (instruction pointer) symbol in assembler

ida_idp.asm_t.a_double (variable)
    double; 8bytes; nullptr if not allowed

ida_idp.asm_t.a_dups (variable)
    array keyword. the following sequences may appear:
    * #h header
    * #d size
    * #v value
    * #s(b,w,l,q,f,d,o) size specifiers for byte,word, dword,qword,
    float,double,oword

ida_idp.asm_t.a_dword (variable)
    nullptr if not allowed

ida_idp.asm_t.a_equ (variable)
    'equ' Used if AS_UNEQU is set

ida_idp.asm_t.a_extrn (variable)
    "extern" name keyword

ida_idp.asm_t.a_float (variable)
    float; 4bytes; nullptr if not allowed

ida_idp.asm_t.a_include_fmt (variable)
    the include directive (format string)

ida_idp.asm_t.a_mod (variable)
    % mod assembler time operation

ida_idp.asm_t.a_oword (variable)
    nullptr if not allowed

ida_idp.asm_t.a_packreal (variable)
    packed decimal real nullptr if not allowed

ida_idp.asm_t.a_public (variable)
    "public" name keyword. nullptr-use default, ""-do not generate

ida_idp.asm_t.a_qword (variable)
    nullptr if not allowed

ida_idp.asm_t.a_rva (variable)
    'rva' keyword for image based offsets (see REFINFO_RVAOFF)

ida_idp.asm_t.a_seg (variable)
    'seg ' prefix (example: push seg seg001)

ida_idp.asm_t.a_shl (variable)
    << shift left assembler time operation

ida_idp.asm_t.a_shr (variable)
    >> shift right assembler time operation

ida_idp.asm_t.a_sizeof_fmt (variable)
    size of type (format string)

ida_idp.asm_t.a_tbyte (variable)
    long double; nullptr if not allowed

ida_idp.asm_t.a_vstruc_fmt (variable)
    if a named item is a structure and displayed in the verbose (multiline) form
    then display the name as printf(a_strucname_fmt, typename) (for asms with type
    checking, e.g. tasm ideal)

ida_idp.asm_t.a_weak (variable)
    "weak" name keyword. nullptr-use default, ""-do not generate

ida_idp.asm_t.a_word (variable)
    word directive

ida_idp.asm_t.a_xor (variable)
    ^ bit xor assembler time operation

ida_idp.asm_t.a_yword (variable)
    32-byte (256-bit) data; nullptr if not allowed requires AS2_YWORD

ida_idp.asm_t.a_zword (variable)
    64-byte (512-bit) data; nullptr if not allowed requires AS2_ZWORD

ida_idp.asm_t.accsep (variable)
    char constant delimiter

ida_idp.asm_t.ascsep (variable)
    string literal delimiter

ida_idp.asm_t.cmnt (variable)
    comment string (see also cmnt2)

ida_idp.asm_t.cmnt2 (variable)
    comment close string (usually nullptr) this is used to denote a string which
    closes comments, for example, if the comments are represented with (* ... *)
    then cmnt = "(*" and cmnt2 = "*)"

ida_idp.asm_t.end (variable)
    end directive

ida_idp.asm_t.esccodes (variable)
    special chars that cannot appear as is in string and char literals

ida_idp.asm_t.flag (variable)
    Assembler feature bits

ida_idp.asm_t.flag2 (variable)
    Secondary assembler feature bits

ida_idp.asm_t.header (variable)
    array of automatically generated header lines they appear at the start of
    disassembled text

ida_idp.asm_t.help (variable)
    Help screen number, 0 - no help.

ida_idp.asm_t.high16 (variable)
    high16

ida_idp.asm_t.high8 (variable)
    high8

ida_idp.asm_t.lbrace (variable)
    left brace used in complex expressions

ida_idp.asm_t.low16 (variable)
    low16

ida_idp.asm_t.low8 (variable)
    low8 operation, should contain s for the operand

ida_idp.asm_t.name (variable)
    Assembler name (displayed in menus)

ida_idp.asm_t.origin (variable)
    org directive

ida_idp.asm_t.rbrace (variable)
    right brace used in complex expressions

ida_idp.asm_t.uflag (variable)
    user defined flags (local only for IDP) you may define and use your own bits

ida_idp.assemble (function)
    assemble(ea, cs, ip, use32, line) -> bool
    Assemble an instruction into the database (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.

ida_idp.cfg_get_cc_header_path (function)
    cfg_get_cc_header_path(compid) -> char const *
    
    @param compid: comp_t

ida_idp.cfg_get_cc_parm (function)
    cfg_get_cc_parm(compid, name) -> char const *
    
    @param compid: comp_t
    @param name: char const *

ida_idp.cfg_get_cc_predefined_macros (function)
    cfg_get_cc_predefined_macros(compid) -> char const *
    
    @param compid: comp_t

ida_idp.delay_slot_insn (function)
    delay_slot_insn(ea, bexec, fexec) -> bool
    
    @param ea: ea_t *
    @param bexec: bool *
    @param fexec: bool *

ida_idp.gen_idb_event (function)
    gen_idb_event(code)
    the kernel will use this function to generate idb_events
    
    @param code: (C++: idb_event::event_code_t) enum idb_event::event_code_t

ida_idp.get_ash (function)
    get_ash() -> asm_t

ida_idp.get_config_value (function)
    get_config_value(key) -> bool
    
    @param key: char const *

ida_idp.get_idb_notifier_addr (function)
    get_idb_notifier_addr(arg1) -> PyObject *
    
    @param arg1: PyObject *

ida_idp.get_idb_notifier_ud_addr (function)
    get_idb_notifier_ud_addr(hooks) -> PyObject *
    
    @param hooks: IDB_Hooks *

ida_idp.get_idp_name (function)
    get_idp_name() -> str
    Get name of the current processor module. The name is derived from the file
    name. For example, for IBM PC the module is named "pc.w32" (windows version),
    then the module name is "PC" (uppercase). If no processor module is loaded, this
    function will return nullptr

ida_idp.get_idp_notifier_addr (function)
    get_idp_notifier_addr(arg1) -> PyObject *
    
    @param arg1: PyObject *

ida_idp.get_idp_notifier_ud_addr (function)
    get_idp_notifier_ud_addr(hooks) -> PyObject *
    
    @param hooks: IDP_Hooks *

ida_idp.get_ph (function)
    get_ph() -> _processor_t

ida_idp.get_reg_info (function)
    get_reg_info(regname, bitrange) -> char const *
    
    @param regname: char const *
    @param bitrange: bitrange_t *

ida_idp.get_reg_name (function)
    get_reg_name(reg, width, reghi=-1) -> str
    Get text representation of a register. For most processors this function will
    just return processor_t::reg_names[reg]. If the processor module has implemented
    processor_t::get_reg_name, it will be used instead
    
    @param reg: (C++: int) internal register number as defined in the processor module
    @param width: (C++: size_t) register width in bytes
    @param reghi: (C++: int) if specified, then this function will return the register pair
    @return: length of register name in bytes or -1 if failure

ida_idp.has_cf_chg (function)
    has_cf_chg(feature, opnum) -> bool
    Does an instruction with the specified feature modify the i-th operand?
    
    @param feature: (C++: uint32)
    @param opnum: (C++: uint)

ida_idp.has_cf_use (function)
    has_cf_use(feature, opnum) -> bool
    Does an instruction with the specified feature use a value of the i-th operand?
    
    @param feature: (C++: uint32)
    @param opnum: (C++: uint)

ida_idp.has_insn_feature (function)
    has_insn_feature(icode, bit) -> bool
    Does the specified instruction have the specified feature?
    
    @param icode: (C++: uint16)
    @param bit: (C++: uint32)

ida_idp.is_align_insn (function)
    is_align_insn(ea) -> int
    If the instruction at 'ea' looks like an alignment instruction, return its
    length in bytes. Otherwise return 0.
    
    @param ea: (C++: ea_t)

ida_idp.is_basic_block_end (function)
    is_basic_block_end(insn, call_insn_stops_block) -> bool
    Is the instruction the end of a basic block?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param call_insn_stops_block: (C++: bool)

ida_idp.is_call_insn (function)
    is_call_insn(insn) -> bool
    Is the instruction a "call"?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp.is_indirect_jump_insn (function)
    is_indirect_jump_insn(insn) -> bool
    Is the instruction an indirect jump?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_idp.is_ret_insn (function)
    is_ret_insn(insn, strict=True) -> bool
    Is the instruction a "return"?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param strict: (C++: bool)

ida_idp.num_range_t (class)
    Proxy of C++ cfgopt_t::num_range_t class.

ida_idp.num_range_t.__init__ (method)
    __init__(self, _min, _max) -> num_range_t
    
    @param _min: int64
    @param _max: int64

ida_idp.params_t (class)
    Proxy of C++ cfgopt_t::params_t class.

ida_idp.params_t.__init__ (method)
    __init__(self, _p1, _p2) -> params_t
    
    @param _p1: int64
    @param _p2: int64

ida_idp.parse_reg_name (function)
    parse_reg_name(ri, regname) -> bool
    Get register info by name.
    
    @param ri: (C++: reg_info_t *) result
    @param regname: (C++: const char *) name of register
    @return: success

ida_idp.ph_calcrel (function)
    ph_calcrel(ea)
    
    @param ea: ea_t

ida_idp.ph_find_op_value (function)
    ph_find_op_value(insn, op) -> ssize_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: int

ida_idp.ph_find_reg_value (function)
    ph_find_reg_value(insn, reg) -> ssize_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param reg: int

ida_idp.ph_get_cnbits (function)
    ph_get_cnbits() -> size_t
    Returns the 'ph.cnbits'

ida_idp.ph_get_dnbits (function)
    ph_get_dnbits() -> size_t
    Returns the 'ph.dnbits'

ida_idp.ph_get_flag (function)
    ph_get_flag() -> size_t
    Returns the 'ph.flag'

ida_idp.ph_get_icode_return (function)
    ph_get_icode_return() -> size_t
    Returns the 'ph.icode_return'

ida_idp.ph_get_id (function)
    ph_get_id() -> size_t
    Returns the 'ph.id' field

ida_idp.ph_get_instruc (function)
    ph_get_instruc() -> [(str, int), ...]
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module

ida_idp.ph_get_instruc_end (function)
    ph_get_instruc_end() -> size_t
    Returns the 'ph.instruc_end'

ida_idp.ph_get_instruc_start (function)
    ph_get_instruc_start() -> size_t
    Returns the 'ph.instruc_start'

ida_idp.ph_get_operand_info (function)
    ph_get_operand_info(ea, n) -> (int, int, int, int, int) or None
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.

ida_idp.ph_get_reg_accesses (function)
    ph_get_reg_accesses(accvec, insn, flags) -> ssize_t
    
    @param accvec: reg_accesses_t *
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param flags: int

ida_idp.ph_get_reg_code_sreg (function)
    ph_get_reg_code_sreg() -> size_t
    Returns the 'ph.reg_code_sreg'

ida_idp.ph_get_reg_data_sreg (function)
    ph_get_reg_data_sreg() -> size_t
    Returns the 'ph.reg_data_sreg'

ida_idp.ph_get_reg_first_sreg (function)
    ph_get_reg_first_sreg() -> size_t
    Returns the 'ph.reg_first_sreg'

ida_idp.ph_get_reg_last_sreg (function)
    ph_get_reg_last_sreg() -> size_t
    Returns the 'ph.reg_last_sreg'

ida_idp.ph_get_regnames (function)
    ph_get_regnames() -> [str, ...]
    Returns the list of register names as defined in the processor module

ida_idp.ph_get_segreg_size (function)
    ph_get_segreg_size() -> size_t
    Returns the 'ph.segreg_size'

ida_idp.ph_get_tbyte_size (function)
    ph_get_tbyte_size() -> size_t
    Returns the 'ph.tbyte_size' field as defined in he processor module

ida_idp.ph_get_version (function)
    ph_get_version() -> size_t
    Returns the 'ph.version'

ida_idp.process_config_directive (function)
    process_config_directive(directive, priority=2)
    
    @param directive: char const *
    @param priority: int

ida_idp.processor_t (class)
    Base class for all processor module scripts
    
    A processor_t instance is both an ida_idp.IDP_Hooks, and an
    ida_idp.IDB_Hooks at the same time: any method of those two classes
    can be overridden in your processor_t subclass (with the exception of
    'ida_idp.IDP_Hooks.ev_init' (replaced with processor_t.__init__),
    and 'ida_idp.IDP_Hooks.ev_term' (replaced with processor_t.__del__)).

ida_idp.processor_t.__init__ (method)

ida_idp.processor_t._get_idb_notifier_addr (method)

ida_idp.processor_t._get_idb_notifier_ud_addr (method)

ida_idp.processor_t._get_idp_notifier_addr (method)

ida_idp.processor_t._get_idp_notifier_ud_addr (method)

ida_idp.processor_t._get_notify (method)
    This helper is used to implement backward-compatibility
    of pre IDA 7.3 processor_t interfaces.

ida_idp.processor_t._make_forced_value_wrapper (method)

ida_idp.processor_t._make_forced_value_wrapper.f (function)

ida_idp.processor_t._make_int_returning_wrapper (method)

ida_idp.processor_t._make_int_returning_wrapper.f (function)

ida_idp.processor_t.auto_empty (method)

ida_idp.processor_t.auto_empty_finally (method)

ida_idp.processor_t.closebase (method)

ida_idp.processor_t.compiler_changed (method)

ida_idp.processor_t.deleting_func (method)

ida_idp.processor_t.determined_main (method)

ida_idp.processor_t.ev_ana_insn (method)

ida_idp.processor_t.ev_assemble (method)

ida_idp.processor_t.ev_auto_queue_empty (method)

ida_idp.processor_t.ev_calc_step_over (method)

ida_idp.processor_t.ev_can_have_type (method)

ida_idp.processor_t.ev_cmp_operands (method)

ida_idp.processor_t.ev_coagulate (method)

ida_idp.processor_t.ev_coagulate_dref (method)

ida_idp.processor_t.ev_create_func_frame (method)

ida_idp.processor_t.ev_create_switch_xrefs (method)

ida_idp.processor_t.ev_creating_segm (method)

ida_idp.processor_t.ev_emu_insn (method)

ida_idp.processor_t.ev_endbinary (method)

ida_idp.processor_t.ev_func_bounds (method)

ida_idp.processor_t.ev_gen_map_file (method)

ida_idp.processor_t.ev_gen_regvar_def (method)

ida_idp.processor_t.ev_gen_src_file_lnnum (method)

ida_idp.processor_t.ev_get_autocmt (method)

ida_idp.processor_t.ev_get_frame_retsize (method)

ida_idp.processor_t.ev_get_operand_string (method)

ida_idp.processor_t.ev_is_align_insn (method)

ida_idp.processor_t.ev_is_alloca_probe (method)

ida_idp.processor_t.ev_is_basic_block_end (method)

ida_idp.processor_t.ev_is_call_insn (method)

ida_idp.processor_t.ev_is_far_jump (method)

ida_idp.processor_t.ev_is_indirect_jump (method)

ida_idp.processor_t.ev_is_insn_table_jump (method)

ida_idp.processor_t.ev_is_ret_insn (method)

ida_idp.processor_t.ev_is_sane_insn (method)

ida_idp.processor_t.ev_is_sp_based (method)

ida_idp.processor_t.ev_is_switch (method)

ida_idp.processor_t.ev_may_be_func (method)

ida_idp.processor_t.ev_may_show_sreg (method)

ida_idp.processor_t.ev_moving_segm (method)

ida_idp.processor_t.ev_newbinary (method)

ida_idp.processor_t.ev_newfile (method)

ida_idp.processor_t.ev_newprc (method)

ida_idp.processor_t.ev_oldfile (method)

ida_idp.processor_t.ev_out_assumes (method)

ida_idp.processor_t.ev_out_data (method)

ida_idp.processor_t.ev_out_footer (method)

ida_idp.processor_t.ev_out_header (method)

ida_idp.processor_t.ev_out_insn (method)

ida_idp.processor_t.ev_out_label (method)

ida_idp.processor_t.ev_out_mnem (method)

ida_idp.processor_t.ev_out_operand (method)

ida_idp.processor_t.ev_out_segend (method)

ida_idp.processor_t.ev_out_segstart (method)

ida_idp.processor_t.ev_out_special_item (method)

ida_idp.processor_t.ev_rename (method)

ida_idp.processor_t.ev_set_idp_options (method)

ida_idp.processor_t.ev_set_proc_options (method)

ida_idp.processor_t.ev_str2reg (method)

ida_idp.processor_t.ev_treat_hindering_item (method)

ida_idp.processor_t.ev_undefine (method)

ida_idp.processor_t.ev_validate_flirt_func (method)

ida_idp.processor_t.ev_verify_noreturn (method)

ida_idp.processor_t.ev_verify_sp (method)

ida_idp.processor_t.func_added (method)

ida_idp.processor_t.get_auxpref (method)
    This function returns insn.auxpref value

ida_idp.processor_t.get_idpdesc (method)
    This function must be present and should return the list of
    short processor names similar to the one in ph.psnames.
    This method can be overridden to return to the kernel a different IDP description.

ida_idp.processor_t.get_uFlag (method)
    Use this utility function to retrieve the 'uFlag' global variable

ida_idp.processor_t.idasgn_loaded (method)

ida_idp.processor_t.kernel_config_loaded (method)

ida_idp.processor_t.make_code (method)

ida_idp.processor_t.make_data (method)

ida_idp.processor_t.renamed (method)

ida_idp.processor_t.savebase (method)

ida_idp.processor_t.segm_moved (method)

ida_idp.processor_t.set_func_end (method)

ida_idp.processor_t.set_func_start (method)

ida_idp.processor_t.sgr_changed (method)

ida_idp.reg_access_t (class)
    Proxy of C++ reg_access_t class.

ida_idp.reg_access_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: reg_access_t const &

ida_idp.reg_access_t.__init__ (method)
    __init__(self) -> reg_access_t

ida_idp.reg_access_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: reg_access_t const &

ida_idp.reg_access_t.have_common_bits (method)
    have_common_bits(self, r) -> bool
    
    @param r: reg_access_t const &

ida_idp.reg_access_t.opnum (variable)
    operand number

ida_idp.reg_access_t.range (variable)
    bitrange inside the register

ida_idp.reg_access_t.regnum (variable)
    register number (only entire registers)

ida_idp.reg_access_vec_t (class)
    Proxy of C++ qvector< reg_access_t > class.

ida_idp.reg_access_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< reg_access_t > const &

ida_idp.reg_access_vec_t.__getitem__ (method)
    __getitem__(self, i) -> reg_access_t
    
    @param i: size_t

ida_idp.reg_access_vec_t.__init__ (method)
    __init__(self) -> reg_access_vec_t
    __init__(self, x) -> reg_access_vec_t
    
    @param x: qvector< reg_access_t > const &

ida_idp.reg_access_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_idp.reg_access_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< reg_access_t > const &

ida_idp.reg_access_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: reg_access_t const &

ida_idp.reg_access_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: reg_access_t const &

ida_idp.reg_access_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: reg_access_t const &

ida_idp.reg_access_vec_t.at (method)
    at(self, _idx) -> reg_access_t
    
    @param _idx: size_t

ida_idp.reg_access_vec_t.begin (method)
    begin(self) -> reg_access_t

ida_idp.reg_access_vec_t.capacity (method)
    capacity(self) -> size_t

ida_idp.reg_access_vec_t.clear (method)
    clear(self)

ida_idp.reg_access_vec_t.empty (method)
    empty(self) -> bool

ida_idp.reg_access_vec_t.end (method)
    end(self) -> reg_access_t

ida_idp.reg_access_vec_t.erase (method)
    erase(self, it) -> reg_access_t
    
    @param it: qvector< reg_access_t >::iterator
    
    erase(self, first, last) -> reg_access_t
    
    @param first: qvector< reg_access_t >::iterator
    @param last: qvector< reg_access_t >::iterator

ida_idp.reg_access_vec_t.extract (method)
    extract(self) -> reg_access_t

ida_idp.reg_access_vec_t.find (method)
    find(self, x) -> reg_access_t
    
    @param x: reg_access_t const &

ida_idp.reg_access_vec_t.grow (method)
    grow(self, x=reg_access_t())
    
    @param x: reg_access_t const &

ida_idp.reg_access_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: reg_access_t const &

ida_idp.reg_access_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: reg_access_t *
    @param len: size_t

ida_idp.reg_access_vec_t.insert (method)
    insert(self, it, x) -> reg_access_t
    
    @param it: qvector< reg_access_t >::iterator
    @param x: reg_access_t const &

ida_idp.reg_access_vec_t.pop_back (method)
    pop_back(self)

ida_idp.reg_access_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: reg_access_t const &
    
    push_back(self) -> reg_access_t

ida_idp.reg_access_vec_t.qclear (method)
    qclear(self)

ida_idp.reg_access_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_idp.reg_access_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: reg_access_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_idp.reg_access_vec_t.size (method)
    size(self) -> size_t

ida_idp.reg_access_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< reg_access_t > &

ida_idp.reg_access_vec_t.truncate (method)
    truncate(self)

ida_idp.reg_accesses_t (class)
    Proxy of C++ reg_accesses_t class.

ida_idp.reg_accesses_t.__init__ (method)
    __init__(self) -> reg_accesses_t

ida_idp.reg_info_t (class)
    Proxy of C++ reg_info_t class.

ida_idp.reg_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.__init__ (method)
    __init__(self) -> reg_info_t

ida_idp.reg_info_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.compare (method)
    compare(self, r) -> int
    
    @param r: reg_info_t const &

ida_idp.reg_info_t.reg (variable)
    register number

ida_idp.reg_info_t.size (variable)
    register size

ida_idp.register_cfgopts (function)
    register_cfgopts(opts, nopts, cb=None, obj=None) -> bool
    
    @param opts: cfgopt_t const []
    @param nopts: size_t
    @param cb: config_changed_cb_t *
    @param obj: void *

ida_idp.set_processor_type (function)
    set_processor_type(procname, level) -> bool
    Set target processor type. Once a processor module is loaded, it cannot be
    replaced until we close the idb.
    
    @param procname: (C++: const char *) name of processor type (one of names present in
                     processor_t::psnames)
    @param level: (C++: setproc_level_t) SETPROC_
    @return: success

ida_idp.set_target_assembler (function)
    set_target_assembler(asmnum) -> bool
    Set target assembler.
    
    @param asmnum: (C++: int) number of assembler in the current processor module
    @return: success

ida_idp.sizeof_ldbl (function)
    sizeof_ldbl() -> size_t

ida_idp.str2reg (function)
    str2reg(p) -> int
    Get any reg number (-1 on error)
    
    @param p: (C++: const char *) char const *

ida_ieee (module)
    IEEE floating point functions.

ida_ieee.E_SPECIAL_EXP (variable)
    Exponent in fpvalue_t for NaN and Inf.

ida_ieee.FPV_BADARG (variable)
    wrong value of max_exp

ida_ieee.FPV_NAN (variable)
    NaN.

ida_ieee.FPV_NINF (variable)
    negative infinity

ida_ieee.FPV_NORM (variable)
    regular value

ida_ieee.FPV_PINF (variable)
    positive infinity

ida_ieee.IEEE_EXONE (variable)
    The exponent of 1.0.

ida_ieee.REAL_ERROR_FPOVER (variable)
    floating overflow or underflow

ida_ieee.REAL_ERROR_INTOVER (variable)
    eetol*: integer overflow

ida_ieee.REAL_ERROR_OK (variable)
    no error

ida_ieee.ecleaz (function)
    ecleaz(x)
    
    @param x: unsigned short [(6+3)]

ida_ieee.fpvalue_shorts_array_t (class)
    Proxy of C++ wrapped_array_t< uint16,FPVAL_NWORDS > class.

ida_ieee.fpvalue_shorts_array_t.__getitem__ (method)
    __getitem__(self, i) -> unsigned short const &
    
    @param i: size_t

ida_ieee.fpvalue_shorts_array_t.__init__ (method)
    __init__(self, data) -> fpvalue_shorts_array_t
    
    @param data: unsigned short (&)[FPVAL_NWORDS]

ida_ieee.fpvalue_shorts_array_t.__len__ (method)
    __len__(self) -> size_t

ida_ieee.fpvalue_shorts_array_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned short const &

ida_ieee.fpvalue_shorts_array_t._get_bytes (method)
    _get_bytes(self) -> bytevec_t

ida_ieee.fpvalue_shorts_array_t._set_bytes (method)
    _set_bytes(self, bts)
    
    Parameters
    ----------
    bts: bytevec_t const &

ida_ieee.fpvalue_t (class)
    Proxy of C++ fpvalue_t class.

ida_ieee.fpvalue_t.__add__ (method)
    __add__(self, o) -> fpvalue_t
    
    @param o: fpvalue_t const &

ida_ieee.fpvalue_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__getitem__ (method)

ida_ieee.fpvalue_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__init__ (method)
    __init__(self) -> fpvalue_t
    __init__(self, _in) -> fpvalue_t
    
    @param in: bytevec12_t const &

ida_ieee.fpvalue_t.__iter__ (method)

ida_ieee.fpvalue_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__mul__ (method)
    __mul__(self, o) -> fpvalue_t
    
    @param o: fpvalue_t const &

ida_ieee.fpvalue_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.__setitem__ (method)

ida_ieee.fpvalue_t.__str__ (method)
    __str__(self) -> qstring

ida_ieee.fpvalue_t.__sub__ (method)
    __sub__(self, o) -> fpvalue_t
    
    @param o: fpvalue_t const &

ida_ieee.fpvalue_t.__truediv__ (method)
    __truediv__(self, o) -> fpvalue_t
    
    @param o: fpvalue_t const &

ida_ieee.fpvalue_t._get_10bytes (method)
    _get_10bytes(self)

ida_ieee.fpvalue_t._get_bytes (method)
    _get_bytes(self)

ida_ieee.fpvalue_t._get_float (method)
    _get_float(self) -> double

ida_ieee.fpvalue_t._get_shorts (method)
    _get_shorts(self) -> fpvalue_shorts_array_t

ida_ieee.fpvalue_t._set_10bytes (method)
    _set_10bytes(self, _in)
    
    Parameters
    ----------
    in: bytevec10_t const &

ida_ieee.fpvalue_t._set_bytes (method)
    _set_bytes(self, _in)
    
    Parameters
    ----------
    in: bytevec12_t const &

ida_ieee.fpvalue_t._set_float (method)
    _set_float(self, v)
    
    Parameters
    ----------
    v: double

ida_ieee.fpvalue_t.assign (method)
    assign(self, r)
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.clear (method)
    clear(self)

ida_ieee.fpvalue_t.compare (method)
    compare(self, r) -> int
    
    @param r: fpvalue_t const &

ida_ieee.fpvalue_t.eabs (method)
    eabs(self)
    Calculate absolute value.

ida_ieee.fpvalue_t.fadd (method)
    fadd(self, y) -> fpvalue_error_t
    Arithmetic operations.
    
    @param y: (C++: const fpvalue_t &) fpvalue_t const &

ida_ieee.fpvalue_t.fdiv (method)
    fdiv(self, y) -> fpvalue_error_t
    
    @param y: fpvalue_t const &

ida_ieee.fpvalue_t.fmul (method)
    fmul(self, y) -> fpvalue_error_t
    
    @param y: fpvalue_t const &

ida_ieee.fpvalue_t.from_10bytes (method)
    from_10bytes(self, fpval) -> fpvalue_error_t
    Conversions for 10-byte floating point values.
    
    @param fpval: (C++: const void *) void const *

ida_ieee.fpvalue_t.from_12bytes (method)
    from_12bytes(self, fpval) -> fpvalue_error_t
    Conversions for 12-byte floating point values.
    
    @param fpval: (C++: const void *) void const *

ida_ieee.fpvalue_t.from_int64 (method)
    from_int64(self, x)
    
    @param x: int64

ida_ieee.fpvalue_t.from_str (method)
    from_str(self, p) -> fpvalue_error_t
    Convert string to IEEE.
    
    @param p_str: (C++: const char **) pointer to pointer to string. it will advanced.

ida_ieee.fpvalue_t.from_sval (method)
    from_sval(self, x)
    Convert integer to IEEE.
    
    @param x: (C++: sval_t)

ida_ieee.fpvalue_t.from_uint64 (method)
    from_uint64(self, x)
    
    @param x: uint64

ida_ieee.fpvalue_t.fsub (method)
    fsub(self, y) -> fpvalue_error_t
    
    @param y: fpvalue_t const &

ida_ieee.fpvalue_t.get_kind (method)
    get_kind(self) -> fpvalue_kind_t
    Get value kind.

ida_ieee.fpvalue_t.is_negative (method)
    is_negative(self) -> bool
    Is negative value?

ida_ieee.fpvalue_t.mul_pow2 (method)
    mul_pow2(self, power_of_2) -> fpvalue_error_t
    Multiply by a power of 2.
    
    @param power_of_2: (C++: int32)

ida_ieee.fpvalue_t.negate (method)
    negate(self)
    Negate.

ida_ieee.fpvalue_t.to_10bytes (method)
    to_10bytes(self, fpval) -> fpvalue_error_t
    
    @param fpval: void *

ida_ieee.fpvalue_t.to_12bytes (method)
    to_12bytes(self, fpval) -> fpvalue_error_t
    
    @param fpval: void *

ida_ieee.fpvalue_t.to_int64 (method)
    to_int64(self, round=False) -> fpvalue_error_t
    
    @param round: bool

ida_ieee.fpvalue_t.to_str (method)
    to_str(self, mode)
    Convert IEEE to string.
    
    @param mode: (C++: uint) broken down into:
    * low byte: number of digits after '.'
    * second byte: FPNUM_LENGTH
    * third byte: FPNUM_DIGITS

ida_ieee.fpvalue_t.to_sval (method)
    to_sval(self, round=False) -> fpvalue_error_t
    Convert IEEE to integer (+-0.5 if round)
    
    @param round: (C++: bool)

ida_ieee.fpvalue_t.to_uint64 (method)
    to_uint64(self, round=False) -> fpvalue_error_t
    
    @param round: bool

ida_kernwin (module)
    Defines the interface between the kernel and the UI.
    
    It contains:
    * the UI dispatcher notification codes (ui_notification_t)
    * convenience functions for UI services
    * structures which hold information about the lines (disassembly, structures,
    enums) generated by the kernel
    * functions to interact with the user (dialog boxes)
    * some string and conversion functions.

ida_kernwin.AA_CHECKABLE (variable)
    see update_action_checkable()

ida_kernwin.AA_CHECKED (variable)
    see update_action_checked()

ida_kernwin.AA_ICON (variable)
    see update_action_icon()

ida_kernwin.AA_LABEL (variable)
    see update_action_label()

ida_kernwin.AA_NONE (variable)
    no effect

ida_kernwin.AA_SHORTCUT (variable)
    see update_action_shortcut()

ida_kernwin.AA_STATE (variable)
    see update_action_state()

ida_kernwin.AA_TOOLTIP (variable)
    see update_action_tooltip()

ida_kernwin.AA_VISIBILITY (variable)
    see update_action_visibility()

ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION (variable)
    'cur_enum_member' and 'dirtree_selection' fields are present

ida_kernwin.ACF_HAS_SELECTION (variable)
    there is currently a valid selection

ida_kernwin.ACF_HAS_SOURCE (variable)
    'source' field is present

ida_kernwin.ACF_HAS_TYPE_REF (variable)
    'type_ref' field is present

ida_kernwin.ACF_XTRN_EA (variable)
    cur_ea is in 'externs' segment

ida_kernwin.ADF_CHECKABLE (variable)
    action is checkable

ida_kernwin.ADF_CHECKED (variable)
    starts in a checked state (requires ADF_CHECKABLE)

ida_kernwin.ADF_GLOBAL (variable)
    Register the action globally, so that it's available even if no IDB is present

ida_kernwin.ADF_NO_HIGHLIGHT (variable)
    After activating, do not update the highlight according to what's under the
    cursor (listings only.)

ida_kernwin.ADF_NO_UNDO (variable)
    the action does not create an undo point. useful for actions that do not modify
    the database.

ida_kernwin.ADF_OT_MASK (variable)
    Owner type mask.

ida_kernwin.ADF_OT_PLUGIN (variable)
    Owner is a plugin_t.

ida_kernwin.ADF_OT_PLUGMOD (variable)
    Owner is a plugmod_t.

ida_kernwin.ADF_OT_PROCMOD (variable)
    Owner is a procmod_t.

ida_kernwin.ADF_OWN_HANDLER (variable)
    handler is owned by the action; it'll be destroyed when the action is
    unregistered. Use DYNACTION_DESC_LITERAL to set this bit.

ida_kernwin.AHF_VERSION (variable)
    action handler version (used by action_handler_t::flags)

ida_kernwin.AHF_VERSION_MASK (variable)
    mask for action_handler_t::flags

ida_kernwin.ASKBTN_BTN1 (variable)
    First (Yes) button.

ida_kernwin.ASKBTN_BTN2 (variable)
    Second (No) button.

ida_kernwin.ASKBTN_BTN3 (variable)
    Third (Cancel) button.

ida_kernwin.ASKBTN_CANCEL (variable)
    Cancel button.

ida_kernwin.ASKBTN_NO (variable)
    No button.

ida_kernwin.ASKBTN_YES (variable)
    Yes button.

ida_kernwin.AST_DISABLE (variable)
    analog of AST_ENABLE

ida_kernwin.AST_DISABLE_ALWAYS (variable)
    disable action and do not call action_handler_t::action() anymore

ida_kernwin.AST_DISABLE_FOR_IDB (variable)
    analog of AST_ENABLE_FOR_IDB

ida_kernwin.AST_DISABLE_FOR_WIDGET (variable)
    analog of AST_ENABLE_FOR_WIDGET

ida_kernwin.AST_ENABLE (variable)
    enable action - call action_handler_t::update() when anything changes

ida_kernwin.AST_ENABLE_ALWAYS (variable)
    enable action and do not call action_handler_t::update() anymore

ida_kernwin.AST_ENABLE_FOR_IDB (variable)
    enable action for the current idb. call action_handler_t::update() when a
    database is opened/closed

ida_kernwin.AST_ENABLE_FOR_WIDGET (variable)
    enable action for the current widget. call action_handler_t::update() when a
    widget gets/loses focus

ida_kernwin.BWN_ADDRWATCH (variable)
    the 'Watch List' window

ida_kernwin.BWN_BOOKMARKS (variable)
    a persistent 'Bookmarks' widget

ida_kernwin.BWN_BPTS (variable)
    breakpoints

ida_kernwin.BWN_CALLS (variable)
    function calls

ida_kernwin.BWN_CALLS_CALLEES (variable)
    function calls, callees

ida_kernwin.BWN_CALLS_CALLERS (variable)
    function calls, callers

ida_kernwin.BWN_CALL_STACK (variable)
    call stack

ida_kernwin.BWN_CHOOSER (variable)
    a non-builtin chooser

ida_kernwin.BWN_CLI (variable)
    the command-line, in the output window

ida_kernwin.BWN_CMDPALCSR (variable)
    the command palette chooser (Qt version only)

ida_kernwin.BWN_CMDPALWIN (variable)
    the command palette window (Qt version only)

ida_kernwin.BWN_CPUREGS (variable)
    one of the 'General registers', 'FPU register', ... debugger windows

ida_kernwin.BWN_CUSTVIEW (variable)
    custom viewers

ida_kernwin.BWN_CV_LINE_INFOS (variable)
    custom viewers' lineinfo widget

ida_kernwin.BWN_DISASM (variable)
    disassembly views

ida_kernwin.BWN_DISASMS (variable)
    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

ida_kernwin.BWN_DISASM_ARROWS (variable)
    disassembly arrows widget

ida_kernwin.BWN_DUMP (variable)
    hex dumps

ida_kernwin.BWN_DUMPS (variable)
    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

ida_kernwin.BWN_ENUMS (variable)
    enumerations

ida_kernwin.BWN_EXPORTS (variable)
    exports

ida_kernwin.BWN_FRAME (variable)
    function frame

ida_kernwin.BWN_FUNCS (variable)
    functions

ida_kernwin.BWN_IMPORTS (variable)
    imports

ida_kernwin.BWN_LOCALS (variable)
    the 'locals' debugger window

ida_kernwin.BWN_LOCTYPS (variable)
    local types

ida_kernwin.BWN_MDVIEWCSR (variable)
    lumina metadata view chooser

ida_kernwin.BWN_MODULES (variable)
    modules

ida_kernwin.BWN_NAMES (variable)
    names

ida_kernwin.BWN_NAVBAND (variable)
    navigation band

ida_kernwin.BWN_NOTEPAD (variable)
    notepad

ida_kernwin.BWN_OUTPUT (variable)
    the text area, in the output window

ida_kernwin.BWN_PROBS (variable)
    problems

ida_kernwin.BWN_PSEUDOCODE (variable)
    hexrays decompiler views

ida_kernwin.BWN_SCRIPTS_CSR (variable)
    the "Recent scripts" chooser

ida_kernwin.BWN_SEARCH (variable)
    search results

ida_kernwin.BWN_SEARCHS (variable)
    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

ida_kernwin.BWN_SEGREGS (variable)
    segment registers

ida_kernwin.BWN_SEGS (variable)
    segments

ida_kernwin.BWN_SELS (variable)
    selectors

ida_kernwin.BWN_SHORTCUTCSR (variable)
    the shortcuts chooser (Qt version only)

ida_kernwin.BWN_SHORTCUTWIN (variable)
    the shortcuts window (Qt version only)

ida_kernwin.BWN_SIGNS (variable)
    signatures

ida_kernwin.BWN_SNIPPETS (variable)
    the 'Execute script' window

ida_kernwin.BWN_SNIPPETS_CSR (variable)
    the list of snippets in the 'Execute script' window

ida_kernwin.BWN_SO_OFFSETS (variable)
    the 'Structure offsets' dialog's offset panel

ida_kernwin.BWN_SO_STRUCTS (variable)
    the 'Structure offsets' dialog's 'Structures and Unions' panel

ida_kernwin.BWN_SRCPTHMAP_CSR (variable)
    "Source paths..."'s path mappings chooser

ida_kernwin.BWN_SRCPTHUND_CSR (variable)
    "Source paths..."'s undesired paths chooser

ida_kernwin.BWN_STACK (variable)
    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

ida_kernwin.BWN_STKVIEW (variable)
    the 'Stack view' debugger window

ida_kernwin.BWN_STRINGS (variable)
    strings

ida_kernwin.BWN_STRUCTS (variable)
    structures

ida_kernwin.BWN_THREADS (variable)
    threads

ida_kernwin.BWN_TILIST (variable)
    a types listing widget

ida_kernwin.BWN_TILS (variable)
    type libraries

ida_kernwin.BWN_TRACE (variable)
    tracing view

ida_kernwin.BWN_UNDOHIST (variable)
    Undo history.

ida_kernwin.BWN_UNKNOWN (variable)
    unknown window

ida_kernwin.BWN_WATCH (variable)
    the 'watches' debugger window

ida_kernwin.BWN_XREFS (variable)
    xrefs

ida_kernwin.CDVF_LINEICONS (variable)
    icons can be drawn over the line control

ida_kernwin.CDVF_NOLINES (variable)
    don't show line numbers

ida_kernwin.CDVF_STATUSBAR (variable)
    keep the status bar in the custom viewer

ida_kernwin.CDVH_LINES_ALIGNMENT (variable)
    see set_code_viewer_lines_alignment()

ida_kernwin.CDVH_LINES_CLICK (variable)
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_DBLCLICK (variable)
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_DRAWICON (variable)
    see code_viewer_lines_icon_t

ida_kernwin.CDVH_LINES_ICONMARGIN (variable)
    see set_code_viewer_lines_icon_margin()

ida_kernwin.CDVH_LINES_LINENUM (variable)
    see code_viewer_lines_linenum_t

ida_kernwin.CDVH_LINES_POPUP (variable)
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_RADIX (variable)
    see set_code_viewer_lines_radix()

ida_kernwin.CDVH_SRCVIEW (variable)
    see set_code_viewer_is_source()

ida_kernwin.CDVH_USERDATA (variable)
    see set_code_viewer_user_data()

ida_kernwin.CH2_LAZY_LOADED (variable)
    The chooser is lazy-loaded; it receives the callback do_lazy_load_dir() (only
    meaningful when CH_HAS_DIRTREE is set)

ida_kernwin.CHCOL_DEC (variable)
    decimal number

ida_kernwin.CHCOL_DEFHIDDEN (variable)
    column should be hidden by default

ida_kernwin.CHCOL_DRAGHINT (variable)
    the column number that will be used to build hints for the dragging undo label.
    This should be provided for at most one column for any given chooser.

ida_kernwin.CHCOL_EA (variable)
    address

ida_kernwin.CHCOL_FNAME (variable)
    function name. If a chooser column has this flag set and implements
    chooser_base_t::get_ea(), rows background colors will be automatically set to
    match the navigator's "Library function", "Lumina function" and "External
    symbol" colors

ida_kernwin.CHCOL_FORMAT (variable)
    column format mask

ida_kernwin.CHCOL_HEX (variable)
    hexadecimal number

ida_kernwin.CHCOL_INODENAME (variable)
    if CH_HAS_DIRTREE has been specified, this instructs the chooser that this
    column shows the inode name. This should be provided for at most one column for
    any given chooser.

ida_kernwin.CHCOL_PATH (variable)
    file path. TUI IDA will truncate excessive cell lengths starting at their
    beginning, and prepending the resulting text with "..." order to leave the
    filename visible

ida_kernwin.CHCOL_PLAIN (variable)
    plain string

ida_kernwin.CHITEM_BOLD (variable)
    display the item in bold

ida_kernwin.CHITEM_GRAY (variable)
    gray out the item

ida_kernwin.CHITEM_ITALIC (variable)
    display the item in italic

ida_kernwin.CHITEM_STRIKE (variable)
    strikeout the item

ida_kernwin.CHITEM_UNDER (variable)
    underline the item

ida_kernwin.CHOOSER_NOMAINMENU (variable)
    do not display main menu

ida_kernwin.CHOOSER_NOSTATUSBAR (variable)
    do not display status bar (obsolete. Use CH_NO_STATUS_BAR instead)

ida_kernwin.CH_ATTRS (variable)
    generate ui_get_chooser_item_attrs (gui only)

ida_kernwin.CH_BUILTIN_MASK (variable)
    Mask for builtin chooser numbers. Plugins should not use them.

ida_kernwin.CH_CAN_DEL (variable)
    allow to delete existing item(s)

ida_kernwin.CH_CAN_EDIT (variable)
    allow to edit existing item(s)

ida_kernwin.CH_CAN_INS (variable)
    allow to insert new items

ida_kernwin.CH_CAN_REFRESH (variable)
    allow to refresh chooser

ida_kernwin.CH_FORCE_DEFAULT (variable)
    if a non-modal chooser was already open, change selection to the default one

ida_kernwin.CH_HAS_DIFF (variable)
    The chooser can be used in a diffing/merging workflow.

ida_kernwin.CH_HAS_DIRTREE (variable)
    The chooser can provide a dirtree_t, meaning a tree-like structure can be
    provided to the user (instead of a flat table)

ida_kernwin.CH_KEEP (variable)
    The chooser instance's lifecycle is not tied to the lifecycle of the widget
    showing its contents. Closing the widget will not destroy the chooser structure.
    This allows for, e.g., static global chooser instances that don't need to be
    allocated on the heap. Also stack-allocated chooser instances must set this bit.

ida_kernwin.CH_MODAL (variable)
    Modal chooser.

ida_kernwin.CH_MULTI (variable)
    The chooser will allow multi-selection (only for GUI choosers). This bit is set
    when using the chooser_multi_t structure.

ida_kernwin.CH_MULTI_EDIT (variable)
    Obsolete.

ida_kernwin.CH_NOBTNS (variable)
    do not display ok/cancel/help/search buttons. Meaningful only for gui modal
    windows because non-modal windows do not have any buttons anyway. Text mode does
    not have them neither.

ida_kernwin.CH_NON_PERSISTED_TREE (variable)
    the chooser tree is not persisted (it is not loaded on startup and is not saved
    on exit)

ida_kernwin.CH_NO_FILTER (variable)
    The chooser will not have filtering abilities.

ida_kernwin.CH_NO_SORT (variable)
    The chooser will not have sorting abilities.

ida_kernwin.CH_NO_STATUS_BAR (variable)
    don't show a status bar

ida_kernwin.CH_QFLT (variable)
    open with quick filter enabled and focused

ida_kernwin.CH_QFTYP_DEFAULT (variable)
    set quick filtering type to the possible existing default for this chooser

ida_kernwin.CH_QFTYP_FUZZY (variable)
    fuzzy search quick filter type

ida_kernwin.CH_QFTYP_NORMAL (variable)
    normal (i.e., lexicographical) quick filter type

ida_kernwin.CH_QFTYP_REGEX (variable)
    regex quick filter type

ida_kernwin.CH_QFTYP_WHOLE_WORDS (variable)
    whole words quick filter type

ida_kernwin.CH_RENAME_IS_EDIT (variable)
    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit()
    callback for the corresponding row.

ida_kernwin.CH_RESTORE (variable)
    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version
    only)

ida_kernwin.CH_TM_FOLDERS_ONLY (variable)
    chooser will show in folders-only mode

ida_kernwin.CH_TM_FULL_TREE (variable)
    chooser will show in no-tree mode

ida_kernwin.CH_TM_NO_TREE (variable)
    chooser will show up in no-tree mode

ida_kernwin.CK_EXTRA1 (variable)
    extra background overlay #1

ida_kernwin.CK_EXTRA10 (variable)
    extra background overlay #10

ida_kernwin.CK_EXTRA11 (variable)
    extra background overlay #11

ida_kernwin.CK_EXTRA12 (variable)
    extra background overlay #12

ida_kernwin.CK_EXTRA13 (variable)
    extra background overlay #13

ida_kernwin.CK_EXTRA14 (variable)
    extra background overlay #14

ida_kernwin.CK_EXTRA15 (variable)
    extra background overlay #15

ida_kernwin.CK_EXTRA16 (variable)
    extra background overlay #16

ida_kernwin.CK_EXTRA2 (variable)
    extra background overlay #2

ida_kernwin.CK_EXTRA3 (variable)
    extra background overlay #3

ida_kernwin.CK_EXTRA4 (variable)
    extra background overlay #4

ida_kernwin.CK_EXTRA5 (variable)
    extra background overlay #5

ida_kernwin.CK_EXTRA6 (variable)
    extra background overlay #6

ida_kernwin.CK_EXTRA7 (variable)
    extra background overlay #7

ida_kernwin.CK_EXTRA8 (variable)
    extra background overlay #8

ida_kernwin.CK_EXTRA9 (variable)
    extra background overlay #9

ida_kernwin.CK_TRACE (variable)
    traced address

ida_kernwin.CK_TRACE_OVL (variable)
    overlay trace address

ida_kernwin.CLNL_FINDCMT (variable)
    Search for the comment symbol everywhere in the line, not only at the beginning.

ida_kernwin.CLNL_LTRIM (variable)
    Remove leading space characters.

ida_kernwin.CLNL_RTRIM (variable)
    Remove trailing space characters.

ida_kernwin.CREATETB_ADV (variable)
    toolbar is for 'advanced mode' only

ida_kernwin.CVH_CLICK (variable)
    see custom_viewer_click_t

ida_kernwin.CVH_CLOSE (variable)
    see custom_viewer_close_t

ida_kernwin.CVH_CURPOS (variable)
    see custom_viewer_curpos_t

ida_kernwin.CVH_DBLCLICK (variable)
    see custom_viewer_dblclick_t

ida_kernwin.CVH_HELP (variable)
    see custom_viewer_help_t

ida_kernwin.CVH_KEYDOWN (variable)
    see custom_viewer_keydown_t

ida_kernwin.CVH_MOUSEMOVE (variable)
    see custom_viewer_mouse_moved_t

ida_kernwin.CVH_POPUP (variable)
    see custom_viewer_popup_t

ida_kernwin.CVH_QT_AWARE (variable)
    see set_custom_viewer_qt_aware()

ida_kernwin.CVLF_USE_MOUSE (variable)
    Fetch the location from the mouse, instead of caret in the listing.

ida_kernwin.CVNF_ACT (variable)
    activate (i.e., switch to) the viewer. Activation is performed before the new
    lochist_entry_t instance is actually copied to the viewer's lochist_t
    (otherwise, if the viewer was invisible its on_location_changed() handler
    wouldn't be called.)

ida_kernwin.CVNF_JUMP (variable)
    push the current position in this viewer's lochist_t before going to the new
    location

ida_kernwin.CVNF_LAZY (variable)
    try and move the cursor to a line displaying the place_t if possible. This might
    disregard the Y position in case of success

ida_kernwin.Choose (class)
    The chooser can be used in a diffing/merging workflow

ida_kernwin.Choose.ALREADY_EXISTS (variable)
    the non-modal chooser with the same data is already open

ida_kernwin.Choose.Activate (method)
    Activates a visible chooser

ida_kernwin.Choose.AddCommand (method)

ida_kernwin.Choose.CH_CAN_DEL (variable)
    allow to delete existing item(s)

ida_kernwin.Choose.CH_CAN_EDIT (variable)
    allow to edit existing item(s)

ida_kernwin.Choose.CH_CAN_INS (variable)
    allow to insert new items

ida_kernwin.Choose.CH_CAN_REFRESH (variable)
    allow to refresh chooser

ida_kernwin.Choose.CH_FORCE_DEFAULT (variable)
    If a non-modal chooser was already open, change selection to the given
    default one

ida_kernwin.Choose.CH_MODAL (variable)
    Modal chooser

ida_kernwin.Choose.CH_MULTI (variable)
    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.

ida_kernwin.Choose.CH_NOIDB (variable)
    use the chooser even without an open database, same as x0=-2

ida_kernwin.Choose.CH_NO_STATUS_BAR (variable)
    don't show a status bar

ida_kernwin.Choose.CH_QFLT (variable)
    open with quick filter enabled and focused

ida_kernwin.Choose.CH_RENAME_IS_EDIT (variable)
    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell,
    should call the edit() callback for the corresponding row.

ida_kernwin.Choose.CH_RESTORE (variable)
    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)

ida_kernwin.Choose.Close (method)
    Closes the chooser

ida_kernwin.Choose.EMPTY_CHOOSER (variable)
    the chooser is initialized

ida_kernwin.Choose.Embedded (method)
    Creates an embedded chooser (as opposed to Show())
    @return: Returns 0 on success or NO_ATTR

ida_kernwin.Choose.GetEmbSelection (method)
    Deprecated. For embedded choosers, the selection is
    available through 'Form.EmbeddedChooserControl.selection'

ida_kernwin.Choose.GetWidget (method)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.Choose.NO_ATTR (variable)
    some mandatory attribute is missing

ida_kernwin.Choose.NO_SELECTION (variable)
    there is no selected item

ida_kernwin.Choose.OnClose (method)
    The chooser window is closed.

ida_kernwin.Choose.OnDeleteLine (method)
    User deleted an element
    
    @param sel: the current selection
    @return: a tuple (changed, selection)

ida_kernwin.Choose.OnEditLine (method)
    User asked to edit an element.
    
    @param sel: the current selection
    @return: a tuple (changed, selection)

ida_kernwin.Choose.OnGetDirTree (method)
    Get the dirtree_t that will be used to present a tree-like
    structure to the user (see CH_HAS_DIRTREE)
    
    @return: the dirtree_t, or None

ida_kernwin.Choose.OnGetEA (method)
    Get the address of an element
    
    When this function returns valid addresses:
      * If any column has the `CHCOL_FNAME` flag, rows will
        be colored according to the attributes of the functions
        who own those addresses (extern, library function,
        Lumina, ... - similar to what the "Functions" widget does)
      * When a selection is present and the user presses `<Enter>`
        (`<Shift+Enter>` if the chooser is modal), IDA will jump
        to that address (through jumpto())
    @param n: element number (0-based)
    @return: the effective address, ida_idaapi.BADADDR if the element has no address

ida_kernwin.Choose.OnGetIcon (method)
    Get an icon to associate with the first cell of an element
    
    @param n: index of the element
    @return: an icon ID

ida_kernwin.Choose.OnGetLine (method)
    Get data for an element
    
    This callback is mandatory
    
    @param n: the index to fetch data for
    @return: a list of strings

ida_kernwin.Choose.OnGetLineAttr (method)
    Get attributes for an element
    
    @param n: index of the element
    @return: a tuple (color, flags)

ida_kernwin.Choose.OnGetSize (method)
    Get the number of elements in the chooser.
    
    This callback is mandatory
    
    @return: the number of elements

ida_kernwin.Choose.OnIndexToDiffpos (method)
    Map an element index to a diffpos_t
    
    This callback is mandatory if CH_HAS_DIFF is specified
    
    @param n: index of the element
    @return: the diffpos

ida_kernwin.Choose.OnIndexToInode (method)
    Map an element index to a dirtree_t inode
    
    This callback is mandatory if CH_HAS_DIRTREE is specified
    
    @param n: index of the element
    @return: the inode number

ida_kernwin.Choose.OnInit (method)
    Initialize the chooser and populate it.
    
    This callback is optional

ida_kernwin.Choose.OnInsertLine (method)
    User asked to insert an element
    
    @param sel: the current selection
    @return: a tuple (changed, selection)

ida_kernwin.Choose.OnLazyLoadDir (method)
    Callback for lazy-loaded, dirtree-based choosers;
    the function will be called when a folder is expanded and it has
    not been loaded before. The implementation should use the
    given dirtree's link() or mkdir() methods to add the folder contents.
    
    @param path: an absolute dirtree path to the directory that is being expanded
    @return: success

ida_kernwin.Choose.OnPopup (method)

ida_kernwin.Choose.OnRefresh (method)
    The chooser needs to be refreshed.
    It returns the new positions of the selected items.
    
    @param sel: the current selection
    @return: a tuple (changed, selection)

ida_kernwin.Choose.OnSelectLine (method)
    User pressed the enter key, or double-clicked a selection
    
    @param sel: the current selection
    @return: a tuple (changed, selection)

ida_kernwin.Choose.OnSelectionChange (method)
    Selection changed
    
    @param sel: the new selection

ida_kernwin.Choose.Refresh (method)
    Causes the refresh callback to trigger

ida_kernwin.Choose.Show (method)
    Activates or creates a chooser window
    @param modal: Display as modal dialog
    @return: For all choosers it will return NO_ATTR if some mandatory
             attribute is missing. The mandatory attributes are: flags,
             title, cols, OnGetSize(), OnGetLine();
             For modal choosers it will return the selected item index (0-based),
             or NO_SELECTION if no selection,
             or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
             For non-modal choosers it will return 0
             or ALREADY_EXISTS if the chooser was already open and is active now;

ida_kernwin.Choose.UI_Hooks_Trampoline (class)

ida_kernwin.Choose.UI_Hooks_Trampoline.__init__ (method)

ida_kernwin.Choose.UI_Hooks_Trampoline.populating_widget_popup (method)

ida_kernwin.Choose.__init__ (method)
    Constructs a chooser window.
    @param title: The chooser title
    @param cols: a list of colums; each list item is a list of two items
        example: [ ["Address", 10 | Choose.CHCOL_HEX],
                   ["Name",    30 | Choose.CHCOL_PLAIN] ]
    @param flags: One of CH_XXXX constants
    @param flags2: One of CH2_XXXX constants
    @param deflt: The index of the default item (0-based) for single
        selection choosers or the list of indexes for multi selection
        chooser
    @param popup_names: List of new captions to replace this list
        ["Insert", "Delete", "Edit", "Refresh"]
    @param icon: Icon index (the icon should exist in ida resources or
        an index to a custom loaded icon)
    @param x1: , y1, x2, y2: The default location (for txt-version)
    @param embedded: Create as embedded chooser
    @param width: Embedded chooser width
    @param height: Embedded chooser height
    @param forbidden_cb: Explicitly forbidden callbacks

ida_kernwin.Choose.__init__._qccb (function)

ida_kernwin.Choose.adjust_last_item (method)
    Helper for OnDeleteLine() and OnRefresh() callbacks.
    They can be finished by the following line:
    return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
    @param line: number of the remaining select item
    @return: list of selected lines numbers (one element or empty)

ida_kernwin.CustomIDAMemo (class)

ida_kernwin.CustomIDAMemo.CreateGroups (method)
    Send a request to modify the graph by creating a
    (set of) group(s), and perform an animation.
    
    Each object in the 'groups_infos' list must be of the format:
    {
      "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
      "text" : <string>                    # The synthetic text for that group
    }
    
    @param groups_infos: A list of objects that describe those groups.
    @return: A [<int>, <int>, ...] list of group nodes, or None (failure).

ida_kernwin.CustomIDAMemo.DelNodesInfos (method)
    Delete the properties for the given node(s).
    
    @param nodes: A list of node IDs

ida_kernwin.CustomIDAMemo.DeleteGroups (method)
    Send a request to delete the specified groups in the graph,
    and perform an animation.
    
    @param groups: A list of group node numbers.
    @param new_current: A node to focus on after the groups have been deleted
    @return: True on success, False otherwise.

ida_kernwin.CustomIDAMemo.GetCurrentRendererType (method)

ida_kernwin.CustomIDAMemo.GetNodeInfo (method)
    Get the properties for the given node.
    
    @param ni: A node_info_t instance
    @param node: The index of the node.
    @return: success

ida_kernwin.CustomIDAMemo.GetWidget (method)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.CustomIDAMemo.GetWidgetAsGraphViewer (method)
    Return the graph_viewer_t underlying this view.
    
    @return: The graph_viewer_t underlying this view, or None.

ida_kernwin.CustomIDAMemo.Refresh (method)
    Refreshes the view. This causes the OnRefresh() to be called

ida_kernwin.CustomIDAMemo.SetCurrentRendererType (method)
    Set the current view's renderer.
    
    @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.

ida_kernwin.CustomIDAMemo.SetGroupsVisibility (method)
    Send a request to expand/collapse the specified groups in the graph,
    and perform an animation.
    
    @param groups: A list of group node numbers.
    @param expand: True to expand the group, False otherwise.
    @param new_current: A node to focus on after the groups have been expanded/collapsed.
    @return: True on success, False otherwise.

ida_kernwin.CustomIDAMemo.SetNodeInfo (method)
    Set the properties for the given node.
    
    Example usage (set second nodes's bg color to red):
      inst = ...
      p = idaapi.node_info_t()
      p.bg_color = 0x00ff0000
      inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
    
    @param node_index: The node index.
    @param node_info: An idaapi.node_info_t instance.
    @param flags: An OR'ed value of NIF_* values.

ida_kernwin.CustomIDAMemo.SetNodesInfos (method)
    Set the properties for the given nodes.
    
    Example usage (set first three nodes's bg color to purple):
      inst = ...
      p = idaapi.node_info_t()
      p.bg_color = 0x00ff00ff
      inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
    
    @param values: A dictionary of 'int -> node_info_t' objects.

ida_kernwin.CustomIDAMemo._OnBind (method)

ida_kernwin.CustomIDAMemo.__init__ (method)

ida_kernwin.CustomIDAMemo._dummy_cb (method)

ida_kernwin.CustomIDAMemo._get_cb (method)

ida_kernwin.CustomIDAMemo._get_cb_arity (method)

ida_kernwin.CustomIDAMemo._graph_item_tuple (method)

ida_kernwin.CustomIDAMemo.view_activated (method)

ida_kernwin.CustomIDAMemo.view_click (method)

ida_kernwin.CustomIDAMemo.view_close (method)

ida_kernwin.CustomIDAMemo.view_curpos (method)

ida_kernwin.CustomIDAMemo.view_dblclick (method)

ida_kernwin.CustomIDAMemo.view_deactivated (method)

ida_kernwin.CustomIDAMemo.view_keydown (method)

ida_kernwin.CustomIDAMemo.view_loc_changed (method)

ida_kernwin.CustomIDAMemo.view_mouse_moved (method)

ida_kernwin.CustomIDAMemo.view_mouse_over (method)

ida_kernwin.CustomIDAMemo.view_switched (method)

ida_kernwin.DP_BEFORE (variable)
    Place src_form before dst_form in the tab bar instead of after; used with
    DP_INSIDE or DP_TAB.

ida_kernwin.DP_BOTTOM (variable)
    Dock src_form below dest_form.

ida_kernwin.DP_FLOATING (variable)
    Make src_form floating.

ida_kernwin.DP_INSIDE (variable)
    Create a new tab bar with both src_form and dest_form.

ida_kernwin.DP_LEFT (variable)
    Dock src_form to the left of dest_form.

ida_kernwin.DP_RIGHT (variable)
    Dock src_form to the right of dest_form.

ida_kernwin.DP_SZHINT (variable)
    When floating or in a splitter (i.e., not tabbed), use the widget's size hint to
    determine the best geometry (Qt only)

ida_kernwin.DP_TAB (variable)
    Place src_form into a tab next to dest_form, if dest_form is in a tab bar
    (otherwise the same as DP_INSIDE)

ida_kernwin.DP_TOP (variable)
    Dock src_form above dest_form.

ida_kernwin.Form (class)

ida_kernwin.Form.Add (method)
    Low level function. Prefer AddControls() to this function.
    This function adds one control to the form.
    
    @param name: Control name
    @param ctrl: Control object
    @param mkattr: Create control name / control object as a form attribute

ida_kernwin.Form.AddControls (method)
    Adds controls from a dictionary.
    The dictionary key is the control name and the value is a Form.Control object
    @param controls: The control dictionary

ida_kernwin.Form.ButtonInput (class)
    Button control.
    A handler along with a 'code' (numeric value) can be associated with the button.
    This way one handler can handle many buttons based on the button code (or in other terms id or tag)

ida_kernwin.Form.ButtonInput.__init__ (method)
    @param handler: Button handler. A callback taking one argument which is the code.
    @param code: A code associated with the button and that is later passed to the handler.

ida_kernwin.Form.ButtonInput.helper_cb (method)

ida_kernwin.Form.ButtonInput.is_input_field (method)

ida_kernwin.Form.ChkGroupControl (class)
    Checkbox group control class.
    It holds a set of checkbox controls

ida_kernwin.Form.ChkGroupControl.ItemClass (variable)
    Group control item factory class instance
    We need this because later we won't be treating ChkGroupControl or RadGroupControl
    individually, instead we will be working with GroupControl in general.

ida_kernwin.Form.ChkGroupControl.__init__ (method)

ida_kernwin.Form.ChkGroupItemControl (class)
    Checkbox group item control

ida_kernwin.Form.ChkGroupItemControl.__get_value (method)

ida_kernwin.Form.ChkGroupItemControl.__init__ (method)

ida_kernwin.Form.ChkGroupItemControl.__set_value (method)

ida_kernwin.Form.ChkGroupItemControl.checked (variable)
    Get/Sets checkbox item check status

ida_kernwin.Form.Close (method)
    Close the form
    @param close_normally
               1: form is closed normally as if the user pressed Enter
               0: form is closed abnormally as if the user pressed Esc
    @return: None

ida_kernwin.Form.ColorInput (class)
    Color button input control

ida_kernwin.Form.ColorInput.__init__ (method)
    @param value: Initial color value in RGB

ida_kernwin.Form.Compile (method)
    Compiles a form and returns the form object (self) and the argument list.
    The form object will contain object names corresponding to the form elements
    
    @return: It will raise an exception on failure. Otherwise the return value is ignored

ida_kernwin.Form.CompileEx (method)
    Low level function.
    Compiles (parses the form syntax and adds the control) the form string and
    returns the argument list to be passed the argument list to ask_form().
    
    The form controls are wrapped inside curly braces: {ControlName}.
    
    A special operator can be used to return the index of a given control by its name: {id:ControlName}.
    This is useful when you use the STARTITEM form keyword to set the initially focused control.
    (note that, technically, the index is not the same as the ID; that's because STARTITEM
    uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
    
    @param form: Compiles the form and returns the arguments needed to be passed to ask_form()

ida_kernwin.Form.CompileEx.next_control (function)

ida_kernwin.Form.Compiled (method)
    Checks if the form has already been compiled
    
    @return: Boolean

ida_kernwin.Form.Control (class)

ida_kernwin.Form.Control.__init__ (method)
    Reference to the parent form. It is filled by Form.Add()

ida_kernwin.Form.Control.free (method)
    Free the control

ida_kernwin.Form.Control.get_arg (method)
    Control returns the parameter to be pushed on the stack
    (Of ask_form())

ida_kernwin.Form.Control.get_tag (method)
    Control tag character. One of Form.FT_XXXX.
    The form class will expand the {} notation and replace them with the tags

ida_kernwin.Form.Control.is_input_field (method)
    Return True if this field acts as an input

ida_kernwin.Form.ControlToFieldTypeIdAndSize (method)
    Converts a control object to a tuple containing the field id
    and the associated buffer size

ida_kernwin.Form.DirInput (class)
    Directory browsing control

ida_kernwin.Form.DirInput.__init__ (method)

ida_kernwin.Form.DropdownListControl (class)
    Dropdown control
    This control allows manipulating a dropdown control

ida_kernwin.Form.DropdownListControl.__get_selval (method)

ida_kernwin.Form.DropdownListControl.__init__ (method)
    @param items: A string list of items used to prepopulate the control
    @param readonly: Specifies whether the dropdown list is editable or not
    @param selval: The preselected item index (when readonly) or text value (when editable)
    @param width: the control width (n/a if the dropdown list is readonly)
    @param swidth: string width

ida_kernwin.Form.DropdownListControl.__set_selval (method)

ida_kernwin.Form.DropdownListControl.free (method)

ida_kernwin.Form.DropdownListControl.selval (variable)
    Read/write the selection value.
    The value is used as an item index in readonly mode or text value in editable mode
    This value can be used only after the form has been closed.

ida_kernwin.Form.DropdownListControl.set_items (method)
    Sets the dropdown list items

ida_kernwin.Form.EmbeddedChooserControl (class)
    Embedded chooser control.
    This control links to a Chooser2 control created with the 'embedded=True'

ida_kernwin.Form.EmbeddedChooserControl.__get_selection__ (method)

ida_kernwin.Form.EmbeddedChooserControl.__init__ (method)
    Embedded chooser control
    
    @param chooser: A chooser2 instance (must be constructed with 'embedded=True')

ida_kernwin.Form.EmbeddedChooserControl.free (method)
    Frees the embedded chooser data

ida_kernwin.Form.EmbeddedChooserControl.selection (variable)
    Returns the selection

ida_kernwin.Form.EmbeddedChooserControl.value (variable)
    Returns the embedded chooser instance

ida_kernwin.Form.EnableField (method)
    Enable or disable an input field
    @return: False - no such control

ida_kernwin.Form.Execute (method)
    Displays a modal dialog containing the compiled form.
    @return: 1 - ok ; 0 - cancel

ida_kernwin.Form.FT_ADDR (variable)
    Address - ea_t *

ida_kernwin.Form.FT_ASCII (variable)
    Ascii string - char *

ida_kernwin.Form.FT_BIN (variable)
    Binary number, 0b prefix - sval_t *

ida_kernwin.Form.FT_BUTTON (variable)
    Button - def handler(code)

ida_kernwin.Form.FT_CHAR (variable)
    Char value -- sval_t *

ida_kernwin.Form.FT_COLOR (variable)
    Color button - bgcolor_t *

ida_kernwin.Form.FT_DEC (variable)
    Decimal number - sval_t *

ida_kernwin.Form.FT_DIR (variable)
    Path to directory - char * at least QMAXPATH

ida_kernwin.Form.FT_DROPDOWN_LIST (variable)
    Dropdown list control - Form.DropdownControl

ida_kernwin.Form.FT_ECHOOSER (variable)
    Embedded chooser - idaapi.Choose

ida_kernwin.Form.FT_FILE (variable)
    File browse - char * at least QMAXPATH

ida_kernwin.Form.FT_FORMCHG (variable)
    Form change callback - formchgcb_t

ida_kernwin.Form.FT_HEX (variable)
    Hex number - uval_t *

ida_kernwin.Form.FT_HTML_LABEL (variable)
    HTML label to display (only for GUI version, and for dynamic labels; no input)

ida_kernwin.Form.FT_IDENT (variable)
    Identifier - char * at least MAXNAMELEN

ida_kernwin.Form.FT_INT64 (variable)
    default base int64 - int64

ida_kernwin.Form.FT_MULTI_LINE_TEXT (variable)
    Multi text control - textctrl_info_t

ida_kernwin.Form.FT_OCT (variable)
    Octal number, C notation - sval_t *

ida_kernwin.Form.FT_RAWHEX (variable)
    Hex number, no 0x prefix - uval_t *

ida_kernwin.Form.FT_SEG (variable)
    Segment - sel_t *

ida_kernwin.Form.FT_SHEX (variable)
    Signed hex number - sval_t *

ida_kernwin.Form.FT_TYPE (variable)
    Type declaration - char * at least MAXSTR

ida_kernwin.Form.FT_UINT64 (variable)
    default base uint64 - uint64

ida_kernwin.Form.FileInput (class)
    File Open/Save input control

ida_kernwin.Form.FileInput.__init__ (method)

ida_kernwin.Form.FindControlById (method)
    Finds a control instance given its id

ida_kernwin.Form.FormChangeCb (class)
    Form change handler.
    This can be thought of like a dialog procedure.
    Everytime a form action occurs, this handler will be called along with the control id.
    The programmer can then call various form actions accordingly:
      - EnableField
      - ShowField
      - MoveField
      - GetFieldValue
      - etc...
    
    Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

ida_kernwin.Form.FormChangeCb.__init__ (method)
    Constructs the handler.
    @param handler: The handler (preferrably a member function of a class derived from the Form class).

ida_kernwin.Form.FormChangeCb.free (method)

ida_kernwin.Form.FormChangeCb.get_tag (method)

ida_kernwin.Form.FormChangeCb.helper_cb (method)

ida_kernwin.Form.Free (method)
    Frees all resources associated with a compiled form.
    Make sure you call this function when you finish using the form.

ida_kernwin.Form.GetControlValue (method)
    Returns the control's value depending on its type
    @param ctrl: Form control instance
    @return:     - color button, radio controls: integer
        - file/dir input, string input and string label: string
        - embedded chooser control (0-based indices of selected items): integer list
        - for multilinetext control: textctrl_info_t
        - dropdown list controls: string (when editable) or index (when readonly)
        - None: on failure

ida_kernwin.Form.GetFocusedField (method)
    Get currently focused input field.
    @return: None if no field is selected otherwise the control ID

ida_kernwin.Form.GroupControl (class)
    Base class for group controls

ida_kernwin.Form.GroupControl.__init__ (method)

ida_kernwin.Form.GroupControl._reset (method)

ida_kernwin.Form.GroupControl.get_tag (method)

ida_kernwin.Form.GroupControl.next_child_pos (method)

ida_kernwin.Form.GroupItemControl (class)
    Base class for group control items

ida_kernwin.Form.GroupItemControl.__init__ (method)

ida_kernwin.Form.GroupItemControl.assign_pos (method)

ida_kernwin.Form.GroupItemControl.get_tag (method)

ida_kernwin.Form.GroupItemControl.is_input_field (method)

ida_kernwin.Form.InputControl (class)
    Generic form input control.
    It could be numeric control, string control, directory/file browsing, etc...

ida_kernwin.Form.InputControl.__init__ (method)
    @param width:  The maximum possible number of characters that
                   can be entered into the input field
    @param swidth: The width of visible part of the input field

ida_kernwin.Form.InputControl.get_tag (method)

ida_kernwin.Form.InputControl.is_input_field (method)

ida_kernwin.Form.LabelControl (class)
    Base class for static label control

ida_kernwin.Form.LabelControl.__init__ (method)

ida_kernwin.Form.LabelControl.get_tag (method)

ida_kernwin.Form.MoveField (method)
    Move/resize an input field
    
    @return: False - no such fiel

ida_kernwin.Form.MultiLineTextControl (class)
    Multi line text control.
    This class inherits from textctrl_info_t. Thus the attributes are also inherited
    This control allows manipulating a multilinetext control

ida_kernwin.Form.MultiLineTextControl.__init__ (method)
    @param text: Initial text value
    @param flags: One of textctrl_info_t.TXTF_.... values
    @param tabsize: Tab size
    @param width: Display width
    @param swidth: String width

ida_kernwin.Form.MultiLineTextControl.free (method)

ida_kernwin.Form.NumericArgument (class)
    Argument representing various integer arguments (ushort, uint32, uint64, etc...)
    @param tp: One of Form.FT_XXX

ida_kernwin.Form.NumericArgument.__init__ (method)

ida_kernwin.Form.NumericArgument.__set_value (method)

ida_kernwin.Form.NumericInput (class)
    A composite class serving as a base numeric input control class

ida_kernwin.Form.NumericInput.__init__ (method)

ida_kernwin.Form.NumericLabel (class)
    Numeric label control

ida_kernwin.Form.NumericLabel.__init__ (method)

ida_kernwin.Form.Open (method)
    Opens a widget containing the compiled form.

ida_kernwin.Form.RadGroupControl (class)
    Radiobox group control class.
    It holds a set of radiobox controls

ida_kernwin.Form.RadGroupControl.__init__ (method)
    Creates a radiogroup control.
    @param children_names: A tuple containing group item names
    @param value: Initial selected radio item
    @param secondory: Allows rendering one the same line as the previous group control.
                      Use this if you have another group control on the same line.

ida_kernwin.Form.RadGroupItemControl (class)
    Radiobox group item control

ida_kernwin.Form.RadGroupItemControl.__get_value (method)

ida_kernwin.Form.RadGroupItemControl.__init__ (method)

ida_kernwin.Form.RadGroupItemControl.__set_value (method)

ida_kernwin.Form.RadGroupItemControl.selected (variable)
    Get/Sets radiobox item selection status

ida_kernwin.Form.RefreshField (method)
    Refresh a field
    @return: False - no such control

ida_kernwin.Form.SetControlValue (method)
    Set the control's value depending on its type
    @param ctrl: Form control instance
    @param value
        - embedded chooser: a 0-base indices list to select embedded chooser items
        - multilinetext: a textctrl_info_t
        - dropdown list: an integer designating the selection index if readonly
                         a string designating the edit control value if not readonly
    @return: Boolean true on success

ida_kernwin.Form.SetFocusedField (method)
    Set currently focused input field
    @return: False - no such control

ida_kernwin.Form.ShowField (method)
    Show or hide an input field
    @return: False - no such control

ida_kernwin.Form.StringArgument (class)
    Argument representing a character buffer

ida_kernwin.Form.StringArgument.__get_value (method)

ida_kernwin.Form.StringArgument.__init__ (method)

ida_kernwin.Form.StringArgument.__set_value (method)

ida_kernwin.Form.StringInput (class)
    Base string input control class.
    This class also constructs a StringArgument

ida_kernwin.Form.StringInput.__init__ (method)
    @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                  If you want to define the string buffer size then pass the 'size' argument
    @param swidth: Control width
    @param value: Initial value
    @param size: String size

ida_kernwin.Form.StringLabel (class)
    String label control

ida_kernwin.Form.StringLabel.__init__ (method)
    Type field can be one of:
    A - ascii string
    T - type declaration
    I - ident
    F - folder
    f - file
    X - command

ida_kernwin.Form._AddGroup (method)
    Internal function.
    This function expands the group item names and creates individual group item controls
    
    @param Group: The group class (checkbox or radio group class)

ida_kernwin.Form._ChkCompiled (method)

ida_kernwin.Form._FT_USHORT (variable)
    Unsigned short

ida_kernwin.Form._ParseFormTitle (method)
    Parses the form's title from the form text

ida_kernwin.Form.__getitem__ (method)
    Returns a control object by name

ida_kernwin.Form.__init__ (method)
    If non-modal, these flags will be passed to open_form.
    This is an OR'ed combination of the PluginForm.FORM_* values.

ida_kernwin.Form._reset (method)
    Resets the Form class state variables

ida_kernwin.Form.create_string_buffer (method)

ida_kernwin.Form.fieldtype_to_ctype (method)
    Factory method returning a ctype class corresponding to the field type string

ida_kernwin.GCRF_ALL (variable)
    Return all rows.

ida_kernwin.GCRF_CURRENT (variable)
    Return the current row.

ida_kernwin.GCRF_HEADER (variable)
    Return header texts.

ida_kernwin.GCRF_SELECTION (variable)
    Return selected rows.

ida_kernwin.HIF_IDENTIFIER (variable)
    text is an identifier (i.e., when searching for the current highlight,
    SEARCH_IDENT will be used)

ida_kernwin.HIF_LOCKED (variable)
    locked; clicking/moving the cursor around doesn't change the highlight

ida_kernwin.HIF_NOCASE (variable)
    case insensitive

ida_kernwin.HIF_REGISTER (variable)
    text represents a register (aliases/subregisters will be highlit as well)

ida_kernwin.HIF_SLOT_0 (variable)
    operate on slot 0

ida_kernwin.HIF_SLOT_1 (variable)
    operate on slot 1

ida_kernwin.HIF_SLOT_2 (variable)
    operate on slot 2

ida_kernwin.HIF_SLOT_3 (variable)
    operate on slot 3

ida_kernwin.HIF_SLOT_4 (variable)
    operate on slot 4

ida_kernwin.HIF_SLOT_5 (variable)
    operate on slot 5

ida_kernwin.HIF_SLOT_6 (variable)
    operate on slot 6

ida_kernwin.HIF_SLOT_7 (variable)
    operate on slot 7

ida_kernwin.HIF_SLOT_SHIFT (variable)
    position of the 3 top bits specifying which highlight to use

ida_kernwin.HIF_USE_SLOT (variable)
    use the given number, or just use the "floating" highlight

ida_kernwin.HIST_CMD (variable)
    commands

ida_kernwin.HIST_CMT (variable)
    comments

ida_kernwin.HIST_DIR (variable)
    directory names (text version only)

ida_kernwin.HIST_FILE (variable)
    file names

ida_kernwin.HIST_IDENT (variable)
    identifiers. usually CPU register names are forbidden

ida_kernwin.HIST_IDENT2 (variable)
    identifiers, including CPU register names

ida_kernwin.HIST_SEG (variable)
    segment names

ida_kernwin.HIST_SRCH (variable)
    search substrings

ida_kernwin.HIST_TYPE (variable)
    type declarations

ida_kernwin.IDAViewWrapper (class)
    Deprecated. Use View_Hooks instead.
    
    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)

ida_kernwin.IDAViewWrapper.Bind (method)

ida_kernwin.IDAViewWrapper.Unbind (method)

ida_kernwin.IDAViewWrapper.__init__ (method)

ida_kernwin.IDA_DEBUG_ACCESSIBILITY (variable)
    accessibility

ida_kernwin.IDA_DEBUG_ALREADY (variable)
    already data or code

ida_kernwin.IDA_DEBUG_ALWAYS (variable)
    everything

ida_kernwin.IDA_DEBUG_APPCALL (variable)
    appcall

ida_kernwin.IDA_DEBUG_CHECKMEM (variable)
    check heap consistency

ida_kernwin.IDA_DEBUG_CONFIG (variable)
    config file

ida_kernwin.IDA_DEBUG_DBGINFO (variable)
    handling of debug info (e.g. pdb, dwarf)

ida_kernwin.IDA_DEBUG_DEBUGGER (variable)
    debugger

ida_kernwin.IDA_DEBUG_DEMANGLE (variable)
    demangler

ida_kernwin.IDA_DEBUG_DREFS (variable)
    drefs

ida_kernwin.IDA_DEBUG_FLIRT (variable)
    flirt

ida_kernwin.IDA_DEBUG_IDP (variable)
    idp module

ida_kernwin.IDA_DEBUG_IDS (variable)
    ids files

ida_kernwin.IDA_DEBUG_INTERNET (variable)
    internet connection (for API backward compatibility)

ida_kernwin.IDA_DEBUG_LDR (variable)
    ldr module

ida_kernwin.IDA_DEBUG_LICENSE (variable)
    licensing

ida_kernwin.IDA_DEBUG_LUMINA (variable)
    lumina related

ida_kernwin.IDA_DEBUG_NETWORK (variable)
    network

ida_kernwin.IDA_DEBUG_NOTIFY (variable)
    show all notifications

ida_kernwin.IDA_DEBUG_OFFSET (variable)
    offsets

ida_kernwin.IDA_DEBUG_PLUGIN (variable)
    plugin module

ida_kernwin.IDA_DEBUG_QUEUE (variable)
    queue

ida_kernwin.IDA_DEBUG_REGEX (variable)
    regular expression

ida_kernwin.IDA_DEBUG_ROLLBACK (variable)
    rollback

ida_kernwin.IDA_DEBUG_SIMPLEX (variable)
    full stack analysis

ida_kernwin.IDA_DEBUG_SRCDBG (variable)
    source debugging

ida_kernwin.IDA_DEBUG_SUBPROC (variable)
    sub process

ida_kernwin.IDA_DEBUG_THEMES (variable)
    themes

ida_kernwin.IDA_DEBUG_TIL (variable)
    type system

ida_kernwin.IDCHK_ARG (variable)
    bad argument(s)

ida_kernwin.IDCHK_KEY (variable)
    bad hotkey name

ida_kernwin.IDCHK_MAX (variable)
    too many IDC hotkeys

ida_kernwin.IDCHK_OK (variable)
    ok

ida_kernwin.IWID_ADDRWATCH (variable)
    address watches (47)

ida_kernwin.IWID_ALL (variable)
    mask

ida_kernwin.IWID_BOOKMARKS (variable)
    bookmarks list (59)

ida_kernwin.IWID_BPTS (variable)
    breakpoints (13)

ida_kernwin.IWID_CALLS (variable)
    function calls (11)

ida_kernwin.IWID_CALLS_CALLEES (variable)
    funcalls, callees (50)

ida_kernwin.IWID_CALLS_CALLERS (variable)
    funcalls, callers (49)

ida_kernwin.IWID_CALL_STACK (variable)
    call stack (17)

ida_kernwin.IWID_CHOOSER (variable)
    chooser (37)

ida_kernwin.IWID_CLI (variable)
    input line (33)

ida_kernwin.IWID_CMDPALCSR (variable)
    command palette (43)

ida_kernwin.IWID_CMDPALWIN (variable)
    command palette (44)

ida_kernwin.IWID_CPUREGS (variable)
    registers (40)

ida_kernwin.IWID_CUSTVIEW (variable)
    custom viewers (46)

ida_kernwin.IWID_CV_LINE_INFOS (variable)
    lineinfo widget (53)

ida_kernwin.IWID_DISASM (variable)
    disassembly views (29)

ida_kernwin.IWID_DISASM_ARROWS (variable)
    arrows widget (52)

ida_kernwin.IWID_DUMP (variable)
    hex dumps (30)

ida_kernwin.IWID_ENUMS (variable)
    enumerations (27)

ida_kernwin.IWID_EXPORTS (variable)
    exports (0)

ida_kernwin.IWID_FRAME (variable)
    function frame (25)

ida_kernwin.IWID_FUNCS (variable)
    functions (3)

ida_kernwin.IWID_IMPORTS (variable)
    imports (1)

ida_kernwin.IWID_LOCALS (variable)
    locals (35)

ida_kernwin.IWID_LOCTYPS (variable)
    local types (10)

ida_kernwin.IWID_MDVIEWCSR (variable)
    lumina md view (51)

ida_kernwin.IWID_MODULES (variable)
    modules (15)

ida_kernwin.IWID_NAMES (variable)
    names (2)

ida_kernwin.IWID_NAVBAND (variable)
    navigation band (26)

ida_kernwin.IWID_NOTEPAD (variable)
    notepad (31)

ida_kernwin.IWID_OUTPUT (variable)
    output (32)

ida_kernwin.IWID_PROBS (variable)
    problems (12)

ida_kernwin.IWID_PSEUDOCODE (variable)
    decompiler (48)

ida_kernwin.IWID_SCRIPTS_CSR (variable)
    recent scripts (58)

ida_kernwin.IWID_SEARCH (variable)
    search results (19)

ida_kernwin.IWID_SEGREGS (variable)
    segment registers (6)

ida_kernwin.IWID_SEGS (variable)
    segments (5)

ida_kernwin.IWID_SELS (variable)
    selectors (7)

ida_kernwin.IWID_SHORTCUTCSR (variable)
    shortcuts chooser (38)

ida_kernwin.IWID_SHORTCUTWIN (variable)
    shortcuts window (39)

ida_kernwin.IWID_SIGNS (variable)
    signatures (8)

ida_kernwin.IWID_SNIPPETS (variable)
    snippets (45)

ida_kernwin.IWID_SNIPPETS_CSR (variable)
    snippets chooser (57)

ida_kernwin.IWID_SO_OFFSETS (variable)
    stroff (42)

ida_kernwin.IWID_SO_STRUCTS (variable)
    stroff (41)

ida_kernwin.IWID_SRCPTHMAP_CSR (variable)
    mappings chooser (54)

ida_kernwin.IWID_SRCPTHUND_CSR (variable)
    undesired chooser (55)

ida_kernwin.IWID_STACK (variable)
    Alias. Some IWID_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

ida_kernwin.IWID_STKVIEW (variable)
    stack view (36)

ida_kernwin.IWID_STRINGS (variable)
    strings (4)

ida_kernwin.IWID_STRUCTS (variable)
    structures (28)

ida_kernwin.IWID_THREADS (variable)
    threads (14)

ida_kernwin.IWID_TILIST (variable)
    types listing (60)

ida_kernwin.IWID_TILS (variable)
    type libraries (9)

ida_kernwin.IWID_TRACE (variable)
    tracing view (16)

ida_kernwin.IWID_UNDOHIST (variable)
    Undo history (56)

ida_kernwin.IWID_WATCH (variable)
    watches (34)

ida_kernwin.IWID_XREFS (variable)
    xrefs (18)

ida_kernwin.LROEF_CPS_RANGE (variable)
    background for range of chars

ida_kernwin.LROEF_FULL_LINE (variable)
    full line background

ida_kernwin.MFF_FAST (variable)
    execute code as soon as possible
    this mode is ok call ui related functions
    that do not query the database.

ida_kernwin.MFF_NOWAIT (variable)
    Do not wait for the request to be executed.
    he caller should ensure that the request is not
    destroyed until the execution completes.
    if not, the request will be ignored.
    the return code of execute_sync() is meaningless
    in this case.
    This flag can be used to delay the code execution
    until the next UI loop run even from the main thread

ida_kernwin.MFF_READ (variable)
    execute code only when ida is idle and it is safe to query the database.
    this mode is recommended only for code that does not modify the database.
    (nb: ida may be in the middle of executing another user request, for example it may be waiting for him to enter values into a modal dialog box)

ida_kernwin.MFF_WRITE (variable)
    execute code only when ida is idle and it is safe to modify the database. in particular, this flag will suspend execution if there is
    a modal dialog box on the screen this mode can be used to call any ida api function. MFF_WRITE implies MFF_READ

ida_kernwin.PCF_EA_CAPABLE (variable)
    toea() implementation returns meaningful data

ida_kernwin.PCF_MAKEPLACE_ALLOCATES (variable)
    makeplace() returns a freshly allocated (i.e., non-static) instance. All new
    code should pass that flag to register_place_class(), and the corresponding
    makeplace() class implementation should return new instances.

ida_kernwin.PluginForm (class)
    PluginForm class.
    
    This form can be used to host additional controls. Please check the PyQt example.

ida_kernwin.PluginForm.Close (method)
    Closes the form.
    
    @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
    
    @return: None

ida_kernwin.PluginForm.GetWidget (method)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.PluginForm.OnClose (method)
    Called when the plugin form is closed
    
    @return: None

ida_kernwin.PluginForm.OnCreate (method)
    This event is called when the plugin form is created.
    The programmer should populate the form when this event is triggered.
    
    @return: None

ida_kernwin.PluginForm.QtWidgetToTWidget (method)
    Convert a QWidget to a TWidget* to be used by IDA
    
    @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules

ida_kernwin.PluginForm.Show (method)
    Creates the form if not was not created or brings to front if it was already created
    
    @param caption: The form caption
    @param options: One of PluginForm.WOPN_ constants

ida_kernwin.PluginForm.TWidgetToPyQtWidget (method)
    Convert a TWidget* to a QWidget to be used by PyQt
    
    @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules

ida_kernwin.PluginForm.TWidgetToPySideWidget (method)
    Use this method to convert a TWidget* to a QWidget to be used by PySide
    
    @param ctx: Context. Reference to a module that already imported QtWidgets module

ida_kernwin.PluginForm.WCLS_DELETE_LATER (variable)
    This flag should be used when Close() is called from an event handler

ida_kernwin.PluginForm.WCLS_DONT_SAVE_SIZE (variable)
    Don't save size of the window

ida_kernwin.PluginForm.WCLS_NO_CONTEXT (variable)
    Don't change the current context (useful for toolbars)

ida_kernwin.PluginForm.WCLS_SAVE (variable)
    Save state in desktop config

ida_kernwin.PluginForm.WOPN_DP_BEFORE (variable)
    place widget before dst_form in the tab bar instead of after
    used with #WOPN_DP_INSIDE and #WOPN_DP_TAB

ida_kernwin.PluginForm.WOPN_DP_BOTTOM (variable)
    Dock widget below dest_ctrl

ida_kernwin.PluginForm.WOPN_DP_FLOATING (variable)
    When floating or in a splitter (i.e., not tabbed),
    use the widget's size hint to determine the best
    geometry (Qt only)

ida_kernwin.PluginForm.WOPN_DP_INSIDE (variable)
    Create a new tab bar with both widget and dest_ctrl

ida_kernwin.PluginForm.WOPN_DP_LEFT (variable)
    Dock widget to the left of dest_ctrl

ida_kernwin.PluginForm.WOPN_DP_RIGHT (variable)
    Dock widget to the right of dest_ctrl

ida_kernwin.PluginForm.WOPN_DP_SZHINT (variable)
    Make widget floating

ida_kernwin.PluginForm.WOPN_DP_TAB (variable)
    Place widget into a tab next to dest_ctrl,
    if dest_ctrl is in a tab bar
    (otherwise the same as #WOPN_DP_INSIDE)

ida_kernwin.PluginForm.WOPN_DP_TOP (variable)
    Dock widget above dest_ctrl

ida_kernwin.PluginForm.WOPN_PERSIST (variable)
    form will persist until explicitly closed with Close()

ida_kernwin.PluginForm.WOPN_RESTORE (variable)
    if the widget is the only widget in a floating area when
    it is closed, remember that area's geometry. The next
    time that widget is created as floating (i.e., WOPN_DP_FLOATING)
    its geometry will be restored (e.g., "Execute script"

ida_kernwin.PluginForm.__init__ (method)

ida_kernwin.PluginForm._ensure_widget_deps (method)

ida_kernwin.RENADDR_HR (variable)
    dialog for "Pseudocode"; additional flags:
    * 0x01 Library function
    * 0x02 Mark as decompiled

ida_kernwin.RENADDR_IDA (variable)
    dialog for "IDA View"

ida_kernwin.S2EAOPT_NOCALC (variable)
    don't try to interpret string as IDC (or current extlang) expression

ida_kernwin.SETMENU_APP (variable)
    add menu item after the specified path

ida_kernwin.SETMENU_ENSURE_SEP (variable)
    make sure there is a separator before the action

ida_kernwin.SETMENU_FIRST (variable)
    add item to the beginning of menu

ida_kernwin.SETMENU_INS (variable)
    add menu item before the specified path (default)

ida_kernwin.SVF_COPY_LINES (variable)
    keep a local copy of '*lines'

ida_kernwin.SVF_LINES_BYPTR (variable)
    remember the 'lines' ptr. do not make a copy of '*lines'

ida_kernwin.TCCPT_ENUMPLACE (variable)
    enumplace_t

ida_kernwin.TCCPT_IDAPLACE (variable)
    idaplace_t

ida_kernwin.TCCPT_INVALID (variable)
    invalid

ida_kernwin.TCCPT_PLACE (variable)
    place_t

ida_kernwin.TCCPT_SIMPLELINE_PLACE (variable)
    simpleline_place_t

ida_kernwin.TCCPT_STRUCTPLACE (variable)
    structplace_t

ida_kernwin.TCCPT_TIPLACE (variable)
    tiplace_t

ida_kernwin.TCCRT_FLAT (variable)
    flat view

ida_kernwin.TCCRT_GRAPH (variable)
    graph view

ida_kernwin.TCCRT_INVALID (variable)
    invalid

ida_kernwin.TCCRT_PROXIMITY (variable)
    proximity view

ida_kernwin.TWidget__from_ptrval__ (function)
    TWidget__from_ptrval__(ptrval) -> TWidget *
    
    @param ptrval: size_t

ida_kernwin.UIJMP_ACTIVATE (variable)
    activate the new window

ida_kernwin.UIJMP_ANYVIEW (variable)
    jump in any ea_t-capable view

ida_kernwin.UIJMP_DONTPUSH (variable)
    do not remember the current address in the navigation history

ida_kernwin.UIJMP_IDAVIEW (variable)
    jump in idaview

ida_kernwin.UIJMP_IDAVIEW_NEW (variable)
    jump in new idaview

ida_kernwin.UI_Hooks (class)
    Proxy of C++ UI_Hooks class.

ida_kernwin.UI_Hooks.__disown__ (method)

ida_kernwin.UI_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> UI_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_kernwin.UI_Hooks.create_desktop_widget (method)
    create_desktop_widget(self, title, cfg) -> PyObject *
    create a widget, to be placed in the widget tree (at desktop-creation time.)
    
    @param title: (const char *)
    @param cfg: (const jobj_t *)
    @return: TWidget * the created widget, or null

ida_kernwin.UI_Hooks.current_widget_changed (method)
    current_widget_changed(self, widget, prev_widget)
    The currently-active TWidget changed.
    
    @param widget: (TWidget *)
    @param prev_widget: (TWidget *)

ida_kernwin.UI_Hooks.database_closed (method)
    database_closed(self)
    The database has been closed. See also processor_t::closebase, it occurs
    earlier. See also ui_initing_database. This is not the same as IDA exiting. If
    you need to perform cleanup at the exiting time, use qatexit().

ida_kernwin.UI_Hooks.database_inited (method)
    database_inited(self, is_new_database, idc_script)
    database initialization has completed. the kernel is about to run idc
    scripts
    
    @param is_new_database: (int)
    @param idc_script: (const char *) - may be nullptr
    @return: void See also ui_initing_database. This event is called for both new
             and old databases.

ida_kernwin.UI_Hooks.debugger_menu_change (method)
    debugger_menu_change(self, enable)
    debugger menu modification detected
    
    @param enable: (bool) true: debugger menu has been added, or a different
                   debugger has been selected false: debugger menu will be removed
                   (user switched to "No debugger")

ida_kernwin.UI_Hooks.desktop_applied (method)
    desktop_applied(self, name, from_idb, type)
    a desktop has been applied
    
    @param name: (const char *) the desktop name
    @param from_idb: (bool) the desktop was stored in the IDB (false if it comes
                     from the registry)
    @param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)

ida_kernwin.UI_Hooks.destroying_plugmod (method)
    destroying_plugmod(self, plugmod, entry)
    The plugin object is about to be destroyed
    
    @param plugmod: (const plugmod_t *)
    @param entry: (const plugin_t *)

ida_kernwin.UI_Hooks.destroying_procmod (method)
    destroying_procmod(self, procmod)
    The processor module is about to be destroyed
    
    @param procmod: (const procmod_t *)

ida_kernwin.UI_Hooks.finish_populating_widget_popup (method)
    finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
    IDA is about to be done populating the context menu for a widget. This is
    your chance to attach_action_to_popup().
    
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param ctx: (const action_activation_ctx_t *)

ida_kernwin.UI_Hooks.get_chooser_item_attrs (method)
    get_chooser_item_attrs(self, chooser, n, attrs)
    get item-specific attributes for a chooser. This callback is generated only
    after enable_chooser_attrs()
    
    @param chooser: (const chooser_base_t *)
    @param n: (::size_t)
    @param attrs: (chooser_item_attrs_t *)

ida_kernwin.UI_Hooks.get_custom_viewer_hint (method)
    get_custom_viewer_hint(self, viewer, place) -> PyObject *
    ui wants to display a hint for a viewer (idaview or custom). Every
    subscriber is supposed to append the hint lines to HINT and increment
    IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT
    is possible but not recommended. If the REG_HINTS_MARKER sequence is found in
    the returned hints string, it will be replaced with the contents of the
    "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned
    hints string, it will be replaced with the contents of the source-level
    debugger-generated hints. The following keywords might appear at the beginning
    of the returned hints: HIGHLIGHT text
    where text will be highlighted CAPTION caption
    caption for the hint widget
    
    @param viewer: (TWidget*) viewer
    @param place: (place_t *) current position in the viewer
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

ida_kernwin.UI_Hooks.get_ea_hint (method)
    get_ea_hint(self, ea) -> PyObject *
    ui wants to display a simple hint for an address. Use this event to generate
    a custom hint See also more generic ui_get_item_hint
    
    @param ea: (::ea_t)
    @return: true if generated a hint

ida_kernwin.UI_Hooks.get_item_hint (method)
    get_item_hint(self, ea, max_lines) -> PyObject *
    ui wants to display multiline hint for an item. See also more generic
    ui_get_custom_viewer_hint
    
    @param ea: (ea_t) or item id like a structure or enum member
    @param max_lines: (int) maximal number of lines
    @return: true if generated a hint

ida_kernwin.UI_Hooks.get_lines_rendering_info (method)
    get_lines_rendering_info(self, out, widget, info)
    get lines rendering information
    
    @param out: (lines_rendering_output_t *)
    @param widget: (const TWidget *)
    @param info: (const lines_rendering_input_t *)

ida_kernwin.UI_Hooks.get_widget_config (method)
    get_widget_config(self, widget, cfg) -> PyObject *
    retrieve the widget configuration (it will be passed back at
    ui_create_desktop_widget-, and ui_set_widget_config-time)
    
    @param widget: (const TWidget *)
    @param cfg: (jobj_t *)

ida_kernwin.UI_Hooks.hook (method)
    hook(self) -> bool

ida_kernwin.UI_Hooks.idcstart (method)
    idcstart(self)
    Start of IDC engine work.

ida_kernwin.UI_Hooks.idcstop (method)
    idcstop(self)
    Stop of IDC engine work.

ida_kernwin.UI_Hooks.initing_database (method)
    initing_database(self)
    database initialization has started.
    
    @return: void See also ui_database_inited. This event is called for both new and
             old databases.

ida_kernwin.UI_Hooks.plugin_loaded (method)
    plugin_loaded(self, plugin_info)
    The plugin was loaded in memory.
    
    @param plugin_info: (const plugin_info_t *)

ida_kernwin.UI_Hooks.plugin_unloading (method)
    plugin_unloading(self, plugin_info)
    The plugin is about to be unloaded
    
    @param plugin_info: (const plugin_info_t *)

ida_kernwin.UI_Hooks.populating_widget_popup (method)
    populating_widget_popup(self, widget, popup_handle, ctx=None)
    IDA is populating the context menu for a widget. This is your chance to
    attach_action_to_popup().
    
    Have a look at ui_finish_populating_widget_popup, if you want to augment the
    context menu with your own actions after the menu has had a chance to be
    properly populated by the owning component or plugin (which typically does it on
    ui_populating_widget_popup.)
    
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param ctx: (const action_activation_ctx_t *)

ida_kernwin.UI_Hooks.postprocess_action (method)
    postprocess_action(self)
    an ida ui action has been handled

ida_kernwin.UI_Hooks.preprocess_action (method)
    preprocess_action(self, name) -> int
    ida ui is about to handle a user action.
    
    @param name: (const char *) ui action name. these names can be looked up in
                 ida[tg]ui.cfg
    @retval 0: ok
    @retval nonzero: a plugin has handled the command

ida_kernwin.UI_Hooks.range (method)
    range(self)
    The disassembly range has been changed ( idainfo::min_ea ...
    idainfo::max_ea). UI should redraw the scrollbars. See also:
    ui_lock_range_refresh

ida_kernwin.UI_Hooks.ready_to_run (method)
    ready_to_run(self)
    all UI elements have been initialized. Automatic plugins may hook to this
    event to perform their tasks.

ida_kernwin.UI_Hooks.resume (method)
    resume(self)
    Resume the suspended graphical interface. Only the text version. Interface
    should respond to it

ida_kernwin.UI_Hooks.saved (method)
    saved(self, path)
    The kernel has saved the database. This callback just informs the interface.
    Note that at the time this notification is sent, the internal paths are not
    updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path.
    
    @param path: (const char *) the database path

ida_kernwin.UI_Hooks.saving (method)
    saving(self)
    The kernel is flushing its buffers to the disk. The user interface should
    save its state. Parameters: none Returns: none

ida_kernwin.UI_Hooks.screen_ea_changed (method)
    screen_ea_changed(self, ea, prev_ea)
    The "current address" changed
    
    @param ea: (ea_t)
    @param prev_ea: (ea_t)

ida_kernwin.UI_Hooks.set_widget_config (method)
    set_widget_config(self, widget, cfg)
    set the widget configuration
    
    @param widget: (const TWidget *)
    @param cfg: (const jobj_t *)

ida_kernwin.UI_Hooks.suspend (method)
    suspend(self)
    Suspend graphical interface. Only the text version. Interface should respond
    to it.

ida_kernwin.UI_Hooks.unhook (method)
    unhook(self) -> bool

ida_kernwin.UI_Hooks.updated_actions (method)
    updated_actions(self)
    IDA is done updating actions.

ida_kernwin.UI_Hooks.updating_actions (method)
    updating_actions(self, ctx)
    IDA is about to update all actions. If your plugin needs to perform
    expensive operations more than once (e.g., once per action it registers), you
    should do them only once, right away.
    
    @param ctx: (action_update_ctx_t *)

ida_kernwin.UI_Hooks.widget_closing (method)
    widget_closing(self, widget)
    TWidget is about to close. This event precedes ui_widget_invisible. Use this to
    perform some possible actions relevant to the lifecycle of this widget
    
    @param widget: (TWidget *)

ida_kernwin.UI_Hooks.widget_invisible (method)
    widget_invisible(self, widget)
    TWidget is being closed. Use this event to destroy the window controls
    
    @param widget: (TWidget *)

ida_kernwin.UI_Hooks.widget_visible (method)
    widget_visible(self, widget)
    TWidget is displayed on the screen. Use this event to populate the window with
    controls
    
    @param widget: (TWidget *)

ida_kernwin.VES_SHIFT (variable)
    state & 1 => Shift is pressed
    state & 2 => Alt is pressed
    state & 4 => Ctrl is pressed
    state & 8 => Mouse left button is pressed
    state & 16 => Mouse right button is pressed
    state & 32 => Mouse middle button is pressed
    state & 128 => Meta is pressed (OSX only)

ida_kernwin.VME_LEFT_BUTTON (variable)
    left mouse button

ida_kernwin.VME_MID_BUTTON (variable)
    middle mouse button

ida_kernwin.VME_RIGHT_BUTTON (variable)
    right mouse button

ida_kernwin.VME_UNKNOWN (variable)
    unknown mouse button

ida_kernwin.View_Hooks (class)
    Proxy of C++ View_Hooks class.

ida_kernwin.View_Hooks.__disown__ (method)

ida_kernwin.View_Hooks.__init__ (method)
    __init__(self, _flags=0, _hkcb_flags=0x0001) -> View_Hooks
    
    @param _flags: uint32
    @param _hkcb_flags: uint32

ida_kernwin.View_Hooks.hook (method)
    hook(self) -> bool

ida_kernwin.View_Hooks.unhook (method)
    unhook(self) -> bool

ida_kernwin.View_Hooks.view_activated (method)
    view_activated(self, view)
    A view is activated
    
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_click (method)
    view_click(self, view, event)
    Click event
    
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_close (method)
    view_close(self, view)
    View closed
    
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_created (method)
    view_created(self, view)
    A view is being created.
    
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_curpos (method)
    view_curpos(self, view)
    Cursor position changed
    
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_dblclick (method)
    view_dblclick(self, view, event)
    Double click event
    
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_deactivated (method)
    view_deactivated(self, view)
    A view is deactivated
    
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_keydown (method)
    view_keydown(self, view, key, state)
    Key down event
    
    @param view: (TWidget *)
    @param key: (int)
    @param state: (::view_event_state_t)

ida_kernwin.View_Hooks.view_loc_changed (method)
    view_loc_changed(self, view, now, was)
    The location for the view has changed (can be either the place_t, the
    renderer_info_t, or both.)
    
    @param view: (TWidget *)
    @param now: (const lochist_entry_t *)
    @param was: (const lochist_entry_t *)

ida_kernwin.View_Hooks.view_mouse_moved (method)
    view_mouse_moved(self, view, event)
    The mouse moved on the view
    
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_mouse_over (method)
    view_mouse_over(self, view, event)
    The user moved the mouse over (or out of) a node or an edge. This is only
    relevant in a graph view.
    
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_switched (method)
    view_switched(self, view, rt)
    A view's renderer has changed.
    
    @param view: (TWidget *)
    @param rt: (tcc_renderer_type_t)

ida_kernwin.WCLS_DELETE_LATER (variable)
    assign the deletion of the widget to the UI loop ///<

ida_kernwin.WCLS_DONT_SAVE_SIZE (variable)
    don't save size of the window

ida_kernwin.WCLS_NO_CONTEXT (variable)
    don't change the current context (useful for toolbars)

ida_kernwin.WCLS_SAVE (variable)
    save state in desktop config

ida_kernwin.WOPN_CLOSED_BY_ESC (variable)
    override idagui.cfg:CLOSED_BY_ESC: esc will close

ida_kernwin.WOPN_DP_BEFORE (variable)
    Place widget before dst_form in the tab bar instead of after; used with
    WOPN_DP_INSIDE and WOPN_DP_TAB

ida_kernwin.WOPN_DP_BOTTOM (variable)
    Dock widget below dest_ctrl.

ida_kernwin.WOPN_DP_FLOATING (variable)
    Make widget floating.

ida_kernwin.WOPN_DP_INSIDE (variable)
    Create a new tab bar with both widget and dest_ctrl.

ida_kernwin.WOPN_DP_LEFT (variable)
    Dock widget to the left of dest_ctrl.

ida_kernwin.WOPN_DP_RIGHT (variable)
    Dock widget to the right of dest_ctrl.

ida_kernwin.WOPN_DP_SZHINT (variable)
    when floating or in a splitter (i.e., not tabbed), use the widget's size hint to
    determine the best geometry (Qt only)

ida_kernwin.WOPN_DP_TAB (variable)
    Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar
    (otherwise the same as WOPN_DP_INSIDE)

ida_kernwin.WOPN_DP_TOP (variable)
    Dock widget above dest_ctrl.

ida_kernwin.WOPN_NOT_CLOSED_BY_ESC (variable)
    override idagui.cfg:CLOSED_BY_ESC: esc will not close

ida_kernwin.WOPN_PERSIST (variable)
    widget will remain available when starting or stopping debugger sessions

ida_kernwin.WOPN_RESTORE (variable)
    if the widget was the only widget in a floating area the last time it was
    closed, it will be restored as floating, with the same position+size as before

ida_kernwin.__qtimer_t (class)
    Proxy of C++ __qtimer_t class.

ida_kernwin.__qtimer_t.__init__ (method)
    __init__(self) -> __qtimer_t

ida_kernwin._ask_addr (function)
    _ask_addr(addr, format) -> bool
    
    Parameters
    ----------
    addr: ea_t *
    format: char const *

ida_kernwin._ask_long (function)
    _ask_long(value, format) -> bool
    
    Parameters
    ----------
    value: sval_t *
    format: char const *

ida_kernwin._ask_seg (function)
    _ask_seg(sel, format) -> bool
    
    Parameters
    ----------
    sel: sel_t *
    format: char const *

ida_kernwin._kludge_force_declare_dirspec_t (function)
    _kludge_force_declare_dirspec_t(arg1)
    
    Parameters
    ----------
    arg1: dirspec_t const *

ida_kernwin._kludge_force_declare_dirtree_t (function)
    _kludge_force_declare_dirtree_t(arg1)
    
    Parameters
    ----------
    arg1: dirtree_t const *

ida_kernwin.action_ctx_base_cur_sel_t (class)
    Proxy of C++ action_ctx_base_cur_sel_t class.

ida_kernwin.action_ctx_base_cur_sel_t.__init__ (method)
    __init__(self) -> action_ctx_base_cur_sel_t

ida_kernwin.action_ctx_base_cur_sel_t.reset (method)
    reset(self)

ida_kernwin.action_ctx_base_cur_sel_t.to (variable)
    end of selection

ida_kernwin.action_ctx_base_source_t (class)
    Proxy of C++ action_ctx_base_source_t class.

ida_kernwin.action_ctx_base_source_t.__init__ (method)
    __init__(self) -> action_ctx_base_source_t

ida_kernwin.action_ctx_base_source_t.reset (method)
    reset(self)

ida_kernwin.action_ctx_base_t (class)
    Proxy of C++ action_ctx_base_t class.

ida_kernwin.action_ctx_base_t.__init__ (method)
    __init__(self) -> action_ctx_base_t

ida_kernwin.action_ctx_base_t.action (variable)
    action name

ida_kernwin.action_ctx_base_t.chooser_selection (variable)
    current chooser selection (0-based)

ida_kernwin.action_ctx_base_t.cur_ea (variable)
    the current EA of the position in the view

ida_kernwin.action_ctx_base_t.cur_enum (variable)
    the current enum

ida_kernwin.action_ctx_base_t.cur_fchunk (variable)
    the current function chunk

ida_kernwin.action_ctx_base_t.cur_flags (variable)
    Current address information. see Action context property bits.

ida_kernwin.action_ctx_base_t.cur_func (variable)
    the current function

ida_kernwin.action_ctx_base_t.cur_seg (variable)
    the current segment

ida_kernwin.action_ctx_base_t.cur_sel (variable)
    the currently selected range. also see ACF_HAS_SELECTION

ida_kernwin.action_ctx_base_t.cur_strmem (variable)
    the current structure member

ida_kernwin.action_ctx_base_t.cur_struc (variable)
    the current structure

ida_kernwin.action_ctx_base_t.cur_value (variable)
    the possible address, or value the cursor is positioned on

ida_kernwin.action_ctx_base_t.dirtree_selection (variable)
    the current dirtree_t selection (if applicable)

ida_kernwin.action_ctx_base_t.focus (variable)
    The focused widget in case it is not the 'form' itself (e.g., the 'quick filter'
    input in choosers.)

ida_kernwin.action_ctx_base_t.graph_selection (variable)
    the current graph selection (if in a graph view)

ida_kernwin.action_ctx_base_t.has_flag (method)
    has_flag(self, flag) -> bool
    Check if the given flag is set.
    
    @param flag: (C++: uint32)

ida_kernwin.action_ctx_base_t.regname (variable)
    register name (if widget_type == BWN_CPUREGS and context menu opened on
    register)

ida_kernwin.action_ctx_base_t.reset (method)
    reset(self)
    Invalidate all context info.

ida_kernwin.action_ctx_base_t.source (variable)
    the underlying chooser_base_t (if 'widget' is a chooser widget)

ida_kernwin.action_ctx_base_t.type_ref (variable)
    a reference to the current type (if 'widget' is a types listing widget; nullptr
    otherwise)

ida_kernwin.action_ctx_base_t.widget_title (variable)
    title of current widget

ida_kernwin.action_ctx_base_t.widget_type (variable)
    type of current widget

ida_kernwin.action_desc_t (class)
    Proxy of C++ action_desc_t class.

ida_kernwin.action_desc_t.__init__ (method)
    __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
    
    @param name: char const *
    @param label: char const *
    @param handler: PyObject *
    @param shortcut: char const *
    @param tooltip: char const *
    @param icon: int
    @param flags: int

ida_kernwin.action_desc_t.cb (variable)
    size of this structure

ida_kernwin.action_desc_t.flags (variable)
    See Action flags.

ida_kernwin.action_desc_t.icon (variable)
    an optional icon ID to use

ida_kernwin.action_desc_t.label (variable)
    the label of the action, possibly with an accelerator key definition (e.g.,
    "~J~ump to operand")

ida_kernwin.action_desc_t.name (variable)
    the internal name of the action; must be unique. a way to reduce possible
    conflicts is to prefix it with some specific prefix. E.g., "myplugin:doSthg".

ida_kernwin.action_desc_t.owner (variable)
    either the plugin_t, or plugmod_t responsible for registering the action. Can be
    nullptr Please see ACTION_DESC_LITERAL_PLUGMOD

ida_kernwin.action_desc_t.shortcut (variable)
    an optional shortcut definition. E.g., "Ctrl+Enter"

ida_kernwin.action_desc_t.tooltip (variable)
    an optional tooltip for the action

ida_kernwin.action_handler_t (class)

ida_kernwin.action_handler_t.__init__ (method)

ida_kernwin.action_handler_t.activate (method)
    Activate an action. This function implements the core behavior of an action. It
    is called when the action is triggered, from a menu, from a popup menu, from the
    toolbar, or programmatically.
    
    @return: non-zero: all IDA windows will be refreshed

ida_kernwin.action_handler_t.update (method)
    Update an action. This is called when the context of the UI changed, and we need
    to let the action update some of its properties if needed (label, icon, ...)
    
    In addition, this lets IDA know whether the action is enabled, and when it
    should be queried for availability again.
    
    Note: This callback is not meant to change anything in the application's state,
    except by calling one (or many) of the "update_action_*()" functions on this
    very action.

ida_kernwin.activate_widget (function)
    activate_widget(widget, take_focus)
    Activate widget (only gui version) (ui_activate_widget).
    
    @param widget: (C++: TWidget *) existing widget to display
    @param take_focus: (C++: bool) give focus to given widget

ida_kernwin.add_hotkey (function)
    add_hotkey(hotkey, pyfunc) -> PyCapsule
    Associates a function call with a hotkey.
    Callable pyfunc will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param pyfunc: Callable
    
    @return: Context object on success or None on failure.

ida_kernwin.add_idc_hotkey (function)
    add_idc_hotkey(hotkey, idcfunc) -> int
    Add hotkey for IDC function (ui_add_idckey).
    
    @param hotkey: (C++: const char *) hotkey name
    @param idcfunc: (C++: const char *) IDC function name
    @return: IDC hotkey error codes

ida_kernwin.add_spaces (function)
    add_spaces(s, len) -> str
    Add space characters to the colored string so that its length will be at least
    'len' characters. Don't trim the string if it is longer than 'len'.
    
    @param str: (C++: char *) pointer to colored string to modify (may not be nullptr)
    @param len: (C++: ssize_t) the desired length of the string
    @return: pointer to the end of input string

ida_kernwin.addon_count (function)
    addon_count() -> int
    Get number of installed addons.

ida_kernwin.addon_info_t (class)
    Proxy of C++ addon_info_t class.

ida_kernwin.addon_info_t.__init__ (method)
    __init__(self) -> addon_info_t

ida_kernwin.analyzer_options (function)
    analyzer_options()
    Allow the user to set analyzer options. (show a dialog box)
    (ui_analyzer_options)

ida_kernwin.ask_addr (function)
    Output a formatted string to the output window (msg) preprended with "**DATABASE
    IS CORRUPTED: " Display a dialog box and wait for the user to input an address
    (ui_ask_addr).
    
    @retval 0: the user pressed Esc.
    @retval 1: ok, the user entered an address

ida_kernwin.ask_buttons (function)
    ask_buttons(Yes, No, Cancel, deflt, format) -> int
    Display a dialog box and get choice from maximum three possibilities
    (ui_ask_buttons).
    @note: for all buttons:
    * use "" or nullptr to take the default name for the button.
    * prepend "HIDECANCEL\n" in 'format' to hide the Cancel button
    
    @param Yes: (C++: const char *) text for the first button
    @param No: (C++: const char *) text for the second button
    @param Cancel: (C++: const char *) text for the third button
    @param deflt: (C++: int) default choice: one of Button IDs
    @param format: (C++: const char *) printf-style format string for question. It may have some
                   prefixes, see below.
    @return: one of Button IDs specifying the selected button (Esc key returns
             Cancel/3rd button value)

ida_kernwin.ask_file (function)
    ask_file(for_saving, defval, format) -> char *
    
    @param for_saving: bool
    @param defval: char const *
    @param format: char const *

ida_kernwin.ask_for_feedback (function)
    ask_for_feedback(format)
    Show a message box asking to send the input file to \link{mailto:support@hex-
    rays.com,support@hex-rays.com}.
    
    @param format: (C++: const char *) the reason why the input file is bad

ida_kernwin.ask_form (function)
    Display a dialog box and wait for the user. If the form contains the "BUTTON NO
    <title>" keyword, then the return values are the same as in the ask_yn()
    function (Button IDs)
    
    @retval 0: no memory to display or form syntax error (a warning is displayed in
               this case). the user pressed the 'No' button (if the form has it) or
               the user cancelled the dialog otherwise. all variables retain their
               original values.
    @retval 1: ok, all input fields are filled and validated.
    @retval -1: the form has the 'No' button and the user cancelled the dialog

ida_kernwin.ask_ident (function)
    Display a dialog box and wait for the user to input an identifier. If the user
    enters a non-valid identifier, this function displays a warning and allows the
    user to correct it. CPU register names are usually forbidden.
    
    @return: false if the user cancelled the dialog, otherwise returns true.

ida_kernwin.ask_ident2 (function)
    ask_ident2(str, format) -> bool
    Display a dialog box and wait for the user to input an identifier. If the user
    enters a non-valid identifier, this function displays a warning and allows the
    user to correct it. CPU register names are permitted.
    
    @param str: (C++: qstring *) qstring to fill. Can contain the default value. Cannot be nullptr.
    @param format: (C++: const char *) printf() style format string with the question
    @return: false if the user cancelled the dialog, otherwise returns true.

ida_kernwin.ask_long (function)
    Display a dialog box and wait for the user to input an number (ui_ask_long). The
    number is represented in C-style. This function allows to enter any IDC
    expression and properly calculates it.
    
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered a valid number.

ida_kernwin.ask_seg (function)
    Display a dialog box and wait for the user to input an segment name
    (ui_ask_seg). This function allows to enter segment register names, segment base
    paragraphs, segment names to denote a segment.
    
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered an segment name

ida_kernwin.ask_str (function)
    ask_str(defval, hist, prompt) -> str or None
    Asks for a long text
    
    @param defval: The default value
    @param hist: history id
    @param prompt: The prompt value
    @return: None or the entered string

ida_kernwin.ask_text (function)
    ask_text(max_size, defval, prompt) -> str
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

ida_kernwin.ask_yn (function)
    ask_yn(deflt, format) -> int
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    @param deflt: (C++: int) default choice: one of Button IDs
    @param format: (C++: const char *) The question in printf() style format
    @return: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.

ida_kernwin.atoea (function)
    atoea(str) -> bool
    Convert a number in C notation to an address. decimal: 1234
    octal: 0123
    hexadecimal: 0xabcd
    binary: 0b00101010
    
    @param str: (C++: const char *) the string to parse

ida_kernwin.attach_action_to_menu (function)
    attach_action_to_menu(menupath, name, flags=0) -> bool
    Attach a previously-registered action to the menu (ui_attach_action_to_menu).
    @note: You should not change top level menu, or the Edit,Plugins submenus If you
           want to modify the debugger menu, do it at the ui_debugger_menu_change
           event (ida might destroy your menu item if you do it elsewhere).
    
    @param menupath: (C++: const char *) path to the menu item after or before which the insertion will
                     take place.
    * Example: Debug/StartProcess
    * Whitespace, punctuation are ignored.
    * It is allowed to specify only the prefix of the menu item.
    * Comparison is case insensitive.
    * menupath may start with the following prefixes:
    * [S] - modify the main menu of the structure window
    * [E] - modify the main menu of the enum window
    @param name: (C++: const char *) the action name
    @param flags: (C++: int) a combination of Set menu flags, to determine menu item position
    @return: success

ida_kernwin.attach_action_to_popup (function)
    attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
    Insert a previously-registered action into the widget's popup menu
    (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and
    'permanent'.
    
    @param widget: (C++: TWidget *) target widget
    @param popup_handle: (C++: TPopupMenu *) target popup menu
    * if non-nullptr, the action is added to this popup menu invocation (i.e.,
    'single-shot')
    * if nullptr, the action is added to a list of actions that should always be
    present in context menus for this widget (i.e., 'permanent'.)
    @param name: (C++: const char *) action name
    @param popuppath: (C++: const char *) can be nullptr
    @param flags: (C++: int) a combination of SETMENU_ flags (see Set menu flags)
    @return: success

ida_kernwin.attach_action_to_toolbar (function)
    attach_action_to_toolbar(toolbar_name, name) -> bool
    Attach an action to an existing toolbar (ui_attach_action_to_toolbar).
    
    @param toolbar_name: (C++: const char *) the name of the toolbar
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.attach_dynamic_action_to_popup (function)
    attach_dynamic_action_to_popup(unused, popup_handle, desc, popuppath=None, flags=0) -> bool
    Create & insert an action into the widget's popup menu
    (::ui_attach_dynamic_action_to_popup).
    Note: The action description in the 'desc' parameter is modified by
          this call so you should prepare a new description for each call.
    For example:
        desc = idaapi.action_desc_t(None, 'Dynamic popup action', Handler())
        idaapi.attach_dynamic_action_to_popup(form, popup, desc)
    
    @param unused: deprecated; should be None
    @param popup_handle: target popup
    @param desc: action description of type action_desc_t
    @param popuppath: can be None
    @param flags: a combination of SETMENU_ constants
    @return: success

ida_kernwin.banner (function)
    banner(wait) -> bool
    Show a banner dialog box (ui_banner).
    
    @param wait: (C++: int) time to wait before closing
    @retval 1: ok
    @retval 0: esc was pressed

ida_kernwin.beep (function)
    beep(beep_type=beep_default)
    Issue a beeping sound (ui_beep).
    
    @param beep_type: (C++: beep_t)

ida_kernwin.call_nav_colorizer (function)
    call_nav_colorizer(dict, ea, nbytes) -> uint32
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    
    @param dict: PyObject *
    @param ea: ea_t
    @param nbytes: asize_t

ida_kernwin.cancel_exec_request (function)
    cancel_exec_request(req_id) -> bool
    Try to cancel an asynchronous exec request (ui_cancel_exec_request).
    
    @param req_id: (C++: int) request id
    @retval true: successfully canceled
    @retval false: request has already been processed.

ida_kernwin.cancel_thread_exec_requests (function)
    cancel_thread_exec_requests(tid) -> int
    Try to cancel asynchronous exec requests created by the specified thread.
    
    @param tid: (C++: qthread_t) thread id
    @return: number of the canceled requests.

ida_kernwin.choose_activate (function)
    choose_activate(_self)
    
    @param self: PyObject *

ida_kernwin.choose_choose (function)
    choose_choose(_self) -> PyObject *
    
    @param self: PyObject *

ida_kernwin.choose_close (function)
    choose_close(_self)
    
    @param self: PyObject *

ida_kernwin.choose_create_embedded_chobj (function)
    choose_create_embedded_chobj(_self) -> PyObject *
    
    @param self: PyObject *

ida_kernwin.choose_entry (function)
    choose_entry(title) -> ea_t
    Choose an entry point (ui_choose, chtype_entry).
    
    @param title: (C++: const char *) chooser title
    @return: ea of selected entry point, BADADDR if none selected

ida_kernwin.choose_enum (function)
    choose_enum(out, title, default_ord) -> bool
    
    @param out: tinfo_t *
    @param title: char const *
    @param default_ord: uint32
    
    choose_enum(title, default_id) -> enum_t
    
    @param title: char const *
    @param default_id: enum_t

ida_kernwin.choose_enum_by_value (function)
    choose_enum_by_value(out, title, default_ord, value, nbytes) -> bool
    
    @param out: tinfo_t *
    @param title: char const *
    @param default_ord: uint32
    @param value: uint64
    @param nbytes: int
    
    choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
    
    @param title: char const *
    @param default_id: enum_t
    @param value: uint64
    @param nbytes: int

ida_kernwin.choose_find (function)
    choose_find(title) -> MyChoose or None
    
    @param title: char const *

ida_kernwin.choose_func (function)
    choose_func(title, default_ea) -> func_t *
    Choose a function (ui_choose, chtype_func).
    
    @param title: (C++: const char *) chooser title
    @param default_ea: (C++: ea_t) ea of function to select by default
    @return: pointer to function that was selected, nullptr if none selected

ida_kernwin.choose_get_widget (function)
    choose_get_widget(_self) -> TWidget *
    
    @param self: PyObject *

ida_kernwin.choose_idasgn (function)
    choose_idasgn() -> PyObject *
    Opens the signature chooser
    
    @return: None or the selected signature name

ida_kernwin.choose_name (function)
    choose_name(title) -> ea_t
    Choose a name (ui_choose, chtype_name).
    
    @param title: (C++: const char *) chooser title
    @return: ea of selected name, BADADDR if none selected

ida_kernwin.choose_refresh (function)
    choose_refresh(_self)
    
    @param self: PyObject *

ida_kernwin.choose_segm (function)
    choose_segm(title, default_ea) -> segment_t *
    Choose a segment (ui_choose, chtype_segm).
    
    @param title: (C++: const char *) chooser title
    @param default_ea: (C++: ea_t) ea of segment to select by default
    @return: pointer to segment that was selected, nullptr if none selected

ida_kernwin.choose_srcp (function)
    choose_srcp(title) -> sreg_range_t *
    Choose a segment register change point (ui_choose, chtype_srcp).
    
    @param title: (C++: const char *) chooser title
    @return: pointer to segment register range of selected change point, nullptr if
             none selected

ida_kernwin.choose_stkvar_xref (function)
    choose_stkvar_xref(pfn, mptr) -> ea_t
    Choose an xref to a stack variable (ui_choose, chtype_name).
    
    @param pfn: (C++: func_t *) function
    @param mptr: (C++: member_t *) variable
    @return: ea of the selected xref, BADADDR if none selected

ida_kernwin.choose_struc (function)
    choose_struc(title) -> struc_t *
    
    @param title: char const *

ida_kernwin.choose_struct (function)
    choose_struct(out, title) -> bool
    Choose a structure (ui_choose, chtype_struct).
    
    @param out: (C++: tinfo_t *) the selected structure type
    @param title: (C++: const char *) chooser title
    @retval true: the selected type is in OUT
    @retval false: nothing was selected

ida_kernwin.choose_til (function)
    choose_til() -> str
    Choose a type library (ui_choose, chtype_idatil).
    
    @retval true: 'buf' was filled with the name of the selected til
    @retval false: otherwise

ida_kernwin.choose_xref (function)
    choose_xref(to) -> ea_t
    Choose an xref to an address (ui_choose, chtype_xref).
    
    @param to: (C++: ea_t) referenced address
    @return: ea of selected xref, BADADDR if none selected

ida_kernwin.chooser_base_t (class)
    Proxy of C++ chooser_base_t class.

ida_kernwin.chooser_base_t.__init__ (method)

ida_kernwin.chooser_base_t.ask_item_attrs (method)
    ask_item_attrs(self) -> bool
    should chooser generate ui_get_chooser_item_attrs events?

ida_kernwin.chooser_base_t.can_del (method)
    can_del(self) -> bool

ida_kernwin.chooser_base_t.can_edit (method)
    can_edit(self) -> bool

ida_kernwin.chooser_base_t.can_filter (method)
    can_filter(self) -> bool

ida_kernwin.chooser_base_t.can_ins (method)
    can_ins(self) -> bool
    is an operation allowed?

ida_kernwin.chooser_base_t.can_refresh (method)
    can_refresh(self) -> bool

ida_kernwin.chooser_base_t.can_sort (method)
    can_sort(self) -> bool

ida_kernwin.chooser_base_t.columns (variable)
    number of columns

ida_kernwin.chooser_base_t.deflt_col (variable)
    Column that will have focus.

ida_kernwin.chooser_base_t.get_builtin_number (method)
    get_builtin_number(self) -> uint
    get number of the built-in chooser

ida_kernwin.chooser_base_t.get_count (method)
    get_count(self) -> size_t
    get the number of elements in the chooser

ida_kernwin.chooser_base_t.get_ea (method)
    get_ea(self, arg2) -> ea_t
    get the address of an element. When this function returns valid addresses: * If
    any column has the `CHCOL_FNAME` flag, rows will be colored according to the
    attributes of the functions who own those addresses (extern, library function,
    Lumina, ... - similar to what the "Functions" widget does) * When a selection is
    present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is
    modal), IDA will jump to that address (through jumpto())
    
    @param arg2: size_t
    @return: the effective address, BADADDR if the element has no address

ida_kernwin.chooser_base_t.get_quick_filter_initial_mode (method)
    get_quick_filter_initial_mode(self) -> int

ida_kernwin.chooser_base_t.get_row (method)
    get_row(self, n) -> ([str, ...], int, chooser_item_attrs_t)
    get a description of an element.
    
    @param n: (C++: size_t) element number (0..get_count()-1)

ida_kernwin.chooser_base_t.has_diff_capability (method)
    has_diff_capability(self) -> bool

ida_kernwin.chooser_base_t.has_dirtree (method)
    has_dirtree(self) -> bool

ida_kernwin.chooser_base_t.has_inode_to_index (method)
    has_inode_to_index(self) -> bool

ida_kernwin.chooser_base_t.header (variable)
    header line; contains the tooltips, and column name for each of 'columns'
    columns. When tooltips need to be provided, the syntax should be:
    "#tooltip#column-name". (Otherwise, the syntax is simply "column-name".)

ida_kernwin.chooser_base_t.height (variable)
    (in chars)

ida_kernwin.chooser_base_t.icon (variable)
    default icon

ida_kernwin.chooser_base_t.is_dirtree_persisted (method)
    is_dirtree_persisted(self) -> bool

ida_kernwin.chooser_base_t.is_force_default (method)
    is_force_default(self) -> bool
    should selection of the already opened non-modal chooser be changed?

ida_kernwin.chooser_base_t.is_lazy_loaded (method)
    is_lazy_loaded(self) -> bool

ida_kernwin.chooser_base_t.is_modal (method)
    is_modal(self) -> bool
    is choose modal?

ida_kernwin.chooser_base_t.is_multi (method)
    is_multi(self) -> bool
    is multi-selection allowed?

ida_kernwin.chooser_base_t.is_quick_filter_visible_initially (method)
    is_quick_filter_visible_initially(self) -> bool

ida_kernwin.chooser_base_t.is_same (method)
    is_same(self, other) -> bool
    do the current and the given objects hold the same data?
    
    @param other: (C++: const chooser_base_t *) chooser_base_t const *

ida_kernwin.chooser_base_t.is_status_bar_hidden (method)
    is_status_bar_hidden(self) -> bool

ida_kernwin.chooser_base_t.popup_allowed (method)
    popup_allowed(self, stdact_idx) -> bool
    is a standard action allowed?
    
    @param stdact_idx: (C++: int)

ida_kernwin.chooser_base_t.popup_names (variable)
    array of custom labels of the standard actions. Used to replace labels for these
    actions.
    An empty name means that the default name will be used.
    @note: Availability of these actions is determined by the CH_CAN_... flags. The
           label, icon and other action attributes can be overwritten in the action
           description returned by get_stdact_descs()

ida_kernwin.chooser_base_t.should_rename_trigger_edit (method)
    should_rename_trigger_edit(self) -> bool

ida_kernwin.chooser_base_t.should_restore_geometry (method)
    should_restore_geometry(self) -> bool

ida_kernwin.chooser_base_t.title (variable)
    menu title (includes ptr to help). May have chooser title prefixes (see "Chooser
     title" above).

ida_kernwin.chooser_base_t.width (variable)
    (in chars)

ida_kernwin.chooser_base_t.widths (variable)
    column widths
    * low 16 bits of each value hold the column width
    * high 16 bits are flags (see Chooser column flags)

ida_kernwin.chooser_base_t.x0 (variable)
    screen position, Functions: generic list choosers

ida_kernwin.chooser_item_attrs_t (class)
    Proxy of C++ chooser_item_attrs_t class.

ida_kernwin.chooser_item_attrs_t.__eq__ (method)
    __eq__(self, other) -> bool
    
    @param other: chooser_item_attrs_t const &

ida_kernwin.chooser_item_attrs_t.__init__ (method)
    __init__(self) -> chooser_item_attrs_t

ida_kernwin.chooser_item_attrs_t.color (variable)
    item color

ida_kernwin.chooser_item_attrs_t.flags (variable)
    Chooser item property bits

ida_kernwin.chooser_item_attrs_t.reset (method)
    reset(self)

ida_kernwin.chooser_row_info_t (class)
    Proxy of C++ chooser_row_info_t class.

ida_kernwin.chooser_row_info_t.__eq__ (method)
    __eq__(self, other) -> bool
    
    @param other: chooser_row_info_t const &

ida_kernwin.chooser_row_info_t.__init__ (method)
    __init__(self) -> chooser_row_info_t

ida_kernwin.chooser_row_info_t.__ne__ (method)
    __ne__(self, other) -> bool
    
    @param other: chooser_row_info_t const &

ida_kernwin.chooser_row_info_t.attrs (variable)
    styling attributes

ida_kernwin.chooser_row_info_t.icon (variable)
    icon number

ida_kernwin.chooser_row_info_t.texts (variable)
    texts, one per chooser column

ida_kernwin.chooser_row_info_vec_t (class)
    Proxy of C++ qvector< chooser_row_info_t > class.

ida_kernwin.chooser_row_info_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< chooser_row_info_t > const &

ida_kernwin.chooser_row_info_vec_t.__getitem__ (method)
    __getitem__(self, i) -> chooser_row_info_t
    
    @param i: size_t

ida_kernwin.chooser_row_info_vec_t.__init__ (method)
    __init__(self) -> chooser_row_info_vec_t
    __init__(self, x) -> chooser_row_info_vec_t
    
    @param x: qvector< chooser_row_info_t > const &

ida_kernwin.chooser_row_info_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.chooser_row_info_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< chooser_row_info_t > const &

ida_kernwin.chooser_row_info_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.at (method)
    at(self, _idx) -> chooser_row_info_t
    
    @param _idx: size_t

ida_kernwin.chooser_row_info_vec_t.begin (method)
    begin(self) -> chooser_row_info_t

ida_kernwin.chooser_row_info_vec_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.chooser_row_info_vec_t.clear (method)
    clear(self)

ida_kernwin.chooser_row_info_vec_t.empty (method)
    empty(self) -> bool

ida_kernwin.chooser_row_info_vec_t.end (method)
    end(self) -> chooser_row_info_t

ida_kernwin.chooser_row_info_vec_t.erase (method)
    erase(self, it) -> chooser_row_info_t
    
    @param it: qvector< chooser_row_info_t >::iterator
    
    erase(self, first, last) -> chooser_row_info_t
    
    @param first: qvector< chooser_row_info_t >::iterator
    @param last: qvector< chooser_row_info_t >::iterator

ida_kernwin.chooser_row_info_vec_t.extract (method)
    extract(self) -> chooser_row_info_t

ida_kernwin.chooser_row_info_vec_t.find (method)
    find(self, x) -> chooser_row_info_t
    
    @param x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.grow (method)
    grow(self, x=chooser_row_info_t())
    
    @param x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: chooser_row_info_t *
    @param len: size_t

ida_kernwin.chooser_row_info_vec_t.insert (method)
    insert(self, it, x) -> chooser_row_info_t
    
    @param it: qvector< chooser_row_info_t >::iterator
    @param x: chooser_row_info_t const &

ida_kernwin.chooser_row_info_vec_t.pop_back (method)
    pop_back(self)

ida_kernwin.chooser_row_info_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: chooser_row_info_t const &
    
    push_back(self) -> chooser_row_info_t

ida_kernwin.chooser_row_info_vec_t.qclear (method)
    qclear(self)

ida_kernwin.chooser_row_info_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.chooser_row_info_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: chooser_row_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.chooser_row_info_vec_t.size (method)
    size(self) -> size_t

ida_kernwin.chooser_row_info_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< chooser_row_info_t > &

ida_kernwin.chooser_row_info_vec_t.truncate (method)
    truncate(self)

ida_kernwin.chooser_stdact_desc_t (class)
    Proxy of C++ chooser_stdact_desc_t class.

ida_kernwin.chooser_stdact_desc_t.__disown__ (method)

ida_kernwin.chooser_stdact_desc_t.__init__ (method)
    __init__(self, _label=None, _tooltip=None, _icon=-1) -> chooser_stdact_desc_t
    
    @param _label: char const *
    @param _tooltip: char const *
    @param _icon: int

ida_kernwin.chooser_stdact_desc_t.label (variable)
    see action_desc_t

ida_kernwin.chooser_stdact_desc_t.ucb (method)
    ucb(self, arg0) -> action_state_t
    the update callback, see action_handler_t::update() When the update callback is
    called from the chooser UI engine, it can be sure that ctx.source.chooser is a
    valid pointer to chooser_base_t and that there are selected items for the Delete
    and Edit actions.
    
    @param arg0: action_update_ctx_t *

ida_kernwin.chooser_stdact_desc_t.version (variable)
    to support the backward compatibility

ida_kernwin.chtype_entry (variable)
    see choose_entry()

ida_kernwin.chtype_enum (variable)
    see choose_enum()

ida_kernwin.chtype_enum_by_value (variable)
    Deprecated. See chtype_enum_by_value_and_size.

ida_kernwin.chtype_enum_by_value_and_size (variable)
    see choose_enum_by_value()

ida_kernwin.chtype_func (variable)
    see choose_func()

ida_kernwin.chtype_generic (variable)
    the generic choose() function

ida_kernwin.chtype_idasgn (variable)
    see choose_idasgn()

ida_kernwin.chtype_idatil (variable)
    see choose_til()

ida_kernwin.chtype_name (variable)
    see choose_name()

ida_kernwin.chtype_obsolete_enum (variable)
    see choose_enum()

ida_kernwin.chtype_obsolete_enum_by_value_and_size (variable)
    see choose_enum_by_value()

ida_kernwin.chtype_obsolete_struc (variable)
    see choose_struc()

ida_kernwin.chtype_segm (variable)
    see choose_segm()

ida_kernwin.chtype_srcp (variable)
    see choose_srcp()

ida_kernwin.chtype_stkvar_xref (variable)
    see choose_stkvar_xref()

ida_kernwin.chtype_strpath (variable)
    see choose_struc_path()

ida_kernwin.chtype_struct (variable)
    see choose_struct()

ida_kernwin.chtype_xref (variable)
    see choose_xref()

ida_kernwin.clear_refresh_request (function)
    clear_refresh_request(mask)
    
    @param mask: uint64

ida_kernwin.cli_t (class)
    cli_t wrapper class.
    
    This class allows you to implement your own command line interface handlers.

ida_kernwin.cli_t.OnCompleteLine (method)
    The user pressed Tab. Find a completion number N for prefix PREFIX
    
    This callback is optional.
    
    @param prefix: Line prefix at prefix_start (string)
    @param n: completion number (int)
    @param line: the current line (string)
    @param prefix_start: the index where PREFIX starts in LINE (int)
    
    @return: None if no completion could be generated otherwise a String with the completion suggestion

ida_kernwin.cli_t.OnExecuteLine (method)
    The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
    
    This callback is mandatory.
    
    @param line: typed line(s)
    @return: Boolean: True-executed line, False-ask for more lines

ida_kernwin.cli_t.OnKeydown (method)
    A keyboard key has been pressed
    This is a generic callback and the CLI is free to do whatever it wants.
    
    This callback is optional.
    
    @param line: current input line
    @param x: current x coordinate of the cursor
    @param sellen: current selection length (usually 0)
    @param vkey: virtual key code. if the key has been handled, it should be returned as zero
    @param shift: shift state
    
    @return:     None - Nothing was changed
        tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
        It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)

ida_kernwin.cli_t.__del__ (method)

ida_kernwin.cli_t.__init__ (method)

ida_kernwin.cli_t.register (method)
    Registers the CLI.
    
    @param flags: Feature bits. No bits are defined yet, must be 0
    @param sname: Short name (displayed on the button)
    @param lname: Long name (displayed in the menu)
    @param hint: Hint for the input line
    
    @return: Boolean: True-Success, False-Failed

ida_kernwin.cli_t.unregister (method)
    Unregisters the CLI (if it was registered)

ida_kernwin.close_chooser (function)
    close_chooser(title) -> bool
    Close a non-modal chooser (ui_close_chooser).
    
    @param title: (C++: const char *) window title of chooser to close
    @return: success

ida_kernwin.close_widget (function)
    close_widget(widget, options)
    Close widget (ui_close_widget, only gui version).
    
    @param widget: (C++: TWidget *) pointer to the widget to close
    @param options: (C++: int) Form close flags

ida_kernwin.clr_cancelled (function)
    clr_cancelled()
    Clear "Cancelled" flag (ui_clr_cancelled)

ida_kernwin.create_code_viewer (function)
    create_code_viewer(custview, flags=0, parent=None) -> TWidget *
    Create a code viewer (ui_create_code_viewer). A code viewer contains on the left
    side a widget representing the line numbers, and on the right side, the child
    widget passed as parameter. It will inherit its title from the child widget.
    
    @param custview: (C++: TWidget *) the custom view to be added
    @param flags: (C++: int) Code viewer flags
    @param parent: (C++: TWidget *) widget to contain the new code viewer

ida_kernwin.create_empty_widget (function)
    create_empty_widget(title, icon=-1) -> TWidget *
    Create an empty widget, serving as a container for custom user widgets
    
    @param title: (C++: const char *) char const *
    @param icon: (C++: int)

ida_kernwin.create_menu (function)
    create_menu(name, label, menupath=None) -> bool
    Create a menu with the given name, label and optional position, either in the
    menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information
    about where the menu should be positioned. First, IDA will try and resolve the
    corresponding menu by its name. If such an existing menu is found and is present
    in the menubar, then the new menu will be inserted in the menubar before it.
    Otherwise, IDA will try to resolve 'menupath' as it would for
    attach_action_to_menu() and, if found, add the new menu like so:
    // The new 'My menu' submenu will appear in the 'Comments' submenu
    // before the 'Enter comment..." command
    create_menu("(...)", "My menu", "Edit/Comments/Enter comment...");
    or
    // The new 'My menu' submenu will appear at the end of the
    // 'Comments' submenu.
    create_menu("(...)", "My menu", "Edit/Comments/");
    If the above fails, the new menu will be appended to the menubar.
    
    @param name: (C++: const char *) name of menu (must be unique)
    @param label: (C++: const char *) label of menu
    @param menupath: (C++: const char *) where should the menu be inserted
    @return: success

ida_kernwin.create_toolbar (function)
    create_toolbar(name, label, before=None, flags=0) -> bool
    Create a toolbar with the given name, label and optional position
    
    @param name: (C++: const char *) name of toolbar (must be unique)
    @param label: (C++: const char *) label of toolbar
    @param before: (C++: const char *) if non-nullptr, the toolbar before which the new toolbar will be
                   inserted
    @param flags: (C++: int) a combination of create toolbar flags, to determine toolbar
                  position
    @return: success

ida_kernwin.custom_viewer_jump (function)
    custom_viewer_jump(v, loc, flags=0) -> bool
    Append 'loc' to the viewer's history, and cause the viewer to display it.
    
    @param v: (C++: TWidget *) (TWidget *)
    @param loc: (C++: const lochist_entry_t &) (const lochist_entry_t &)
    @param flags: (C++: uint32) (uint32) or'ed combination of CVNF_* values
    @return: success

ida_kernwin.del_hotkey (function)
    del_hotkey(pyctx) -> bool
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.

ida_kernwin.del_idc_hotkey (function)
    del_idc_hotkey(hotkey) -> bool
    
    @param hotkey: char const *

ida_kernwin.delete_menu (function)
    delete_menu(name) -> bool
    Delete an existing menu
    
    @param name: (C++: const char *) name of menu
    @return: success

ida_kernwin.delete_toolbar (function)
    delete_toolbar(name) -> bool
    Delete an existing toolbar
    
    @param name: (C++: const char *) name of toolbar
    @return: success

ida_kernwin.detach_action_from_menu (function)
    detach_action_from_menu(menupath, name) -> bool
    Detach an action from the menu (ui_detach_action_from_menu).
    
    @param menupath: (C++: const char *) path to the menu item
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.detach_action_from_popup (function)
    detach_action_from_popup(widget, name) -> bool
    Remove a previously-registered action, from the list of 'permanent' context menu
    actions for this widget (ui_detach_action_from_popup). This only makes sense if
    the action has been added to 'widget's list of permanent popup actions by
    calling attach_action_to_popup in 'permanent' mode.
    
    @param widget: (C++: TWidget *) target widget
    @param name: (C++: const char *) action name

ida_kernwin.detach_action_from_toolbar (function)
    detach_action_from_toolbar(toolbar_name, name) -> bool
    Detach an action from the toolbar (ui_detach_action_from_toolbar).
    
    @param toolbar_name: (C++: const char *) the name of the toolbar
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.disabled_script_timeout_t (class)

ida_kernwin.disabled_script_timeout_t.__enter__ (method)

ida_kernwin.disabled_script_timeout_t.__exit__ (method)

ida_kernwin.disasm_line_t (class)
    Proxy of C++ disasm_line_t class.

ida_kernwin.disasm_line_t.__init__ (method)
    __init__(self) -> disasm_line_t
    __init__(self, other) -> disasm_line_t
    
    @param other: disasm_line_t const &

ida_kernwin.disasm_text_t (class)
    Proxy of C++ qvector< disasm_line_t > class.

ida_kernwin.disasm_text_t.__getitem__ (method)
    __getitem__(self, i) -> disasm_line_t
    
    @param i: size_t

ida_kernwin.disasm_text_t.__init__ (method)
    __init__(self) -> disasm_text_t
    __init__(self, x) -> disasm_text_t
    
    @param x: qvector< disasm_line_t > const &

ida_kernwin.disasm_text_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.disasm_text_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: disasm_line_t const &

ida_kernwin.disasm_text_t.at (method)
    at(self, _idx) -> disasm_line_t
    
    @param _idx: size_t

ida_kernwin.disasm_text_t.begin (method)
    begin(self) -> disasm_line_t

ida_kernwin.disasm_text_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.disasm_text_t.clear (method)
    clear(self)

ida_kernwin.disasm_text_t.empty (method)
    empty(self) -> bool

ida_kernwin.disasm_text_t.end (method)
    end(self) -> disasm_line_t

ida_kernwin.disasm_text_t.erase (method)
    erase(self, it) -> disasm_line_t
    
    @param it: qvector< disasm_line_t >::iterator
    
    erase(self, first, last) -> disasm_line_t
    
    @param first: qvector< disasm_line_t >::iterator
    @param last: qvector< disasm_line_t >::iterator

ida_kernwin.disasm_text_t.extract (method)
    extract(self) -> disasm_line_t

ida_kernwin.disasm_text_t.grow (method)
    grow(self, x=disasm_line_t())
    
    @param x: disasm_line_t const &

ida_kernwin.disasm_text_t.inject (method)
    inject(self, s, len)
    
    @param s: disasm_line_t *
    @param len: size_t

ida_kernwin.disasm_text_t.insert (method)
    insert(self, it, x) -> disasm_line_t
    
    @param it: qvector< disasm_line_t >::iterator
    @param x: disasm_line_t const &

ida_kernwin.disasm_text_t.pop_back (method)
    pop_back(self)

ida_kernwin.disasm_text_t.push_back (method)
    push_back(self, x)
    
    @param x: disasm_line_t const &
    
    push_back(self) -> disasm_line_t

ida_kernwin.disasm_text_t.qclear (method)
    qclear(self)

ida_kernwin.disasm_text_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.disasm_text_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: disasm_line_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.disasm_text_t.size (method)
    size(self) -> size_t

ida_kernwin.disasm_text_t.swap (method)
    swap(self, r)
    
    @param r: qvector< disasm_line_t > &

ida_kernwin.disasm_text_t.truncate (method)
    truncate(self)

ida_kernwin.display_copyright_warning (function)
    display_copyright_warning() -> bool
    Display copyright warning (ui_copywarn).
    
    @return: yes/no

ida_kernwin.display_widget (function)
    display_widget(widget, options, dest_ctrl=None)
    Display a widget, dock it if not done before
    
    @param widget: (C++: TWidget *) widget to display
    @param options: (C++: uint32) Widget open flags
    @param dest_ctrl: (C++: const char *) where to dock: if nullptr or invalid then use the active
                      docker if there is not create a new tab relative to current
                      active tab

ida_kernwin.ea2str (function)
    ea2str(ea) -> str
    Convert linear address to UTF-8 string.
    
    @param ea: (C++: ea_t)

ida_kernwin.ea_viewer_history_push_and_jump (function)
    ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
    Push current location in the history and jump to the given location
    (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and
    also in other synchronized views.
    
    @param v: (C++: TWidget *) ea viewer
    @param ea: (C++: ea_t) jump destination
    @param x: (C++: int) ,y: coords on screen
    @param lnnum: (C++: int) desired line number of given address
    @param lnnum: (C++: int) desired line number of given address

ida_kernwin.enable_chooser_item_attrs (function)
    enable_chooser_item_attrs(chooser_caption, enable) -> bool
    Enable item-specific attributes for chooser items
    (ui_enable_chooser_item_attrs). For example: color list items differently
    depending on a criterium.
    If enabled, the chooser will generate ui_get_chooser_item_attrs
    events that can be intercepted by a plugin to modify the item attributes.
    This event is generated only in the GUI version of IDA.
    Specifying CH_ATTRS bit at the chooser creation time has the same effect.
    
    @param chooser_caption: (C++: const char *) char const *
    @param enable: (C++: bool)
    @return: success

ida_kernwin.enumplace_t (class)
    Proxy of C++ enumplace_t class.

ida_kernwin.enumplace_t.__init__ (method)

ida_kernwin.enumplace_t.bmask (variable)
    enum member bitmask

ida_kernwin.enumplace_t.idx (variable)
    enum serial number

ida_kernwin.enumplace_t.serial (variable)
    enum member serial number

ida_kernwin.enumplace_t.value (variable)
    enum member value

ida_kernwin.error (function)
    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

ida_kernwin.execute_sync (function)
    execute_sync(py_callable, reqf) -> int
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param py_callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable

ida_kernwin.execute_ui_requests (function)
    execute_ui_requests(py_list) -> bool
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callable item

ida_kernwin.find_widget (function)
    find_widget(caption) -> TWidget *
    Find widget with the specified caption (only gui version) (ui_find_widget). NB:
    this callback works only with the tabbed widgets!
    
    @param caption: (C++: const char *) title of tab, or window title if widget is not tabbed
    @return: pointer to the TWidget, nullptr if none is found

ida_kernwin.formchgcbfa_close (function)
    formchgcbfa_close(p_fa, close_normally)
    
    @param p_fa: size_t
    @param close_normally: int

ida_kernwin.formchgcbfa_enable_field (function)
    formchgcbfa_enable_field(p_fa, fid, enable) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param enable: bool

ida_kernwin.formchgcbfa_get_field_value (function)
    formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
    
    @param p_fa: size_t
    @param fid: int
    @param ft: int
    @param sz: size_t

ida_kernwin.formchgcbfa_get_focused_field (function)
    formchgcbfa_get_focused_field(p_fa) -> int
    
    @param p_fa: size_t

ida_kernwin.formchgcbfa_move_field (function)
    formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param x: int
    @param y: int
    @param w: int
    @param h: int

ida_kernwin.formchgcbfa_refresh_field (function)
    formchgcbfa_refresh_field(p_fa, fid)
    
    @param p_fa: size_t
    @param fid: int

ida_kernwin.formchgcbfa_set_field_value (function)
    formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param ft: int
    @param py_val: PyObject *

ida_kernwin.formchgcbfa_set_focused_field (function)
    formchgcbfa_set_focused_field(p_fa, fid) -> bool
    
    @param p_fa: size_t
    @param fid: int

ida_kernwin.formchgcbfa_show_field (function)
    formchgcbfa_show_field(p_fa, fid, show) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param show: bool

ida_kernwin.free_custom_icon (function)
    free_custom_icon(icon_id)
    Frees an icon loaded with load_custom_icon()
    
    @param icon_id: int

ida_kernwin.gen_disasm_text (function)
    gen_disasm_text(text, ea1, ea2, truncate_lines)
    Generate disassembly text for a range.
    
    @param text: (C++: text_t &) result
    @param ea1: (C++: ea_t) start address
    @param ea2: (C++: ea_t) end address
    @param truncate_lines: (C++: bool) (on idainfo::margin)

ida_kernwin.get_action_checkable (function)
    get_action_checkable(name) -> bool
    Get an action's checkability (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_checked (function)
    get_action_checked(name) -> bool
    Get an action's checked state (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_icon (function)
    get_action_icon(name) -> bool
    Get an action's icon (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_label (function)
    get_action_label(name) -> str
    Get an action's label (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_shortcut (function)
    get_action_shortcut(name) -> str
    Get an action's shortcut (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_state (function)
    get_action_state(name) -> bool
    Get an action's state (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_tooltip (function)
    get_action_tooltip(name) -> str
    Get an action's tooltip (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_action_visibility (function)
    get_action_visibility(name) -> bool
    Get an action's visibility (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

ida_kernwin.get_active_modal_widget (function)
    get_active_modal_widget() -> TWidget *
    Get the current, active modal TWidget instance. Note that in this context, the
    "wait dialog" is not considered: this function will return nullptr even if it is
    currently shown.
    
    @return: TWidget * the active modal widget, or nullptr

ida_kernwin.get_addon_info (function)
    get_addon_info(id, info) -> bool
    Get info about a registered addon with a given product code. info->cb must be
    valid! NB: all pointers are invalidated by next call to register_addon or
    get_addon_info
    
    @param id: (C++: const char *) char const *
    @param info: (C++: addon_info_t *)
    @return: false if not found

ida_kernwin.get_addon_info_idx (function)
    get_addon_info_idx(index, info) -> bool
    Get info about a registered addon with specific index. info->cb must be valid!
    NB: all pointers are invalidated by next call to register_addon or
    get_addon_info
    
    @param index: (C++: int)
    @param info: (C++: addon_info_t *)
    @return: false if index is out of range

ida_kernwin.get_chooser_data (function)
    get_chooser_data(chooser_caption, n) -> [str, ...]
    Get the text corresponding to the index N in the chooser data. Use -1 to get the
    header.
    
    See also get_chooser_rows().
    
    @param chooser_caption: (C++: const char *) char const *
    @param n: (C++: int)

ida_kernwin.get_chooser_obj (function)
    get_chooser_obj(chooser_caption) -> void *
    Get the underlying object of the specified chooser (ui_get_chooser_obj).
    
    This attemps to find the choser by its title and, if found, returns the result
    of calling its chooser_base_t::get_chooser_obj() method.
    
    @note: This is object is chooser-specific.
    
    @param chooser_caption: (C++: const char *) char const *
    @return: the object that was used to create the chooser

ida_kernwin.get_chooser_rows (function)
    get_chooser_rows(out, chooser_caption, what) -> bool
    Get the chooser contents corresponding to the rows indicated by "what".
    
    @param out: (C++: chooser_row_info_vec_t *) A vector of chooser_row_info_t, one entry per returned row.
    @param chooser_caption: (C++: const char *) The caption that identifies the desired chooser.
    @param what: (C++: size_t) Either one of the GCRF_ flags, or a row index.
    @return: Success.

ida_kernwin.get_curline (function)
    get_curline() -> char const *
    Get current line from the disassemble window (ui_get_curline).
    
    @return: cptr current line with the color codes (use tag_remove() to remove the
             color codes)

ida_kernwin.get_current_viewer (function)
    get_current_viewer() -> TWidget *
    Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)

ida_kernwin.get_current_widget (function)
    get_current_widget() -> TWidget *
    Get a pointer to the current widget (ui_get_current_widget).

ida_kernwin.get_cursor (function)
    get_cursor() -> bool
    Get the cursor position on the screen (ui_get_cursor).
    @note: coordinates are 0-based
    
    @retval true: pointers are filled
    @retval false: no disassembly window open

ida_kernwin.get_custom_viewer_curline (function)
    get_custom_viewer_curline(custom_viewer, mouse) -> char const *
    Get current line of custom viewer (ui_get_custom_viewer_curline). The returned
    line contains color codes
    
    See also the more powerful get_custom_viewer_location()
    
    @param custom_viewer: (C++: TWidget *) view
    @param mouse: (C++: bool) mouse position (otherwise cursor position)
    @return: pointer to contents of current line

ida_kernwin.get_custom_viewer_location (function)
    get_custom_viewer_location(out, custom_viewer, mouse=False) -> bool
    Get the current location in a custom viewer (ui_get_custom_viewer_location_2).
    
    @param out: (C++: listing_location_t *) output structure to fill
    @param custom_viewer: (C++: TWidget *) the listing widget
    @param flags: (C++: uint32) or'ed combination of CVLF_* values
    get_custom_viewer_location(out, custom_viewer, flags=0) -> bool
    
    @param out: listing_location_t *
    @param custom_viewer: TWidget *
    @param flags: uint32

ida_kernwin.get_custom_viewer_place (function)
    get_custom_viewer_place(custom_viewer, mouse) -> place_t
    Get current place in a custom viewer (ui_get_curplace).
    
    See also the more complete get_custom_viewer_location()
    
    @param custom_viewer: (C++: TWidget *) view
    @param mouse: (C++: bool) mouse position (otherwise cursor position)

ida_kernwin.get_custom_viewer_place_xcoord (function)
    get_custom_viewer_place_xcoord(custom_viewer, pline, pitem) -> int
    Get the X position of the item, in the line
    
    @param custom_viewer: (C++: TWidget *) the widget
    @param pline: (C++: const place_t *) a place corresponding to the line
    @param pitem: (C++: const place_t *) a place corresponding to the item
    @return: -1 if 'pitem' is not included in the line
    -2 if 'pitem' points at the entire line
    >= 0 for the X coordinate within the pline, where pitem points

ida_kernwin.get_ea_viewer_history_info (function)
    get_ea_viewer_history_info(nback, nfwd, v) -> bool
    Get information about what's in the history (ui_ea_viewer_history_info).
    
    @param nback: (C++: int *) number of available back steps
    @param nfwd: (C++: int *) number of available forward steps
    @param v: (C++: TWidget *) ea viewer
    @retval false: if the given ea viewer does not exist
    @retval true: otherwise

ida_kernwin.get_hexdump_ea (function)
    get_hexdump_ea(hexdump_num) -> ea_t
    Get the current address in a hex view.
    
    @param hexdump_num: (C++: int) number of hexview window

ida_kernwin.get_highlight (function)
    get_highlight(v, in_flags=0) -> (str, int) or None
    Returns the currently highlighted identifier and flags
    
    @param v: The UI widget to operate on
    @param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.

ida_kernwin.get_icon_id_by_name (function)
    get_icon_id_by_name(icon_name) -> int
    Retrieve the id of the icon by name (ui_get_icon_id_by_name).
    
    @param icon_name: (C++: const char *) full name of the icon
    @return: icon id

ida_kernwin.get_kernel_version (function)
    get_kernel_version() -> str
    Get IDA kernel version (in a string like "5.1").

ida_kernwin.get_key_code (function)
    get_key_code(keyname) -> ushort
    Get keyboard key code by its name (ui_get_key_code)
    
    @param keyname: (C++: const char *) char const *

ida_kernwin.get_navband_ea (function)
    get_navband_ea(pixel) -> ea_t
    Translate the pixel position on the navigation band, into an address.
    
    @param pixel: (C++: int)

ida_kernwin.get_navband_pixel (function)
    get_navband_pixel(ea) -> int
    Maps an address, onto a pixel coordinate within the navigation band
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]

ida_kernwin.get_opnum (function)
    get_opnum() -> int
    Get current operand number, -1 means no operand (ui_get_opnum)

ida_kernwin.get_output_curline (function)
    get_output_curline(mouse) -> str
    Get current line of output window (ui_get_output_curline).
    
    @param mouse: (C++: bool) current for mouse pointer?
    @return: false if output contains no text

ida_kernwin.get_output_cursor (function)
    get_output_cursor() -> bool
    Get coordinates of the output window's cursor (ui_get_output_cursor).
    @note: coordinates are 0-based
    @note: this function will succeed even if the output window is not visible
    
    @retval false: the output window has been destroyed.
    @retval true: pointers are filled

ida_kernwin.get_output_selected_text (function)
    get_output_selected_text() -> str
    Returns selected text from output window (ui_get_output_selected_text).
    
    @return: true if there is a selection

ida_kernwin.get_place_class (function)
    get_place_class(out_flags, out_sdk_version, id) -> place_t
    Get information about a previously-registered place_t class. See also
    register_place_class().
    
    @param out_flags: (C++: int *) output flags (can be nullptr)
    @param out_sdk_version: (C++: int *) sdk version the place was created with (can be nullptr)
    @param id: (C++: int) place class ID
    @return: the place_t template, or nullptr if not found

ida_kernwin.get_place_class_id (function)
    get_place_class_id(name) -> int
    Get the place class ID for the place that has been registered as 'name'.
    
    @param name: (C++: const char *) the class name
    @return: the place class ID, or -1 if not found

ida_kernwin.get_place_class_template (function)
    get_place_class_template(id) -> place_t
    See get_place_class()
    
    @param id: (C++: int)

ida_kernwin.get_registered_actions (function)
    get_registered_actions() -> [str, ...]
    Get a list of all currently-registered actions

ida_kernwin.get_screen_ea (function)
    get_screen_ea() -> ea_t
    Get the address at the screen cursor (ui_screenea)

ida_kernwin.get_synced_group (function)
    get_synced_group(w) -> synced_group_t
    Get the group of widgets/registers this view is synchronized with
    
    @param w: (C++: const TWidget *) the widget
    @return: the group of widgets/registers, or nullptr

ida_kernwin.get_tab_size (function)
    get_tab_size(path) -> int
    Get the size of a tab in spaces (ui_get_tab_size).
    
    @param path: (C++: const char *) the path of the source view for which the tab size is requested.
    * if nullptr, the default size is returned.

ida_kernwin.get_user_input_event (function)
    get_user_input_event(out) -> bool
    Get the current user input event (mouse button press, key press, ...) It is
    sometimes desirable to be able to tell when a certain situation happens (e.g.,
    'view_curpos' gets triggered); this function exists to provide that context (GUI
    version only)
    
    @param out: (C++: input_event_t *) the input event data
    @return: false if we are not currently processing a user input event

ida_kernwin.get_user_strlist_options (function)
    get_user_strlist_options(out)
    
    @param out: strwinsetup_t *

ida_kernwin.get_view_renderer_type (function)
    get_view_renderer_type(v) -> tcc_renderer_type_t
    Get the type of renderer currently in use in the given view
    (ui_get_renderer_type)
    
    @param v: (C++: TWidget *)

ida_kernwin.get_viewer_place_type (function)
    get_viewer_place_type(viewer) -> tcc_place_type_t
    Get the type of place_t instances a viewer uses & creates
    (ui_get_viewer_place_type).
    
    @param viewer: (C++: TWidget *)

ida_kernwin.get_viewer_user_data (function)
    get_viewer_user_data(viewer) -> void *
    Get the user data from a custom viewer (ui_get_viewer_user_data)
    
    @param viewer: (C++: TWidget *)

ida_kernwin.get_widget_title (function)
    get_widget_title(widget) -> str
    Get the TWidget's title (ui_get_widget_title).
    
    @param widget: (C++: TWidget *)

ida_kernwin.get_widget_type (function)
    get_widget_type(widget) -> twidget_type_t
    Get the type of the TWidget * (ui_get_widget_type).
    
    @param widget: (C++: TWidget *)

ida_kernwin.get_window_id (function)
    get_window_id(name=None) -> void *
    Get the system-specific window ID (GUI version only)
    
    @param name: (C++: const char *) name of the window (nullptr means the main IDA window)
    @return: the low-level window ID

ida_kernwin.hide_wait_box (function)
    hide_wait_box()
    Hide the "Please wait dialog box".

ida_kernwin.idaplace_t (class)
    Proxy of C++ idaplace_t class.

ida_kernwin.idaplace_t.__init__ (method)

ida_kernwin.idaplace_t.ea (variable)
    address

ida_kernwin.info (function)
    info(format)
    
    @param format: char const *

ida_kernwin.input_event_keyboard_data_t (class)
    Proxy of C++ input_event_t::input_event_keyboard_data_t class.

ida_kernwin.input_event_keyboard_data_t.__init__ (method)
    __init__(self) -> input_event_keyboard_data_t

ida_kernwin.input_event_mouse_data_t (class)
    Proxy of C++ input_event_t::input_event_mouse_data_t class.

ida_kernwin.input_event_mouse_data_t.__init__ (method)
    __init__(self) -> input_event_mouse_data_t

ida_kernwin.input_event_shortcut_data_t (class)
    Proxy of C++ input_event_t::input_event_shortcut_data_t class.

ida_kernwin.input_event_shortcut_data_t.__init__ (method)
    __init__(self) -> input_event_shortcut_data_t

ida_kernwin.input_event_t (class)
    Proxy of C++ input_event_t class.

ida_kernwin.input_event_t.__init__ (method)
    __init__(self) -> input_event_t

ida_kernwin.input_event_t._source_as_size (method)
    _source_as_size(self) -> size_t

ida_kernwin.input_event_t._target_as_size (method)
    _target_as_size(self) -> size_t

ida_kernwin.input_event_t.cb (variable)
    size marker

ida_kernwin.input_event_t.get_source_QEvent (method)

ida_kernwin.input_event_t.get_target_QWidget (method)

ida_kernwin.input_event_t.kind (variable)
    the kind of event

ida_kernwin.input_event_t.modifiers (variable)
    current keyboard (and mouse) modifiers

ida_kernwin.input_event_t.source (variable)
    the source event, should it be required for detailed inform (e.g., a QEvent in
    the GUI version of IDA)

ida_kernwin.input_event_t.target (variable)
    the target widget

ida_kernwin.install_command_interpreter (function)
    install_command_interpreter(py_obj) -> int
    Install command line interpreter (ui_install_cli)
    
    @param py_obj: PyObject *

ida_kernwin.internal_register_place_class (function)
    internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
    
    @param tmplate: place_t const *
    @param flags: int
    @param owner: plugin_t const *
    @param sdk_version: int

ida_kernwin.is_action_enabled (function)
    is_action_enabled(s) -> bool
    Check if the given action state is one of AST_ENABLE*.
    
    @param s: (C++: action_state_t) enum action_state_t

ida_kernwin.is_chooser_widget (function)
    is_chooser_widget(t) -> bool
    Does the given widget type specify a chooser widget?
    
    @param t: (C++: twidget_type_t)

ida_kernwin.is_idaq (function)
    is_idaq() -> bool
    Returns True or False depending if IDAPython is hosted by IDAQ

ida_kernwin.is_idaview (function)
    is_idaview(v) -> bool
    Is the given custom view an idaview? (ui_is_idaview)
    
    @param v: (C++: TWidget *)

ida_kernwin.is_msg_inited (function)
    is_msg_inited() -> bool
    Can we use msg() functions?

ida_kernwin.is_place_class_ea_capable (function)
    is_place_class_ea_capable(id) -> bool
    See get_place_class()
    
    @param id: (C++: int)

ida_kernwin.is_refresh_requested (function)
    is_refresh_requested(mask) -> bool
    Get a refresh request state
    
    @param mask: (C++: uint64) Window refresh flags
    @return: the state (set or cleared)

ida_kernwin.is_tif_cursor_footer (function)
    is_tif_cursor_footer(c) -> bool
    
    @param c: tif_cursor_t

ida_kernwin.is_tif_cursor_header (function)
    is_tif_cursor_header(c) -> bool
    
    @param c: tif_cursor_t

ida_kernwin.is_tif_cursor_index (function)
    is_tif_cursor_index(c) -> bool
    
    @param c: tif_cursor_t

ida_kernwin.jobj_wrapper_t (class)
    Proxy of C++ jobj_wrapper_t class.

ida_kernwin.jobj_wrapper_t.__init__ (method)

ida_kernwin.jobj_wrapper_t.get_dict (method)
    get_dict(self) -> dict

ida_kernwin.jumpto (function)
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    Set cursor position in custom ida viewer.
    
    @param custom_viewer: (C++: TWidget *) view
    @param place: (C++: place_t *) target position
    @param uijmp_flags: int
    
    @return: success
    jumpto(custom_viewer, place, x, y) -> bool
    
    @param custom_viewer: TWidget *
    @param place: place_t *
    @param x: int

ida_kernwin.l_compare2 (function)
    l_compare2(t1, t2, ud) -> int
    
    @param t1: place_t const *
    @param t2: place_t const *
    @param ud: void *

ida_kernwin.line_rendering_output_entries_refs_t (class)
    Proxy of C++ qvector< line_rendering_output_entry_t * > class.

ida_kernwin.line_rendering_output_entries_refs_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< line_rendering_output_entry_t * > const &

ida_kernwin.line_rendering_output_entries_refs_t.__getitem__ (method)
    __getitem__(self, i) -> line_rendering_output_entry_t
    
    @param i: size_t

ida_kernwin.line_rendering_output_entries_refs_t.__init__ (method)
    __init__(self) -> line_rendering_output_entries_refs_t
    __init__(self, x) -> line_rendering_output_entries_refs_t
    
    @param x: qvector< line_rendering_output_entry_t * > const &

ida_kernwin.line_rendering_output_entries_refs_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.line_rendering_output_entries_refs_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< line_rendering_output_entry_t * > const &

ida_kernwin.line_rendering_output_entries_refs_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t._internal_push_back (method)
    _internal_push_back(self, e)
    
    Parameters
    ----------
    e: line_rendering_output_entry_t *

ida_kernwin.line_rendering_output_entries_refs_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t.at (method)
    at(self, _idx) -> line_rendering_output_entry_t
    
    @param _idx: size_t

ida_kernwin.line_rendering_output_entries_refs_t.begin (method)
    begin(self) -> qvector< line_rendering_output_entry_t * >::iterator
    begin(self) -> qvector< line_rendering_output_entry_t * >::const_iterator

ida_kernwin.line_rendering_output_entries_refs_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.line_rendering_output_entries_refs_t.clear (method)
    clear(self)

ida_kernwin.line_rendering_output_entries_refs_t.empty (method)
    empty(self) -> bool

ida_kernwin.line_rendering_output_entries_refs_t.end (method)
    end(self) -> qvector< line_rendering_output_entry_t * >::iterator
    end(self) -> qvector< line_rendering_output_entry_t * >::const_iterator

ida_kernwin.line_rendering_output_entries_refs_t.erase (method)
    erase(self, it) -> qvector< line_rendering_output_entry_t * >::iterator
    
    @param it: qvector< line_rendering_output_entry_t * >::iterator
    
    erase(self, first, last) -> qvector< line_rendering_output_entry_t * >::iterator
    
    @param first: qvector< line_rendering_output_entry_t * >::iterator
    @param last: qvector< line_rendering_output_entry_t * >::iterator

ida_kernwin.line_rendering_output_entries_refs_t.extract (method)
    extract(self) -> line_rendering_output_entry_t **

ida_kernwin.line_rendering_output_entries_refs_t.find (method)
    find(self, x) -> qvector< line_rendering_output_entry_t * >::iterator
    
    @param x: line_rendering_output_entry_t *const &
    
    find(self, x) -> qvector< line_rendering_output_entry_t * >::const_iterator
    
    @param x: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t.has (method)
    has(self, x) -> bool
    
    @param x: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t.inject (method)
    inject(self, s, len)
    
    @param s: line_rendering_output_entry_t **
    @param len: size_t

ida_kernwin.line_rendering_output_entries_refs_t.insert (method)
    insert(self, it, x) -> qvector< line_rendering_output_entry_t * >::iterator
    
    @param it: qvector< line_rendering_output_entry_t * >::iterator
    @param x: line_rendering_output_entry_t *const &

ida_kernwin.line_rendering_output_entries_refs_t.pop_back (method)
    pop_back(self)

ida_kernwin.line_rendering_output_entries_refs_t.push_back (method)
    push_back(self, x)
    
    @param x: line_rendering_output_entry_t *const &
    
    push_back(self) -> line_rendering_output_entry_t *&

ida_kernwin.line_rendering_output_entries_refs_t.push_back (method)

ida_kernwin.line_rendering_output_entries_refs_t.qclear (method)
    qclear(self)

ida_kernwin.line_rendering_output_entries_refs_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.line_rendering_output_entries_refs_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: line_rendering_output_entry_t *const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.line_rendering_output_entries_refs_t.size (method)
    size(self) -> size_t

ida_kernwin.line_rendering_output_entries_refs_t.swap (method)
    swap(self, r)
    
    @param r: qvector< line_rendering_output_entry_t * > &

ida_kernwin.line_rendering_output_entries_refs_t.truncate (method)
    truncate(self)

ida_kernwin.line_rendering_output_entry_t (class)
    Proxy of C++ line_rendering_output_entry_t class.

ida_kernwin.line_rendering_output_entry_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: line_rendering_output_entry_t const &

ida_kernwin.line_rendering_output_entry_t.__init__ (method)
    __init__(self, _line, _flags=0, _bg_color=0) -> line_rendering_output_entry_t
    
    @param _line: twinline_t const *
    @param _flags: uint32
    @param _bg_color: bgcolor_t
    
    __init__(self, _line, _cpx, _nchars, _flags, _bg_color) -> line_rendering_output_entry_t
    
    @param _line: twinline_t const *
    @param _cpx: int
    @param _nchars: int
    @param _flags: uint32
    @param _bg_color: bgcolor_t

ida_kernwin.line_rendering_output_entry_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: line_rendering_output_entry_t const &

ida_kernwin.line_rendering_output_entry_t.cpx (variable)
    number of char to start from, valid if LROEF_CPS_RANGE

ida_kernwin.line_rendering_output_entry_t.flags (variable)
    line_rendering_output_entry_t flags

ida_kernwin.line_rendering_output_entry_t.is_bg_color_direct (method)
    is_bg_color_direct(self) -> bool

ida_kernwin.line_rendering_output_entry_t.is_bg_color_empty (method)
    is_bg_color_empty(self) -> bool

ida_kernwin.line_rendering_output_entry_t.is_bg_color_key (method)
    is_bg_color_key(self) -> bool

ida_kernwin.line_rendering_output_entry_t.nchars (variable)
    chars count, valid if LROEF_CPS_RANGE

ida_kernwin.line_section_t (class)
    Proxy of C++ line_section_t class.

ida_kernwin.line_section_t.__init__ (method)
    __init__(self) -> line_section_t

ida_kernwin.line_section_t.contains (method)
    contains(self, x) -> bool
    
    @param x: cpidx_t

ida_kernwin.line_section_t.is_closed (method)
    is_closed(self) -> bool

ida_kernwin.line_section_t.is_open (method)
    is_open(self) -> bool

ida_kernwin.line_section_t.valid (method)
    valid(self) -> bool

ida_kernwin.linearray_t (class)
    Proxy of C++ linearray_t class.

ida_kernwin.linearray_t.__init__ (method)
    __init__(self, _ud) -> linearray_t
    
    @param _ud: void *

ida_kernwin.linearray_t.beginning (method)
    beginning(self) -> bool
    Are we at the beginning?

ida_kernwin.linearray_t.down (method)
    down(self) -> qstring const *
    Get a line from down direction. place is ok BEFORE

ida_kernwin.linearray_t.ending (method)
    ending(self) -> bool

ida_kernwin.linearray_t.get_bg_color (method)
    get_bg_color(self) -> bgcolor_t
    Get current background color. (the same behavior as with get_place(): good
    before down() and after up())

ida_kernwin.linearray_t.get_dlnnum (method)
    get_dlnnum(self) -> int
    Get default line number. (the same behavior as with get_place(): good before
    down() and after up())

ida_kernwin.linearray_t.get_linecnt (method)
    get_linecnt(self) -> int
    Get number of lines for the current place. (the same behavior as with
    get_place(): good before down() and after up())

ida_kernwin.linearray_t.get_pfx_color (method)
    get_pfx_color(self) -> bgcolor_t
    Get current prefix color. (the same behavior as with get_place(): good before
    down() and after up())

ida_kernwin.linearray_t.get_place (method)
    get_place(self) -> place_t
    Get the current place. If called before down(), then returns place of line which
    will be returned by down(). If called after up(), then returns place if line
    returned by up().

ida_kernwin.linearray_t.set_place (method)
    set_place(self, new_at) -> int
    Position the array. This function must be called before calling any other member
    functions.
    
    linearray_t doesn't own place_t structures. The caller must take care of place_t
    objects.
    
    @param new_at: (C++: const place_t *) new position of the array
    @return: the delta of lines that the linearray_t had to adjust the place by.
    For example, if the place_t has a lnnum of 5, but it turns out, upon generating
    lines,
    that the number of lines for that particular place is only 2, then 3 will be
    returned.

ida_kernwin.linearray_t.set_userdata (method)
    set_userdata(self, userd)
    Change the user data.
    
    @param userd: (C++: void *)

ida_kernwin.linearray_t.up (method)
    up(self) -> qstring const *
    Get a line from up direction. place is ok AFTER

ida_kernwin.linearray_t.userdata (method)
    userdata(self) -> void *
    Get pointer to user data.

ida_kernwin.lines_rendering_input_t (class)
    Proxy of C++ lines_rendering_input_t class.

ida_kernwin.lines_rendering_input_t.__init__ (method)
    __init__(self) -> lines_rendering_input_t

ida_kernwin.lines_rendering_input_t.sections_lines (variable)
    references to the lines that are used for rendering

ida_kernwin.lines_rendering_input_t.sync_group (variable)
    the 'synced' group 'widget' (see ui_get_lines_rendering_info) belongs to, or
    nullptr

ida_kernwin.lines_rendering_output_t (class)
    Proxy of C++ lines_rendering_output_t class.

ida_kernwin.lines_rendering_output_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: lines_rendering_output_t const &

ida_kernwin.lines_rendering_output_t.__init__ (method)
    __init__(self) -> lines_rendering_output_t

ida_kernwin.lines_rendering_output_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: lines_rendering_output_t const &

ida_kernwin.lines_rendering_output_t.clear (method)
    clear(self)

ida_kernwin.lines_rendering_output_t.swap (method)
    swap(self, r)
    
    @param r: lines_rendering_output_t &

ida_kernwin.listing_location_t (class)
    Proxy of C++ listing_location_t class.

ida_kernwin.listing_location_t.__init__ (method)
    __init__(self) -> listing_location_t

ida_kernwin.load_custom_icon (function)
    Loads a custom icon and returns an identifier that can be used with other APIs
    
    If file_name is passed then the other two arguments are ignored.
    
    Load an icon and return its id (ui_load_custom_icon).
    
    @return: icon id

ida_kernwin.load_dbg_dbginfo (function)
    load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
    Load debugging information from a file.
    
    @param path: (C++: const char *) path to file
    @param li: (C++: linput_t *) loader input. if nullptr, check DBG_NAME_KEY
    @param base: (C++: ea_t) loading address
    @param verbose: (C++: bool) dump status to message window

ida_kernwin.lookup_key_code (function)
    lookup_key_code(key, shift, is_qt) -> ushort
    Get shortcut code previously created by ui_get_key_code.
    
    @param key: (C++: int) key constant
    @param shift: (C++: int) modifiers
    @param is_qt: (C++: bool) are we using gui version?

ida_kernwin.mbox_internal (variable)
    internal error

ida_kernwin.msg (function)
    msg(o) -> int
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

ida_kernwin.msg_activated (variable)
    The message window is activated.

ida_kernwin.msg_clear (function)
    msg_clear()
    Clear the "Output" window.

ida_kernwin.msg_click (variable)
    Click event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

ida_kernwin.msg_closed (variable)
    View closed.

ida_kernwin.msg_dblclick (variable)
    Double click event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

ida_kernwin.msg_deactivated (variable)
    The message window is deactivated.

ida_kernwin.msg_get_lines (function)
    msg_get_lines(count=-1) -> [str, ...]
    Retrieve the last 'count' lines from the output window, in reverse order (from
    most recent, to least recent)
    
    @param count: (C++: int) The number of lines to retrieve. -1 means: all

ida_kernwin.msg_keydown (variable)
    Key down event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

ida_kernwin.msg_save (function)
    msg_save(path) -> bool
    Save the "Output" window contents into a file
    
    @param path: (C++: qstring &) The path of the file to save the contents into. An empty path means
                 that the user will be prompted for the destination and, if the file
                 already exists, the user will be asked to confirm before overriding
                 its contents. Upon return, 'path' will contain the path that the
                 user chose.
    @return: success

ida_kernwin.nomem (function)
    nomem(format)
    
    @param format: char const *

ida_kernwin.open_bookmarks_window (function)
    open_bookmarks_window(w) -> TWidget *
    Open the bookmarks window (ui_open_builtin).
    
    @param w: (C++: TWidget *) The widget for which the bookmarks will open. For example, this can be
              an IDAView, or Enums view, etc.
    @return: pointer to resulting window

ida_kernwin.open_bpts_window (function)
    open_bpts_window(ea) -> TWidget *
    Open the breakpoints window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_calls_window (function)
    open_calls_window(ea) -> TWidget *
    Open the function calls window (ui_open_builtin).
    
    @param ea: (C++: ea_t)
    @return: pointer to resulting window

ida_kernwin.open_disasm_window (function)
    open_disasm_window(window_title, ranges=None) -> TWidget *
    Open a disassembly view (ui_open_builtin).
    
    @param window_title: (C++: const char *) title of view to open
    @param ranges: (C++: const rangevec_t *) if != nullptr, then display a flow chart with the specified
                   ranges
    @return: pointer to resulting window

ida_kernwin.open_enums_window (function)
    open_enums_window(const_id=BADADDR) -> TWidget *
    Open the enums window (ui_open_builtin).
    
    @param const_id: (C++: tid_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_exports_window (function)
    open_exports_window(ea) -> TWidget *
    Open the exports window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_form (function)
    Display a dockable modeless dialog box and return a handle to it. The modeless
    form can be closed in the following ways:
    * by pressing the small 'x' in the window title
    * by calling form_actions_t::close() from the form callback (form_actions_t)
    @note: pressing the 'Yes/No/Cancel' buttons does not close the modeless form,
           except if the form callback explicitly calls close().
    
    @return: handle to the form or nullptr. the handle can be used with TWidget

ida_kernwin.open_frame_window (function)
    open_frame_window(pfn, offset) -> TWidget *
    Open the frame window for the given function (ui_open_builtin).
    
    @param pfn: (C++: func_t *) function to analyze
    @param offset: (C++: uval_t) offset where the cursor is placed
    @return: pointer to resulting window if 'pfn' is a valid function and the window
             was displayed,
    nullptr otherwise

ida_kernwin.open_funcs_window (function)
    open_funcs_window(ea) -> TWidget *
    Open the 'Functions' window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_hexdump_window (function)
    open_hexdump_window(window_title) -> TWidget *
    Open a hexdump view (ui_open_builtin).
    
    @param window_title: (C++: const char *) title of view to open
    @return: pointer to resulting window

ida_kernwin.open_imports_window (function)
    open_imports_window(ea) -> TWidget *
    Open the exports window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_loctypes_window (function)
    open_loctypes_window(ordinal, cursor=None) -> TWidget *
    Open the local types window (ui_open_builtin).
    
    @param ordinal: (C++: int) ordinal of type to select by default
    @param cursor: (C++: const tif_cursor_t *) cursor to the type member
    @return: pointer to resulting window

ida_kernwin.open_modules_window (function)
    open_modules_window() -> TWidget *
    Open the modules window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_names_window (function)
    open_names_window(ea) -> TWidget *
    Open the names window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_navband_window (function)
    open_navband_window(ea, zoom) -> TWidget *
    Open the navigation band window (ui_open_builtin).
    
    @param ea: (C++: ea_t) sets the address of the navband arrow
    @param zoom: (C++: int) sets the navband zoom level
    @return: pointer to resulting window

ida_kernwin.open_notepad_window (function)
    open_notepad_window() -> TWidget *
    Open the notepad window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_problems_window (function)
    open_problems_window(ea) -> TWidget *
    Open the problems window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_segments_window (function)
    open_segments_window(ea) -> TWidget *
    Open the segments window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_segregs_window (function)
    open_segregs_window(ea) -> TWidget *
    Open the segment registers window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.open_selectors_window (function)
    open_selectors_window() -> TWidget *
    Open the selectors window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_signatures_window (function)
    open_signatures_window() -> TWidget *
    Open the signatures window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_stack_window (function)
    open_stack_window() -> TWidget *
    Open the call stack window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_strings_window (function)
    open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
    Open the 'Strings' window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @param selstart: (C++: ea_t) ,selend: only display strings that occur within this range
    @param selend: (C++: ea_t)
    @return: pointer to resulting window

ida_kernwin.open_structs_window (function)
    open_structs_window(id=BADADDR, offset=0) -> TWidget *
    Open the structs window (ui_open_builtin).
    
    @param id: (C++: tid_t) index of entry to select by default
    @param offset: (C++: uval_t) offset where the cursor is placed
    @return: pointer to resulting window

ida_kernwin.open_threads_window (function)
    open_threads_window() -> TWidget *
    Open the threads window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_tils_window (function)
    open_tils_window() -> TWidget *
    Open the type libraries window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_trace_window (function)
    open_trace_window() -> TWidget *
    Open the tracing window (ui_open_builtin).
    
    @return: pointer to resulting window

ida_kernwin.open_url (function)
    open_url(url)
    Open the given url (ui_open_url)
    
    @param url: (C++: const char *) char const *

ida_kernwin.open_xrefs_window (function)
    open_xrefs_window(ea) -> TWidget *
    Open the cross references window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

ida_kernwin.place_t (class)
    Proxy of C++ place_t class.

ida_kernwin.place_t.__init__ (method)

ida_kernwin.place_t._print (method)
    _print(self, ud)
    
    Parameters
    ----------
    ud: void *

ida_kernwin.place_t.adjust (method)
    adjust(self, ud)
    Adjust the current location to point to a displayable object. This function
    validates the location and makes sure that it points to an existing object. For
    example, if the location points to the middle of an instruction, it will be
    adjusted to point to the beginning of the instruction.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t

ida_kernwin.place_t.as_enumplace_t (method)
    as_enumplace_t(p) -> enumplace_t
    
    @param p: place_t *

ida_kernwin.place_t.as_idaplace_t (method)
    as_idaplace_t(p) -> idaplace_t
    
    @param p: place_t *

ida_kernwin.place_t.as_simpleline_place_t (method)
    as_simpleline_place_t(p) -> simpleline_place_t
    
    @param p: place_t *

ida_kernwin.place_t.as_structplace_t (method)
    as_structplace_t(p) -> structplace_t
    
    @param p: place_t *

ida_kernwin.place_t.as_tiplace_t (method)
    as_tiplace_t(p) -> tiplace_t
    
    @param p: place_t *

ida_kernwin.place_t.beginning (method)
    beginning(self, ud) -> bool
    Are we at the first displayable object?.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: true if the current location points to the first displayable object

ida_kernwin.place_t.clone (method)
    clone(self) -> place_t
    Clone the location.
    
    @return: a pointer to a copy of the current location in dynamic memory

ida_kernwin.place_t.compare (method)
    compare(self, t2) -> int
    Deprecated. Please consider compare2(const place_t *, void *) instead.
    
    @param t2: (C++: const place_t *) place_t const *

ida_kernwin.place_t.compare2 (method)
    compare2(self, t2, arg3) -> int
    Compare two locations except line numbers (lnnum). This function is used to
    organize loops. For example, if the user has selected an range, its boundaries
    are remembered as location objects. Any operation within the selection will have
    the following look: for ( loc=starting_location; loc < ending_location;
    loc.next() ) In this loop, the comparison function is used.
    
    @param t2: (C++: const place_t *) the place to compare this one to.
    @param arg3: void *

ida_kernwin.place_t.copyfrom (method)
    copyfrom(self, _from)
    Copy the specified location object to the current object.
    
    @param from: (C++: const place_t *) place_t const *

ida_kernwin.place_t.deserialize (method)
    deserialize(self, _in) -> bool
    De-serialize into this instance. 'pptr' should be incremented by as many bytes
    as de-serialization consumed.
    
    @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
    @return: whether de-serialization was successful

ida_kernwin.place_t.ending (method)
    ending(self, ud) -> bool
    Are we at the last displayable object?.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: true if the current location points to the last displayable object

ida_kernwin.place_t.enter (method)
    enter(self, arg2) -> place_t
    Visit this place, possibly 'unhiding' a section of text. If entering that place
    required some expanding, a place_t should be returned that represents that
    section, plus some flags for later use by 'leave()'.
    
    @param out_flags: flags to be used together with the place_t that is returned,
                      in order to restore the section to its original state when
                      leave() is called.
    @return: a place_t corresponding to the beginning of the section of text that
             had to be expanded. That place_t's leave() will be called with the
             flags contained in 'out_flags' when the user navigates away from it.

ida_kernwin.place_t.generate (method)
    generate(self, ud, maxsize) -> ([str, ...], int, int, int)
    Generate text lines for the current location.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @param maxsize: (C++: int) the maximum number of lines to generate
    @return: number of generated lines

ida_kernwin.place_t.id (method)
    id(self) -> int
    Get the place's ID (i.e., the value returned by register_place_class())
    
    @return: the id

ida_kernwin.place_t.leave (method)
    leave(self, arg2)
    Leave this place, possibly 'hiding' a section of text that was previously
    expanded (at enter()-time.)
    
    @param arg2: uint32

ida_kernwin.place_t.lnnum (variable)
    Number of line within the current object.

ida_kernwin.place_t.makeplace (method)
    makeplace(self, ud, x, lnnum) -> place_t
    Map a number to a location. When the user clicks on the scrollbar and drags it,
    we need to determine the location corresponding to the new scrollbar position.
    This function is used to determine it. It builds a location object for the
    specified 'x' and returns a pointer to it.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @param x: (C++: uval_t) number to map
    @param lnnum: (C++: int) line number to initialize 'lnnum'
    @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES

ida_kernwin.place_t.name (method)
    name(self) -> char const *
    Get this place type name. All instances of a given class must return the same
    string.
    
    @return: the place type name. Please try and pick something that is not too
             generic, as it might clash w/ other plugins. A good practice is to
             prefix the class name with the name of your plugin. E.g.,
             "myplugin:srcplace_t".

ida_kernwin.place_t.next (method)
    next(self, ud) -> bool
    Move to the next displayable location.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: success

ida_kernwin.place_t.prev (method)
    prev(self, ud) -> bool
    Move to the previous displayable location.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: success

ida_kernwin.place_t.rebase (method)
    rebase(self, arg2) -> bool
    Rebase the place instance
    
    @param arg2: segm_move_infos_t const &
    @return: true if place was rebased, false otherwise

ida_kernwin.place_t.serialize (method)
    serialize(self)
    Serialize this instance. It is fundamental that all instances of a particular
    subclass of of place_t occupy the same number of bytes when serialized.

ida_kernwin.place_t.toea (method)
    toea(self) -> ea_t
    Map the location to an ea_t.
    
    @return: the corresponding ea_t, or BADADDR;

ida_kernwin.place_t.touval (method)
    touval(self, ud) -> uval_t
    Map the location to a number. This mapping is used to draw the vertical
    scrollbar.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t

ida_kernwin.place_t_as_enumplace_t (function)
    place_t_as_enumplace_t(p) -> enumplace_t
    
    @param p: place_t *

ida_kernwin.place_t_as_idaplace_t (function)
    place_t_as_idaplace_t(p) -> idaplace_t
    
    @param p: place_t *

ida_kernwin.place_t_as_simpleline_place_t (function)
    place_t_as_simpleline_place_t(p) -> simpleline_place_t
    
    @param p: place_t *

ida_kernwin.place_t_as_structplace_t (function)
    place_t_as_structplace_t(p) -> structplace_t
    
    @param p: place_t *

ida_kernwin.place_t_as_tiplace_t (function)
    place_t_as_tiplace_t(p) -> tiplace_t
    
    @param p: place_t *

ida_kernwin.plgform_close (function)
    plgform_close(py_link, options)
    
    @param py_link: PyObject *
    @param options: int

ida_kernwin.plgform_get_widget (function)
    plgform_get_widget(py_link) -> TWidget *
    
    @param py_link: PyObject *

ida_kernwin.plgform_new (function)
    plgform_new() -> PyObject *

ida_kernwin.plgform_show (function)
    plgform_show(py_link, py_obj, caption, options=(0x0040 << 16)|0x00000004u) -> bool
    
    @param py_link: PyObject *
    @param py_obj: PyObject *
    @param caption: char const *
    @param options: int

ida_kernwin.process_ui_action (function)
    process_ui_action(name, flags=0) -> bool
    Invokes an IDA UI action by name
    
    @param name: action name
    @param flags: int
    @return: Boolean

ida_kernwin.py_chooser_base_t_get_row (function)
    py_chooser_base_t_get_row(chobj, n) -> PyObject *
    
    @param chobj: chooser_base_t const *
    @param n: size_t

ida_kernwin.py_get_ask_form (function)
    py_get_ask_form() -> size_t

ida_kernwin.py_get_open_form (function)
    py_get_open_form() -> size_t

ida_kernwin.py_load_custom_icon_data (function)
    py_load_custom_icon_data(data, format) -> int
    
    @param data: PyObject *
    @param format: char const *

ida_kernwin.py_load_custom_icon_fn (function)
    py_load_custom_icon_fn(filename) -> int
    
    @param filename: char const *

ida_kernwin.py_register_compiled_form (function)
    py_register_compiled_form(py_form)
    
    @param py_form: PyObject *

ida_kernwin.py_unregister_compiled_form (function)
    py_unregister_compiled_form(py_form)
    
    @param py_form: PyObject *

ida_kernwin.pyidag_bind (function)
    pyidag_bind(_self) -> bool
    
    @param self: PyObject *

ida_kernwin.pyidag_unbind (function)
    pyidag_unbind(_self) -> bool
    
    @param self: PyObject *

ida_kernwin.pyscv_add_line (function)
    pyscv_add_line(py_this, py_sl) -> bool
    
    @param py_this: PyObject *
    @param py_sl: PyObject *

ida_kernwin.pyscv_clear_lines (function)
    pyscv_clear_lines(py_this) -> PyObject *
    
    @param py_this: PyObject *

ida_kernwin.pyscv_close (function)
    pyscv_close(py_this)
    
    @param py_this: PyObject *

ida_kernwin.pyscv_count (function)
    pyscv_count(py_this) -> size_t
    
    @param py_this: PyObject *

ida_kernwin.pyscv_del_line (function)
    pyscv_del_line(py_this, nline) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t

ida_kernwin.pyscv_edit_line (function)
    pyscv_edit_line(py_this, nline, py_sl) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param py_sl: PyObject *

ida_kernwin.pyscv_get_current_line (function)
    pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool
    @param notags: bool

ida_kernwin.pyscv_get_current_word (function)
    pyscv_get_current_word(py_this, mouse) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool

ida_kernwin.pyscv_get_line (function)
    pyscv_get_line(py_this, nline) -> PyObject *
    
    @param py_this: PyObject *
    @param nline: size_t

ida_kernwin.pyscv_get_pos (function)
    pyscv_get_pos(py_this, mouse) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool

ida_kernwin.pyscv_get_selection (function)
    pyscv_get_selection(py_this) -> PyObject *
    
    @param py_this: PyObject *

ida_kernwin.pyscv_get_widget (function)
    pyscv_get_widget(py_this) -> TWidget *
    
    @param py_this: PyObject *

ida_kernwin.pyscv_init (function)
    pyscv_init(py_link, title) -> PyObject *
    
    @param py_link: PyObject *
    @param title: char const *

ida_kernwin.pyscv_insert_line (function)
    pyscv_insert_line(py_this, nline, py_sl) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param py_sl: PyObject *

ida_kernwin.pyscv_is_focused (function)
    pyscv_is_focused(py_this) -> bool
    
    @param py_this: PyObject *

ida_kernwin.pyscv_jumpto (function)
    pyscv_jumpto(py_this, ln, x, y) -> bool
    
    @param py_this: PyObject *
    @param ln: size_t
    @param x: int
    @param y: int

ida_kernwin.pyscv_patch_line (function)
    pyscv_patch_line(py_this, nline, offs, value) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param offs: size_t
    @param value: int

ida_kernwin.pyscv_refresh (function)
    pyscv_refresh(py_this) -> bool
    
    @param py_this: PyObject *

ida_kernwin.pyscv_show (function)
    pyscv_show(py_this) -> bool
    
    @param py_this: PyObject *

ida_kernwin.qcleanline (function)
    qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> str
    Performs some cleanup operations to a line.
    
    @param cmt_char: (C++: char) character that denotes the start of a comment:
    * the entire text is removed if the line begins with this character (ignoring
    leading spaces)
    * all text after (and including) this character is removed if flag CLNL_FINDCMT
    is set
    @param flags: (C++: uint32) a combination of line cleanup flags. defaults to CLNL_TRIM
    @return: length of line

ida_kernwin.quick_widget_commands_t (class)

ida_kernwin.quick_widget_commands_t.__init__ (method)

ida_kernwin.quick_widget_commands_t._ah_t (class)

ida_kernwin.quick_widget_commands_t._ah_t.__init__ (method)

ida_kernwin.quick_widget_commands_t._ah_t.activate (method)

ida_kernwin.quick_widget_commands_t._ah_t.update (method)

ida_kernwin.quick_widget_commands_t._cmd_t (class)

ida_kernwin.quick_widget_commands_t._cmd_t.__init__ (method)

ida_kernwin.quick_widget_commands_t.add (method)

ida_kernwin.quick_widget_commands_t.populate_popup (method)

ida_kernwin.read_range_selection (function)
    read_range_selection(v) -> bool
    Get the address range for the selected range boundaries, this is the convenient
    function for read_selection()
    
    @param v: (C++: TWidget *) view, nullptr means the last active window containing addresses
    @retval 0: no range is selected
    @retval 1: ok, start ea and end ea are filled

ida_kernwin.read_selection (function)
    read_selection(v, p1, p2) -> bool
    Read the user selection, and store its information in p0 (from) and p1 (to).
    
    This can be used as follows:
    
    
    >>> p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    idaapi.read_selection(view, p0, p1)
    
    
    At that point, p0 and p1 hold information for the selection.
    But, the 'at' property of p0 and p1 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p0.place(view)
    place1 = p1.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param view: The view to retrieve the selection for.
    @param p1: Storage for the "to" part of the selection.
    @param p1: Storage for the "to" part of the selection.
    @return: a bool value indicating success.

ida_kernwin.refresh_chooser (function)
    refresh_chooser(title) -> bool
    Mark a non-modal custom chooser for a refresh (ui_refresh_chooser).
    
    @param title: (C++: const char *) title of chooser
    @return: success

ida_kernwin.refresh_choosers (function)
    refresh_choosers()

ida_kernwin.refresh_custom_viewer (function)
    refresh_custom_viewer(custom_viewer)
    Refresh custom ida viewer (ui_refresh_custom_viewer)
    
    @param custom_viewer: (C++: TWidget *)

ida_kernwin.refresh_idaview (function)
    refresh_idaview()
    Refresh marked windows (ui_refreshmarked)

ida_kernwin.refresh_idaview_anyway (function)
    refresh_idaview_anyway()
    Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please
    consider request_refresh() instead

ida_kernwin.refresh_navband (function)
    refresh_navband(force)
    Refresh navigation band if changed (ui_refresh_navband).
    
    @param force: (C++: bool) refresh regardless

ida_kernwin.register_action (function)
    register_action(desc) -> bool
    Create a new action (ui_register_action). After an action has been created, it
    is possible to attach it to menu items (attach_action_to_menu()), or to popup
    menus (attach_action_to_popup()).
    
    Because the actions will need to call the handler's activate() and update()
    methods at any time, you shouldn't build your action handler on the stack.
    
    Please see the SDK's "ht_view" plugin for an example how to register actions.
    
    @param desc: (C++: const action_desc_t &) action to register
    @return: success

ida_kernwin.register_addon (function)
    register_addon(info) -> int
    Register an add-on. Show its info in the About box. For plugins, should be
    called from init() function (repeated calls with the same product code overwrite
    previous entries) returns: index of the add-on in the list, or -1 on error
    
    @param info: (C++: const addon_info_t *) addon_info_t const *

ida_kernwin.register_and_attach_to_menu (function)
    register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner, action_desc_t_flags) -> bool
    Helper.
    
    You are not encouraged to use this, as it mixes flags for both
    register_action(), and attach_action_to_menu().
    
    The only reason for its existence is to make it simpler to port existing plugins
    to the new actions API.
    
    @param menupath: (C++: const char *) char const *
    @param name: (C++: const char *) char const *
    @param label: (C++: const char *) char const *
    @param shortcut: (C++: const char *) char const *
    @param flags: (C++: int)
    @param handler: (C++: action_handler_t *)
    @param owner: (C++: void *)
    @param action_desc_t_flags: (C++: int)

ida_kernwin.register_timer (function)
    register_timer(interval, py_callback) -> PyCapsule
    Register a timer
    
    @param interval: Interval in milliseconds
    @param py_callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object

ida_kernwin.remove_command_interpreter (function)
    remove_command_interpreter(cli_idx)
    Remove command line interpreter (ui_install_cli)
    
    @param cli_idx: int

ida_kernwin.renderer_pos_info_t (class)
    Proxy of C++ renderer_pos_info_t class.

ida_kernwin.renderer_pos_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: renderer_pos_info_t const &

ida_kernwin.renderer_pos_info_t.__init__ (method)
    __init__(self) -> renderer_pos_info_t

ida_kernwin.renderer_pos_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: renderer_pos_info_t const &

ida_kernwin.renderer_pos_info_t.cx (variable)
    the X coords of the character in the current line. When in graph mode: X coords
    of the character in 'node'.
    When in flat mode: X coords of the character in the line, w/o
    taking scrolling into consideration.

ida_kernwin.renderer_pos_info_t.cy (variable)
    the Y coords of the character. When in graph mode: Y coords of the character in
    'node'.
    When in flat mode: Line number, starting from the top.

ida_kernwin.renderer_pos_info_t.node (variable)
    the node, or -1 if the current renderer is not a graph renderer.

ida_kernwin.renderer_pos_info_t.sx (variable)
    the number of chars that are scrolled (flat mode only)

ida_kernwin.repaint_custom_viewer (function)
    repaint_custom_viewer(custom_viewer)
    Repaint the given widget immediately (ui_repaint_qwidget)
    
    @param custom_viewer: (C++: TWidget *)

ida_kernwin.replace_wait_box (function)
    replace_wait_box(format)
    Replace the label of "Please wait dialog box".
    
    @param format: (C++: const char *) char const *

ida_kernwin.request_refresh (function)
    request_refresh(mask, cnd=True)
    Request a refresh of a builtin window.
    
    @param mask: (C++: uint64) Window refresh flags
    @param cnd: (C++: bool) set if true or clear flag otherwise

ida_kernwin.restore_database_snapshot (function)
    restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> bool
    Restore a database snapshot. Note: This call is asynchronous. When it is
    completed, the callback will be triggered.
    
    @param ss: (C++: const snapshot_t *) snapshot instance (see build_snapshot_tree())
    @param pyfunc_or_none: PyObject *
    @param pytuple_or_none: PyObject *
    @return: false if restoration could not be started (snapshot file was not
             found).
    If the returned value is True then check if the operation succeeded from the
    callback.

ida_kernwin.section_lines_refs_t (class)
    Proxy of C++ qvector< twinline_t const * > class.

ida_kernwin.section_lines_refs_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< twinline_t const * > const &

ida_kernwin.section_lines_refs_t.__getitem__ (method)
    __getitem__(self, i) -> twinline_t
    
    @param i: size_t

ida_kernwin.section_lines_refs_t.__init__ (method)
    __init__(self) -> section_lines_refs_t
    __init__(self, x) -> section_lines_refs_t
    
    @param x: qvector< twinline_t const * > const &

ida_kernwin.section_lines_refs_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.section_lines_refs_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< twinline_t const * > const &

ida_kernwin.section_lines_refs_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: twinline_t const *const &

ida_kernwin.section_lines_refs_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: twinline_t const *const &

ida_kernwin.section_lines_refs_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: twinline_t const *const &

ida_kernwin.section_lines_refs_t.at (method)
    at(self, _idx) -> twinline_t
    
    @param _idx: size_t

ida_kernwin.section_lines_refs_t.begin (method)
    begin(self) -> qvector< twinline_t const * >::iterator
    begin(self) -> qvector< twinline_t const * >::const_iterator

ida_kernwin.section_lines_refs_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.section_lines_refs_t.clear (method)
    clear(self)

ida_kernwin.section_lines_refs_t.empty (method)
    empty(self) -> bool

ida_kernwin.section_lines_refs_t.end (method)
    end(self) -> qvector< twinline_t const * >::iterator
    end(self) -> qvector< twinline_t const * >::const_iterator

ida_kernwin.section_lines_refs_t.erase (method)
    erase(self, it) -> qvector< twinline_t const * >::iterator
    
    @param it: qvector< twinline_t const * >::iterator
    
    erase(self, first, last) -> qvector< twinline_t const * >::iterator
    
    @param first: qvector< twinline_t const * >::iterator
    @param last: qvector< twinline_t const * >::iterator

ida_kernwin.section_lines_refs_t.extract (method)
    extract(self) -> twinline_t const **

ida_kernwin.section_lines_refs_t.find (method)
    find(self, x) -> qvector< twinline_t const * >::iterator
    
    @param x: twinline_t const *const &
    
    find(self, x) -> qvector< twinline_t const * >::const_iterator
    
    @param x: twinline_t const *const &

ida_kernwin.section_lines_refs_t.has (method)
    has(self, x) -> bool
    
    @param x: twinline_t const *const &

ida_kernwin.section_lines_refs_t.inject (method)
    inject(self, s, len)
    
    @param s: twinline_t const **
    @param len: size_t

ida_kernwin.section_lines_refs_t.insert (method)
    insert(self, it, x) -> qvector< twinline_t const * >::iterator
    
    @param it: qvector< twinline_t const * >::iterator
    @param x: twinline_t const *const &

ida_kernwin.section_lines_refs_t.pop_back (method)
    pop_back(self)

ida_kernwin.section_lines_refs_t.push_back (method)
    push_back(self, x)
    
    @param x: twinline_t const *const &
    
    push_back(self) -> twinline_t const *&

ida_kernwin.section_lines_refs_t.qclear (method)
    qclear(self)

ida_kernwin.section_lines_refs_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.section_lines_refs_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: twinline_t const *const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.section_lines_refs_t.size (method)
    size(self) -> size_t

ida_kernwin.section_lines_refs_t.swap (method)
    swap(self, r)
    
    @param r: qvector< twinline_t const * > &

ida_kernwin.section_lines_refs_t.truncate (method)
    truncate(self)

ida_kernwin.sections_lines_refs_t (class)
    Proxy of C++ qvector< section_lines_refs_t > class.

ida_kernwin.sections_lines_refs_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< section_lines_refs_t > const &

ida_kernwin.sections_lines_refs_t.__getitem__ (method)
    __getitem__(self, i) -> section_lines_refs_t
    
    @param i: size_t

ida_kernwin.sections_lines_refs_t.__init__ (method)
    __init__(self) -> sections_lines_refs_t
    __init__(self, x) -> sections_lines_refs_t
    
    @param x: qvector< section_lines_refs_t > const &

ida_kernwin.sections_lines_refs_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.sections_lines_refs_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< section_lines_refs_t > const &

ida_kernwin.sections_lines_refs_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.at (method)
    at(self, _idx) -> section_lines_refs_t
    
    @param _idx: size_t

ida_kernwin.sections_lines_refs_t.begin (method)
    begin(self) -> qvector< section_lines_refs_t >::iterator
    begin(self) -> qvector< section_lines_refs_t >::const_iterator

ida_kernwin.sections_lines_refs_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.sections_lines_refs_t.clear (method)
    clear(self)

ida_kernwin.sections_lines_refs_t.empty (method)
    empty(self) -> bool

ida_kernwin.sections_lines_refs_t.end (method)
    end(self) -> qvector< section_lines_refs_t >::iterator
    end(self) -> qvector< section_lines_refs_t >::const_iterator

ida_kernwin.sections_lines_refs_t.erase (method)
    erase(self, it) -> qvector< section_lines_refs_t >::iterator
    
    @param it: qvector< section_lines_refs_t >::iterator
    
    erase(self, first, last) -> qvector< section_lines_refs_t >::iterator
    
    @param first: qvector< section_lines_refs_t >::iterator
    @param last: qvector< section_lines_refs_t >::iterator

ida_kernwin.sections_lines_refs_t.extract (method)
    extract(self) -> section_lines_refs_t

ida_kernwin.sections_lines_refs_t.find (method)
    find(self, x) -> qvector< section_lines_refs_t >::iterator
    
    @param x: section_lines_refs_t const &
    
    find(self, x) -> qvector< section_lines_refs_t >::const_iterator
    
    @param x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.grow (method)
    grow(self, x=section_lines_refs_t())
    
    @param x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.has (method)
    has(self, x) -> bool
    
    @param x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.inject (method)
    inject(self, s, len)
    
    @param s: section_lines_refs_t *
    @param len: size_t

ida_kernwin.sections_lines_refs_t.insert (method)
    insert(self, it, x) -> qvector< section_lines_refs_t >::iterator
    
    @param it: qvector< section_lines_refs_t >::iterator
    @param x: section_lines_refs_t const &

ida_kernwin.sections_lines_refs_t.pop_back (method)
    pop_back(self)

ida_kernwin.sections_lines_refs_t.push_back (method)
    push_back(self, x)
    
    @param x: section_lines_refs_t const &
    
    push_back(self) -> section_lines_refs_t

ida_kernwin.sections_lines_refs_t.qclear (method)
    qclear(self)

ida_kernwin.sections_lines_refs_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.sections_lines_refs_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: section_lines_refs_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.sections_lines_refs_t.size (method)
    size(self) -> size_t

ida_kernwin.sections_lines_refs_t.swap (method)
    swap(self, r)
    
    @param r: qvector< section_lines_refs_t > &

ida_kernwin.sections_lines_refs_t.truncate (method)
    truncate(self)

ida_kernwin.set_cancelled (function)
    set_cancelled()
    Set "Cancelled" flag (ui_set_cancelled)

ida_kernwin.set_code_viewer_handler (function)
    set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
    Set a handler for a code viewer event (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *) the code viewer
    @param handler_id: (C++: custom_viewer_handler_id_t) one of CDVH_ in custom_viewer_handler_id_t
    @param handler_or_data: (C++: void *) can be a handler or data. see examples in Functions:
                            custom viewer handlers
    @return: old value of the handler or data

ida_kernwin.set_code_viewer_is_source (function)
    set_code_viewer_is_source(code_viewer) -> bool
    Specify that the given code viewer is used to display source code
    (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)

ida_kernwin.set_code_viewer_line_handlers (function)
    set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
    Set handlers for code viewer line events. Any of these handlers may be nullptr
    
    @param code_viewer: (C++: TWidget *)
    @param click_handler: (C++: code_viewer_lines_click_t *)
    @param popup_handler: (C++: code_viewer_lines_click_t *)
    @param dblclick_handler: (C++: code_viewer_lines_click_t *)
    @param drawicon_handler: (C++: code_viewer_lines_icon_t *)
    @param linenum_handler: (C++: code_viewer_lines_linenum_t *)

ida_kernwin.set_code_viewer_lines_alignment (function)
    set_code_viewer_lines_alignment(code_viewer, align) -> bool
    Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param align: (C++: int)

ida_kernwin.set_code_viewer_lines_icon_margin (function)
    set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
    Set space allowed for icons in the margin of a code viewer
    (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param margin: (C++: int)

ida_kernwin.set_code_viewer_lines_radix (function)
    set_code_viewer_lines_radix(code_viewer, radix) -> bool
    Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param radix: (C++: int)

ida_kernwin.set_code_viewer_user_data (function)
    set_code_viewer_user_data(code_viewer, ud) -> bool
    Set the user data on a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param ud: (C++: void *)

ida_kernwin.set_custom_viewer_qt_aware (function)
    set_custom_viewer_qt_aware(custom_viewer) -> bool
    Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)
    
    @param custom_viewer: (C++: TWidget *)

ida_kernwin.set_dock_pos (function)
    set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
    Sets the dock orientation of a window relatively to another window.
    
    Use the left, top, right, bottom parameters if DP_FLOATING is used,
    or if you want to specify the width of docked windows.
    
    @param src_ctrl: char const *
    @param dest_ctrl: char const *
    @param orient: One of DP_XXXX constants
    @param left: int
    @param top: int
    @param right: int
    @param bottom: int
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window

ida_kernwin.set_highlight (function)
    set_highlight(viewer, str, flags) -> bool
    Set the highlighted identifier in the viewer (ui_set_highlight).
    
    @param viewer: (C++: TWidget *) the viewer
    @param str: (C++: const char *) the text to match, or nullptr to remove current
    @param flags: (C++: int) combination of HIF_... bits (see set_highlight flags)
    @return: false if an error occurred

ida_kernwin.set_nav_colorizer (function)
    set_nav_colorizer(new_py_colorizer) -> dict or None
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)
    
    @param new_py_colorizer: PyObject *

ida_kernwin.set_view_renderer_type (function)
    set_view_renderer_type(v, rt)
    Set the type of renderer to use in a view (ui_set_renderer_type)
    
    @param v: (C++: TWidget *)
    @param rt: (C++: tcc_renderer_type_t) enum tcc_renderer_type_t

ida_kernwin.show_wait_box (function)
    show_wait_box(message)
    Display a dialog box with "Please wait...". The behavior of the dialog box can
    be configured with well-known
    tokens, that should be placed at the start of the format string:
    "NODELAY\n": the dialog will show immediately, instead of
    appearing after usual grace threshold
    "HIDECANCEL\n": the cancel button won't be added to the dialog box
    and user_cancelled() will always return false (but
    can be called to refresh UI)
    Using "HIDECANCEL" implies "NODELAY"
    Plugins must call hide_wait_box() to close the dialog box, otherwise
    the user interface will remain disabled.
    Note that, if the wait dialog is already visible, show_wait_box() will
    1) push the currently-displayed text on a stack
    2) display the new text
    Then, when hide_wait_box() is called, if that stack isn't empty its top
    label will be popped and restored in the wait dialog.
    This implies that a plugin should call hide_wait_box() exactly as many
    times as it called show_wait_box(), or the wait dialog might remain
    visible and block the UI.
    Also, in case the plugin knows the wait dialog is currently displayed,
    alternatively it can call replace_wait_box(), to replace the text of the
    dialog without pushing the currently-displayed text on the stack.
    
    @param message: char const *

ida_kernwin.simplecustviewer_t (class)
    The base class for implementing simple custom viewers

ida_kernwin.simplecustviewer_t.AddLine (method)
    Adds a colored line to the view
    @return: Boolean

ida_kernwin.simplecustviewer_t.ClearLines (method)
    Clears all the lines

ida_kernwin.simplecustviewer_t.Close (method)
    Destroys the view.
    One has to call Create() afterwards.
    Show() can be called and it will call Create() internally.
    @return: Boolean

ida_kernwin.simplecustviewer_t.Count (method)
    Returns the number of lines in the view

ida_kernwin.simplecustviewer_t.Create (method)
    Creates the custom view. This should be the first method called after instantiation
    
    @param title: The title of the view
    @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
             In this case better close existing windows

ida_kernwin.simplecustviewer_t.DelLine (method)
    Deletes an existing line
    @return: Boolean

ida_kernwin.simplecustviewer_t.EditLine (method)
    Edits an existing line.
    @return: Boolean

ida_kernwin.simplecustviewer_t.GetCurrentLine (method)
    Returns the current line.
    @param mouse: Current line at mouse pos
    @param notags: If True then tag_remove() will be called before returning the line
    @return: Returns the current line (colored or uncolored) or None on failure

ida_kernwin.simplecustviewer_t.GetCurrentWord (method)
    Returns the current word
    @param mouse: Use mouse position or cursor position
    @return: None if failed or a String containing the current word at mouse or cursor

ida_kernwin.simplecustviewer_t.GetLine (method)
    Returns a line
    @param lineno: The line number
    @return:     Returns a tuple (colored_line, fgcolor, bgcolor) or None

ida_kernwin.simplecustviewer_t.GetLineNo (method)
    Calls GetPos() and returns the current line number or -1 on failure

ida_kernwin.simplecustviewer_t.GetPos (method)
    Returns the current cursor or mouse position.
    @param mouse: return mouse position
    @return: Returns a tuple (lineno, x, y)

ida_kernwin.simplecustviewer_t.GetSelection (method)
    Returns the selected range or None
    @return:     - tuple(x1, y1, x2, y2)
        - None if no selection

ida_kernwin.simplecustviewer_t.GetWidget (method)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.simplecustviewer_t.InsertLine (method)
    Inserts a line in the given position
    @return: Boolean

ida_kernwin.simplecustviewer_t.IsFocused (method)
    Returns True if the current view is the focused view

ida_kernwin.simplecustviewer_t.Jump (method)

ida_kernwin.simplecustviewer_t.OnPopup (method)
    Context menu popup is about to be shown. Create items dynamically if you wish
    @return: Boolean. True if you handled the event

ida_kernwin.simplecustviewer_t.PatchLine (method)
    Patches an existing line character at the given offset. This is a low level function. You must know what you're doing

ida_kernwin.simplecustviewer_t.Refresh (method)

ida_kernwin.simplecustviewer_t.RefreshCurrent (method)
    Refreshes the current line only

ida_kernwin.simplecustviewer_t.Show (method)
    Shows an already created view. It the view was closed, then it will call Create() for you
    @return: Boolean

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline (class)

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.__init__ (method)

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.populating_widget_popup (method)

ida_kernwin.simplecustviewer_t.__init__ (method)

ida_kernwin.simplecustviewer_t.__make_sl_arg (method)

ida_kernwin.simpleline_place_t (class)
    Proxy of C++ simpleline_place_t class.

ida_kernwin.simpleline_place_t.__init__ (method)

ida_kernwin.simpleline_place_t.n (variable)
    line number

ida_kernwin.simpleline_t (class)
    Proxy of C++ simpleline_t class.

ida_kernwin.simpleline_t.__init__ (method)
    __init__(self) -> simpleline_t
    __init__(self, c, str) -> simpleline_t
    
    @param c: color_t
    @param str: char const *
    
    __init__(self, str) -> simpleline_t
    
    @param str: char const *

ida_kernwin.simpleline_t.bgcolor (variable)
    line background color

ida_kernwin.simpleline_t.color (variable)
    line prefix color

ida_kernwin.simpleline_t.line (variable)
    line text

ida_kernwin.str2ea (function)
    str2ea(str, screen_ea=BADADDR) -> bool
    Convert string to linear address. Tries to interpret the string as:
    1) "current IP" keyword if supported by assembler (e.g. "$" in x86)
    2) segment:offset expression, where "segment" may be a name or a fixed segment
    register (e.g. cs, ds)
    3) just segment name/register (translated to segment's start address)
    4) a name in the database (or debug name during debugging)
    5) hexadecimal value without prefix or suffix
    6) +delta or -delta, where numerical 'delta' is added to or subtracted from
    'screen_ea'
    7) register name (only during debugging)
    8) if all else fails, try to evaluate 'str' as an IDC expression
    
    @param str: (C++: const char *) string to parse
    @param screen_ea: (C++: ea_t) the current address in the disassembly/pseudocode view
    @return: success

ida_kernwin.str2ea_ex (function)
    str2ea_ex(str, screen_ea=BADADDR, flags=0) -> bool
    Same as str2ea() but possibly with some steps skipped.
    
    @param str: (C++: const char *) string to parse
    @param screen_ea: (C++: ea_t) the current address in the disassembly/pseudocode view
    @param flags: (C++: int) see String to address conversion flags
    @return: success

ida_kernwin.strarray (function)
    strarray(array, array_size, code) -> char const *
    Find a line with the specified code in the strarray_t array. If the last element
    of the array has code==0 then it is considered as the default entry.
    If no default entry exists and the code is not found, strarray() returns "".
    
    @param array: (C++: const strarray_t *) strarray_t const *
    @param array_size: (C++: size_t)
    @param code: (C++: int)

ida_kernwin.strarray_t (class)
    Proxy of C++ strarray_t class.

ida_kernwin.strarray_t.__init__ (method)
    __init__(self) -> strarray_t

ida_kernwin.structplace_t (class)
    Proxy of C++ structplace_t class.

ida_kernwin.structplace_t.__init__ (method)

ida_kernwin.structplace_t.idx (variable)
    struct serial number

ida_kernwin.structplace_t.offset (variable)
    offset within struct

ida_kernwin.sync_source_t (class)
    Proxy of C++ sync_source_t class.

ida_kernwin.sync_source_t.__eq__ (method)
    __eq__(self, _o) -> bool
    
    @param _o: sync_source_t const &

ida_kernwin.sync_source_t.__init__ (method)
    __init__(self, _view) -> sync_source_t
    
    @param _view: TWidget const *
    
    __init__(self, _regname) -> sync_source_t
    
    @param _regname: char const *

ida_kernwin.sync_source_t.__ne__ (method)
    __ne__(self, _o) -> bool
    
    @param _o: sync_source_t const &

ida_kernwin.sync_source_t.get_register (method)
    get_register(self) -> char const *

ida_kernwin.sync_source_t.get_widget (method)
    get_widget(self) -> TWidget const *

ida_kernwin.sync_source_t.is_register (method)
    is_register(self) -> bool

ida_kernwin.sync_source_t.is_widget (method)
    is_widget(self) -> bool

ida_kernwin.sync_source_vec_t (class)
    Proxy of C++ qvector< sync_source_t > class.

ida_kernwin.sync_source_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< sync_source_t > const &

ida_kernwin.sync_source_vec_t.__getitem__ (method)
    __getitem__(self, i) -> sync_source_t
    
    @param i: size_t

ida_kernwin.sync_source_vec_t.__init__ (method)
    __init__(self) -> sync_source_vec_t
    __init__(self, x) -> sync_source_vec_t
    
    @param x: qvector< sync_source_t > const &

ida_kernwin.sync_source_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.sync_source_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< sync_source_t > const &

ida_kernwin.sync_source_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: sync_source_t const &

ida_kernwin.sync_source_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: sync_source_t const &

ida_kernwin.sync_source_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: sync_source_t const &

ida_kernwin.sync_source_vec_t.at (method)
    at(self, _idx) -> sync_source_t
    
    @param _idx: size_t

ida_kernwin.sync_source_vec_t.begin (method)
    begin(self) -> sync_source_t

ida_kernwin.sync_source_vec_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.sync_source_vec_t.clear (method)
    clear(self)

ida_kernwin.sync_source_vec_t.empty (method)
    empty(self) -> bool

ida_kernwin.sync_source_vec_t.end (method)
    end(self) -> sync_source_t

ida_kernwin.sync_source_vec_t.erase (method)
    erase(self, it) -> sync_source_t
    
    @param it: qvector< sync_source_t >::iterator
    
    erase(self, first, last) -> sync_source_t
    
    @param first: qvector< sync_source_t >::iterator
    @param last: qvector< sync_source_t >::iterator

ida_kernwin.sync_source_vec_t.extract (method)
    extract(self) -> sync_source_t

ida_kernwin.sync_source_vec_t.find (method)
    find(self, x) -> sync_source_t
    
    @param x: sync_source_t const &

ida_kernwin.sync_source_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: sync_source_t const &

ida_kernwin.sync_source_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: sync_source_t *
    @param len: size_t

ida_kernwin.sync_source_vec_t.insert (method)
    insert(self, it, x) -> sync_source_t
    
    @param it: qvector< sync_source_t >::iterator
    @param x: sync_source_t const &

ida_kernwin.sync_source_vec_t.pop_back (method)
    pop_back(self)

ida_kernwin.sync_source_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: sync_source_t const &

ida_kernwin.sync_source_vec_t.qclear (method)
    qclear(self)

ida_kernwin.sync_source_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.sync_source_vec_t.size (method)
    size(self) -> size_t

ida_kernwin.sync_source_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< sync_source_t > &

ida_kernwin.sync_source_vec_t.truncate (method)
    truncate(self)

ida_kernwin.sync_sources (function)
    sync_sources(what, _with, sync) -> bool
    [Un]synchronize sources
    
    @param what: (C++: const sync_source_t &)
    @param with: (C++: const sync_source_t &)
    @param sync: (C++: bool)
    @return: success

ida_kernwin.synced_group_t (class)
    Proxy of C++ synced_group_t class.

ida_kernwin.synced_group_t.__init__ (method)
    __init__(self) -> synced_group_t

ida_kernwin.synced_group_t.has (method)
    has(self, ss) -> bool
    
    @param ss: sync_source_t const &

ida_kernwin.synced_group_t.has_register (method)
    has_register(self, r) -> bool
    
    @param r: char const *

ida_kernwin.synced_group_t.has_widget (method)
    has_widget(self, v) -> bool
    
    @param v: TWidget const *

ida_kernwin.tagged_line_section_t (class)
    Proxy of C++ tagged_line_section_t class.

ida_kernwin.tagged_line_section_t.__init__ (method)
    __init__(self) -> tagged_line_section_t

ida_kernwin.tagged_line_section_t.substr (method)
    substr(self, _in) -> bool
    
    @param in: qstring const &

ida_kernwin.tagged_line_section_t.valid (method)
    valid(self) -> bool

ida_kernwin.tagged_line_section_t.valid_in (method)
    valid_in(self, _in) -> bool
    
    @param in: qstring const &

ida_kernwin.tagged_line_sections_t (class)
    Proxy of C++ tagged_line_sections_t class.

ida_kernwin.tagged_line_sections_t.__init__ (method)
    __init__(self) -> tagged_line_sections_t

ida_kernwin.tagged_line_sections_t.find_in (method)
    find_in(self, range, tag=0) -> tagged_line_section_t
    
    @param range: tagged_line_section_t const &
    @param tag: color_t

ida_kernwin.tagged_line_sections_t.nearest_at (method)
    nearest_at(self, x, tag=0) -> tagged_line_section_t
    
    @param x: cpidx_t
    @param tag: color_t

ida_kernwin.tagged_line_sections_t.sections_at (method)
    sections_at(self, out, x, tag=0)
    
    @param out: tagged_line_sections_t *
    @param x: cpidx_t
    @param tag: color_t

ida_kernwin.take_database_snapshot (function)
    take_database_snapshot(ss) -> (bool, NoneType)
    Take a database snapshot (ui_take_database_snapshot).
    
    @param ss: (C++: snapshot_t *) in/out parameter.
    * in: description, flags
    * out: filename, id
    @return: success

ida_kernwin.text_t (class)
    Proxy of C++ qvector< twinline_t > class.

ida_kernwin.text_t.__getitem__ (method)
    __getitem__(self, i) -> twinline_t
    
    @param i: size_t

ida_kernwin.text_t.__init__ (method)
    __init__(self) -> text_t
    __init__(self, x) -> text_t
    
    @param x: qvector< twinline_t > const &

ida_kernwin.text_t.__len__ (method)
    __len__(self) -> size_t

ida_kernwin.text_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: twinline_t const &

ida_kernwin.text_t.at (method)
    at(self, _idx) -> twinline_t
    
    @param _idx: size_t

ida_kernwin.text_t.begin (method)
    begin(self) -> twinline_t

ida_kernwin.text_t.capacity (method)
    capacity(self) -> size_t

ida_kernwin.text_t.clear (method)
    clear(self)

ida_kernwin.text_t.empty (method)
    empty(self) -> bool

ida_kernwin.text_t.end (method)
    end(self) -> twinline_t

ida_kernwin.text_t.erase (method)
    erase(self, it) -> twinline_t
    
    @param it: qvector< twinline_t >::iterator
    
    erase(self, first, last) -> twinline_t
    
    @param first: qvector< twinline_t >::iterator
    @param last: qvector< twinline_t >::iterator

ida_kernwin.text_t.extract (method)
    extract(self) -> twinline_t

ida_kernwin.text_t.grow (method)
    grow(self, x=twinline_t())
    
    @param x: twinline_t const &

ida_kernwin.text_t.inject (method)
    inject(self, s, len)
    
    @param s: twinline_t *
    @param len: size_t

ida_kernwin.text_t.insert (method)
    insert(self, it, x) -> twinline_t
    
    @param it: qvector< twinline_t >::iterator
    @param x: twinline_t const &

ida_kernwin.text_t.pop_back (method)
    pop_back(self)

ida_kernwin.text_t.push_back (method)
    push_back(self, x)
    
    @param x: twinline_t const &
    
    push_back(self) -> twinline_t

ida_kernwin.text_t.qclear (method)
    qclear(self)

ida_kernwin.text_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_kernwin.text_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: twinline_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_kernwin.text_t.size (method)
    size(self) -> size_t

ida_kernwin.text_t.swap (method)
    swap(self, r)
    
    @param r: qvector< twinline_t > &

ida_kernwin.text_t.truncate (method)
    truncate(self)

ida_kernwin.textctrl_info_t (class)
    Class representing textctrl_info_t

ida_kernwin.textctrl_info_t.TXTF_ACCEPTTABS (variable)
    Tab key inserts 'tabsize' spaces

ida_kernwin.textctrl_info_t.TXTF_AUTOINDENT (variable)
    Auto-indent on new line

ida_kernwin.textctrl_info_t.TXTF_FIXEDFONT (variable)
    The control uses IDA's fixed font

ida_kernwin.textctrl_info_t.TXTF_MODIFIED (variable)
    Gets/sets the modified status

ida_kernwin.textctrl_info_t.TXTF_READONLY (variable)
    Text cannot be edited (but can be selected and copied)

ida_kernwin.textctrl_info_t.TXTF_SELECTED (variable)
    Shows the field with its text selected

ida_kernwin.textctrl_info_t.__get_flags__ (method)
    Returns the flags value

ida_kernwin.textctrl_info_t.__get_tabsize__ (method)
    Returns the tabsize value

ida_kernwin.textctrl_info_t.__get_text (method)
    Sets the text value

ida_kernwin.textctrl_info_t.__init__ (method)

ida_kernwin.textctrl_info_t.__set_flags__ (method)
    Sets the flags value

ida_kernwin.textctrl_info_t.__set_tabsize__ (method)
    Sets the tabsize value

ida_kernwin.textctrl_info_t.__set_text (method)
    Sets the text value

ida_kernwin.textctrl_info_t._create_clink (method)

ida_kernwin.textctrl_info_t._del_clink (method)

ida_kernwin.textctrl_info_t._get_clink_ptr (method)

ida_kernwin.textctrl_info_t.assign (method)
    Copies the contents of 'other' to 'self'

ida_kernwin.textctrl_info_t.flags (variable)
    Text control property bits

ida_kernwin.textctrl_info_t.tabsize (variable)
    how many spaces a single tab will indent

ida_kernwin.textctrl_info_t.text (variable)
    in, out: text control value

ida_kernwin.textctrl_info_t.value (variable)
    Alias for the text property

ida_kernwin.textctrl_info_t_assign (function)
    textctrl_info_t_assign(_self, other) -> bool
    
    @param self: PyObject *
    @param other: PyObject *

ida_kernwin.textctrl_info_t_create (function)
    textctrl_info_t_create() -> PyObject *

ida_kernwin.textctrl_info_t_destroy (function)
    textctrl_info_t_destroy(py_obj) -> bool
    
    @param py_obj: PyObject *

ida_kernwin.textctrl_info_t_get_clink (function)
    textctrl_info_t_get_clink(_self) -> textctrl_info_t *
    
    @param self: PyObject *

ida_kernwin.textctrl_info_t_get_clink_ptr (function)
    textctrl_info_t_get_clink_ptr(_self) -> PyObject *
    
    @param self: PyObject *

ida_kernwin.textctrl_info_t_get_flags (function)
    textctrl_info_t_get_flags(_self) -> unsigned int
    
    @param self: PyObject *

ida_kernwin.textctrl_info_t_get_tabsize (function)
    textctrl_info_t_get_tabsize(_self) -> unsigned int
    
    @param self: PyObject *

ida_kernwin.textctrl_info_t_get_text (function)
    textctrl_info_t_get_text(_self) -> char const *
    
    @param self: PyObject *

ida_kernwin.textctrl_info_t_set_flags (function)
    textctrl_info_t_set_flags(_self, flags) -> bool
    
    @param self: PyObject *
    @param flags: unsigned int

ida_kernwin.textctrl_info_t_set_tabsize (function)
    textctrl_info_t_set_tabsize(_self, tabsize) -> bool
    
    @param self: PyObject *
    @param tabsize: unsigned int

ida_kernwin.textctrl_info_t_set_text (function)
    textctrl_info_t_set_text(_self, s) -> bool
    
    @param self: PyObject *
    @param s: char const *

ida_kernwin.tiplace_t (class)
    Proxy of C++ tiplace_t class.

ida_kernwin.tiplace_t.__init__ (method)

ida_kernwin.tiplace_t.calc_udm_offset (method)
    calc_udm_offset(self, ud, p_udmidx=None, p_bitoff=None) -> uint64
    for structs: calculate the offset that corresponds to the tiplace.
    
    @param ud: (C++: const void *) pointer to user-defined context data. Is supplied by linearray_t
    @param p_udmidx: (C++: ssize_t *) place to return the index of the current udt member, if any. if
                     there is no member at the current offset, return -1
    @param p_bitoff: (C++: int *) place to return the bit offset of the item from the beginning
                     of the bit bucket if there no bitfields, return -1
    @return: the current offset or uint64(-1)

ida_kernwin.tiplace_t.fill_type_ref (method)
    fill_type_ref(self, out, ud) -> bool
    fill the type information for use in actions
    
    @param out: (C++: til_type_ref_t *) pointer to storage
    @param ud: (C++: const void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: success

ida_kernwin.tiplace_t.get_kind (method)
    get_kind(self, ud) -> type_t
    get the kind of type this place represents
    
    @param ud: (C++: const void *) pointer to user-defined context data. Is supplied by linearray_t
    @return: one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK

ida_kernwin.tiplace_t.is_footer (method)
    is_footer(self) -> bool

ida_kernwin.tiplace_t.is_header (method)
    is_header(self) -> bool

ida_kernwin.tiplace_t.is_index (method)
    is_index(self) -> bool

ida_kernwin.tiplace_t.reset (method)
    reset(self)

ida_kernwin.tiplace_t.set_footer (method)
    set_footer(self)

ida_kernwin.tiplace_t.set_header (method)
    set_header(self)

ida_kernwin.tiplace_t.set_index_by_offset (method)
    set_index_by_offset(self, ud, offset)
    for structs: calculate the index that corresponds to the offset and set it.
    
    @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
    @param offset: (C++: uint64) offset of udt member

ida_kernwin.tiplace_t.valid_ord (method)
    valid_ord(self) -> bool

ida_kernwin.twinline_t (class)
    Proxy of C++ twinline_t class.

ida_kernwin.twinline_t.__init__ (method)
    __init__(self) -> twinline_t
    __init__(self, t, pc, bc) -> twinline_t
    
    @param t: place_t *
    @param pc: color_t
    @param bc: bgcolor_t

ida_kernwin.twinline_t.at (variable)
    location in view

ida_kernwin.twinline_t.bg_color (variable)
    line background color

ida_kernwin.twinline_t.is_default (variable)
    is this the default line of the current location?

ida_kernwin.twinline_t.line (variable)
    line contents

ida_kernwin.twinline_t.prefix_color (variable)
    line prefix color

ida_kernwin.twinpos_t (class)
    Proxy of C++ twinpos_t class.

ida_kernwin.twinpos_t.__init__ (method)
    __init__(self) -> twinpos_t
    __init__(self, t) -> twinpos_t
    
    @param t: place_t *
    
    __init__(self, t, x0) -> twinpos_t
    
    @param t: place_t *
    @param x0: int

ida_kernwin.twinpos_t.at (variable)
    location in view

ida_kernwin.twinpos_t.place (method)

ida_kernwin.twinpos_t.place_as_enumplace_t (method)

ida_kernwin.twinpos_t.place_as_idaplace_t (method)

ida_kernwin.twinpos_t.place_as_simpleline_place_t (method)

ida_kernwin.twinpos_t.place_as_structplace_t (method)

ida_kernwin.twinpos_t.place_as_tiplace_t (method)

ida_kernwin.twinpos_t.x (variable)
    cursor x

ida_kernwin.ui_load_new_file (function)
    ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
    Display a load file dialog and load file (ui_load_file).
    
    @param temp_file: (C++: qstring *) name of the file with the extracted archive member.
    @param filename: (C++: qstring *) the name of input file as is, library or archive name
    @param pli: (C++: linput_t **) loader input source, may be changed to point to temp_file
    @param neflags: (C++: ushort) combination of NEF_... bits (see Load file flags)
    @param ploaders: (C++: load_info_t **) list of loaders which accept file, may be changed for loaders
                     of temp_file
    @retval true: file was successfully loaded
    @retval false: otherwise

ida_kernwin.ui_requests_t (class)
    Proxy of C++ ui_requests_t class.

ida_kernwin.ui_requests_t.__init__ (method)
    __init__(self) -> ui_requests_t

ida_kernwin.ui_run_debugger (function)
    ui_run_debugger(dbgopts, exename, argc, argv) -> bool
    Load a debugger plugin and run the specified program (ui_run_dbg).
    
    @param dbgopts: (C++: const char *) value of the -r command line switch
    @param exename: (C++: const char *) name of the file to run
    @param argc: (C++: int) number of arguments for the executable
    @param argv: (C++: const char *const *) argument vector
    @return: success

ida_kernwin.unmark_selection (function)
    unmark_selection()
    Unmark selection (ui_unmarksel)

ida_kernwin.unregister_action (function)
    unregister_action(name) -> bool
    Delete a previously-registered action (ui_unregister_action).
    
    @param name: (C++: const char *) name of action
    @return: success

ida_kernwin.unregister_timer (function)
    unregister_timer(py_timerctx) -> bool
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.

ida_kernwin.update_action_checkable (function)
    update_action_checkable(name, checkable) -> bool
    Update an action's checkability (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param checkable: (C++: bool) new checkability
    @return: success

ida_kernwin.update_action_checked (function)
    update_action_checked(name, checked) -> bool
    Update an action's checked state (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param checked: (C++: bool) new checked state
    @return: success

ida_kernwin.update_action_icon (function)
    update_action_icon(name, icon) -> bool
    Update an action's icon (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param icon: (C++: int) new icon id
    @return: success

ida_kernwin.update_action_label (function)
    update_action_label(name, label) -> bool
    Update an action's label (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param label: (C++: const char *) new label
    @return: success

ida_kernwin.update_action_shortcut (function)
    update_action_shortcut(name, shortcut) -> bool
    Update an action's shortcut (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param shortcut: (C++: const char *) new shortcut
    @return: success

ida_kernwin.update_action_state (function)
    update_action_state(name, state) -> bool
    Update an action's state (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param state: (C++: action_state_t) new state
    @return: success

ida_kernwin.update_action_tooltip (function)
    update_action_tooltip(name, tooltip) -> bool
    Update an action's tooltip (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param tooltip: (C++: const char *) new tooltip
    @return: success

ida_kernwin.update_action_visibility (function)
    update_action_visibility(name, visible) -> bool
    Update an action's visibility (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param visible: (C++: bool) new visibility
    @return: success

ida_kernwin.user_cancelled (function)
    user_cancelled() -> bool
    Test the ctrl-break flag (ui_test_cancelled).
    @retval 1: Ctrl-Break is detected, a message is displayed
    @retval 2: Ctrl-Break is detected again, a message is not displayed
    @retval 0: Ctrl-Break is not detected

ida_kernwin.view_activated (variable)
    A view is activated

ida_kernwin.view_click (variable)
    Click event

ida_kernwin.view_close (variable)
    View closed

ida_kernwin.view_created (variable)
    A view is being created.

ida_kernwin.view_curpos (variable)
    Cursor position changed

ida_kernwin.view_dblclick (variable)
    Double click event

ida_kernwin.view_deactivated (variable)
    A view is deactivated

ida_kernwin.view_keydown (variable)
    Key down event

ida_kernwin.view_loc_changed (variable)
    The location for the view has changed (can be either the place_t, the
    renderer_info_t, or both.)

ida_kernwin.view_mouse_event_location_t (class)
    Proxy of C++ view_mouse_event_location_t class.

ida_kernwin.view_mouse_event_location_t.__init__ (method)
    __init__(self) -> view_mouse_event_location_t

ida_kernwin.view_mouse_event_location_t.ea (variable)
    flat view (rtype == TCCRT_FLAT)

ida_kernwin.view_mouse_event_location_t.item (variable)
    graph views (rtype != TCCRT_FLAT). nullptr if mouse is not currently over an
    item.

ida_kernwin.view_mouse_event_t (class)
    Proxy of C++ view_mouse_event_t class.

ida_kernwin.view_mouse_event_t.__init__ (method)
    __init__(self) -> view_mouse_event_t

ida_kernwin.view_mouse_event_t.button (variable)
    represents which mouse button was responsible for generating the event. This
    field does not care about the current state of the mouse.

ida_kernwin.view_mouse_event_t.location (variable)
    location where event was generated

ida_kernwin.view_mouse_event_t.renderer_pos (variable)
    position where event was generated, relative to the renderer

ida_kernwin.view_mouse_event_t.rtype (variable)
    type of renderer that received the event

ida_kernwin.view_mouse_event_t.state (variable)
    contains information about what buttons are CURRENTLY pressed on the keyboard
    and mouse. view_mouse_event_t instances created in functions like
    mouseReleaseEvent() won't contain any information about the mouse, because it
    has been released.

ida_kernwin.view_mouse_event_t.x (variable)
    screen x coordinate

ida_kernwin.view_mouse_event_t.y (variable)
    screen y coordinate

ida_kernwin.view_mouse_moved (variable)
    The mouse moved on the view

ida_kernwin.view_mouse_over (variable)
    The user moved the mouse over (or out of) a node or an edge. This is only
    relevant in a graph view.

ida_kernwin.view_switched (variable)
    A view's renderer has changed.

ida_kernwin.warning (function)
    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

ida_lines (module)
    High level functions that deal with the generation of the disassembled text
    lines.
    
    This file also contains definitions for the syntax highlighting.
    
    Finally there are functions that deal with anterior/posterior user-defined
    lines.

ida_lines.COLOR_ADDR (variable)
    hidden address marks. the address is represented as 8digit hex number: 01234567.
    it doesn't have COLOR_OFF pair. NB: for 64-bit IDA, the address is 16digit.

ida_lines.COLOR_ADDR_SIZE (variable)
    Size of a tagged address (see COLOR_ADDR)

ida_lines.COLOR_ALTOP (variable)
    Alternative operand.

ida_lines.COLOR_ASMDIR (variable)
    Assembler directive.

ida_lines.COLOR_AUTOCMT (variable)
    Automatic comment.

ida_lines.COLOR_BG_MAX (variable)
    Max color number.

ida_lines.COLOR_BINPREF (variable)
    Binary line prefix bytes.

ida_lines.COLOR_CHAR (variable)
    Char constant in instruction.

ida_lines.COLOR_CNAME (variable)
    Regular code name.

ida_lines.COLOR_CODE (variable)
    Single instruction.

ida_lines.COLOR_CODNAME (variable)
    Dummy code name.

ida_lines.COLOR_COLLAPSED (variable)
    Collapsed line.

ida_lines.COLOR_CREF (variable)
    Code reference.

ida_lines.COLOR_CREFTAIL (variable)
    Code reference to tail byte.

ida_lines.COLOR_CURITEM (variable)
    Current item.

ida_lines.COLOR_CURLINE (variable)
    Current line.

ida_lines.COLOR_DATA (variable)
    Data bytes.

ida_lines.COLOR_DATNAME (variable)
    Dummy Data Name.

ida_lines.COLOR_DCHAR (variable)
    Char constant in data directive.

ida_lines.COLOR_DEFAULT (variable)
    Default.

ida_lines.COLOR_DEMNAME (variable)
    Demangled Name.

ida_lines.COLOR_DNAME (variable)
    Regular Data Name.

ida_lines.COLOR_DNUM (variable)
    Numeric constant in data directive.

ida_lines.COLOR_DREF (variable)
    Data reference.

ida_lines.COLOR_DREFTAIL (variable)
    Data reference to tail byte.

ida_lines.COLOR_DSTR (variable)
    String constant in data directive.

ida_lines.COLOR_ERROR (variable)
    Error or problem.

ida_lines.COLOR_ESC (variable)
    Escape character (Quote next character). This is needed to output '\1' and '\2'
    characters.

ida_lines.COLOR_EXTERN (variable)
    External name definition segment.

ida_lines.COLOR_EXTRA (variable)
    Extra line.

ida_lines.COLOR_FG_MAX (variable)
    Max color number.

ida_lines.COLOR_HIDLINE (variable)
    Hidden line.

ida_lines.COLOR_HIDNAME (variable)
    Hidden name.

ida_lines.COLOR_IMPNAME (variable)
    Imported name.

ida_lines.COLOR_INSN (variable)
    Instruction.

ida_lines.COLOR_INV (variable)
    Escape character (Inverse foreground and background colors). This escape
    character has no corresponding COLOR_OFF. Its action continues until the next
    COLOR_INV or end of line.

ida_lines.COLOR_KEYWORD (variable)
    Keywords.

ida_lines.COLOR_LIBFUNC (variable)
    Library function.

ida_lines.COLOR_LIBNAME (variable)
    Library function name.

ida_lines.COLOR_LOCNAME (variable)
    Local variable name.

ida_lines.COLOR_LUMFUNC (variable)
    Lumina function.

ida_lines.COLOR_LUMINA (variable)
    Lumina-related, only for the navigation band.

ida_lines.COLOR_MACRO (variable)
    Macro.

ida_lines.COLOR_NUMBER (variable)
    Numeric constant in instruction.

ida_lines.COLOR_OFF (variable)
    Escape character (OFF). Followed by a color code (color_t).

ida_lines.COLOR_ON (variable)
    Escape character (ON). Followed by a color code (color_t).

ida_lines.COLOR_OPND1 (variable)
    Instruction operand 1.

ida_lines.COLOR_OPND2 (variable)
    Instruction operand 2.

ida_lines.COLOR_OPND3 (variable)
    Instruction operand 3.

ida_lines.COLOR_OPND4 (variable)
    Instruction operand 4.

ida_lines.COLOR_OPND5 (variable)
    Instruction operand 5.

ida_lines.COLOR_OPND6 (variable)
    Instruction operand 6.

ida_lines.COLOR_OPND7 (variable)
    Instruction operand 7.

ida_lines.COLOR_OPND8 (variable)
    Instruction operand 8.

ida_lines.COLOR_PREFIX (variable)
    Line prefix.

ida_lines.COLOR_REG (variable)
    Register name.

ida_lines.COLOR_REGCMT (variable)
    Regular comment.

ida_lines.COLOR_REGFUNC (variable)
    Regular function.

ida_lines.COLOR_RESERVED1 (variable)
    This tag is reserved for internal IDA use.

ida_lines.COLOR_RPTCMT (variable)
    Repeatable comment (comment defined somewhere else)

ida_lines.COLOR_SEGNAME (variable)
    Segment name.

ida_lines.COLOR_SELECTED (variable)
    Selected.

ida_lines.COLOR_STRING (variable)
    String constant in instruction.

ida_lines.COLOR_SYMBOL (variable)
    Punctuation.

ida_lines.COLOR_UNAME (variable)
    Regular unknown name.

ida_lines.COLOR_UNKNAME (variable)
    Dummy unknown name.

ida_lines.COLOR_UNKNOWN (variable)
    Unexplored byte.

ida_lines.COLOR_VOIDOP (variable)
    Void operand.

ida_lines.COLSTR (function)
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX

ida_lines.SCOLOR_ADDR (variable)
    Hidden address mark.

ida_lines.SCOLOR_ALTOP (variable)
    Alternative operand.

ida_lines.SCOLOR_ASMDIR (variable)
    Assembler directive.

ida_lines.SCOLOR_AUTOCMT (variable)
    Automatic comment.

ida_lines.SCOLOR_BINPREF (variable)
    Binary line prefix bytes.

ida_lines.SCOLOR_CHAR (variable)
    Char constant in instruction.

ida_lines.SCOLOR_CNAME (variable)
    Regular code name.

ida_lines.SCOLOR_CODNAME (variable)
    Dummy code name.

ida_lines.SCOLOR_COLLAPSED (variable)
    Collapsed line.

ida_lines.SCOLOR_CREF (variable)
    Code reference.

ida_lines.SCOLOR_CREFTAIL (variable)
    Code reference to tail byte.

ida_lines.SCOLOR_DATNAME (variable)
    Dummy Data Name.

ida_lines.SCOLOR_DCHAR (variable)
    Char constant in data directive.

ida_lines.SCOLOR_DEFAULT (variable)
    Default.

ida_lines.SCOLOR_DEMNAME (variable)
    Demangled Name.

ida_lines.SCOLOR_DNAME (variable)
    Regular Data Name.

ida_lines.SCOLOR_DNUM (variable)
    Numeric constant in data directive.

ida_lines.SCOLOR_DREF (variable)
    Data reference.

ida_lines.SCOLOR_DREFTAIL (variable)
    Data reference to tail byte.

ida_lines.SCOLOR_DSTR (variable)
    String constant in data directive.

ida_lines.SCOLOR_ERROR (variable)
    Error or problem.

ida_lines.SCOLOR_ESC (variable)
    Escape character (Quote next character)

ida_lines.SCOLOR_EXTRA (variable)
    Extra line.

ida_lines.SCOLOR_HIDNAME (variable)
    Hidden name.

ida_lines.SCOLOR_IMPNAME (variable)
    Imported name.

ida_lines.SCOLOR_INSN (variable)
    Instruction.

ida_lines.SCOLOR_INV (variable)
    Escape character (Inverse colors)

ida_lines.SCOLOR_KEYWORD (variable)
    Keywords.

ida_lines.SCOLOR_LIBNAME (variable)
    Library function name.

ida_lines.SCOLOR_LOCNAME (variable)
    Local variable name.

ida_lines.SCOLOR_MACRO (variable)
    Macro.

ida_lines.SCOLOR_NUMBER (variable)
    Numeric constant in instruction.

ida_lines.SCOLOR_OFF (variable)
    Escape character (OFF)

ida_lines.SCOLOR_ON (variable)
    Escape character (ON)

ida_lines.SCOLOR_PREFIX (variable)
    Line prefix.

ida_lines.SCOLOR_REG (variable)
    Register name.

ida_lines.SCOLOR_REGCMT (variable)
    Regular comment.

ida_lines.SCOLOR_RPTCMT (variable)
    Repeatable comment (defined not here)

ida_lines.SCOLOR_SEGNAME (variable)
    Segment name.

ida_lines.SCOLOR_STRING (variable)
    String constant in instruction.

ida_lines.SCOLOR_SYMBOL (variable)
    Punctuation.

ida_lines.SCOLOR_UNAME (variable)
    Regular unknown name.

ida_lines.SCOLOR_UNKNAME (variable)
    Dummy unknown name.

ida_lines.SCOLOR_VOIDOP (variable)
    Void operand.

ida_lines.add_extra_cmt (function)
    add_extra_cmt(ea, isprev, format) -> bool
    Add anterior/posterior comment line(s).
    
    @param ea: (C++: ea_t) linear address
    @param isprev: (C++: bool) do we add anterior lines? (0-no, posterior)
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
                   The resulting string should not contain comment characters (;),
                   the kernel will add them automatically.
    @return: true if success

ida_lines.add_extra_line (function)
    add_extra_line(ea, isprev, format) -> bool
    Add anterior/posterior non-comment line(s).
    
    @param ea: (C++: ea_t) linear address
    @param isprev: (C++: bool) do we add anterior lines? (0-no, posterior)
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
    @return: true if success

ida_lines.add_pgm_cmt (function)
    add_pgm_cmt(format) -> bool
    Add anterior comment line(s) at the start of program.
    
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
                   The resulting string should not contain comment characters (;),
                   the kernel will add them automatically.
    @return: true if success

ida_lines.add_sourcefile (function)
    add_sourcefile(ea1, ea2, filename) -> bool
    Mark a range of address as belonging to a source file. An address range may
    belong only to one source file. A source file may be represented by several
    address ranges.
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range (excluded)
    @param filename: (C++: const char *) name of source file.
    @return: success

ida_lines.calc_bg_color (function)
    calc_bg_color(ea) -> bgcolor_t
    Get background color for line at 'ea'
    
    @param ea: (C++: ea_t)
    @return: RGB color

ida_lines.calc_prefix_color (function)
    calc_prefix_color(ea) -> color_t
    Get prefix color for line at 'ea'
    
    @param ea: (C++: ea_t)
    @return: Line prefix colors

ida_lines.create_encoding_helper (function)
    create_encoding_helper(encidx=-1, nr=nr_once) -> encoder_t *
    
    @param encidx: int
    @param nr: enum encoder_t::notify_recerr_t

ida_lines.del_extra_cmt (function)
    del_extra_cmt(ea, what)
    
    @param ea: ea_t
    @param what: int

ida_lines.del_sourcefile (function)
    del_sourcefile(ea) -> bool
    Delete information about the source file.
    
    @param ea: (C++: ea_t) linear address
    @return: success

ida_lines.delete_extra_cmts (function)
    delete_extra_cmts(ea, what)
    
    @param ea: ea_t
    @param what: int

ida_lines.generate_disasm_line (function)
    generate_disasm_line(ea, flags=0) -> str
    
    @param ea: ea_t
    @param flags: int

ida_lines.generate_disassembly (function)
    generate_disassembly(ea, max_lines, as_stack, notags) -> (int, [str, ...])
    Generate disassembly lines (many lines) and put them into a buffer
    
    @param ea: address to generate disassembly for
    @param max_lines: how many lines max to generate
    @param as_stack: Display undefined items as 2/4/8 bytes
    @param notags: bool
    @return:     - None on failure
        - tuple(most_important_line_number, list(lines)) : Returns a tuple containing
          the most important line number and a list of generated lines

ida_lines.get_extra_cmt (function)
    get_extra_cmt(ea, what) -> ssize_t
    
    @param ea: ea_t
    @param what: int

ida_lines.get_first_free_extra_cmtidx (function)
    get_first_free_extra_cmtidx(ea, start) -> int
    
    @param ea: ea_t
    @param start: int

ida_lines.get_sourcefile (function)
    get_sourcefile(ea, bounds=None) -> char const *
    Get name of source file occupying the given address.
    
    @param ea: (C++: ea_t) linear address
    @param bounds: (C++: range_t *) pointer to the output buffer with the address range for the
                   current file. May be nullptr.
    @return: nullptr if source file information is not found, otherwise returns
             pointer to file name

ida_lines.install_user_defined_prefix (function)
    install_user_defined_prefix(prefix_len, udp, owner) -> bool
    User-defined line-prefixes are displayed just after the autogenerated line
    prefixes in the disassembly listing. There is no need to call this function
    explicitly. Use the user_defined_prefix_t class.
    
    @param prefix_len: (C++: size_t) prefixed length. if 0, then uninstall UDP
    @param udp: (C++: struct user_defined_prefix_t *) object to generate user-defined prefix
    @param owner: (C++: const void *) pointer to the plugin_t that owns UDP if non-nullptr, then the
                  object will be uninstalled and destroyed when the plugin gets
                  unloaded

ida_lines.requires_color_esc (function)
    Checks if the given character requires escaping
    Is the given char a color escape character?

ida_lines.set_user_defined_prefix (function)
    set_user_defined_prefix(width, pycb) -> bool
    Deprecated. Please use install_user_defined_prefix() instead
    
    @param width: size_t
    @param pycb: PyObject *

ida_lines.tag_addr (function)
    tag_addr(ea) -> PyObject *
    Insert an address mark into a string.
    
    @param ea: (C++: ea_t) address to include

ida_lines.tag_advance (function)
    tag_advance(line, cnt) -> int
    Move pointer to a 'line' to 'cnt' positions right. Take into account escape
    sequences.
    
    @param line: (C++: const char *) pointer to string
    @param cnt: (C++: int) number of positions to move right
    @return: moved pointer

ida_lines.tag_remove (function)
    tag_remove(nonnul_instr) -> str
    
    @param nonnul_instr: char const *

ida_lines.tag_skipcode (function)
    tag_skipcode(line) -> int
    Skip one color code. This function should be used if you are interested in color
    codes and want to analyze all of them. Otherwise tag_skipcodes() function is
    better since it will skip all colors at once. This function will skip the
    current color code if there is one. If the current symbol is not a color code,
    it will return the input.
    
    @param line: (C++: const char *) char const *
    @return: moved pointer

ida_lines.tag_skipcodes (function)
    tag_skipcodes(line) -> int
    Move the pointer past all color codes.
    
    @param line: (C++: const char *) can't be nullptr
    @return: moved pointer, can't be nullptr

ida_lines.tag_strlen (function)
    tag_strlen(line) -> ssize_t
    Calculate length of a colored string This function computes the length in
    unicode codepoints of a line
    
    @param line: (C++: const char *) char const *
    @return: the number of codepoints in the line, or -1 on error

ida_lines.update_extra_cmt (function)
    update_extra_cmt(ea, what, str)
    
    @param ea: ea_t
    @param what: int
    @param str: char const *

ida_lines.user_defined_prefix_t (class)
    Proxy of C++ user_defined_prefix_t class.

ida_lines.user_defined_prefix_t.__disown__ (method)

ida_lines.user_defined_prefix_t.__init__ (method)
    __init__(self, prefix_len, owner) -> user_defined_prefix_t
    
    @param prefix_len: size_t
    @param owner: void const *

ida_lines.user_defined_prefix_t.get_user_defined_prefix (method)
    get_user_defined_prefix(self, ea, insn, lnnum, indent, line)
    This callback must be overridden by the derived class.
    
    @param ea: (C++: ea_t) the current address
    @param insn: (C++: const class insn_t &) the current instruction. if the current item is not an instruction,
                 then insn.itype is zero.
    @param lnnum: (C++: int) number of the current line (each address may have several listing
                  lines for it). 0 means the very first line for the current
                  address.
    @param indent: (C++: int) see explanations for gen_printf()
    @param line: (C++: const char *) the line to be generated. the line usually contains color tags.
                 this argument can be examined to decide whether to generate the
                 prefix.

ida_loader (module)
    Definitions of IDP, LDR, PLUGIN module interfaces.
    
    This file also contains:
    * functions to load files into the database
    * functions to generate output files
    * high level functions to work with the database (open, save, close)
    
    The LDR interface consists of one structure: loader_t
    The IDP interface consists of one structure: processor_t
    The PLUGIN interface consists of one structure: plugin_t
    
    Modules can't use standard FILE* functions. They must use functions from
    <fpro.h>
    
    Modules can't use standard memory allocation functions. They must use functions
    from <pro.h>
    
    The exported entry #1 in the module should point to the the appropriate
    structure. (loader_t for LDR module, for example)

ida_loader.ACCEPT_ARCHIVE (variable)
    Specify that a file format is served by archive loader See loader_t::accept_file

ida_loader.ACCEPT_CONTINUE (variable)
    Specify that the function must be called another time See loader_t::accept_file

ida_loader.ACCEPT_FIRST (variable)
    Specify that a file format should be place first in "load file" dialog box. See
    loader_t::accept_file

ida_loader.DBFL_BAK (variable)
    create backup file (if !DBFL_KILL)

ida_loader.DBFL_COMP (variable)
    collect garbage

ida_loader.DBFL_KILL (variable)
    delete unpacked database

ida_loader.DBFL_TEMP (variable)
    temporary database

ida_loader.FILEREG_NOTPATCHABLE (variable)
    the data is kept in some encoded form in the file.

ida_loader.FILEREG_PATCHABLE (variable)
    means that the input file may be patched (i.e. no compression, no iterated data,
    etc)

ida_loader.GENFLG_ASMINC (variable)
    OFILE_ASM,OFILE_LST: gen information only about types

ida_loader.GENFLG_ASMTYPE (variable)
    OFILE_ASM,OFILE_LST: gen information about types too

ida_loader.GENFLG_GENHTML (variable)
    OFILE_ASM,OFILE_LST: generate html (ui_genfile_callback will be used)

ida_loader.LDRF_RELOAD (variable)
    loader recognizes NEF_RELOAD flag

ida_loader.LDRF_REQ_PROC (variable)
    Requires a processor to be set. if this bit is not set, load_file() must call
    set_processor_type(..., SETPROC_LOADER)

ida_loader.MAX_DATABASE_DESCRIPTION (variable)
    Maximum database snapshot description length.

ida_loader.NEF_CODE (variable)
    for load_binary_file(): load as a code segment

ida_loader.NEF_FILL (variable)
    Fill segment gaps.

ida_loader.NEF_FIRST (variable)
    This is the first file loaded into the database.

ida_loader.NEF_FLAT (variable)
    Autocreate FLAT group (PE)

ida_loader.NEF_IMPS (variable)
    Create import segment.

ida_loader.NEF_LALL (variable)
    Load all segments without questions.

ida_loader.NEF_LOPT (variable)
    Display additional loader options dialog.

ida_loader.NEF_MAN (variable)
    Manual load.

ida_loader.NEF_MINI (variable)
    Create mini database (do not copy segment bytes from the input file; use only
    the file header metadata)

ida_loader.NEF_NAME (variable)
    Rename entries.

ida_loader.NEF_RELOAD (variable)
    reload the file at the same place:
    * don't create segments
    * don't create fixup info
    * don't import segments
    * etc.
    
    Load only the bytes into the base. A loader should have the LDRF_RELOAD bit set.

ida_loader.NEF_RSCS (variable)
    Load resources.

ida_loader.NEF_SEGS (variable)
    Create segments.

ida_loader.OFILE_ASM (variable)
    Assembly.

ida_loader.OFILE_DIF (variable)
    Difference.

ida_loader.OFILE_EXE (variable)
    Executable file.

ida_loader.OFILE_IDC (variable)
    IDC file.

ida_loader.OFILE_LST (variable)
    Disassembly listing.

ida_loader.OFILE_MAP (variable)
    MAP file.

ida_loader.PATH_TYPE_CMD (variable)
    full path to the file specified in the command line

ida_loader.PATH_TYPE_ID0 (variable)
    full path of ID0 file

ida_loader.PATH_TYPE_IDB (variable)
    full path of IDB file

ida_loader.PLUGIN_DLL (variable)
    Pattern to find plugin files.

ida_loader.SSF_AUTOMATIC (variable)
    automatic snapshot

ida_loader.SSUF_DESC (variable)
    Update the description.

ida_loader.SSUF_FLAGS (variable)
    Update the flags.

ida_loader.SSUF_PATH (variable)
    Update the path.

ida_loader.base2file (function)
    base2file(fp, pos, ea1, ea2) -> int
    Unload database to a binary file. This function works for wide byte processors
    too.
    
    @param fp: (C++: FILE *) pointer to file
    @param pos: (C++: qoff64_t) position in the file
    @param ea1: (C++: ea_t) ,ea2: range of source linear addresses
    @param ea2: (C++: ea_t)
    @return: 1-ok(always), write error leads to immediate exit

ida_loader.build_snapshot_tree (function)
    build_snapshot_tree(root) -> bool
    Build the snapshot tree.
    
    @param root: (C++: snapshot_t *) snapshot root that will contain the snapshot tree elements.
    @return: success

ida_loader.clr_database_flag (function)
    clr_database_flag(dbfl)
    
    @param dbfl: uint32

ida_loader.extract_module_from_archive (function)
    extract_module_from_archive(fname, is_remote=False) -> (NoneType, NoneType), (str, str)
    Extract a module for an archive file. Parse an archive file, show the list of
    modules to the user, allow him to select a module, extract the selected module
    to a file (if the extract module is an archive, repeat the process). This
    function can handle ZIP, AR, AIXAR, OMFLIB files. The temporary file will be
    automatically deleted by IDA at the end.
    
    @param filename: (C++: char *) in: input file. out: name of the selected module.
    @param is_remote: (C++: bool) is the input file remote?
    @retval true: ok
    @retval false: something bad happened (error message has been displayed to the
                   user)

ida_loader.file2base (function)
    file2base(li, pos, ea1, ea2, patchable) -> int
    Load portion of file into the database. This function will include (ea1..ea2)
    into the addressing space of the program (make it enabled).
    
    @param li: (C++: linput_t *) pointer of input source
    @param pos: (C++: qoff64_t) position in the file
    @param ea1: (C++: ea_t) ,ea2: range of destination linear addresses
    @param patchable: (C++: int) should the kernel remember correspondence of file offsets to
                      linear addresses.
    @retval 1: ok
    @retval 0: read error, a warning is displayed
    @note: The storage type of the specified range will be changed to STT_VA.
    @param patchable: (C++: int) should the kernel remember correspondence of file offsets to
                      linear addresses.
    @retval 1: ok
    @retval 0: read error, a warning is displayed
    @note: The storage type of the specified range will be changed to STT_VA.

ida_loader.find_plugin (function)
    find_plugin(name, load_if_needed=False) -> plugin_t *
    Find a user-defined plugin and optionally load it.
    
    @param name: (C++: const char *) short plugin name without path and extension, or absolute path to
                 the file name
    @param load_if_needed: (C++: bool) if the plugin is not present in the memory, try to load
                           it
    @return: pointer to plugin description block

ida_loader.flush_buffers (function)
    flush_buffers() -> int
    Flush buffers to the disk.

ida_loader.gen_exe_file (function)
    gen_exe_file(fp) -> int
    Generate an exe file (unload the database in binary form).
    
    @param fp: (C++: FILE *)
    @return: fp the output file handle. if fp == nullptr then return:
    * 1: can generate an executable file
    * 0: can't generate an executable file
    @retval 1: ok
    @retval 0: failed

ida_loader.gen_file (function)
    gen_file(otype, fp, ea1, ea2, flags) -> int
    Generate an output file.
    
    @param otype: (C++: ofile_type_t) type of output file.
    @param fp: (C++: FILE *) the output file handle
    @param ea1: (C++: ea_t) start address. For some file types this argument is ignored
    @param ea2: (C++: ea_t) end address. For some file types this argument is ignored as usual
                in ida, the end address of the range is not included
    @param flags: (C++: int) Generate file flagsOFILE_EXE:
    @retval 0: can't generate exe file
    @retval 1: ok
    @return: number of the generated lines. -1 if an error occurred

ida_loader.get_basic_file_type (function)
    get_basic_file_type(li) -> filetype_t
    Get the input file type. This function can recognize libraries and zip files.
    
    @param li: (C++: linput_t *)

ida_loader.get_elf_debug_file_directory (function)
    get_elf_debug_file_directory() -> char const *
    Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.

ida_loader.get_file_type_name (function)
    get_file_type_name() -> str
    Get name of the current file type. The current file type is kept in
    idainfo::filetype.
    
    @return: size of answer, this function always succeeds

ida_loader.get_fileregion_ea (function)
    get_fileregion_ea(offset) -> ea_t
    Get linear address which corresponds to the specified input file offset. If
    can't be found, return BADADDR
    
    @param offset: (C++: qoff64_t)

ida_loader.get_fileregion_offset (function)
    get_fileregion_offset(ea) -> qoff64_t
    Get offset in the input file which corresponds to the given ea. If the specified
    ea can't be mapped into the input file offset, return -1.
    
    @param ea: (C++: ea_t)

ida_loader.get_path (function)
    get_path(pt) -> char const *
    Get the file path
    
    @param pt: (C++: path_type_t) file path type Types of the file pathes
    @return: file path, never returns nullptr

ida_loader.get_plugin_options (function)
    get_plugin_options(plugin) -> char const *
    Get plugin options from the command line. If the user has specified the options
    in the -Oplugin_name:options format, them this function will return the
    'options' part of it The 'plugin' parameter should denote the plugin name
    Returns nullptr if there we no options specified
    
    @param plugin: (C++: const char *) char const *

ida_loader.idp_desc_t (class)
    Proxy of C++ idp_desc_t class.

ida_loader.idp_desc_t.__init__ (method)
    __init__(self) -> idp_desc_t

ida_loader.idp_desc_t.checked (variable)
    internal, for cache management

ida_loader.idp_desc_t.family (variable)
    processor's family

ida_loader.idp_desc_t.is_script (variable)
    the processor module is a script

ida_loader.idp_desc_t.mtime (variable)
    time of last modification

ida_loader.idp_desc_t.names (variable)
    processor names

ida_loader.idp_desc_t.path (variable)
    module file name

ida_loader.idp_name_t (class)
    Proxy of C++ idp_name_t class.

ida_loader.idp_name_t.__init__ (method)
    __init__(self) -> idp_name_t

ida_loader.idp_name_t.hidden (variable)
    is hidden

ida_loader.idp_name_t.lname (variable)
    long processor name

ida_loader.idp_name_t.sname (variable)
    short processor name

ida_loader.is_database_flag (function)
    is_database_flag(dbfl) -> bool
    Get the current database flag
    
    @param dbfl: (C++: uint32) flag Database flags
    @return: the state of the flag (set or cleared)

ida_loader.is_trusted_idb (function)
    is_trusted_idb() -> bool
    Is the database considered as trusted?

ida_loader.load_and_run_plugin (function)
    load_and_run_plugin(name, arg) -> bool
    Load & run a plugin.
    
    @param name: (C++: const char *) char const *
    @param arg: (C++: size_t)

ida_loader.load_binary_file (function)
    load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
    Load a binary file into the database. This function usually is called from ui.
    
    @param filename: (C++: const char *) the name of input file as is (if the input file is from
                     library, then this is the name from the library)
    @param li: (C++: linput_t *) loader input source
    @param _neflags: (C++: ushort) Load file flags. For the first file, the flag NEF_FIRST must be
                     set.
    @param fileoff: (C++: qoff64_t) Offset in the input file
    @param basepara: (C++: ea_t) Load address in paragraphs
    @param binoff: (C++: ea_t) Load offset (load_address=(basepara<<4)+binoff)
    @param nbytes: (C++: uint64) Number of bytes to load from the file.
    * 0: up to the end of the file
    @retval true: ok
    @retval false: failed (couldn't open the file)

ida_loader.load_ids_module (function)
    load_ids_module(fname) -> int
    Load and apply IDS file. This function loads the specified IDS file and applies
    it to the database. If the program imports functions from a module with the same
    name as the name of the ids file being loaded, then only functions from this
    module will be affected. Otherwise (i.e. when the program does not import a
    module with this name) any function in the program may be affected.
    
    @param fname: (C++: char *) name of file to apply
    @retval 1: ok
    @retval 0: some error (a message is displayed). if the ids file does not exist,
               no message is displayed

ida_loader.load_plugin (function)
    load_plugin(name) -> PyCapsule or None
    Loads a plugin
    
    @param name: char const *
    @return:     - None if plugin could not be loaded
        - An opaque object representing the loaded plugin

ida_loader.loader_t (class)
    Proxy of C++ loader_t class.

ida_loader.loader_t.__init__ (method)
    __init__(self) -> loader_t

ida_loader.loader_t.flags (variable)
    Loader flags

ida_loader.loader_t.version (variable)
    api version, should be IDP_INTERFACE_VERSION

ida_loader.mem2base (function)
    mem2base(py_mem, ea, fpos=-1) -> int
    Load database from the memory.
    
    @param py_mem: the buffer
    @param ea: start linear addresses
    @param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    @return:     - Returns zero if the passed buffer was not a string
        - Otherwise 1 is returned

ida_loader.plugin_info_t (class)
    Proxy of C++ plugin_info_t class.

ida_loader.plugin_info_t.__init__ (method)
    __init__(self) -> plugin_info_t

ida_loader.plugin_info_t.arg (variable)
    argument used to call the plugin

ida_loader.plugin_info_t.comment (variable)
    a copy of plugin_t::comment

ida_loader.plugin_info_t.entry (variable)
    pointer to the plugin if it is already loaded

ida_loader.plugin_info_t.flags (variable)
    a copy of plugin_t::flags

ida_loader.plugin_info_t.hotkey (variable)
    current hotkey to run the plugin

ida_loader.plugin_info_t.name (variable)
    short name of the plugin it will appear in the menu

ida_loader.plugin_info_t.next (variable)
    next plugin information

ida_loader.plugin_info_t.org_hotkey (variable)
    original hotkey to run the plugin

ida_loader.plugin_info_t.org_name (variable)
    original short name of the plugin

ida_loader.plugin_info_t.path (variable)
    full path to the plugin

ida_loader.process_archive (function)
    process_archive(temp_file, li, module_name, neflags, defmember, loader) -> str
    Calls loader_t::process_archive() For parameters and return value description
    look at loader_t::process_archive(). Additional parameter 'loader' is a pointer
    to load_info_t structure.
    
    @param temp_file: (C++: qstring *)
    @param li: (C++: linput_t *)
    @param module_name: (C++: qstring *)
    @param neflags: (C++: ushort *)
    @param defmember: (C++: const char *) char const *
    @param loader: (C++: const load_info_t *) load_info_t const *

ida_loader.qvector_snapshotvec_t (class)
    Proxy of C++ qvector< snapshot_t * > class.

ida_loader.qvector_snapshotvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< snapshot_t * > const &

ida_loader.qvector_snapshotvec_t.__getitem__ (method)
    __getitem__(self, i) -> snapshot_t
    
    @param i: size_t

ida_loader.qvector_snapshotvec_t.__init__ (method)
    __init__(self) -> qvector_snapshotvec_t
    __init__(self, x) -> qvector_snapshotvec_t
    
    @param x: qvector< snapshot_t * > const &

ida_loader.qvector_snapshotvec_t.__len__ (method)
    __len__(self) -> size_t

ida_loader.qvector_snapshotvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< snapshot_t * > const &

ida_loader.qvector_snapshotvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: snapshot_t *const &

ida_loader.qvector_snapshotvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: snapshot_t *const &

ida_loader.qvector_snapshotvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: snapshot_t *const &

ida_loader.qvector_snapshotvec_t.at (method)
    at(self, _idx) -> snapshot_t
    
    @param _idx: size_t

ida_loader.qvector_snapshotvec_t.begin (method)
    begin(self) -> qvector< snapshot_t * >::iterator
    begin(self) -> qvector< snapshot_t * >::const_iterator

ida_loader.qvector_snapshotvec_t.capacity (method)
    capacity(self) -> size_t

ida_loader.qvector_snapshotvec_t.clear (method)
    clear(self)

ida_loader.qvector_snapshotvec_t.empty (method)
    empty(self) -> bool

ida_loader.qvector_snapshotvec_t.end (method)
    end(self) -> qvector< snapshot_t * >::iterator
    end(self) -> qvector< snapshot_t * >::const_iterator

ida_loader.qvector_snapshotvec_t.erase (method)
    erase(self, it) -> qvector< snapshot_t * >::iterator
    
    @param it: qvector< snapshot_t * >::iterator
    
    erase(self, first, last) -> qvector< snapshot_t * >::iterator
    
    @param first: qvector< snapshot_t * >::iterator
    @param last: qvector< snapshot_t * >::iterator

ida_loader.qvector_snapshotvec_t.extract (method)
    extract(self) -> snapshot_t **

ida_loader.qvector_snapshotvec_t.find (method)
    find(self, x) -> qvector< snapshot_t * >::iterator
    
    @param x: snapshot_t *const &
    
    find(self, x) -> qvector< snapshot_t * >::const_iterator
    
    @param x: snapshot_t *const &

ida_loader.qvector_snapshotvec_t.has (method)
    has(self, x) -> bool
    
    @param x: snapshot_t *const &

ida_loader.qvector_snapshotvec_t.inject (method)
    inject(self, s, len)
    
    @param s: snapshot_t **
    @param len: size_t

ida_loader.qvector_snapshotvec_t.insert (method)
    insert(self, it, x) -> qvector< snapshot_t * >::iterator
    
    @param it: qvector< snapshot_t * >::iterator
    @param x: snapshot_t *const &

ida_loader.qvector_snapshotvec_t.pop_back (method)
    pop_back(self)

ida_loader.qvector_snapshotvec_t.push_back (method)
    push_back(self, x)
    
    @param x: snapshot_t *const &
    
    push_back(self) -> snapshot_t *&

ida_loader.qvector_snapshotvec_t.qclear (method)
    qclear(self)

ida_loader.qvector_snapshotvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_loader.qvector_snapshotvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: snapshot_t *const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_loader.qvector_snapshotvec_t.size (method)
    size(self) -> size_t

ida_loader.qvector_snapshotvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< snapshot_t * > &

ida_loader.qvector_snapshotvec_t.truncate (method)
    truncate(self)

ida_loader.reload_file (function)
    reload_file(file, is_remote) -> bool
    Reload the input file. This function reloads the byte values from the input
    file. It doesn't modify the segmentation, names, comments, etc.
    
    @param file: (C++: const char *) name of the input file. if file == nullptr then returns:
    * 1: can reload the input file
    * 0: can't reload the input file
    @param is_remote: (C++: bool) is the file located on a remote computer with the debugger
                      server?
    @return: success

ida_loader.run_plugin (function)
    run_plugin(plg, arg) -> bool
    Runs a plugin
    
    @param plg: A plugin object (returned by load_plugin())
    @param arg: size_t
    @return: Boolean

ida_loader.save_database (function)
    save_database(outfile, flags, root=None, attr=None) -> bool
    Save current database using a new file name.
    
    @param outfile: (C++: const char *) output database file name
    @param flags: (C++: uint32) Database flags
    @param root: (C++: const snapshot_t *) optional: snapshot tree root.
    @param attr: (C++: const snapshot_t *) optional: snapshot attributes
    @note: when both root and attr are not nullptr then the snapshot attributes will
           be updated, otherwise the snapshot attributes will be inherited from the
           current database.
    @return: success

ida_loader.set_database_flag (function)
    set_database_flag(dbfl, cnd=True)
    Set or clear database flag
    
    @param dbfl: (C++: uint32) flag Database flags
    @param cnd: (C++: bool) set if true or clear flag otherwise

ida_loader.set_import_name (function)
    set_import_name(modnode, ea, name)
    Set information about the named import entry. This function performs
    'modnode.supset_ea(ea, name);'
    
    @param modnode: (C++: uval_t) node with information about imported entries
    @param ea: (C++: ea_t) linear address of the entry
    @param name: (C++: const char *) name of the entry

ida_loader.set_import_ordinal (function)
    set_import_ordinal(modnode, ea, ord)
    Set information about the ordinal import entry. This function performs
    'modnode.altset(ord, ea2node(ea));'
    
    @param modnode: (C++: uval_t) node with information about imported entries
    @param ea: (C++: ea_t) linear address of the entry
    @param ord: (C++: uval_t) ordinal number of the entry

ida_loader.set_path (function)
    set_path(pt, path)
    Set the file path
    
    @param pt: (C++: path_type_t) file path type Types of the file pathes
    @param path: (C++: const char *) new file path, use nullptr or empty string to clear the file path

ida_loader.snapshot_t (class)
    Proxy of C++ snapshot_t class.

ida_loader.snapshot_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.__init__ (method)
    __init__(self) -> snapshot_t

ida_loader.snapshot_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: snapshot_t const &

ida_loader.snapshot_t.children (variable)
    snapshot children

ida_loader.snapshot_t.clear (method)
    clear(self)

ida_loader.snapshot_t.desc (variable)
    snapshot description

ida_loader.snapshot_t.filename (variable)
    snapshot file name

ida_loader.snapshot_t.flags (variable)
    Snapshot flags

ida_loader.snapshot_t.id (variable)
    snapshot ID. This value is computed using qgettimeofday()

ida_moves (module)
    

ida_moves.bookmarks_t (class)
    Proxy of C++ bookmarks_t class.

ida_moves.bookmarks_t.__getitem__ (method)
    Get the n-th bookmark for the widget.

ida_moves.bookmarks_t.__init__ (method)

ida_moves.bookmarks_t.__init__ (method)
    Build an object suitable for iterating bookmarks
    associated with the specified widget.
    
    Note: all ea_t-based widgets (e.g., "IDA View-*",
    "Pseudocode-*", "Hex View-*", ...) share a common storage,
    so bookmarks can be re-used interchangeably between them

ida_moves.bookmarks_t.__iter__ (method)
    Iterate on bookmarks present for the widget.

ida_moves.bookmarks_t.__len__ (method)
    Get the number of bookmarks for the widget.

ida_moves.bookmarks_t.erase (method)
    erase(e, index, ud) -> bool
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

ida_moves.bookmarks_t.find_index (method)
    find_index(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.bookmarks_t.get (method)
    get(out, _index, ud) -> PyObject *
    
    @param out: lochist_entry_t *
    @param _index: uint32
    @param ud: void *

ida_moves.bookmarks_t.get_desc (method)
    get_desc(e, index, ud) -> bool
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

ida_moves.bookmarks_t.get_dirtree_id (method)
    get_dirtree_id(e, ud) -> dirtree_id_t
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.bookmarks_t.mark (method)
    mark(e, index, title, desc, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param title: char const *
    @param desc: char const *
    @param ud: void *

ida_moves.bookmarks_t.size (method)
    size(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.bookmarks_t_erase (function)
    bookmarks_t_erase(e, index, ud) -> bool
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

ida_moves.bookmarks_t_find_index (function)
    bookmarks_t_find_index(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.bookmarks_t_get (function)
    bookmarks_t_get(out, _index, ud) -> PyObject *
    
    @param out: lochist_entry_t *
    @param _index: uint32
    @param ud: void *

ida_moves.bookmarks_t_get_desc (function)
    bookmarks_t_get_desc(e, index, ud) -> str
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

ida_moves.bookmarks_t_get_dirtree_id (function)
    bookmarks_t_get_dirtree_id(e, ud) -> dirtree_id_t
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.bookmarks_t_mark (function)
    bookmarks_t_mark(e, index, title, desc, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param title: char const *
    @param desc: char const *
    @param ud: void *

ida_moves.bookmarks_t_size (function)
    bookmarks_t_size(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

ida_moves.graph_location_info_t (class)
    Proxy of C++ graph_location_info_t class.

ida_moves.graph_location_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: graph_location_info_t const &

ida_moves.graph_location_info_t.__init__ (method)
    __init__(self) -> graph_location_info_t

ida_moves.graph_location_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: graph_location_info_t const &

ida_moves.lochist_entry_t (class)
    Proxy of C++ lochist_entry_t class.

ida_moves.lochist_entry_t.__init__ (method)
    __init__(self) -> lochist_entry_t
    __init__(self, p, r) -> lochist_entry_t
    
    @param p: place_t const *
    @param r: renderer_info_t const &
    
    __init__(self, other) -> lochist_entry_t
    
    @param other: lochist_entry_t const &

ida_moves.lochist_entry_t.acquire_place (method)
    acquire_place(self, in_p)
    
    @param in_p: place_t *

ida_moves.lochist_entry_t.is_valid (method)
    is_valid(self) -> bool

ida_moves.lochist_entry_t.place (method)
    place(self) -> place_t

ida_moves.lochist_entry_t.renderer_info (method)
    renderer_info(self) -> renderer_info_t

ida_moves.lochist_entry_t.set_place (method)
    set_place(self, p)
    
    @param p: place_t const *

ida_moves.lochist_t (class)
    Proxy of C++ lochist_t class.

ida_moves.lochist_t.__init__ (method)
    __init__(self) -> lochist_t

ida_moves.lochist_t.back (method)
    back(self, cnt, try_to_unhide) -> bool
    
    @param cnt: uint32
    @param try_to_unhide: bool

ida_moves.lochist_t.clear (method)
    clear(self)

ida_moves.lochist_t.current_index (method)
    current_index(self) -> uint32

ida_moves.lochist_t.fwd (method)
    fwd(self, cnt, try_to_unhide) -> bool
    
    @param cnt: uint32
    @param try_to_unhide: bool

ida_moves.lochist_t.get (method)
    get(self, out, index) -> bool
    
    @param out: lochist_entry_t *
    @param index: uint32

ida_moves.lochist_t.get_current (method)
    get_current(self) -> lochist_entry_t

ida_moves.lochist_t.get_place_id (method)
    get_place_id(self) -> int

ida_moves.lochist_t.get_template_place (method)
    get_template_place(self) -> place_t

ida_moves.lochist_t.init (method)
    init(self, stream_name, _defpos, _ud, _flags) -> bool
    
    @param stream_name: char const *
    @param _defpos: place_t const *
    @param _ud: void *
    @param _flags: uint32

ida_moves.lochist_t.is_history_enabled (method)
    is_history_enabled(self) -> bool

ida_moves.lochist_t.jump (method)
    jump(self, try_to_unhide, e)
    
    @param try_to_unhide: bool
    @param e: lochist_entry_t const &

ida_moves.lochist_t.netcode (method)
    netcode(self) -> nodeidx_t

ida_moves.lochist_t.save (method)
    save(self)

ida_moves.lochist_t.seek (method)
    seek(self, index, try_to_unhide) -> bool
    
    @param index: uint32
    @param try_to_unhide: bool

ida_moves.lochist_t.set (method)
    set(self, index, e)
    
    @param index: uint32
    @param e: lochist_entry_t const &

ida_moves.lochist_t.set_current (method)
    set_current(self, e)
    
    @param e: lochist_entry_t const &

ida_moves.lochist_t.size (method)
    size(self) -> uint32

ida_moves.renderer_info_pos_t (class)
    Proxy of C++ renderer_info_pos_t class.

ida_moves.renderer_info_pos_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: renderer_info_pos_t const &

ida_moves.renderer_info_pos_t.__init__ (method)
    __init__(self) -> renderer_info_pos_t

ida_moves.renderer_info_pos_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: renderer_info_pos_t const &

ida_moves.renderer_info_t (class)
    Proxy of C++ renderer_info_t class.

ida_moves.renderer_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: renderer_info_t const &

ida_moves.renderer_info_t.__init__ (method)
    __init__(self) -> renderer_info_t
    __init__(self, _rtype, cx, cy) -> renderer_info_t
    
    @param _rtype: enum tcc_renderer_type_t
    @param cx: short
    @param cy: short

ida_moves.renderer_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: renderer_info_t const &

ida_moves.segm_move_info_t (class)
    Proxy of C++ segm_move_info_t class.

ida_moves.segm_move_info_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: segm_move_info_t const &

ida_moves.segm_move_info_t.__init__ (method)
    __init__(self, _from=0, _to=0, _sz=0) -> segm_move_info_t
    
    @param _from: ea_t
    @param _to: ea_t
    @param _sz: size_t

ida_moves.segm_move_info_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: segm_move_info_t const &

ida_moves.segm_move_info_vec_t (class)
    Proxy of C++ qvector< segm_move_info_t > class.

ida_moves.segm_move_info_vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< segm_move_info_t > const &

ida_moves.segm_move_info_vec_t.__getitem__ (method)
    __getitem__(self, i) -> segm_move_info_t
    
    @param i: size_t

ida_moves.segm_move_info_vec_t.__init__ (method)
    __init__(self) -> segm_move_info_vec_t
    __init__(self, x) -> segm_move_info_vec_t
    
    @param x: qvector< segm_move_info_t > const &

ida_moves.segm_move_info_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_moves.segm_move_info_vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< segm_move_info_t > const &

ida_moves.segm_move_info_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: segm_move_info_t const &

ida_moves.segm_move_info_vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.at (method)
    at(self, _idx) -> segm_move_info_t
    
    @param _idx: size_t

ida_moves.segm_move_info_vec_t.begin (method)
    begin(self) -> segm_move_info_t

ida_moves.segm_move_info_vec_t.capacity (method)
    capacity(self) -> size_t

ida_moves.segm_move_info_vec_t.clear (method)
    clear(self)

ida_moves.segm_move_info_vec_t.empty (method)
    empty(self) -> bool

ida_moves.segm_move_info_vec_t.end (method)
    end(self) -> segm_move_info_t

ida_moves.segm_move_info_vec_t.erase (method)
    erase(self, it) -> segm_move_info_t
    
    @param it: qvector< segm_move_info_t >::iterator
    
    erase(self, first, last) -> segm_move_info_t
    
    @param first: qvector< segm_move_info_t >::iterator
    @param last: qvector< segm_move_info_t >::iterator

ida_moves.segm_move_info_vec_t.extract (method)
    extract(self) -> segm_move_info_t

ida_moves.segm_move_info_vec_t.find (method)
    find(self, x) -> segm_move_info_t
    
    @param x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.grow (method)
    grow(self, x=segm_move_info_t())
    
    @param x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.has (method)
    has(self, x) -> bool
    
    @param x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: segm_move_info_t *
    @param len: size_t

ida_moves.segm_move_info_vec_t.insert (method)
    insert(self, it, x) -> segm_move_info_t
    
    @param it: qvector< segm_move_info_t >::iterator
    @param x: segm_move_info_t const &

ida_moves.segm_move_info_vec_t.pop_back (method)
    pop_back(self)

ida_moves.segm_move_info_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: segm_move_info_t const &
    
    push_back(self) -> segm_move_info_t

ida_moves.segm_move_info_vec_t.qclear (method)
    qclear(self)

ida_moves.segm_move_info_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_moves.segm_move_info_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: segm_move_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_moves.segm_move_info_vec_t.size (method)
    size(self) -> size_t

ida_moves.segm_move_info_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< segm_move_info_t > &

ida_moves.segm_move_info_vec_t.truncate (method)
    truncate(self)

ida_moves.segm_move_infos_t (class)
    Proxy of C++ segm_move_infos_t class.

ida_moves.segm_move_infos_t.__init__ (method)
    __init__(self) -> segm_move_infos_t

ida_moves.segm_move_infos_t.find (method)
    find(self, ea) -> segm_move_info_t
    
    @param ea: ea_t

ida_nalt (module)
    Definitions of various information kept in netnodes.
    
    Each address in the program has a corresponding netnode: netnode(ea).
    
    If we have no information about an address, the corresponding netnode is not
    created. Otherwise we will create a netnode and save information in it. All
    variable length information (names, comments, offset information, etc) is stored
    in the netnode.
    
    Don't forget that some information is already stored in the flags (bytes.hpp)
    
    @warning: Many of the functions in this file are very low level (they are marked
              as low level functions). Use them only if you can't find higher level
              function to set/get/del information.netnode.

ida_nalt.AFL_ALIGNFLOW (variable)
    the previous insn was created for alignment purposes only

ida_nalt.AFL_BNOT0 (variable)
    the 1st operand is bitwise negated

ida_nalt.AFL_BNOT1 (variable)
    the 2nd operand is bitwise negated

ida_nalt.AFL_COLORED (variable)
    has user defined instruction color?

ida_nalt.AFL_FIXEDSPD (variable)
    sp delta value is fixed by analysis. should not be modified by modules

ida_nalt.AFL_HIDDEN (variable)
    the item is hidden completely

ida_nalt.AFL_HR_DETERMINED (variable)
    the type is definitely guessed by the decompiler

ida_nalt.AFL_HR_GUESSED_DATA (variable)
    the data type is guessed by the decompiler

ida_nalt.AFL_HR_GUESSED_FUNC (variable)
    the function type is guessed by the decompiler

ida_nalt.AFL_IDA_GUESSED (variable)
    the type is guessed by IDA

ida_nalt.AFL_LIB (variable)
    item from the standard library. low level flag, is used to set FUNC_LIB of
    func_t

ida_nalt.AFL_LINNUM (variable)
    has line number info

ida_nalt.AFL_LNAME (variable)
    has local name too (FF_NAME should be set)

ida_nalt.AFL_LZERO0 (variable)
    toggle leading zeroes for the 1st operand

ida_nalt.AFL_LZERO1 (variable)
    toggle leading zeroes for the 2nd operand

ida_nalt.AFL_MANUAL (variable)
    the instruction/data is specified by the user

ida_nalt.AFL_NOBRD (variable)
    the code/data border is hidden

ida_nalt.AFL_NORET (variable)
    for imported function pointers: doesn't return. this flag can also be used for
    any instruction which halts or finishes the program execution

ida_nalt.AFL_NOTCODE (variable)
    autoanalysis should not create code here

ida_nalt.AFL_NOTPROC (variable)
    autoanalysis should not create proc here

ida_nalt.AFL_PUBNAM (variable)
    name is public (inter-file linkage)

ida_nalt.AFL_RETFP (variable)
    function returns a floating point value

ida_nalt.AFL_TERSESTR (variable)
    terse structure variable display?

ida_nalt.AFL_TI (variable)
    has typeinfo? (NSUP_TYPEINFO); used only for addresses, not for member_t

ida_nalt.AFL_TI0 (variable)
    has typeinfo for operand 0? (NSUP_OPTYPES)

ida_nalt.AFL_TI1 (variable)
    has typeinfo for operand 1? (NSUP_OPTYPES+1)

ida_nalt.AFL_TILCMT (variable)
    has type comment? (such a comment may be changed by IDA)

ida_nalt.AFL_TYPE_GUESSED (variable)
    who guessed the type information?

ida_nalt.AFL_USEMODSP (variable)
    insn modifes SP and uses the modified value; example: pop [rsp+N]

ida_nalt.AFL_USERSP (variable)
    user-defined SP value

ida_nalt.AFL_USERTI (variable)
    the type information is definitive. (comes from the user or type library) if not
    set see AFL_TYPE_GUESSED

ida_nalt.AFL_WEAKNAM (variable)
    name is weak

ida_nalt.AFL_ZSTROFF (variable)
    display struct field name at 0 offset when displaying an offset. example:
    offset somestruct.field_0  if this flag is clear, then
    offset somestruct

ida_nalt.AP_ALLOWDUPS (variable)
    use 'dup' construct

ida_nalt.AP_ARRAY (variable)
    create as array (this flag is not stored in database)

ida_nalt.AP_IDXBASEMASK (variable)
    mask for number base of the indexes

ida_nalt.AP_IDXBIN (variable)
    display indexes in binary

ida_nalt.AP_IDXDEC (variable)
    display indexes in decimal

ida_nalt.AP_IDXHEX (variable)
    display indexes in hex

ida_nalt.AP_IDXOCT (variable)
    display indexes in octal

ida_nalt.AP_INDEX (variable)
    display array element indexes as comments

ida_nalt.AP_SIGNED (variable)
    treats numbers as signed

ida_nalt.IDB_DESKTOPS_NODE_NAME (variable)
    hash indexed by desktop name with dekstop netnode

ida_nalt.IDB_DESKTOPS_TAG (variable)
    tag to store desktop blob & timestamp

ida_nalt.MAXSTRUCPATH (variable)
    maximal inclusion depth of unions

ida_nalt.NALT_ABSBASE (variable)
    absolute segment location

ida_nalt.NALT_AFLAGS (variable)
    additional flags for an item

ida_nalt.NALT_ALIGN (variable)
    alignment value if the item is FF_ALIGN (should by equal to power of 2)

ida_nalt.NALT_COLOR (variable)
    instruction/data background color

ida_nalt.NALT_CREF_FROM (variable)
    code xref from, idx: source address

ida_nalt.NALT_CREF_TO (variable)
    code xref to, idx: target address

ida_nalt.NALT_DREF_FROM (variable)
    data xref from, idx: source address

ida_nalt.NALT_DREF_TO (variable)
    data xref to, idx: target address

ida_nalt.NALT_ENUM0 (variable)
    enum id for the first operand

ida_nalt.NALT_ENUM1 (variable)
    enum id for the second operand

ida_nalt.NALT_GR_LAYX (variable)
    group layout ptrs, hash: md5 of 'belongs'

ida_nalt.NALT_LINNUM (variable)
    source line number

ida_nalt.NALT_PURGE (variable)
    number of bytes purged from the stack when a function is called indirectly

ida_nalt.NALT_STRTYPE (variable)
    type of string item

ida_nalt.NALT_STRUCT (variable)
    struct id

ida_nalt.NALT_SWITCH (variable)
    switch idiom address (used at jump targets)

ida_nalt.NSUP_ARGEAS (variable)
    instructions that initialize call arguments

ida_nalt.NSUP_ARRAY (variable)
    array parameters

ida_nalt.NSUP_CMT (variable)
    regular comment

ida_nalt.NSUP_CUSTDT (variable)
    custom data type id

ida_nalt.NSUP_EX_FLAGS (variable)
    Extended flags.

ida_nalt.NSUP_FOP1 (variable)
    forced operand 1

ida_nalt.NSUP_FOP2 (variable)
    forced operand 2

ida_nalt.NSUP_FOP3 (variable)
    forced operand 3

ida_nalt.NSUP_FOP4 (variable)
    forced operand 4

ida_nalt.NSUP_FOP5 (variable)
    forced operand 5

ida_nalt.NSUP_FOP6 (variable)
    forced operand 6

ida_nalt.NSUP_FOP7 (variable)
    forced operand 7

ida_nalt.NSUP_FOP8 (variable)
    forced operand 8

ida_nalt.NSUP_FTAILS (variable)
    function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000 are
    reserved

ida_nalt.NSUP_GROUP (variable)
    graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are reserved

ida_nalt.NSUP_GR_INFO (variable)
    group node info: color, ea, text

ida_nalt.NSUP_GR_LAYT (variable)
    group layouts, idx: layout pointer

ida_nalt.NSUP_JINFO (variable)
    jump table info

ida_nalt.NSUP_LLABEL (variable)
    local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved

ida_nalt.NSUP_MANUAL (variable)
    manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are reserved

ida_nalt.NSUP_OPTYPES (variable)
    operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000 are
    reserved

ida_nalt.NSUP_OREF0 (variable)
    outer complex reference information for operand 1

ida_nalt.NSUP_OREF1 (variable)
    outer complex reference information for operand 2

ida_nalt.NSUP_OREF2 (variable)
    outer complex reference information for operand 3

ida_nalt.NSUP_OREF3 (variable)
    outer complex reference information for operand 4

ida_nalt.NSUP_OREF4 (variable)
    outer complex reference information for operand 5

ida_nalt.NSUP_OREF5 (variable)
    outer complex reference information for operand 6

ida_nalt.NSUP_OREF6 (variable)
    outer complex reference information for operand 7

ida_nalt.NSUP_OREF7 (variable)
    outer complex reference information for operand 8

ida_nalt.NSUP_ORIGFMD (variable)
    function metadata before lumina information was applied values
    NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved

ida_nalt.NSUP_POINTS (variable)
    SP change points blob (see funcs.cpp). values NSUP_POINTS..NSUP_POINTS+0x1000
    are reserved

ida_nalt.NSUP_REF0 (variable)
    complex reference information for operand 1

ida_nalt.NSUP_REF1 (variable)
    complex reference information for operand 2

ida_nalt.NSUP_REF2 (variable)
    complex reference information for operand 3

ida_nalt.NSUP_REF3 (variable)
    complex reference information for operand 4

ida_nalt.NSUP_REF4 (variable)
    complex reference information for operand 5

ida_nalt.NSUP_REF5 (variable)
    complex reference information for operand 6

ida_nalt.NSUP_REF6 (variable)
    complex reference information for operand 7

ida_nalt.NSUP_REF7 (variable)
    complex reference information for operand 8

ida_nalt.NSUP_REGARG (variable)
    register argument type/name descriptions values NSUP_REGARG..NSUP_REGARG+0x1000
    are reserved

ida_nalt.NSUP_REGVAR (variable)
    register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are reserved

ida_nalt.NSUP_REPCMT (variable)
    repeatable comment

ida_nalt.NSUP_SEGTRANS (variable)
    segment translations

ida_nalt.NSUP_SWITCH (variable)
    switch information

ida_nalt.NSUP_TYPEINFO (variable)
    type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are reserved

ida_nalt.NSUP_XREFPOS (variable)
    saved xref address and type in the xrefs window

ida_nalt.PATCH_TAG (variable)
    Patch netnode tag.

ida_nalt.REFINFO_CUSTOM (variable)
    a custom reference. see custom_refinfo_handler_t. the id of the custom refinfo
    is stored under the REFINFO_TYPE mask.

ida_nalt.REFINFO_NOBASE (variable)
    don't create the base xref; implies that the base can be any value. nb: base
    xrefs are created only if the offset base points to the middle of a segment

ida_nalt.REFINFO_NO_ONES (variable)
    an opval of ~0 will be considered invalid

ida_nalt.REFINFO_NO_ZEROS (variable)
    an opval of 0 will be considered invalid

ida_nalt.REFINFO_PASTEND (variable)
    reference past an item; it may point to an nonexistent address; do not destroy
    alignment dirs

ida_nalt.REFINFO_RVAOFF (variable)
    based reference (rva); refinfo_t::base will be forced to get_imagebase(); such a
    reference is displayed with the asm_t::a_rva keyword

ida_nalt.REFINFO_SELFREF (variable)
    the self-based reference; refinfo_t::base will be forced to the reference
    address

ida_nalt.REFINFO_SIGNEDOP (variable)
    the operand value is sign-extended (only supported for REF_OFF8/16/32/64)

ida_nalt.REFINFO_SUBTRACT (variable)
    the reference value is subtracted from the base value instead of (as usual)
    being added to it

ida_nalt.REFINFO_TYPE (variable)
    reference type (reftype_t), or custom reference ID if REFINFO_CUSTOM set

ida_nalt.REF_HIGH16 (variable)
    high 16bits of 32bit offset

ida_nalt.REF_HIGH8 (variable)
    high 8bits of 16bit offset

ida_nalt.REF_LOW16 (variable)
    low 16bits of 32bit offset

ida_nalt.REF_LOW8 (variable)
    low 8bits of 16bit offset

ida_nalt.REF_OFF16 (variable)
    16bit full offset

ida_nalt.REF_OFF32 (variable)
    32bit full offset

ida_nalt.REF_OFF64 (variable)
    64bit full offset

ida_nalt.REF_OFF8 (variable)
    8bit full offset

ida_nalt.RIDX_ABINAME (variable)
    ABI name (processor specific)

ida_nalt.RIDX_ARCHIVE_PATH (variable)
    archive file path

ida_nalt.RIDX_C_MACROS (variable)
    C predefined macros.

ida_nalt.RIDX_DBG_BINPATHS (variable)
    unused (20 indexes)

ida_nalt.RIDX_DUALOP_GRAPH (variable)
    Graph text representation options.

ida_nalt.RIDX_DUALOP_TEXT (variable)
    Text text representation options.

ida_nalt.RIDX_FILE_FORMAT_NAME (variable)
    file format name for loader modules

ida_nalt.RIDX_GROUPS (variable)
    segment group information (see init_groups())

ida_nalt.RIDX_H_PATH (variable)
    C header path.

ida_nalt.RIDX_IDA_VERSION (variable)
    version of ida which created the database

ida_nalt.RIDX_INCLUDE (variable)
    assembler include file name

ida_nalt.RIDX_MD5 (variable)
    MD5 of the input file.

ida_nalt.RIDX_NOTEPAD (variable)
    notepad blob, occupies 1000 indexes (1MB of text)

ida_nalt.RIDX_PROBLEMS (variable)
    problem lists

ida_nalt.RIDX_SELECTORS (variable)
    2..63 are for selector_t blob (see init_selectors())

ida_nalt.RIDX_SHA256 (variable)
    SHA256 of the input file.

ida_nalt.RIDX_SMALL_IDC (variable)
    Instant IDC statements, blob.

ida_nalt.RIDX_SMALL_IDC_OLD (variable)
    Instant IDC statements (obsolete)

ida_nalt.RIDX_SRCDBG_PATHS (variable)
    source debug paths, occupies 20 indexes

ida_nalt.RIDX_SRCDBG_UNDESIRED (variable)
    user-closed source files, occupies 20 indexes

ida_nalt.RIDX_STR_ENCODINGS (variable)
    a list of encodings for the program strings

ida_nalt.STRENC_DEFAULT (variable)
    use default encoding for this type (see get_default_encoding_idx())

ida_nalt.STRENC_NONE (variable)
    force no-conversion encoding

ida_nalt.STRTYPE_C (variable)
    Zero-terminated 16bit chars.

ida_nalt.STRTYPE_C_16 (variable)
    Zero-terminated 32bit chars.

ida_nalt.STRTYPE_C_32 (variable)
    Pascal-style, one-byte length prefix.

ida_nalt.STRTYPE_LEN2 (variable)
    Pascal-style, 16bit chars, two-byte length prefix.

ida_nalt.STRTYPE_LEN2_16 (variable)
    Pascal-style, 32bit chars, two-byte length prefix.

ida_nalt.STRTYPE_LEN2_32 (variable)
    Pascal-style, four-byte length prefix.

ida_nalt.STRTYPE_LEN4 (variable)
    Pascal-style, 16bit chars, four-byte length prefix.

ida_nalt.STRTYPE_LEN4_16 (variable)
    Pascal-style, 32bit chars, four-byte length prefix.

ida_nalt.STRTYPE_PASCAL (variable)
    Pascal-style, 16bit chars, one-byte length prefix.

ida_nalt.STRTYPE_PASCAL_16 (variable)
    Pascal-style, 32bit chars, one-byte length prefix.

ida_nalt.STRTYPE_PASCAL_32 (variable)
    Pascal-style, two-byte length prefix.

ida_nalt.STRTYPE_TERMCHR (variable)
    C-style string.

ida_nalt.SWI_CUSTOM (variable)
    custom jump table. processor_t::create_switch_xrefs will be called to create
    code xrefs for the table. Custom jump table must be created by the module (see
    also SWI_STDTBL)

ida_nalt.SWI_DEFRET (variable)
    return in the default case (defjump==BADADDR)

ida_nalt.SWI_DEF_IN_TBL (variable)
    default case is an entry in the jump table. This flag is applicable in 2 cases:
    * The sparse indirect switch (i.e. a switch with a values table) {jump table
    size} == {value table size} + 1. The default case entry is the last one in the
    table (or the first one in the case of an inversed jump table).
    * The switch with insns in the jump table. The default case entry is before the
    first entry of the table.
    See also the find_defjump_from_table() helper function.

ida_nalt.SWI_ELBASE (variable)
    elbase is present (otherwise the base of the switch segment will be used)

ida_nalt.SWI_HXNOLOWCASE (variable)
    lowcase value should not be used by the decompiler (internal flag)

ida_nalt.SWI_INDIRECT (variable)
    value table elements are used as indexes into the jump table (for sparse
    switches)

ida_nalt.SWI_J32 (variable)
    32-bit jump offsets

ida_nalt.SWI_JMPINSN (variable)
    jump table entries are insns. For such entries SHIFT has a different meaning. It
    denotes the number of insns in the entry. For example, 0 - the entry contains
    the jump to the case, 1 - the entry contains one insn like a 'mov' and jump to
    the end of case, and so on.

ida_nalt.SWI_JMP_INV (variable)
    jumptable is inversed. (last entry is for first entry in values table)

ida_nalt.SWI_JSIZE (variable)
    jump offset expansion bit

ida_nalt.SWI_SELFREL (variable)
    jump address is relative to the element not to ELBASE

ida_nalt.SWI_SEPARATE (variable)
    create an array of individual elements (otherwise separate items)

ida_nalt.SWI_SHIFT_MASK (variable)
    use formula (element<<shift) + elbase to find jump targets

ida_nalt.SWI_SIGNED (variable)
    jump table entries are signed

ida_nalt.SWI_SPARSE (variable)
    sparse switch (value table present), otherwise lowcase present

ida_nalt.SWI_STDTBL (variable)
    custom jump table with standard table formatting. ATM IDA doesn't use SWI_CUSTOM
    for switches with standard table formatting. So this flag can be considered as
    obsolete.

ida_nalt.SWI_SUBTRACT (variable)
    table values are subtracted from the elbase instead of being added

ida_nalt.SWI_USER (variable)
    user specified switch (starting from version 2)

ida_nalt.SWI_V32 (variable)
    32-bit values in table

ida_nalt.SWI_VERSION (variable)
    the structure contains the VERSION member

ida_nalt.SWI_VSIZE (variable)
    value table element size expansion bit

ida_nalt.SWI_VSPLIT (variable)
    value table is split (only for 32-bit values)

ida_nalt.V695_REF_OFF8 (variable)
    reserved

ida_nalt.V695_REF_VHIGH (variable)
    obsolete

ida_nalt.V695_REF_VLOW (variable)
    obsolete

ida_nalt.add_encoding (function)
    add_encoding(encname) -> int
    Add a new encoding (e.g. "UTF-8"). If it's already in the list, return its
    index.
    
    @param encname: (C++: const char *) the encoding name
    @return: its index (1-based); -1 means error

ida_nalt.array_parameters_t (class)
    Proxy of C++ array_parameters_t class.

ida_nalt.array_parameters_t.__init__ (method)
    __init__(self, _f=0x00000001, _l=0, _a=-1) -> array_parameters_t
    
    @param _f: int32
    @param _l: int32
    @param _a: int32

ida_nalt.array_parameters_t.alignment (variable)
    -1 - don't align. 0 - align automatically. else item width

ida_nalt.array_parameters_t.is_default (method)
    is_default(self) -> bool

ida_nalt.array_parameters_t.lineitems (variable)
    number of items on a line

ida_nalt.clr__bnot0 (function)
    clr__bnot0(ea)
    
    @param ea: ea_t

ida_nalt.clr__bnot1 (function)
    clr__bnot1(ea)
    
    @param ea: ea_t

ida_nalt.clr__invsign0 (function)
    clr__invsign0(ea)
    
    @param ea: ea_t

ida_nalt.clr__invsign1 (function)
    clr__invsign1(ea)
    
    @param ea: ea_t

ida_nalt.clr_abits (function)
    clr_abits(ea, bits)
    
    @param ea: ea_t
    @param bits: aflags_t

ida_nalt.clr_align_flow (function)
    clr_align_flow(ea)
    
    @param ea: ea_t

ida_nalt.clr_colored_item (function)
    clr_colored_item(ea)
    
    @param ea: ea_t

ida_nalt.clr_fixed_spd (function)
    clr_fixed_spd(ea)
    
    @param ea: ea_t

ida_nalt.clr_has_lname (function)
    clr_has_lname(ea)
    
    @param ea: ea_t

ida_nalt.clr_has_ti (function)
    clr_has_ti(ea)
    
    @param ea: ea_t

ida_nalt.clr_has_ti0 (function)
    clr_has_ti0(ea)
    
    @param ea: ea_t

ida_nalt.clr_has_ti1 (function)
    clr_has_ti1(ea)
    
    @param ea: ea_t

ida_nalt.clr_libitem (function)
    clr_libitem(ea)
    
    @param ea: ea_t

ida_nalt.clr_lzero0 (function)
    clr_lzero0(ea)
    
    @param ea: ea_t

ida_nalt.clr_lzero1 (function)
    clr_lzero1(ea)
    
    @param ea: ea_t

ida_nalt.clr_noret (function)
    clr_noret(ea)
    
    @param ea: ea_t

ida_nalt.clr_notcode (function)
    clr_notcode(ea)
    Clear not-code mark.
    
    @param ea: (C++: ea_t)

ida_nalt.clr_notproc (function)
    clr_notproc(ea)
    
    @param ea: ea_t

ida_nalt.clr_retfp (function)
    clr_retfp(ea)
    
    @param ea: ea_t

ida_nalt.clr_terse_struc (function)
    clr_terse_struc(ea)
    
    @param ea: ea_t

ida_nalt.clr_tilcmt (function)
    clr_tilcmt(ea)
    
    @param ea: ea_t

ida_nalt.clr_usemodsp (function)
    clr_usemodsp(ea)
    
    @param ea: ea_t

ida_nalt.clr_usersp (function)
    clr_usersp(ea)
    
    @param ea: ea_t

ida_nalt.clr_userti (function)
    clr_userti(ea)
    
    @param ea: ea_t

ida_nalt.clr_zstroff (function)
    clr_zstroff(ea)
    
    @param ea: ea_t

ida_nalt.custom_data_type_ids_fids_array (class)
    Proxy of C++ wrapped_array_t< int16,8 > class.

ida_nalt.custom_data_type_ids_fids_array.__getitem__ (method)
    __getitem__(self, i) -> short const &
    
    @param i: size_t

ida_nalt.custom_data_type_ids_fids_array.__init__ (method)
    __init__(self, data) -> custom_data_type_ids_fids_array
    
    @param data: short (&)[8]

ida_nalt.custom_data_type_ids_fids_array.__len__ (method)
    __len__(self) -> size_t

ida_nalt.custom_data_type_ids_fids_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: short const &

ida_nalt.custom_data_type_ids_fids_array._get_bytes (method)
    _get_bytes(self) -> bytevec_t

ida_nalt.custom_data_type_ids_fids_array._set_bytes (method)
    _set_bytes(self, bts)
    
    Parameters
    ----------
    bts: bytevec_t const &

ida_nalt.custom_data_type_ids_t (class)
    Proxy of C++ custom_data_type_ids_t class.

ida_nalt.custom_data_type_ids_t.__getFids (method)
    __getFids(self) -> custom_data_type_ids_fids_array

ida_nalt.custom_data_type_ids_t.__init__ (method)
    __init__(self) -> custom_data_type_ids_t

ida_nalt.custom_data_type_ids_t.dtid (variable)
    data type id

ida_nalt.custom_data_type_ids_t.fids (variable)
    data format ids

ida_nalt.custom_data_type_ids_t.get_dtid (method)
    get_dtid(self) -> tid_t

ida_nalt.custom_data_type_ids_t.set (method)
    set(self, tid)
    
    @param tid: tid_t

ida_nalt.dbg_get_input_path (function)
    dbg_get_input_path() -> str
    Get debugger input file name/path (see LFLG_DBG_NOPATH)

ida_nalt.del_absbase (function)
    del_absbase(ea)
    
    @param ea: ea_t

ida_nalt.del_aflags (function)
    del_aflags(ea)
    
    @param ea: ea_t

ida_nalt.del_alignment (function)
    del_alignment(ea)
    
    @param ea: ea_t

ida_nalt.del_array_parameters (function)
    del_array_parameters(ea)
    
    @param ea: ea_t

ida_nalt.del_custom_data_type_ids (function)
    del_custom_data_type_ids(ea)
    
    @param ea: ea_t

ida_nalt.del_encoding (function)
    del_encoding(idx) -> bool
    Delete an encoding The encoding is not actually removed because its index may be
    used in strtype. So the deletion just clears the encoding name. The default
    encoding cannot be deleted.
    
    @param idx: (C++: int) the encoding index (1-based)

ida_nalt.del_ind_purged (function)
    del_ind_purged(ea)
    
    @param ea: ea_t

ida_nalt.del_item_color (function)
    del_item_color(ea) -> bool
    
    @param ea: ea_t

ida_nalt.del_op_tinfo (function)
    del_op_tinfo(ea, n)
    
    @param ea: ea_t
    @param n: int

ida_nalt.del_refinfo (function)
    del_refinfo(ea, n) -> bool
    
    @param ea: ea_t
    @param n: int

ida_nalt.del_source_linnum (function)
    del_source_linnum(ea)
    
    @param ea: ea_t

ida_nalt.del_str_type (function)
    del_str_type(ea)
    
    @param ea: ea_t

ida_nalt.del_switch_info (function)
    del_switch_info(ea)
    
    @param ea: ea_t

ida_nalt.del_switch_parent (function)
    del_switch_parent(ea)
    
    @param ea: ea_t

ida_nalt.del_tinfo (function)
    del_tinfo(ea)
    
    @param ea: ea_t

ida_nalt.delete_imports (function)
    delete_imports()
    Delete all imported modules information.

ida_nalt.ea2node (function)
    ea2node(ea) -> nodeidx_t
    Get netnode for the specified address.
    
    @param ea: (C++: ea_t)

ida_nalt.encoding_from_strtype (function)
    encoding_from_strtype(strtype) -> char const *
    Get encoding name for this strtype
    @retval nullptr: if STRTYPE has an incorrent encoding index
    @retval empty: string if the encoding was deleted
    
    @param strtype: (C++: int32)

ida_nalt.end_ea2node (function)
    end_ea2node(ea) -> nodeidx_t
    
    @param ea: ea_t

ida_nalt.enum_const_t (class)
    Proxy of C++ enum_const_t class.

ida_nalt.enum_const_t.__init__ (method)
    __init__(self) -> enum_const_t

ida_nalt.enum_import_names (function)
    enum_import_names(mod_index, py_cb) -> int
    Enumerate imports from a specific module.
    Please refer to ex_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)

ida_nalt.find_custom_refinfo (function)
    find_custom_refinfo(name) -> int
    Get id of a custom refinfo type.
    
    @param name: (C++: const char *) char const *

ida_nalt.get_abi_name (function)

ida_nalt.get_absbase (function)
    get_absbase(ea) -> ea_t
    
    @param ea: ea_t

ida_nalt.get_aflags (function)
    get_aflags(ea) -> aflags_t
    
    @param ea: ea_t

ida_nalt.get_alignment (function)
    get_alignment(ea) -> uint32
    
    @param ea: ea_t

ida_nalt.get_archive_path (function)
    get_archive_path() -> str
    Get archive file path from which input file was extracted.

ida_nalt.get_array_parameters (function)
    get_array_parameters(out, ea) -> ssize_t
    
    @param out: array_parameters_t *
    @param ea: ea_t

ida_nalt.get_asm_inc_file (function)
    get_asm_inc_file() -> str
    Get name of the include file.

ida_nalt.get_custom_data_type_ids (function)
    get_custom_data_type_ids(cdis, ea) -> int
    
    @param cdis: custom_data_type_ids_t *
    @param ea: ea_t

ida_nalt.get_custom_refinfo (function)
    get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
    Get definition of a registered custom refinfo type.
    
    @param crid: (C++: int)

ida_nalt.get_default_encoding_idx (function)
    get_default_encoding_idx(bpu) -> int
    Get default encoding index for a specific string type.
    
    @param bpu: (C++: int) the amount of bytes per unit (e.g., 1 for ASCII, CP1252, UTF-8..., 2
                for UTF-16, 4 for UTF-32)
    @retval 0: bad BPU argument

ida_nalt.get_elapsed_secs (function)
    get_elapsed_secs() -> size_t
    Get seconds database stayed open.

ida_nalt.get_encoding_bpu (function)
    get_encoding_bpu(idx) -> int
    Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32) for the
    encoding with the given index.
    
    @param idx: (C++: int) the encoding index (1-based)
    @return: the number of bytes per units (1/2/4); -1 means error

ida_nalt.get_encoding_bpu_by_name (function)
    get_encoding_bpu_by_name(encname) -> int
    Get the amount of bytes per unit for the given encoding
    
    @param encname: (C++: const char *) the encoding name
    @return: the number of bytes per units (1/2/4); -1 means error

ida_nalt.get_encoding_name (function)
    get_encoding_name(idx) -> char const *
    Get encoding name for specific index (1-based).
    
    @param idx: (C++: int) the encoding index (1-based)
    @retval nullptr: if IDX is out of bounds
    @retval empty: string if the encoding was deleted

ida_nalt.get_encoding_qty (function)
    get_encoding_qty() -> int
    Get total number of encodings (counted from 0)

ida_nalt.get_gotea (function)
    get_gotea() -> ea_t

ida_nalt.get_ida_notepad_text (function)
    get_ida_notepad_text() -> str
    Get notepad text.

ida_nalt.get_idb_ctime (function)
    get_idb_ctime() -> time_t
    Get database creation timestamp.

ida_nalt.get_idb_nopens (function)
    get_idb_nopens() -> size_t
    Get number of times the database is opened.

ida_nalt.get_ids_modnode (function)
    get_ids_modnode() -> netnode
    Get ids modnode.

ida_nalt.get_imagebase (function)
    get_imagebase() -> ea_t
    Get image base address.

ida_nalt.get_import_module_name (function)
    get_import_module_name(mod_index) -> str
    Returns the name of an imported module given its index
    
    @param mod_index: int
    @return: None or the module name

ida_nalt.get_import_module_qty (function)
    get_import_module_qty() -> uint
    Get number of import modules.

ida_nalt.get_ind_purged (function)
    get_ind_purged(ea) -> ea_t
    
    @param ea: ea_t

ida_nalt.get_initial_ida_version (function)
    get_initial_ida_version() -> str
    Get version of ida which created the database (string format like "7.5")

ida_nalt.get_initial_idb_version (function)
    get_initial_idb_version() -> ushort
    Get initial version of the database (numeric format like 700)

ida_nalt.get_input_file_path (function)
    get_input_file_path() -> str
    Get full path of the input file.

ida_nalt.get_item_color (function)
    get_item_color(ea) -> bgcolor_t
    
    @param ea: ea_t

ida_nalt.get_loader_format_name (function)
    get_loader_format_name() -> str
    Get file format name for loader modules.

ida_nalt.get_op_tinfo (function)
    get_op_tinfo(tif, ea, n) -> bool
    
    @param tif: tinfo_t *
    @param ea: ea_t
    @param n: int

ida_nalt.get_outfile_encoding_idx (function)
    get_outfile_encoding_idx() -> int
    Get the index of the encoding used when producing files
    @retval 0: the IDB's default 1 byte-per-unit encoding is used

ida_nalt.get_refinfo (function)
    get_refinfo(ri, ea, n) -> bool
    
    @param ri: refinfo_t *
    @param ea: ea_t
    @param n: int

ida_nalt.get_reftype_by_size (function)
    get_reftype_by_size(size) -> reftype_t
    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other sizes
    returns reftype_t(-1)
    
    @param size: (C++: size_t)

ida_nalt.get_root_filename (function)
    get_root_filename() -> str
    Get file name only of the input file.

ida_nalt.get_source_linnum (function)
    get_source_linnum(ea) -> uval_t
    
    @param ea: ea_t

ida_nalt.get_srcdbg_paths (function)
    get_srcdbg_paths() -> str
    Get source debug paths.

ida_nalt.get_srcdbg_undesired_paths (function)
    get_srcdbg_undesired_paths() -> str
    Get user-closed source files.

ida_nalt.get_str_encoding_idx (function)
    get_str_encoding_idx(strtype) -> uchar
    Get index of the string encoding for this string.
    
    @param strtype: (C++: int32)

ida_nalt.get_str_term1 (function)
    get_str_term1(strtype) -> char
    
    @param strtype: int32

ida_nalt.get_str_term2 (function)
    get_str_term2(strtype) -> char
    
    @param strtype: int32

ida_nalt.get_str_type (function)
    get_str_type(ea) -> uint32
    
    @param ea: ea_t

ida_nalt.get_str_type_code (function)
    get_str_type_code(strtype) -> uchar
    
    @param strtype: int32

ida_nalt.get_str_type_prefix_length (function)
    get_str_type_prefix_length(strtype) -> size_t
    
    @param strtype: int32

ida_nalt.get_strid (function)
    get_strid(ea) -> tid_t
    
    @param ea: ea_t

ida_nalt.get_strtype_bpu (function)
    get_strtype_bpu(strtype) -> int
    
    @param strtype: int32

ida_nalt.get_switch_info (function)
    get_switch_info(out, ea) -> ssize_t
    
    @param out: switch_info_t *
    @param ea: ea_t

ida_nalt.get_switch_info (function)

ida_nalt.get_switch_parent (function)
    get_switch_parent(ea) -> ea_t
    
    @param ea: ea_t

ida_nalt.get_tinfo (function)
    get_tinfo(tif, ea) -> bool
    
    @param tif: tinfo_t *
    @param ea: ea_t

ida_nalt.getnode (function)
    getnode(ea) -> netnode
    
    @param ea: ea_t

ida_nalt.has_aflag_linnum (function)
    has_aflag_linnum(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.has_aflag_lname (function)
    has_aflag_lname(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.has_aflag_ti (function)
    has_aflag_ti(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.has_aflag_ti0 (function)
    has_aflag_ti0(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.has_aflag_ti1 (function)
    has_aflag_ti1(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.has_lname (function)
    has_lname(ea) -> bool
    
    @param ea: ea_t

ida_nalt.has_ti (function)
    has_ti(ea) -> bool
    
    @param ea: ea_t

ida_nalt.has_ti0 (function)
    has_ti0(ea) -> bool
    
    @param ea: ea_t

ida_nalt.has_ti1 (function)
    has_ti1(ea) -> bool
    
    @param ea: ea_t

ida_nalt.hide_border (function)
    hide_border(ea)
    
    @param ea: ea_t

ida_nalt.hide_item (function)
    hide_item(ea)
    
    @param ea: ea_t

ida_nalt.is__bnot0 (function)
    is__bnot0(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is__bnot1 (function)
    is__bnot1(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is__invsign0 (function)
    is__invsign0(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is__invsign1 (function)
    is__invsign1(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_aflag__bnot0 (function)
    is_aflag__bnot0(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag__bnot1 (function)
    is_aflag__bnot1(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag__invsign0 (function)
    is_aflag__invsign0(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag__invsign1 (function)
    is_aflag__invsign1(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_align_flow (function)
    is_aflag_align_flow(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_colored_item (function)
    is_aflag_colored_item(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_data_guessed_by_hexrays (function)
    is_aflag_data_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_fixed_spd (function)
    is_aflag_fixed_spd(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_func_guessed_by_hexrays (function)
    is_aflag_func_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_hidden_border (function)
    is_aflag_hidden_border(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_hidden_item (function)
    is_aflag_hidden_item(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_libitem (function)
    is_aflag_libitem(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_lzero0 (function)
    is_aflag_lzero0(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_lzero1 (function)
    is_aflag_lzero1(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_manual_insn (function)
    is_aflag_manual_insn(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_noret (function)
    is_aflag_noret(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_notcode (function)
    is_aflag_notcode(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_notproc (function)
    is_aflag_notproc(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_public_name (function)
    is_aflag_public_name(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_retfp (function)
    is_aflag_retfp(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_terse_struc (function)
    is_aflag_terse_struc(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_tilcmt (function)
    is_aflag_tilcmt(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_type_determined_by_hexrays (function)
    is_aflag_type_determined_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_type_guessed_by_hexrays (function)
    is_aflag_type_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_type_guessed_by_ida (function)
    is_aflag_type_guessed_by_ida(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_usersp (function)
    is_aflag_usersp(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_userti (function)
    is_aflag_userti(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_weak_name (function)
    is_aflag_weak_name(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_aflag_zstroff (function)
    is_aflag_zstroff(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.is_align_flow (function)
    is_align_flow(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_colored_item (function)
    is_colored_item(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_data_guessed_by_hexrays (function)
    is_data_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_finally_visible_item (function)
    is_finally_visible_item(ea) -> bool
    Is instruction visible?
    
    @param ea: (C++: ea_t)

ida_nalt.is_fixed_spd (function)
    is_fixed_spd(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_func_guessed_by_hexrays (function)
    is_func_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_hidden_border (function)
    is_hidden_border(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_hidden_item (function)
    is_hidden_item(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_libitem (function)
    is_libitem(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_lzero0 (function)
    is_lzero0(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_lzero1 (function)
    is_lzero1(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_noret (function)
    is_noret(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_notcode (function)
    is_notcode(ea) -> bool
    Is the address marked as not-code?
    
    @param ea: (C++: ea_t)

ida_nalt.is_notproc (function)
    is_notproc(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_pascal (function)
    is_pascal(strtype) -> bool
    
    @param strtype: int32

ida_nalt.is_reftype_target_optional (function)
    is_reftype_target_optional(type) -> bool
    Can the target be calculated using operand value?
    
    @param type: (C++: reftype_t)

ida_nalt.is_retfp (function)
    is_retfp(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_terse_struc (function)
    is_terse_struc(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_tilcmt (function)
    is_tilcmt(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_type_determined_by_hexrays (function)
    is_type_determined_by_hexrays(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_type_guessed_by_hexrays (function)
    is_type_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_type_guessed_by_ida (function)
    is_type_guessed_by_ida(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_usersp (function)
    is_usersp(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_userti (function)
    is_userti(ea) -> bool
    
    @param ea: ea_t

ida_nalt.is_visible_item (function)
    is_visible_item(ea) -> bool
    Test visibility of item at given ea.
    
    @param ea: (C++: ea_t)

ida_nalt.is_zstroff (function)
    is_zstroff(ea) -> bool
    
    @param ea: ea_t

ida_nalt.make_str_type (function)
    make_str_type(type_code, encoding_idx, term1=0, term2=0) -> int32
    Get string type for a string in the given encoding.
    
    @param type_code: (C++: uchar)
    @param encoding_idx: (C++: int)
    @param term1: (C++: uchar)
    @param term2: (C++: uchar)

ida_nalt.node2ea (function)
    node2ea(ndx) -> ea_t
    
    @param ndx: nodeidx_t

ida_nalt.opinfo_t (class)
    Proxy of C++ opinfo_t class.

ida_nalt.opinfo_t.__init__ (method)
    __init__(self) -> opinfo_t

ida_nalt.opinfo_t.cd (variable)
    for custom data

ida_nalt.opinfo_t.ec (variable)
    for enums

ida_nalt.opinfo_t.path (variable)
    for stroff

ida_nalt.opinfo_t.ri (variable)
    for offset members

ida_nalt.opinfo_t.strtype (variable)
    for strings (String type codes)

ida_nalt.opinfo_t.tid (variable)
    for struct, etc. members

ida_nalt.printop_t (class)
    Proxy of C++ printop_t class.

ida_nalt.printop_t.__init__ (method)
    __init__(self) -> printop_t

ida_nalt.printop_t.get_ti (method)
    get_ti(self) -> opinfo_t

ida_nalt.printop_t.is_aflags_initialized (method)
    is_aflags_initialized(self) -> bool

ida_nalt.printop_t.is_f64 (method)
    is_f64(self) -> bool

ida_nalt.printop_t.is_ti_initialized (method)
    is_ti_initialized(self) -> bool

ida_nalt.printop_t.set_aflags_initialized (method)
    set_aflags_initialized(self, v=True)
    
    @param v: bool

ida_nalt.printop_t.set_ti_initialized (method)
    set_ti_initialized(self, v=True)
    
    @param v: bool

ida_nalt.refinfo_t (class)
    Proxy of C++ refinfo_t class.

ida_nalt.refinfo_t.__init__ (method)
    __init__(self) -> refinfo_t

ida_nalt.refinfo_t.base (variable)
    base of reference (may be BADADDR)

ida_nalt.refinfo_t.flags (variable)
    Reference info flags

ida_nalt.refinfo_t.init (method)
    init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
    
    @param reft_and_flags: uint32
    @param _base: ea_t
    @param _target: ea_t
    @param _tdelta: adiff_t

ida_nalt.refinfo_t.is_custom (method)
    is_custom(self) -> bool

ida_nalt.refinfo_t.is_no_ones (method)
    is_no_ones(self) -> bool

ida_nalt.refinfo_t.is_no_zeros (method)
    is_no_zeros(self) -> bool

ida_nalt.refinfo_t.is_pastend (method)
    is_pastend(self) -> bool

ida_nalt.refinfo_t.is_rvaoff (method)
    is_rvaoff(self) -> bool

ida_nalt.refinfo_t.is_selfref (method)
    is_selfref(self) -> bool

ida_nalt.refinfo_t.is_signed (method)
    is_signed(self) -> bool

ida_nalt.refinfo_t.is_subtract (method)
    is_subtract(self) -> bool

ida_nalt.refinfo_t.is_target_optional (method)
    is_target_optional(self) -> bool
    < is_reftype_target_optional()

ida_nalt.refinfo_t.no_base_xref (method)
    no_base_xref(self) -> bool

ida_nalt.refinfo_t.set_type (method)
    set_type(self, rt)
    
    @param rt: reftype_t

ida_nalt.refinfo_t.target (variable)
    reference target (BADADDR-none)

ida_nalt.refinfo_t.tdelta (variable)
    offset from the target

ida_nalt.refinfo_t.type (method)
    type(self) -> reftype_t

ida_nalt.rename_encoding (function)
    rename_encoding(idx, encname) -> bool
    Change name for an encoding The number of bytes per unit (BPU) of the new
    encoding must match this number of the existing default encoding. Specifying the
    empty name simply deletes this encoding.
    
    @param idx: (C++: int) the encoding index (1-based)
    @param encname: (C++: const char *) the new encoding name

ida_nalt.retrieve_input_file_crc32 (function)
    retrieve_input_file_crc32() -> uint32
    Get input file crc32 stored in the database. it can be used to check that the
    input file has not been changed.

ida_nalt.retrieve_input_file_md5 (function)
    retrieve_input_file_md5() -> bytes
    Get input file md5.

ida_nalt.retrieve_input_file_sha256 (function)
    retrieve_input_file_sha256() -> bytes
    Get input file sha256.

ida_nalt.retrieve_input_file_size (function)
    retrieve_input_file_size() -> size_t
    Get size of input file in bytes.

ida_nalt.set__bnot0 (function)
    set__bnot0(ea)
    
    @param ea: ea_t

ida_nalt.set__bnot1 (function)
    set__bnot1(ea)
    
    @param ea: ea_t

ida_nalt.set__invsign0 (function)
    set__invsign0(ea)
    
    @param ea: ea_t

ida_nalt.set__invsign1 (function)
    set__invsign1(ea)
    
    @param ea: ea_t

ida_nalt.set_abits (function)
    set_abits(ea, bits)
    
    @param ea: ea_t
    @param bits: aflags_t

ida_nalt.set_absbase (function)
    set_absbase(ea, x)
    
    @param ea: ea_t
    @param x: ea_t

ida_nalt.set_aflags (function)
    set_aflags(ea, flags)
    
    @param ea: ea_t
    @param flags: aflags_t

ida_nalt.set_align_flow (function)
    set_align_flow(ea)
    
    @param ea: ea_t

ida_nalt.set_alignment (function)
    set_alignment(ea, x)
    
    @param ea: ea_t
    @param x: uint32

ida_nalt.set_archive_path (function)
    set_archive_path(file) -> bool
    Set archive file path from which input file was extracted.
    
    @param file: (C++: const char *) char const *

ida_nalt.set_array_parameters (function)
    set_array_parameters(ea, _in)
    
    @param ea: ea_t
    @param in: array_parameters_t const *

ida_nalt.set_asm_inc_file (function)
    set_asm_inc_file(file) -> bool
    Set name of the include file.
    
    @param file: (C++: const char *) char const *

ida_nalt.set_colored_item (function)
    set_colored_item(ea)
    
    @param ea: ea_t

ida_nalt.set_custom_data_type_ids (function)
    set_custom_data_type_ids(ea, cdis)
    
    @param ea: ea_t
    @param cdis: custom_data_type_ids_t const *

ida_nalt.set_data_guessed_by_hexrays (function)
    set_data_guessed_by_hexrays(ea)
    
    @param ea: ea_t

ida_nalt.set_default_encoding_idx (function)
    set_default_encoding_idx(bpu, idx) -> bool
    Set default encoding for a string type
    
    @param bpu: (C++: int) the amount of bytes per unit
    @param idx: (C++: int) the encoding index. It cannot be 0

ida_nalt.set_fixed_spd (function)
    set_fixed_spd(ea)
    
    @param ea: ea_t

ida_nalt.set_func_guessed_by_hexrays (function)
    set_func_guessed_by_hexrays(ea)
    
    @param ea: ea_t

ida_nalt.set_gotea (function)
    set_gotea(gotea)
    
    @param gotea: ea_t

ida_nalt.set_has_lname (function)
    set_has_lname(ea)
    
    @param ea: ea_t

ida_nalt.set_has_ti (function)
    set_has_ti(ea)
    
    @param ea: ea_t

ida_nalt.set_has_ti0 (function)
    set_has_ti0(ea)
    
    @param ea: ea_t

ida_nalt.set_has_ti1 (function)
    set_has_ti1(ea)
    
    @param ea: ea_t

ida_nalt.set_ida_notepad_text (function)
    set_ida_notepad_text(text, size=0)
    Set notepad text.
    
    @param text: (C++: const char *) char const *
    @param size: (C++: size_t)

ida_nalt.set_ids_modnode (function)
    set_ids_modnode(id)
    Set ids modnode.
    
    @param id: (C++: netnode)

ida_nalt.set_imagebase (function)
    set_imagebase(base)
    Set image base address.
    
    @param base: (C++: ea_t)

ida_nalt.set_item_color (function)
    set_item_color(ea, color)
    
    @param ea: ea_t
    @param color: bgcolor_t

ida_nalt.set_libitem (function)
    set_libitem(ea)
    
    @param ea: ea_t

ida_nalt.set_loader_format_name (function)
    set_loader_format_name(name)
    Set file format name for loader modules.
    
    @param name: (C++: const char *) char const *

ida_nalt.set_lzero0 (function)
    set_lzero0(ea)
    
    @param ea: ea_t

ida_nalt.set_lzero1 (function)
    set_lzero1(ea)
    
    @param ea: ea_t

ida_nalt.set_noret (function)
    set_noret(ea)
    
    @param ea: ea_t

ida_nalt.set_notcode (function)
    set_notcode(ea)
    Mark address so that it cannot be converted to instruction.
    
    @param ea: (C++: ea_t)

ida_nalt.set_notproc (function)
    set_notproc(ea)
    
    @param ea: ea_t

ida_nalt.set_op_tinfo (function)
    set_op_tinfo(ea, n, tif) -> bool
    
    @param ea: ea_t
    @param n: int
    @param tif: tinfo_t const *

ida_nalt.set_outfile_encoding_idx (function)
    set_outfile_encoding_idx(idx) -> bool
    set encoding to be used when producing files
    
    @param idx: (C++: int) the encoding index IDX can be 0 to use the IDB's default 1-byte-per-
                unit encoding

ida_nalt.set_refinfo (function)
    set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
    
    @param ea: ea_t
    @param n: int
    @param type: reftype_t
    @param target: ea_t
    @param base: ea_t
    @param tdelta: adiff_t

ida_nalt.set_refinfo_ex (function)
    set_refinfo_ex(ea, n, ri) -> bool
    
    @param ea: ea_t
    @param n: int
    @param ri: refinfo_t const *

ida_nalt.set_retfp (function)
    set_retfp(ea)
    
    @param ea: ea_t

ida_nalt.set_root_filename (function)
    set_root_filename(file)
    Set full path of the input file.
    
    @param file: (C++: const char *) char const *

ida_nalt.set_source_linnum (function)
    set_source_linnum(ea, lnnum)
    
    @param ea: ea_t
    @param lnnum: uval_t

ida_nalt.set_srcdbg_paths (function)
    set_srcdbg_paths(paths)
    Set source debug paths.
    
    @param paths: (C++: const char *) char const *

ida_nalt.set_srcdbg_undesired_paths (function)
    set_srcdbg_undesired_paths(paths)
    Set user-closed source files.
    
    @param paths: (C++: const char *) char const *

ida_nalt.set_str_encoding_idx (function)
    set_str_encoding_idx(strtype, encoding_idx) -> int32
    Set index of the string encoding in the string type.
    
    @param strtype: (C++: int32)
    @param encoding_idx: (C++: int)

ida_nalt.set_str_type (function)
    set_str_type(ea, x)
    
    @param ea: ea_t
    @param x: uint32

ida_nalt.set_switch_info (function)
    set_switch_info(ea, _in)
    
    @param ea: ea_t
    @param in: switch_info_t const &

ida_nalt.set_switch_parent (function)
    set_switch_parent(ea, x)
    
    @param ea: ea_t
    @param x: ea_t

ida_nalt.set_terse_struc (function)
    set_terse_struc(ea)
    
    @param ea: ea_t

ida_nalt.set_tilcmt (function)
    set_tilcmt(ea)
    
    @param ea: ea_t

ida_nalt.set_tinfo (function)
    set_tinfo(ea, tif) -> bool
    
    @param ea: ea_t
    @param tif: tinfo_t const *

ida_nalt.set_type_determined_by_hexrays (function)
    set_type_determined_by_hexrays(ea)
    
    @param ea: ea_t

ida_nalt.set_type_guessed_by_ida (function)
    set_type_guessed_by_ida(ea)
    
    @param ea: ea_t

ida_nalt.set_usemodsp (function)
    set_usemodsp(ea)
    
    @param ea: ea_t

ida_nalt.set_usersp (function)
    set_usersp(ea)
    
    @param ea: ea_t

ida_nalt.set_userti (function)
    set_userti(ea)
    
    @param ea: ea_t

ida_nalt.set_visible_item (function)
    set_visible_item(ea, visible)
    Change visibility of item at given ea.
    
    @param ea: (C++: ea_t)
    @param visible: (C++: bool)

ida_nalt.set_zstroff (function)
    set_zstroff(ea)
    
    @param ea: ea_t

ida_nalt.strpath_ids_array (class)
    Proxy of C++ wrapped_array_t< tid_t,32 > class.

ida_nalt.strpath_ids_array.__getitem__ (method)
    __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
    
    @param i: size_t

ida_nalt.strpath_ids_array.__init__ (method)
    __init__(self, data) -> strpath_ids_array
    
    @param data: unsigned-ea-like-numeric-type (&)[32]

ida_nalt.strpath_ids_array.__len__ (method)
    __len__(self) -> size_t

ida_nalt.strpath_ids_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned-ea-like-numeric-type const &

ida_nalt.strpath_ids_array._get_bytes (method)
    _get_bytes(self) -> bytevec_t

ida_nalt.strpath_ids_array._set_bytes (method)
    _set_bytes(self, bts)
    
    Parameters
    ----------
    bts: bytevec_t const &

ida_nalt.strpath_t (class)
    Proxy of C++ strpath_t class.

ida_nalt.strpath_t.__getIds (method)
    __getIds(self) -> strpath_ids_array

ida_nalt.strpath_t.__init__ (method)
    __init__(self) -> strpath_t

ida_nalt.switch_info_t (class)
    Proxy of C++ switch_info_t class.

ida_nalt.switch_info_t.__init__ (method)
    __init__(self) -> switch_info_t

ida_nalt.switch_info_t._get_values_lowcase (method)
    _get_values_lowcase(self) -> ea_t

ida_nalt.switch_info_t._set_values_lowcase (method)
    _set_values_lowcase(self, values)
    
    Parameters
    ----------
    values: ea_t

ida_nalt.switch_info_t.assign (method)
    assign(self, other)
    
    @param other: switch_info_t const &

ida_nalt.switch_info_t.clear (method)
    clear(self)

ida_nalt.switch_info_t.custom (variable)
    information for custom tables (filled and used by modules)

ida_nalt.switch_info_t.defjump (variable)
    default jump address (BADADDR if no default case)

ida_nalt.switch_info_t.elbase (variable)
    element base

ida_nalt.switch_info_t.expr_ea (variable)
    the address before that the switch expression is in REGNUM. If BADADDR, then the
    first insn marked as IM_SWITCH after STARTEA is used.

ida_nalt.switch_info_t.flags (variable)
    Switch info flags

ida_nalt.switch_info_t.get_jrange_vrange (method)
    get_jrange_vrange(self, jrange=None, vrange=None) -> bool
    get separate parts of the switch
    
    @param jrange: (C++: range_t *)
    @param vrange: (C++: range_t *)

ida_nalt.switch_info_t.get_jtable_element_size (method)
    get_jtable_element_size(self) -> int

ida_nalt.switch_info_t.get_jtable_size (method)
    get_jtable_size(self) -> int

ida_nalt.switch_info_t.get_lowcase (method)
    get_lowcase(self) -> sval_t

ida_nalt.switch_info_t.get_shift (method)
    get_shift(self) -> int
    See SWI_SHIFT_MASK. possible answers: 0..3.

ida_nalt.switch_info_t.get_version (method)
    get_version(self) -> int

ida_nalt.switch_info_t.get_vtable_element_size (method)
    get_vtable_element_size(self) -> int

ida_nalt.switch_info_t.has_default (method)
    has_default(self) -> bool

ida_nalt.switch_info_t.has_elbase (method)
    has_elbase(self) -> bool

ida_nalt.switch_info_t.is_custom (method)
    is_custom(self) -> bool

ida_nalt.switch_info_t.is_indirect (method)
    is_indirect(self) -> bool

ida_nalt.switch_info_t.is_nolowcase (method)
    is_nolowcase(self) -> bool

ida_nalt.switch_info_t.is_sparse (method)
    is_sparse(self) -> bool

ida_nalt.switch_info_t.is_subtract (method)
    is_subtract(self) -> bool

ida_nalt.switch_info_t.is_user_defined (method)
    is_user_defined(self) -> bool

ida_nalt.switch_info_t.jcases (variable)
    number of entries in the jump table (SWI_INDIRECT)

ida_nalt.switch_info_t.jumps (variable)
    jump table start address

ida_nalt.switch_info_t.lowcase (variable)
    the lowest value in cases

ida_nalt.switch_info_t.marks (variable)
    the insns marked as IM_SWITCH. They are used to delete the switch.

ida_nalt.switch_info_t.ncases (variable)
    number of cases (excluding default)

ida_nalt.switch_info_t.regdtype (variable)
    size of the switch expression register as dtype

ida_nalt.switch_info_t.regnum (variable)
    the switch expression as a value of the REGNUM register before the instruction
    at EXPR_EA. -1 means 'unknown'

ida_nalt.switch_info_t.set_elbase (method)
    set_elbase(self, base)
    
    @param base: ea_t

ida_nalt.switch_info_t.set_expr (method)
    set_expr(self, r, dt)
    
    @param r: int
    @param dt: op_dtype_t

ida_nalt.switch_info_t.set_jtable_element_size (method)
    set_jtable_element_size(self, size)
    
    @param size: int

ida_nalt.switch_info_t.set_jtable_size (method)
    set_jtable_size(self, size)
    
    @param size: int

ida_nalt.switch_info_t.set_shift (method)
    set_shift(self, shift)
    See SWI_SHIFT_MASK.
    
    @param shift: (C++: int)

ida_nalt.switch_info_t.set_vtable_element_size (method)
    set_vtable_element_size(self, size)
    
    @param size: int

ida_nalt.switch_info_t.startea (variable)
    start of the switch idiom

ida_nalt.switch_info_t.use_std_table (method)
    use_std_table(self) -> bool

ida_nalt.switch_info_t.values (variable)
    values table address (if SWI_SPARSE is set)

ida_nalt.switch_info_t__from_ptrval__ (function)
    switch_info_t__from_ptrval__(ptrval) -> switch_info_t
    
    @param ptrval: size_t

ida_nalt.unhide_border (function)
    unhide_border(ea)
    
    @param ea: ea_t

ida_nalt.unhide_item (function)
    unhide_item(ea)
    
    @param ea: ea_t

ida_nalt.upd_abits (function)
    upd_abits(ea, clr_bits, set_bits)
    
    @param ea: ea_t
    @param clr_bits: aflags_t
    @param set_bits: aflags_t

ida_nalt.uses_aflag_modsp (function)
    uses_aflag_modsp(flags) -> bool
    
    @param flags: aflags_t

ida_nalt.uses_modsp (function)
    uses_modsp(ea) -> bool
    
    @param ea: ea_t

ida_nalt.validate_idb_names (function)
    validate_idb_names(do_repair) -> int
    
    @param do_repair: bool

ida_name (module)
    Functions that deal with names.
    
    A non-tail address of the program may have a name. Tail addresses (i.e. the
    addresses in the middle of an instruction or data item) cannot have names.

ida_name.DEBNAME_EXACT (variable)
    find a name at exactly the specified address

ida_name.DEBNAME_LOWER (variable)
    find a name with the address >= the specified address

ida_name.DEBNAME_NICE (variable)
    find a name with the address <= the specified address

ida_name.DEBNAME_UPPER (variable)
    find a name with the address > the specified address

ida_name.FUNC_IMPORT_PREFIX (variable)
    Name prefix used by IDA for the imported functions.

ida_name.GETN_APPZERO (variable)
    meaningful only if the name refers to a structure. append a struct field name if
    the field offset is zero?

ida_name.GETN_NODUMMY (variable)
    do not create a new dummy name but pretend it exists

ida_name.GETN_NOFIXUP (variable)
    ignore the fixup information when producing the name

ida_name.GNCN_NOCOLOR (variable)
    generate an uncolored name

ida_name.GNCN_NODBGNM (variable)
    don't use debug names

ida_name.GNCN_NOFUNC (variable)
    don't generate funcname+... expressions

ida_name.GNCN_NOLABEL (variable)
    don't generate labels

ida_name.GNCN_NOSEG (variable)
    ignore the segment prefix when producing the name

ida_name.GNCN_PREFDBG (variable)
    if using debug names, prefer debug names over function names

ida_name.GNCN_REQFUNC (variable)
    return 0 if the address does not belong to a function

ida_name.GNCN_REQNAME (variable)
    return 0 if the address can only be represented as a hex number

ida_name.GNCN_SEGNUM (variable)
    segment part is displayed as a hex number

ida_name.GNCN_SEG_FUNC (variable)
    generate both segment and function names (default is to omit segment name if a
    function name is present)

ida_name.GN_COLORED (variable)
    return colored name

ida_name.GN_DEMANGLED (variable)
    return demangled name

ida_name.GN_ISRET (variable)
    for dummy names: use retloc

ida_name.GN_LOCAL (variable)
    try to get local name first; if failed, get global

ida_name.GN_LONG (variable)
    use long form of demangled name

ida_name.GN_NOT_DUMMY (variable)
    do not return a dummy name

ida_name.GN_NOT_ISRET (variable)
    for dummy names: do not use retloc

ida_name.GN_SHORT (variable)
    use short form of demangled name

ida_name.GN_STRICT (variable)
    fail if cannot demangle

ida_name.GN_VISIBLE (variable)
    replace forbidden characters by SUBSTCHAR

ida_name.MAXNAMELEN (variable)
    Maximum length of a name in IDA (with the trailing zero)

ida_name.NT_ABS (variable)
    name is absolute symbol (SEG_ABSSYM)

ida_name.NT_BMASK (variable)
    name is a bit group mask name

ida_name.NT_BYTE (variable)
    name is byte name (regular name)

ida_name.NT_ENUM (variable)
    name is symbolic constant

ida_name.NT_LOCAL (variable)
    name is local label

ida_name.NT_NONE (variable)
    name doesn't exist or has no value

ida_name.NT_REGVAR (variable)
    name is a renamed register (*value is idx into pfn->regvars)

ida_name.NT_SEG (variable)
    name is segment or segment register name

ida_name.NT_STKVAR (variable)
    name is stack variable name

ida_name.NT_STROFF (variable)
    name is structure member

ida_name.NearestName (class)
    Utility class to help find the nearest name in a given ea/name dictionary

ida_name.NearestName.__getitem__ (method)
    Returns the tupple (ea, name, index)

ida_name.NearestName.__init__ (method)

ida_name.NearestName.__iter__ (method)

ida_name.NearestName._get_item (method)

ida_name.NearestName.find (method)
    Returns a tupple (ea, name, pos) that is the nearest to the passed ea
    If no name is matched then None is returned

ida_name.NearestName.update (method)
    Updates the ea/names map

ida_name.SN_AUTO (variable)
    if set, make name autogenerated

ida_name.SN_CHECK (variable)
    Fail if the name contains invalid characters.

ida_name.SN_DELTAIL (variable)
    if name cannot be set because of a tail byte, delete the hindering item

ida_name.SN_FORCE (variable)
    if the specified name is already present in the database, try variations with a
    numerical suffix like "_123"

ida_name.SN_IDBENC (variable)
    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly. Specifying SN_IDBENC also implies SN_NODUMMY

ida_name.SN_LOCAL (variable)
    create local name. a function should exist. local names can't be public or weak.
    also they are not included into the list of names they can't have dummy
    prefixes.

ida_name.SN_NOCHECK (variable)
    Replace invalid characters silently. If this bit is set, all invalid chars (not
    in NameChars or MangleChars) will be replaced by '_' List of valid characters is
    defined in ida.cfg

ida_name.SN_NODUMMY (variable)
    automatically prepend the name with '_' if it begins with a dummy suffix such as
    'sub_'. See also SN_IDBENC

ida_name.SN_NOLIST (variable)
    if set, exclude name from the list. if not set, then include the name into the
    list (however, if other bits are set, the name might be immediately excluded
    from the list).

ida_name.SN_NON_AUTO (variable)
    if set, make name non-autogenerated

ida_name.SN_NON_PUBLIC (variable)
    if set, make name non-public

ida_name.SN_NON_WEAK (variable)
    if set, make name non-weak

ida_name.SN_NOWARN (variable)
    don't display a warning if failed

ida_name.SN_PUBLIC (variable)
    if set, make name public

ida_name.SN_WEAK (variable)
    if set, make name weak

ida_name.append_struct_fields (function)
    append_struct_fields(disp, n, path, flags, delta, appzero) -> str
    Append names of struct fields to a name if the name is a struct name.
    
    @param disp: (C++: adiff_t *) displacement from the name
    @param n: (C++: int) operand number in which the name appears
    @param path: (C++: const tid_t *) path in the struct. path is an array of id's. maximal length of
                 array is MAXSTRUCPATH. the first element of the array is the
                 structure id. consecutive elements are id's of used union members
                 (if any).
    @param flags: (C++: flags64_t) the input flags. they will be returned if the struct cannot be
                  found.
    @param delta: (C++: adiff_t) delta to add to displacement
    @param appzero: (C++: bool) should append a struct field name if the displacement is zero?
    @return: flags of the innermost struct member or the input flags

ida_name.calc_gtn_flags (function)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

ida_name.cleanup_name (function)
    cleanup_name(ea, name, flags=0) -> str
    
    @param ea: ea_t
    @param name: char const *
    @param flags: uint32

ida_name.del_debug_names (function)
    del_debug_names(ea1, ea2)
    
    @param ea1: ea_t
    @param ea2: ea_t

ida_name.del_global_name (function)
    del_global_name(ea) -> bool
    
    @param ea: ea_t

ida_name.del_local_name (function)
    del_local_name(ea) -> bool
    
    @param ea: ea_t

ida_name.demangle_name (function)
    demangle_name(name, disable_mask, demreq=DQT_FULL) -> str
    Demangle a name.
    
    @param name: (C++: const char *) char const *
    @param disable_mask: (C++: uint32)
    @param demreq: (C++: demreq_type_t) enum demreq_type_t

ida_name.ea_name_t (class)
    Proxy of C++ ea_name_t class.

ida_name.ea_name_t.__init__ (method)
    __init__(self) -> ea_name_t
    __init__(self, _ea, _name) -> ea_name_t
    
    @param _ea: ea_t
    @param _name: qstring const &

ida_name.ea_name_vec_t (class)
    Proxy of C++ qvector< ea_name_t > class.

ida_name.ea_name_vec_t.__getitem__ (method)
    __getitem__(self, i) -> ea_name_t
    
    @param i: size_t

ida_name.ea_name_vec_t.__init__ (method)
    __init__(self) -> ea_name_vec_t
    __init__(self, x) -> ea_name_vec_t
    
    @param x: qvector< ea_name_t > const &

ida_name.ea_name_vec_t.__len__ (method)
    __len__(self) -> size_t

ida_name.ea_name_vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: ea_name_t const &

ida_name.ea_name_vec_t.at (method)
    at(self, _idx) -> ea_name_t
    
    @param _idx: size_t

ida_name.ea_name_vec_t.begin (method)
    begin(self) -> ea_name_t

ida_name.ea_name_vec_t.capacity (method)
    capacity(self) -> size_t

ida_name.ea_name_vec_t.clear (method)
    clear(self)

ida_name.ea_name_vec_t.empty (method)
    empty(self) -> bool

ida_name.ea_name_vec_t.end (method)
    end(self) -> ea_name_t

ida_name.ea_name_vec_t.erase (method)
    erase(self, it) -> ea_name_t
    
    @param it: qvector< ea_name_t >::iterator
    
    erase(self, first, last) -> ea_name_t
    
    @param first: qvector< ea_name_t >::iterator
    @param last: qvector< ea_name_t >::iterator

ida_name.ea_name_vec_t.extract (method)
    extract(self) -> ea_name_t

ida_name.ea_name_vec_t.grow (method)
    grow(self, x=ea_name_t())
    
    @param x: ea_name_t const &

ida_name.ea_name_vec_t.inject (method)
    inject(self, s, len)
    
    @param s: ea_name_t *
    @param len: size_t

ida_name.ea_name_vec_t.insert (method)
    insert(self, it, x) -> ea_name_t
    
    @param it: qvector< ea_name_t >::iterator
    @param x: ea_name_t const &

ida_name.ea_name_vec_t.pop_back (method)
    pop_back(self)

ida_name.ea_name_vec_t.push_back (method)
    push_back(self, x)
    
    @param x: ea_name_t const &
    
    push_back(self) -> ea_name_t

ida_name.ea_name_vec_t.qclear (method)
    qclear(self)

ida_name.ea_name_vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_name.ea_name_vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: ea_name_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_name.ea_name_vec_t.size (method)
    size(self) -> size_t

ida_name.ea_name_vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< ea_name_t > &

ida_name.ea_name_vec_t.truncate (method)
    truncate(self)

ida_name.extract_name (function)
    extract_name(line, x) -> str
    Extract a name or address from the specified string.
    
    @param line: (C++: const char *) input string
    @param x: (C++: int) x coordinate of cursor
    @return: -1 if cannot extract. otherwise length of the name

ida_name.force_name (function)
    force_name(ea, name, flags=0) -> bool
    
    @param ea: ea_t
    @param name: char const *
    @param flags: int

ida_name.get_colored_demangled_name (function)
    get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param inhibitor: int32
    @param demform: int
    @param gtn_flags: int

ida_name.get_colored_long_name (function)
    get_colored_long_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

ida_name.get_colored_name (function)
    get_colored_name(ea) -> qstring
    
    @param ea: ea_t

ida_name.get_colored_short_name (function)
    get_colored_short_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

ida_name.get_cp_validity (function)
    get_cp_validity(kind, cp, endcp=wchar32_t(-1)) -> bool
    Is the given codepoint (or range) acceptable in the given context? If 'endcp' is
    not BADCP, it is considered to be the end of the range: [cp, endcp), and is not
    included in the range
    
    @param kind: (C++: ucdr_kind_t) enum ucdr_kind_t
    @param cp: (C++: wchar32_t)
    @param endcp: (C++: wchar32_t)

ida_name.get_debug_name (function)
    get_debug_name(ea_ptr, how) -> str
    
    @param ea_ptr: ea_t *
    @param how: enum debug_name_how_t

ida_name.get_debug_name_ea (function)
    get_debug_name_ea(name) -> ea_t
    
    @param name: char const *

ida_name.get_debug_names (function)
    get_debug_names(names, ea1, ea2)
    
    @param names: ea_name_vec_t *
    @param ea1: ea_t
    @param ea2: ea_t
    
    get_debug_names(ea1, ea2, return_list=False) -> dict or None
    
    @param ea1: ea_t
    @param ea2: ea_t
    @param return_list: bool

ida_name.get_demangled_name (function)
    get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param inhibitor: int32
    @param demform: int
    @param gtn_flags: int

ida_name.get_ea_name (function)
    get_ea_name(ea, gtn_flags=0) -> qstring
    Get name at the specified address.
    
    @param ea: (C++: ea_t) linear address
    @param gtn_flags: (C++: int) how exactly the name should be retrieved. combination of bits
                      for get_ea_name() function. There is a convenience bits
    @return: success

ida_name.get_long_name (function)
    get_long_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

ida_name.get_mangled_name_type (function)
    get_mangled_name_type(name) -> mangled_name_type_t
    
    @param name: char const *

ida_name.get_name (function)
    get_name(ea) -> qstring
    
    @param ea: ea_t

ida_name.get_name_base_ea (function)
    get_name_base_ea(_from, to) -> ea_t
    Get address of the name used in the expression for the address
    
    @param from: (C++: ea_t) address of the operand which references to the address
    @param to: (C++: ea_t) the referenced address
    @return: address of the name used to represent the operand

ida_name.get_name_color (function)
    get_name_color(_from, ea) -> color_t
    Calculate flags for get_ea_name() function.
    
    Get name color.
    
    @param from: (C++: ea_t) linear address where the name is used. if not applicable, then
                 should be BADADDR. The kernel returns a local name color if the
                 reference is within a function, i.e. 'from' and 'ea' belong to the
                 same function.
    @param ea: (C++: ea_t) linear address

ida_name.get_name_ea (function)
    get_name_ea(_from, name) -> ea_t
    Get the address of a name. This function resolves a name into an address. It can
    handle regular global and local names, as well as debugger names.
    
    @param from: (C++: ea_t) linear address where the name is used. If specified, the local
                 labels of the function at the specified address will will be
                 checked. BADADDR means that local names won't be consulted.
    @param name: (C++: const char *) any name in the program or nullptr
    @return: address of the name or BADADDR

ida_name.get_name_expr (function)
    get_name_expr(_from, n, ea, off, flags=0x0001) -> str
    Convert address to name expression (name with a displacement). This function
    takes into account fixup information and returns a colored name expression (in
    the form <name> +/- <offset>). It also knows about structure members and arrays.
    If the specified address doesn't have a name, a dummy name is generated.
    
    @param from: (C++: ea_t) linear address of instruction operand or data referring to the
                 name. This address will be used to get fixup information, so it
                 should point to exact position of the operand in the instruction.
    @param n: (C++: int) number of referencing operand. for data items specify 0
    @param ea: (C++: ea_t) address to convert to name expression
    @param off: (C++: uval_t) the value of name expression. this parameter is used only to check
                that the name expression will have the wanted value. 'off' may be
                equal to BADADDR but this is discouraged because it prohibits
                checks.
    @param flags: (C++: int) Name expression flags
    @return: < 0 if address is not valid, no segment or other failure. otherwise the
             length of the name expression in characters.

ida_name.get_name_value (function)
    get_name_value(_from, name) -> int
    Get value of the name. This function knows about: regular names, enums, special
    segments, etc.
    
    @param from: (C++: ea_t) linear address where the name is used if not applicable, then
                 should be BADADDR
    @param name: (C++: const char *) any name in the program or nullptr
    @return: Name value result codes

ida_name.get_nice_colored_name (function)
    get_nice_colored_name(ea, flags=0) -> str
    Get a nice colored name at the specified address. Ex:
    * segment:sub+offset
    * segment:sub:local_label
    * segment:label
    * segment:address
    * segment:address+offset
    
    @param ea: (C++: ea_t) linear address
    @param flags: (C++: int) Nice colored name flags
    @return: the length of the generated name in bytes.

ida_name.get_nlist_ea (function)
    get_nlist_ea(idx) -> ea_t
    Get address from the list at 'idx'.
    
    @param idx: (C++: size_t)

ida_name.get_nlist_idx (function)
    get_nlist_idx(ea) -> size_t
    Get index of the name in the list
    @warning: returns the closest match. may return idx >= size.
    
    @param ea: (C++: ea_t)

ida_name.get_nlist_name (function)
    get_nlist_name(idx) -> char const *
    Get name using idx.
    
    @param idx: (C++: size_t)

ida_name.get_nlist_size (function)
    get_nlist_size() -> size_t
    Get number of names in the list.

ida_name.get_short_name (function)
    get_short_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

ida_name.get_visible_name (function)
    get_visible_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

ida_name.hide_name (function)
    hide_name(ea)
    Remove name from the list of names
    
    @param ea: (C++: ea_t) address of the name

ida_name.is_ident (function)
    is_ident(name) -> bool
    Is a valid name? (including ::MangleChars)
    
    @param name: (C++: const char *) char const *

ida_name.is_ident_cp (function)
    is_ident_cp(cp) -> bool
    Can a character appear in a name? (present in ::NameChars or ::MangleChars)
    
    @param cp: (C++: wchar32_t)

ida_name.is_in_nlist (function)
    is_in_nlist(ea) -> bool
    Is the name included into the name list?
    
    @param ea: (C++: ea_t)

ida_name.is_name_defined_locally (function)
    is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
    Is the name defined locally in the specified function?
    
    @param pfn: (C++: func_t *) pointer to function
    @param name: (C++: const char *) name to check
    @param ignore_name_def: (C++: ignore_name_def_t) which names to ignore when checking
    @param ea1: (C++: ea_t) the starting address of the range inside the function (optional)
    @param ea2: (C++: ea_t) the ending address of the range inside the function (optional)
    @return: true if the name has been defined

ida_name.is_public_name (function)
    is_public_name(ea) -> bool
    
    @param ea: ea_t

ida_name.is_strlit_cp (function)
    is_strlit_cp(cp, specific_ranges=None) -> bool
    Can a character appear in a string literal (present in ::StrlitChars) If
    'specific_ranges' are specified, those will be used instead of the ones
    corresponding to the current culture (only if ::StrlitChars is configured to use
    the current culture)
    
    @param cp: (C++: wchar32_t)
    @param specific_ranges: (C++: const rangeset_crefvec_t *) rangeset_crefvec_t const *

ida_name.is_uname (function)
    is_uname(name) -> bool
    Is valid user-specified name? (valid name & !dummy prefix).
    
    @param name: (C++: const char *) name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

ida_name.is_valid_cp (function)
    is_valid_cp(cp, kind, data=None) -> bool
    Is the given codepoint acceptable in the given context?
    
    @param cp: (C++: wchar32_t)
    @param kind: (C++: nametype_t) enum nametype_t
    @param data: (C++: void *)

ida_name.is_valid_name (function)
    is_valid_name(name, cpuregs_permitted) -> bool
    
    @param name: char const *
    @param cpuregs_permitted: bool

ida_name.is_valid_typename (function)
    is_valid_typename(name) -> bool
    Is valid type name?
    
    @param name: (C++: const char *) name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

ida_name.is_visible_cp (function)
    is_visible_cp(cp) -> bool
    Can a character be displayed in a name? (present in ::NameChars)
    
    @param cp: (C++: wchar32_t)

ida_name.is_weak_name (function)
    is_weak_name(ea) -> bool
    
    @param ea: ea_t

ida_name.make_name_auto (function)
    make_name_auto(ea) -> bool
    
    @param ea: ea_t

ida_name.make_name_non_public (function)
    make_name_non_public(ea)
    
    @param ea: ea_t

ida_name.make_name_non_weak (function)
    make_name_non_weak(ea)
    
    @param ea: ea_t

ida_name.make_name_public (function)
    make_name_public(ea)
    
    @param ea: ea_t

ida_name.make_name_user (function)
    make_name_user(ea) -> bool
    
    @param ea: ea_t

ida_name.make_name_weak (function)
    make_name_weak(ea)
    
    @param ea: ea_t

ida_name.rebuild_nlist (function)
    rebuild_nlist()
    Rebuild the name list.

ida_name.reorder_dummy_names (function)
    reorder_dummy_names()
    Renumber dummy names.

ida_name.set_cp_validity (function)
    set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
    Mark the given codepoint (or range) as acceptable or unacceptable in the given
    context If 'endcp' is not BADCP, it is considered to be the end of the range:
    [cp, endcp), and is not included in the range
    
    @param kind: (C++: ucdr_kind_t) enum ucdr_kind_t
    @param cp: (C++: wchar32_t)
    @param endcp: (C++: wchar32_t)

ida_name.set_debug_name (function)
    set_debug_name(ea, name) -> bool
    
    @param ea: ea_t
    @param name: char const *

ida_name.set_dummy_name (function)
    set_dummy_name(_from, ea) -> bool
    Give an autogenerated (dummy) name. Autogenerated names have special prefixes
    (loc_...).
    
    @param from: (C++: ea_t) linear address of the operand which references to the address
    @param ea: (C++: ea_t) linear address
    @retval 1: ok, dummy name is generated or the byte already had a name
    @retval 0: failure, invalid address or tail byte

ida_name.set_name (function)
    set_name(ea, name, flags=0) -> bool
    Set or delete name of an item at the specified address. An item can be anything:
    instruction, function, data byte, word, string, structure, etc... Include name
    into the list of names.
    
    @param ea: (C++: ea_t) linear address. do nothing if ea is not valid (return 0). tail bytes
               can't have names.
    @param name: (C++: const char *) new name.
    * nullptr: do nothing (return 0).
    * "" : delete name.
    * otherwise this is a new name.
    @param flags: (C++: int) Set name flags. If a bit is not specified, then the corresponding
                  action is not performed and the name will retain the same bits as
                  before calling this function. For new names, default is: non-
                  public, non-weak, non-auto.
    @retval 1: ok, name is changed
    @retval 0: failure, a warning is displayed

ida_name.show_name (function)
    show_name(ea)
    Insert name to the list of names.
    
    @param ea: (C++: ea_t)

ida_name.validate_name (function)
    validate_name(name, type, flags=0) -> PyObject *
    Validate a name. If SN_NOCHECK is specified, this function replaces all invalid
    characters in the name with SUBSTCHAR. However, it will return false if name is
    valid but not allowed to be an identifier (is a register name).
    
    @param name: (C++: qstring *) ptr to name. the name will be modified
    @param type: (C++: nametype_t) the type of name we want to validate
    @param flags: (C++: int) see SN_*
    @return: success

ida_netnode (module)
    Functions that provide the lowest level public interface to the database.
    Namely, we use Btree. To learn more about BTree:
    
    \link{https://en.wikipedia.org/wiki/B-tree}
    
    We do not use Btree directly. Instead, we have another layer built on the top of
    Btree. Here is a brief explanation of this layer.
    
    An object called "netnode" is modeled on the top of Btree. Each netnode has a
    unique id: a 32-bit value (64-bit for ida64). Initially there is a trivial
    mapping of the linear addresses used in the program to netnodes (later this
    mapping may be modified using ea2node and node2ea functions; this is used for
    fast database rebasings). If we have additional information about an address
    (for example, a comment is attached to it), this information is stored in the
    corresponding netnode. See nalt.hpp to see how the kernel uses netnodes. Also,
    some netnodes have no corresponding linear address (however, they still have an
    id). They are used to store information not related to a particular address.
    
    Each netnode _may_ have the following attributes:
    
    * a name: an arbitrary non-empty string, up to 255KB-1 bytes
    * a value: arbitrary sized object, max size is MAXSPECSIZE
    * altvals: a sparse array of 32-bit values. indexes in this array may be 8-bit
    or 32-bit values
    * supvals: an array of arbitrary sized objects. (size of each object is limited
    by MAXSPECSIZE) indexes in this array may be 8-bit or 32-bit values
    * charvals: a sparse array of 8-bit values. indexes in this array may be 8-bit
    or 32-bit values
    * hashvals: a hash (an associative array). indexes in this array are strings
    values are arbitrary sized (max size is MAXSPECSIZE)
    
    Initially a new netnode contains no information at all so no disk space is used
    for it. As you add new information, the netnode grows.
    
    All arrays that are attached to the netnode behave in the same manner.
    Initially:
    * all members of altvals/charvals array are zeroes
    * all members of supvals/hashvals array are undefined
    
    If you need to store objects bigger that MAXSPECSIZE, please note that there are
    high-level functions to store arbitrary sized objects in supvals. See
    setblob/getblob and other blob-related functions.
    
    You may use netnodes to store additional information about the program.
    Limitations on the use of netnodes are the following:
    
    * use netnodes only if you could not find a kernel service to store your type of
    information
    * do not create netnodes with valid identifier names. Use the "$ " prefix (or
    any other prefix with characters not allowed in the identifiers for the names of
    your netnodes. Although you will probably not destroy anything by accident,
    using already defined names for the names of your netnodes is still discouraged.
    * you may create as many netnodes as you want (creation of an unnamed netnode
    does not increase the size of the database). however, since each netnode has a
    number, creating too many netnodes could lead to the exhaustion of the netnode
    numbers (the numbering starts at 0xFF000000)
    * remember that netnodes are automatically saved to the disk by the kernel.
    
    Advanced info:
    
    In fact a netnode may contain up to 256 arrays of arbitrary sized objects (not
    only the 4 listed above). Each array has an 8-bit tag. Usually tags are
    represented by character constants. For example, altvals and supvals are simply
    2 of 256 arrays, with the tags 'A' and 'S' respectively.

ida_netnode.BADNODE (variable)
    A number to represent a bad netnode reference.

ida_netnode.MAXNAMESIZE (variable)
    Maximum length of a netnode name. WILL BE REMOVED IN THE FUTURE.

ida_netnode.MAXSPECSIZE (variable)
    Maximum length of strings or objects stored in a supval array element.

ida_netnode.MAX_NODENAME_SIZE (variable)
    Maximum length of a name. We permit names up to 32KB-1 bytes.

ida_netnode.atag (variable)
    Array of altvals.

ida_netnode.exist (function)
    exist(n) -> bool
    
    @param n: netnode const &

ida_netnode.htag (variable)
    Array of hashvals.

ida_netnode.ltag (variable)
    Links between netnodes.

ida_netnode.netnode (class)
    Proxy of C++ netnode class.

ida_netnode.netnode.__eq__ (method)
    __eq__(self, n) -> bool
    
    @param n: netnode &
    
    __eq__(self, x) -> bool
    
    @param x: nodeidx_t

ida_netnode.netnode.__init__ (method)
    __init__(self, num=nodeidx_t(-1)) -> netnode
    
    @param num: nodeidx_t
    
    __init__(self, _name, namlen=0, do_create=False) -> netnode
    
    @param _name: char const *
    @param namlen: size_t
    @param do_create: bool

ida_netnode.netnode.__ne__ (method)
    __ne__(self, n) -> bool
    
    @param n: netnode &
    
    __ne__(self, x) -> bool
    
    @param x: nodeidx_t

ida_netnode.netnode.altdel (method)
    altdel(self, alt, tag=atag) -> bool
    Delete all elements of altval array. This function may be applied to 32-bit and
    8-bit altval arrays. This function deletes the whole altval array.
    
    @param alt: nodeidx_t
    @param tag: uchar
    
    @return: success
    altdel(self) -> bool

ida_netnode.netnode.altdel_all (method)
    altdel_all(self, tag=atag) -> bool
    Delete all elements of the specified altval array. This function may be applied
    to 32-bit and 8-bit altval arrays. This function deletes the whole altval array.
    
    @param tag: (C++: uchar) tag of array
    @return: success

ida_netnode.netnode.altdel_ea (method)
    altdel_ea(self, ea, tag=atag) -> bool
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.altdel_idx8 (method)
    altdel_idx8(self, alt, tag) -> bool
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.altfirst (method)
    altfirst(self, tag=atag) -> nodeidx_t
    Get first existing element of altval array.
    
    @param tag: (C++: uchar) tag of array
    @return: index of first existing element of altval array, BADNODE if altval
             array is empty

ida_netnode.netnode.altfirst_idx8 (method)
    altfirst_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.altlast (method)
    altlast(self, tag=atag) -> nodeidx_t
    Get last element of altval array.
    
    @param tag: (C++: uchar) tag of array
    @return: index of last existing element of altval array, BADNODE if altval array
             is empty

ida_netnode.netnode.altlast_idx8 (method)
    altlast_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.altnext (method)
    altnext(self, cur, tag=atag) -> nodeidx_t
    Get next existing element of altval array.
    
    @param cur: (C++: nodeidx_t) current index
    @param tag: (C++: uchar) tag of array
    @return: index of the next existing element of altval array, BADNODE if no more
             altval array elements exist

ida_netnode.netnode.altnext_idx8 (method)
    altnext_idx8(self, cur, tag) -> nodeidx_t
    
    @param cur: uchar
    @param tag: uchar

ida_netnode.netnode.altprev (method)
    altprev(self, cur, tag=atag) -> nodeidx_t
    Get previous existing element of altval array.
    
    @param cur: (C++: nodeidx_t) current index
    @param tag: (C++: uchar) tag of array
    @return: index of the previous existing element of altval array, BADNODE if no
             more altval array elements exist

ida_netnode.netnode.altprev_idx8 (method)
    altprev_idx8(self, cur, tag) -> nodeidx_t
    
    @param cur: uchar
    @param tag: uchar

ida_netnode.netnode.altset (method)
    altset(self, alt, value, tag=atag) -> bool
    Set value of altval array.
    
    @param alt: (C++: nodeidx_t) index into array of altvals
    @param value: (C++: nodeidx_t) new value of altval element
    @param tag: (C++: uchar) tag of array
    @retval 1: ok
    @retval 0: failed, normally should not occur

ida_netnode.netnode.altset_ea (method)
    altset_ea(self, ea, value, tag=atag) -> bool
    
    @param ea: ea_t
    @param value: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.altset_idx8 (method)
    altset_idx8(self, alt, val, tag) -> bool
    
    @param alt: uchar
    @param val: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.altshift (method)
    altshift(self, _from, to, size, tag=atag) -> size_t
    Shift the altval array elements. Moves the array elements at (from..from+size)
    to (to..to+size)
    
    @param from: (C++: nodeidx_t)
    @param to: (C++: nodeidx_t)
    @param size: (C++: nodeidx_t)
    @param tag: (C++: uchar)
    @return: number of shifted elements

ida_netnode.netnode.altval (method)
    altval(self, alt, tag=atag) -> nodeidx_t
    Get altval element of the specified array.
    
    @param alt: (C++: nodeidx_t) index into array of altvals
    @param tag: (C++: uchar) tag of array. may be omitted
    @return: value of altval element. nonexistent altval members are returned as
             zeroes

ida_netnode.netnode.altval_ea (method)
    altval_ea(self, ea, tag=atag) -> nodeidx_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.altval_idx8 (method)
    altval_idx8(self, alt, tag) -> nodeidx_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.blobshift (method)
    blobshift(self, _from, to, size, tag) -> size_t
    Shift the blob array elements. Moves the array elements at (from..from+size) to
    (to..to+size)
    
    @param from: (C++: nodeidx_t)
    @param to: (C++: nodeidx_t)
    @param size: (C++: nodeidx_t)
    @param tag: (C++: uchar)
    @return: number of shifted elements

ida_netnode.netnode.blobsize (method)
    blobsize(self, _start, tag) -> size_t
    Get size of blob.
    
    @param _start: (C++: nodeidx_t) index of the first supval element used to store blob
    @param tag: (C++: uchar) tag of supval array
    @return: number of bytes required to store a blob

ida_netnode.netnode.blobsize_ea (method)
    blobsize_ea(self, ea, tag) -> size_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.chardel (method)
    chardel(self, alt, tag) -> bool
    
    @param alt: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.chardel_ea (method)
    chardel_ea(self, ea, tag) -> bool
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.chardel_idx8 (method)
    chardel_idx8(self, alt, tag) -> bool
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.charfirst (method)
    charfirst(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.charfirst_idx8 (method)
    charfirst_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.charlast (method)
    charlast(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.charlast_idx8 (method)
    charlast_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.charnext (method)
    charnext(self, cur, tag) -> nodeidx_t
    
    @param cur: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.charnext_idx8 (method)
    charnext_idx8(self, cur, tag) -> nodeidx_t
    
    @param cur: uchar
    @param tag: uchar

ida_netnode.netnode.charprev (method)
    charprev(self, cur, tag) -> nodeidx_t
    
    @param cur: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.charprev_idx8 (method)
    charprev_idx8(self, cur, tag) -> nodeidx_t
    
    @param cur: uchar
    @param tag: uchar

ida_netnode.netnode.charset (method)
    charset(self, alt, val, tag) -> bool
    
    @param alt: nodeidx_t
    @param val: uchar
    @param tag: uchar

ida_netnode.netnode.charset_ea (method)
    charset_ea(self, ea, val, tag) -> bool
    
    @param ea: ea_t
    @param val: uchar
    @param tag: uchar

ida_netnode.netnode.charset_idx8 (method)
    charset_idx8(self, alt, val, tag) -> bool
    
    @param alt: uchar
    @param val: uchar
    @param tag: uchar

ida_netnode.netnode.charshift (method)
    charshift(self, _from, to, size, tag) -> size_t
    
    @param from: nodeidx_t
    @param to: nodeidx_t
    @param size: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.charval (method)
    charval(self, alt, tag) -> uchar
    
    @param alt: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.charval_ea (method)
    charval_ea(self, ea, tag) -> uchar
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.charval_idx8 (method)
    charval_idx8(self, alt, tag) -> uchar
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.copyto (method)
    copyto(self, destnode, count=1) -> size_t
    
    @param destnode: netnode
    @param count: nodeidx_t

ida_netnode.netnode.create (method)
    create(self, _name, namlen=0) -> bool
    Create unnamed netnode.
    @retval 1: ok
    @retval 0: should not happen, indicates internal error
    
    @param _name: char const *
    @param namlen: size_t
    
    create(self) -> bool

ida_netnode.netnode.delblob (method)
    delblob(self, _start, tag) -> int
    Delete a blob.
    
    @param _start: (C++: nodeidx_t) index of the first supval element used to store blob
    @param tag: (C++: uchar) tag of supval array
    @return: number of deleted supvals

ida_netnode.netnode.delblob_ea (method)
    delblob_ea(self, ea, tag) -> int
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.delvalue (method)
    delvalue(self) -> bool
    Delete value of netnode.
    @retval 1: ok
    @retval 0: failed, netnode is bad or other error

ida_netnode.netnode.eadel (method)
    eadel(self, ea, tag) -> bool
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.eadel_idx8 (method)
    eadel_idx8(self, idx, tag) -> bool
    
    @param idx: uchar
    @param tag: uchar

ida_netnode.netnode.eaget (method)
    eaget(self, ea, tag) -> ea_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.eaget_idx (method)
    eaget_idx(self, idx, tag) -> ea_t
    
    @param idx: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.eaget_idx8 (method)
    eaget_idx8(self, idx, tag) -> ea_t
    
    @param idx: uchar
    @param tag: uchar

ida_netnode.netnode.easet (method)
    easet(self, ea, addr, tag) -> bool
    Store/retrieve/delete an address value in the netnode that corresponds to an
    address.
    
    @param ea: (C++: ea_t)
    @param addr: (C++: ea_t)
    @param tag: (C++: uchar)

ida_netnode.netnode.easet_idx (method)
    easet_idx(self, idx, addr, tag) -> bool
    
    @param idx: nodeidx_t
    @param addr: ea_t
    @param tag: uchar

ida_netnode.netnode.easet_idx8 (method)
    easet_idx8(self, idx, addr, tag) -> bool
    
    @param idx: uchar
    @param addr: ea_t
    @param tag: uchar

ida_netnode.netnode.end (method)
    end(self) -> bool
    Get last netnode in the graph. Sets netnodenumber to the highest existing
    number.
    @retval true: ok
    @retval false: graph is empty

ida_netnode.netnode.exist (method)
    exist(_name) -> bool
    Does the netnode with the specified name exist?
    
    @param _name: (C++: const char *) char const *

ida_netnode.netnode.get_name (method)
    get_name(self) -> ssize_t
    Get the netnode name.
    
    @return: -1 if netnode is unnamed (buf is untouched in this case), otherwise the
             name length

ida_netnode.netnode.getblob (method)
    getblob(self, start, tag) -> bytes or None
    Get blob from a netnode into a qstring* and make sure the string is null-
    terminated.
    
    @param start: nodeidx_t
    @param tag: (C++: uchar) tag of supval array
    @return: -1 if blob doesn't exist size of string (including terminating null)
             otherwise

ida_netnode.netnode.getblob_ea (method)
    getblob_ea(self, ea, tag) -> PyObject *
    
    @param ea: ea_t
    @param tag: char

ida_netnode.netnode.getclob (method)
    getclob(self, start, tag) -> str
    
    @param start: nodeidx_t
    @param tag: char

ida_netnode.netnode.hashdel (method)
    hashdel(self, idx, tag=htag) -> bool
    Delete hash element.
    
    @param idx: (C++: const char *) index into hash
    @param tag: (C++: uchar) tag of hash. Default: htag
    @retval true: deleted
    @retval false: element does not exist

ida_netnode.netnode.hashdel_all (method)
    hashdel_all(self, tag=htag) -> bool
    Delete all elements of hash. This function deletes the whole hash.
    
    @param tag: (C++: uchar) tag of hash. Default: htag
    @return: success

ida_netnode.netnode.hashfirst (method)
    hashfirst(self, tag=htag) -> ssize_t
    @see: hashfirst(qstring *buf, uchar tag=htag) const
    
    @param tag: (C++: uchar)

ida_netnode.netnode.hashlast (method)
    hashlast(self, tag=htag) -> ssize_t
    @see: hashlast(qstring *buf, uchar tag=htag) const
    
    @param tag: (C++: uchar)

ida_netnode.netnode.hashnext (method)
    hashnext(self, idx, tag=htag) -> ssize_t
    @see: hashnext(qstring *buf, const char *idx, uchar tag=htag) const
    
    @param idx: (C++: const char *) char const *
    @param tag: (C++: uchar)

ida_netnode.netnode.hashprev (method)
    hashprev(self, idx, tag=htag) -> ssize_t
    @see: hashprev(qstring *buf, const char *idx, uchar tag=htag) const
    
    @param idx: (C++: const char *) char const *
    @param tag: (C++: uchar)

ida_netnode.netnode.hashset (method)
    hashset(self, idx, value, tag=htag) -> bool
    Set value of hash element to long value.
    
    @param idx: (C++: const char *) index into hash
    @param value: (C++: nodeidx_t) new value of hash element
    @param tag: (C++: uchar) tag of hash. Default: htag
    @retval 1: ok
    @retval 0: should not occur - indicates internal error

ida_netnode.netnode.hashset_buf (method)
    hashset_buf(self, idx, py_str, tag=htag) -> bool
    
    @param idx: char const *
    @param py_str: PyObject *
    @param tag: char

ida_netnode.netnode.hashset_idx (method)
    hashset_idx(self, idx, value, tag=htag) -> bool
    
    @param idx: char const *
    @param value: nodeidx_t
    @param tag: uchar

ida_netnode.netnode.hashstr (method)
    hashstr(self, idx, tag=htag) -> ssize_t
    @see: hashstr(qstring *buf, const char *idx, uchar tag=htag) const
    
    @param idx: (C++: const char *) char const *
    @param tag: (C++: uchar)

ida_netnode.netnode.hashstr_buf (method)
    hashstr_buf(self, idx, tag=htag) -> PyObject *
    
    @param idx: char const *
    @param tag: char

ida_netnode.netnode.hashval (method)
    hashval(self, idx, tag=htag) -> ssize_t
    Get value of the specified hash element.
    
    @param idx: (C++: const char *) index into hash
    @param tag: (C++: uchar) tag of hash. Default: htag
    @return: -1 if element doesn't exist or idx is nullptr. otherwise returns the
             value size in bytes

ida_netnode.netnode.hashval_long (method)
    hashval_long(self, idx, tag=htag) -> nodeidx_t
    Get value of the specified hash element.
    
    @param idx: (C++: const char *) index into hash
    @param tag: (C++: uchar) tag of hash. Default: htag
    @return: value of hash element (it should be set using hashset(nodeidx_t)), 0 if
             the element does not exist

ida_netnode.netnode.index (method)
    index(self) -> nodeidx_t

ida_netnode.netnode.kill (method)
    kill(self)
    Delete a netnode with all information attached to it.

ida_netnode.netnode.long_value (method)
    long_value(self) -> nodeidx_t

ida_netnode.netnode.lower_bound (method)
    lower_bound(self, cur, tag=stag) -> nodeidx_t
    Get lower bound of existing elements of supval array.
    
    @param cur: (C++: nodeidx_t) current index
    @param tag: (C++: uchar) tag of array
    @return: index of first existing element of supval array >= cur BADNODE if
             supval array is empty

ida_netnode.netnode.lower_bound_ea (method)
    lower_bound_ea(self, ea, tag=stag) -> nodeidx_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.lower_bound_idx8 (method)
    lower_bound_idx8(self, alt, tag) -> nodeidx_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.moveto (method)
    moveto(self, destnode, count=1) -> size_t
    
    @param destnode: netnode
    @param count: nodeidx_t

ida_netnode.netnode.next (method)
    next(self) -> bool
    Get next netnode in the graph. Sets netnodenumber to the next existing number
    @retval true: ok
    @retval false: no more netnodes

ida_netnode.netnode.prev (method)
    prev(self) -> bool
    Get prev netnode in the graph. Sets netnodenumber to the previous existing
    number
    @retval true: ok
    @retval false: no more netnodes

ida_netnode.netnode.rename (method)
    rename(self, newname, namlen=0) -> bool
    Rename a netnode.
    
    @param newname: (C++: const char *) new name of netnode. nullptr or "" means to delete name. names
                    of user-defined netnodes must have the "$ " prefix in order to
                    avoid clashes with program byte names.
    @param namlen: (C++: size_t) length of new name. if not specified, it will be calculated using
                   strlen()
    @retval 1: ok
    @retval 0: failed, newname is already used

ida_netnode.netnode.set (method)
    set(self, value) -> bool
    Set value of netnode.
    
    @param value: (C++: const void *) pointer to value
    @return: 1 - ok

ida_netnode.netnode.set_long (method)
    set_long(self, x) -> bool
    Value of netnode as a long number:
    
    @param x: (C++: nodeidx_t)

ida_netnode.netnode.setblob (method)
    setblob(self, buf, _start, tag) -> bool
    Store a blob in a netnode.
    
    @param buf: (C++: const void *) pointer to blob to save
    @param _start: (C++: nodeidx_t)
    @param tag: (C++: uchar) tag of supval array
    @return: success

ida_netnode.netnode.setblob_ea (method)
    setblob_ea(self, buf, ea, tag) -> bool
    
    @param buf: void const *
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.start (method)
    start(self) -> bool
    Get first netnode in the graph. Sets netnodenumber to the lowest existing
    number.
    @retval true: ok
    @retval false: graph is empty

ida_netnode.netnode.supdel (method)
    supdel(self, alt, tag=stag) -> bool
    Delete all elements of supval array. This function may be applied to 32-bit and
    8-bit supval arrays. This function deletes the whole supval array.
    
    @param alt: nodeidx_t
    @param tag: uchar
    
    @return: success
    supdel(self) -> bool

ida_netnode.netnode.supdel_all (method)
    supdel_all(self, tag) -> bool
    Delete all elements of the specified supval array. This function may be applied
    to 32-bit and 8-bit supval arrays. This function deletes the whole supval array.
    
    @param tag: (C++: uchar)
    @return: success

ida_netnode.netnode.supdel_ea (method)
    supdel_ea(self, ea, tag=stag) -> bool
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.supdel_idx8 (method)
    supdel_idx8(self, alt, tag) -> bool
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.supdel_range (method)
    supdel_range(self, idx1, idx2, tag) -> int
    Delete range of elements in the specified supval array. Elements in range [idx1,
    idx2) will be deleted.
    @note: This function can also be used to delete a range of altval elements
    
    @param idx1: (C++: nodeidx_t) first element to delete
    @param idx2: (C++: nodeidx_t) last element to delete + 1
    @param tag: (C++: uchar) tag of array
    @return: number of deleted elements

ida_netnode.netnode.supdel_range_idx8 (method)
    supdel_range_idx8(self, idx1, idx2, tag) -> int
    Same as above, but accepts 8-bit indexes.
    
    @param idx1: (C++: uchar)
    @param idx2: (C++: uchar)
    @param tag: (C++: uchar)

ida_netnode.netnode.supfirst (method)
    supfirst(self, tag=stag) -> nodeidx_t
    Get first existing element of supval array.
    
    @param tag: (C++: uchar) tag of array
    @return: index of first existing element of supval array, BADNODE if supval
             array is empty

ida_netnode.netnode.supfirst_idx8 (method)
    supfirst_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.suplast (method)
    suplast(self, tag=stag) -> nodeidx_t
    Get last existing element of supval array.
    
    @param tag: (C++: uchar) tag of array
    @return: index of last existing element of supval array, BADNODE if supval array
             is empty

ida_netnode.netnode.suplast_idx8 (method)
    suplast_idx8(self, tag) -> nodeidx_t
    
    @param tag: uchar

ida_netnode.netnode.supnext (method)
    supnext(self, cur, tag=stag) -> nodeidx_t
    Get next existing element of supval array.
    
    @param cur: (C++: nodeidx_t) current index
    @param tag: (C++: uchar) tag of array
    @return: index of the next existing element of supval array, BADNODE if no more
             supval array elements exist

ida_netnode.netnode.supnext_idx8 (method)
    supnext_idx8(self, alt, tag) -> nodeidx_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.supprev (method)
    supprev(self, cur, tag=stag) -> nodeidx_t
    Get previous existing element of supval array.
    
    @param cur: (C++: nodeidx_t) current index
    @param tag: (C++: uchar) tag of array
    @return: index of the previous existing element of supval array BADNODE if no
             more supval array elements exist

ida_netnode.netnode.supprev_idx8 (method)
    supprev_idx8(self, alt, tag) -> nodeidx_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.supset (method)
    supset(self, alt, value, tag=stag) -> bool
    Set value of supval array element.
    
    @param alt: (C++: nodeidx_t) index into array of supvals
    @param value: (C++: const void *) pointer to supval value
    @param tag: (C++: uchar) tag of array
    @retval 1: ok
    @retval 0: should not occur - indicates internal error

ida_netnode.netnode.supset_ea (method)
    supset_ea(self, ea, value, tag=stag) -> bool
    
    @param ea: ea_t
    @param value: void const *
    @param tag: uchar

ida_netnode.netnode.supset_idx8 (method)
    supset_idx8(self, alt, value, tag) -> bool
    
    @param alt: uchar
    @param value: void const *
    @param tag: uchar

ida_netnode.netnode.supshift (method)
    supshift(self, _from, to, size, tag=stag) -> size_t
    Shift the supval array elements. Moves the array elements at (from..from+size)
    to (to..to+size)
    
    @param from: (C++: nodeidx_t)
    @param to: (C++: nodeidx_t)
    @param size: (C++: nodeidx_t)
    @param tag: (C++: uchar)
    @return: number of shifted elements

ida_netnode.netnode.supstr (method)
    supstr(self, alt, tag=stag) -> ssize_t
    @see: supstr(qstring *buf, nodeidx_t alt, uchar tag=stag) const
    
    @param alt: (C++: nodeidx_t)
    @param tag: (C++: uchar)

ida_netnode.netnode.supstr_ea (method)
    supstr_ea(self, ea, tag=stag) -> ssize_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.supstr_idx8 (method)
    supstr_idx8(self, alt, tag) -> ssize_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.supval (method)
    supval(self, alt, tag=stag) -> ssize_t
    Get value of the specified supval array element. NB: do not use this function to
    retrieve strings, see supstr()!
    
    @param alt: (C++: nodeidx_t) index into array of supvals
    @param tag: (C++: uchar) tag of array. Default: stag
    @return: size of value, -1 if element doesn't exist

ida_netnode.netnode.supval_ea (method)
    supval_ea(self, ea, tag=stag) -> ssize_t
    
    @param ea: ea_t
    @param tag: uchar

ida_netnode.netnode.supval_idx8 (method)
    supval_idx8(self, alt, tag) -> ssize_t
    
    @param alt: uchar
    @param tag: uchar

ida_netnode.netnode.valobj (method)
    valobj(self) -> ssize_t
    Get value of netnode. Netnode values are arbitrary sized objects with max size
    is MAXSPECSIZE. NB: do not use this function for strings - see valstr().
    
    @return: length of value, -1 if no value present

ida_netnode.netnode.valstr (method)
    valstr(self) -> ssize_t
    @see: valstr(qstring *buf) const

ida_netnode.netnode.value_exists (method)
    value_exists(self) -> bool

ida_netnode.netnode_exist (function)
    netnode_exist(_name) -> bool
    
    @param _name: char const *

ida_netnode.ntag (variable)
    Name of netnode.

ida_netnode.stag (variable)
    Array of supvals.

ida_netnode.vtag (variable)
    Value of netnode.

ida_offset (module)
    Functions that deal with offsets.
    
    "Being an offset" is a characteristic of an operand. This means that operand or
    its part represent offset from some address in the program. This linear address
    is called "offset base". Some operands may have 2 offsets simultaneously.
    Generally, IDA doesn't handle this except for Motorola outer offsets. Thus there
    may be two offset values in an operand: simple offset and outer offset.
    
    Outer offsets are handled by specifying special operand number: it should be
    ORed with OPND_OUTER value.
    
    See bytes.hpp for further explanation of operand numbers.

ida_offset.add_refinfo_dref (function)
    add_refinfo_dref(insn, _from, ri, opval, type, opoff) -> ea_t
    Add xrefs for a reference from the given instruction ( insn_t::ea). This
    function creates a cross references to the target and the base.
    insn_t::add_off_drefs() calls this function to create xrefs for 'offset'
    operand.
    
    @param insn: (C++: const insn_t &) the referencing instruction
    @param from: (C++: ea_t) the referencing instruction/data address
    @param ri: (C++: const refinfo_t &) reference info block from the database
    @param opval: (C++: adiff_t) operand value (usually op_t::value or op_t::addr)
    @param type: (C++: dref_t) type of xref
    @param opoff: (C++: int) offset of the operand from the start of instruction
    @return: the target address of the reference

ida_offset.calc_basevalue (function)
    calc_basevalue(target, base) -> ea_t
    Calculate the value of the reference base.
    
    @param target: (C++: ea_t)
    @param base: (C++: ea_t)

ida_offset.calc_offset_base (function)
    calc_offset_base(ea, n) -> ea_t
    Try to calculate the offset base This function takes into account the fixup
    information, current ds and cs values.
    
    @param ea: (C++: ea_t) the referencing instruction/data address
    @param n: (C++: int) operand number
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    @return: output base address or BADADDR

ida_offset.calc_probable_base_by_value (function)
    calc_probable_base_by_value(ea, off) -> ea_t
    Try to calculate the offset base. 2 bases are checked: current ds and cs. If
    fails, return BADADDR
    
    @param ea: (C++: ea_t)
    @param off: (C++: uval_t)

ida_offset.calc_reference_data (function)
    calc_reference_data(target, base, _from, ri, opval) -> bool
    Calculate the target and base addresses of an offset expression. The calculated
    target and base addresses are returned in the locations pointed by 'base' and
    'target'. In case 'ri.base' is BADADDR, the function calculates the offset base
    address from the referencing instruction/data address. The target address is
    copied from ri.target. If ri.target is BADADDR then the target is calculated
    using the base address and 'opval'. This function also checks if 'opval' matches
    the full value of the reference and takes in account the memory-mapping.
    
    @param target: (C++: ea_t *) output target address
    @param base: (C++: ea_t *) output base address
    @param from: (C++: ea_t) the referencing instruction/data address
    @param ri: (C++: const refinfo_t &) reference info block from the database
    @param opval: (C++: adiff_t) operand value (usually op_t::value or op_t::addr)
    @return: success

ida_offset.calc_target (function)
    calc_target(_from, opval, ri) -> ea_t
    Retrieve refinfo_t structure and calculate the target.
    
    @param from: (C++: ea_t)
    @param opval: (C++: adiff_t)
    @param ri: refinfo_t const &
    
    calc_target(_from, ea, n, opval) -> ea_t
    
    @param from: ea_t
    @param ea: ea_t
    @param n: int
    @param opval: adiff_t

ida_offset.can_be_off32 (function)
    can_be_off32(ea) -> ea_t
    Does the specified address contain a valid OFF32 value?. For symbols in special
    segments the displacement is not taken into account. If yes, then the target
    address of OFF32 will be returned. If not, then BADADDR is returned.
    
    @param ea: (C++: ea_t)

ida_offset.get_default_reftype (function)
    get_default_reftype(ea) -> reftype_t
    Get default reference type depending on the segment.
    
    @param ea: (C++: ea_t)
    @return: one of REF_OFF8, REF_OFF16, REF_OFF32, REF_OFF64

ida_offset.get_offbase (function)
    get_offbase(ea, n) -> ea_t
    Get offset base value
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) 0..UA_MAXOP-1 operand number
    @return: offset base or BADADDR

ida_offset.get_offset_expr (function)
    get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -> str
    See get_offset_expression()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param ri: (C++: const refinfo_t &) refinfo_t const &
    @param from: (C++: ea_t)
    @param offset: (C++: adiff_t)
    @param getn_flags: (C++: int)

ida_offset.get_offset_expression (function)
    get_offset_expression(ea, n, _from, offset, getn_flags=0) -> str
    Get offset expression (in the form "offset name+displ"). This function uses
    offset translation function ( processor_t::translate) if your IDP module has
    such a function. Translation function is used to map linear addresses in the
    program (only for offsets).
    
    Example: suppose we have instruction at linear address 0x00011000:
    mov     ax, [bx+7422h]  and at ds:7422h:
    array   dw      ...  We want to represent the second operand with an offset
    expression, so then we call:
    get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf);
                         |         |  |         |       |
                         |         |  |         |       +output buffer
                         |         |  |         +value of offset expression
                         |         |  +address offset value in the instruction
                         |         +the second operand
                         +address of instruction and the function will return a
    colored string:
    offset array
    
    @param ea: (C++: ea_t) start of instruction or data with the offset expression
    @param n: (C++: int) operand number (may be ORed with OPND_OUTER)
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    @param from: (C++: ea_t) linear address of instruction operand or data referring to the
                 name. This address will be used to get fixup information, so it
                 should point to exact position of operand in the instruction.
    @param offset: (C++: adiff_t) value of operand or its part. The function will return text
                   representation of this value as offset expression.
    @param getn_flags: (C++: int) combination of:
    * GETN_APPZERO: meaningful only if the name refers to a structure. appends the
    struct field name if the field offset is zero
    * GETN_NODUMMY: do not generate dummy names for the expression but pretend they
    already exist (useful to verify that the offset expression can be represented)
    @retval 0: can't convert to offset expression
    @retval 1: ok, a simple offset expression
    @retval 2: ok, a complex offset expression

ida_offset.op_offset (function)
    op_offset(ea, n, type_and_flags, target=BADADDR, base=0, tdelta=0) -> bool
    See op_offset_ex()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param type_and_flags: (C++: uint32)
    @param target: (C++: ea_t)
    @param base: (C++: ea_t)
    @param tdelta: (C++: adiff_t)

ida_offset.op_offset_ex (function)
    op_offset_ex(ea, n, ri) -> bool
    Convert operand to a reference. To delete an offset, use clr_op_type() function.
    
    @param ea: (C++: ea_t) linear address. if 'ea' has unexplored bytes, try to convert them to
    * no segment: fail
    * 16bit segment: to 16bit word data
    * 32bit segment: to dword
    @param n: (C++: int) operand number (may be ORed with OPND_OUTER)
    * 0: first
    * 1: second
    * ...
    * 7: eighth operand
    * OPND_MASK: all operands
    @param ri: (C++: const refinfo_t *) reference information
    @return: success

ida_offset.op_plain_offset (function)
    op_plain_offset(ea, n, base) -> bool
    Convert operand to a reference with the default reference type.
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param base: (C++: ea_t)

ida_pro (module)
    This is the first header included in the IDA project.
    
    It defines the most common types, functions and data. Also, it tries to make
    system dependent definitions.
    
    The following preprocessor macros are used in the project (the list may be
    incomplete)
    
    Platform must be specified as one of:
    
    __NT__ - MS Windows (all platforms)
    __LINUX__ - Linux
    __MAC__ - MAC OS X
    
    __EA64__ - 64-bit address size (sizeof(ea_t)==8)
    __X86__ - 32-bit debug servers (sizeof(void*)==4)
    __X64__ - x64 processor (sizeof(void*)==8) default
    __PPC__ - PowerPC
    __ARM__ - ARM

ida_pro.CP_UTF16 (variable)
    UTF-16 codepage.

ida_pro.IDA_SDK_VERSION (variable)
    IDA SDK v8.4.

ida_pro.IDBDEC_ESCAPE (variable)
    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

ida_pro.IOREDIR_APPEND (variable)
    append, do not overwrite the output file

ida_pro.IOREDIR_INPUT (variable)
    input redirection

ida_pro.IOREDIR_OUTPUT (variable)
    output redirection

ida_pro.IOREDIR_QUOTED (variable)
    the file name was quoted

ida_pro.MAXSTR (variable)
    maximum string size

ida_pro.SUBSTCHAR (variable)
    default char, used if a char cannot be represented in a codepage

ida_pro.__MF__ (variable)
    byte sex of our platform (Most significant byte First). 0: little endian (Intel
    80x86). 1: big endian (PowerPC).

ida_pro.__qmutex_t (class)
    Proxy of C++ __qmutex_t class.

ida_pro.__qmutex_t.__init__ (method)
    __init__(self) -> __qmutex_t

ida_pro.__qsemaphore_t (class)
    Proxy of C++ __qsemaphore_t class.

ida_pro.__qsemaphore_t.__init__ (method)
    __init__(self) -> __qsemaphore_t

ida_pro.__qthread_t (class)
    Proxy of C++ __qthread_t class.

ida_pro.__qthread_t.__init__ (method)
    __init__(self) -> __qthread_t

ida_pro._qstrvec_t (class)
    WARNING: It is very unlikely an IDAPython user should ever, ever
    have to use this type. It should only be used for IDAPython internals.
    
    For example, in py_askusingform.py, we ctypes-expose to the IDA
    kernel & UI a qstrvec instance, in case a DropdownListControl is
    constructed.
    That's because that's what ask_form expects, and we have no
    choice but to make a DropdownListControl hold a qstrvec_t.
    This is, afaict, the only situation where a Python
    _qstrvec_t is required.

ida_pro._qstrvec_t.__get_size (method)

ida_pro._qstrvec_t.__getitem__ (method)
    Gets the string at the given index

ida_pro._qstrvec_t.__init__ (method)

ida_pro._qstrvec_t.__setitem__ (method)
    Sets string at the given index

ida_pro._qstrvec_t._create_clink (method)

ida_pro._qstrvec_t._del_clink (method)

ida_pro._qstrvec_t._get_clink_ptr (method)

ida_pro._qstrvec_t.add (method)
    Add a string to the vector

ida_pro._qstrvec_t.addressof (method)
    Returns the address (as number) of the qstring at the given index

ida_pro._qstrvec_t.assign (method)
    Copies the contents of 'other' to 'self'

ida_pro._qstrvec_t.clear (method)
    Clears all strings from the vector.
    @param qclear: Just reset the size but do not actually free the memory

ida_pro._qstrvec_t.from_list (method)
    Populates the vector from a Python string list

ida_pro._qstrvec_t.insert (method)
    Insert a string into the vector

ida_pro._qstrvec_t.remove (method)
    Removes a string from the vector

ida_pro._qstrvec_t.size (variable)
    Returns the count of elements

ida_pro.boolvec_t (class)
    Proxy of C++ qvector< bool > class.

ida_pro.boolvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< bool > const &

ida_pro.boolvec_t.__getitem__ (method)
    __getitem__(self, i) -> bool const &
    
    @param i: size_t

ida_pro.boolvec_t.__init__ (method)
    __init__(self) -> boolvec_t
    __init__(self, x) -> boolvec_t
    
    @param x: qvector< bool > const &

ida_pro.boolvec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.boolvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< bool > const &

ida_pro.boolvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: bool const &

ida_pro.boolvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: bool const &

ida_pro.boolvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: bool const &

ida_pro.boolvec_t.at (method)
    at(self, _idx) -> bool const &
    
    @param _idx: size_t

ida_pro.boolvec_t.begin (method)
    begin(self) -> qvector< bool >::iterator
    begin(self) -> qvector< bool >::const_iterator

ida_pro.boolvec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.boolvec_t.clear (method)
    clear(self)

ida_pro.boolvec_t.empty (method)
    empty(self) -> bool

ida_pro.boolvec_t.end (method)
    end(self) -> qvector< bool >::iterator
    end(self) -> qvector< bool >::const_iterator

ida_pro.boolvec_t.erase (method)
    erase(self, it) -> qvector< bool >::iterator
    
    @param it: qvector< bool >::iterator
    
    erase(self, first, last) -> qvector< bool >::iterator
    
    @param first: qvector< bool >::iterator
    @param last: qvector< bool >::iterator

ida_pro.boolvec_t.extract (method)
    extract(self) -> bool *

ida_pro.boolvec_t.find (method)
    find(self, x) -> qvector< bool >::iterator
    
    @param x: bool const &
    
    find(self, x) -> qvector< bool >::const_iterator
    
    @param x: bool const &

ida_pro.boolvec_t.grow (method)
    grow(self, x=bool())
    
    @param x: bool const &

ida_pro.boolvec_t.has (method)
    has(self, x) -> bool
    
    @param x: bool const &

ida_pro.boolvec_t.inject (method)
    inject(self, s, len)
    
    @param s: bool *
    @param len: size_t

ida_pro.boolvec_t.insert (method)
    insert(self, it, x) -> qvector< bool >::iterator
    
    @param it: qvector< bool >::iterator
    @param x: bool const &

ida_pro.boolvec_t.pop_back (method)
    pop_back(self)

ida_pro.boolvec_t.push_back (method)
    push_back(self, x)
    
    @param x: bool const &
    
    push_back(self) -> bool &

ida_pro.boolvec_t.qclear (method)
    qclear(self)

ida_pro.boolvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.boolvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: bool const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.boolvec_t.size (method)
    size(self) -> size_t

ida_pro.boolvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< bool > &

ida_pro.boolvec_t.truncate (method)
    truncate(self)

ida_pro.channel_redir_t (class)
    Proxy of C++ channel_redir_t class.

ida_pro.channel_redir_t.__init__ (method)
    __init__(self) -> channel_redir_t

ida_pro.channel_redir_t.fd (variable)
    channel number

ida_pro.channel_redir_t.file (variable)
    file name to redirect to/from. if empty, the channel must be closed.

ida_pro.channel_redir_t.flags (variable)
    i/o redirection flags

ida_pro.channel_redir_t.is_append (method)
    is_append(self) -> bool

ida_pro.channel_redir_t.is_input (method)
    is_input(self) -> bool

ida_pro.channel_redir_t.is_output (method)
    is_output(self) -> bool

ida_pro.channel_redir_t.is_quoted (method)
    is_quoted(self) -> bool

ida_pro.channel_redir_t.length (variable)
    length of the redirection string in the command line

ida_pro.channel_redir_t.start (variable)
    begin of the redirection string in the command line

ida_pro.check_process_exit (function)
    check_process_exit(handle, exit_code, msecs=-1) -> int
    Check whether process has terminated or not.
    
    @param handle: (C++: void *) process handle to wait for
    @param exit_code: (C++: int *) pointer to the buffer for the exit code
    @param msecs: how long to wait. special values:
    * 0: do not wait
    * 1 or -1: wait infinitely
    * other values: timeout in milliseconds
    @retval 0: process has exited, and the exit code is available. if *exit_code <
               0: the process was killed with a signal -*exit_code
    @retval 1: process has not exited yet
    @retval -1: error happened, see error code for winerr() in *exit_code

ida_pro.ea_array (class)
    Proxy of C++ ea_array class.

ida_pro.ea_array.__getitem__ (method)
    __getitem__(self, index) -> ea_t
    
    @param index: size_t

ida_pro.ea_array.__init__ (method)
    __init__(self, nelements) -> ea_array
    
    @param nelements: size_t

ida_pro.ea_array.__setitem__ (method)
    __setitem__(self, index, value)
    
    @param index: size_t
    @param value: ea_t

ida_pro.ea_array.cast (method)
    cast(self) -> ea_t *

ida_pro.ea_array.frompointer (method)
    frompointer(t) -> ea_array
    
    @param t: ea_t *

ida_pro.ea_array_frompointer (function)
    ea_array_frompointer(t) -> ea_array
    
    @param t: ea_t *

ida_pro.ea_pointer (class)
    Proxy of C++ ea_pointer class.

ida_pro.ea_pointer.__init__ (method)
    __init__(self) -> ea_pointer

ida_pro.ea_pointer.assign (method)
    assign(self, value)
    
    @param value: ea_t

ida_pro.ea_pointer.cast (method)
    cast(self) -> ea_t *

ida_pro.ea_pointer.frompointer (method)
    frompointer(t) -> ea_pointer
    
    @param t: ea_t *

ida_pro.ea_pointer.value (method)
    value(self) -> ea_t

ida_pro.ea_pointer_frompointer (function)
    ea_pointer_frompointer(t) -> ea_pointer
    
    @param t: ea_t *

ida_pro.extend_sign (function)
    extend_sign(v, nbytes, sign_extend) -> uint64
    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v' is
    considered to be of size 'nbytes'.
    
    @param v: (C++: uint64)
    @param nbytes: (C++: int)
    @param sign_extend: (C++: bool)

ida_pro.instant_dbgopts_t (class)
    Proxy of C++ instant_dbgopts_t class.

ida_pro.instant_dbgopts_t.__init__ (method)
    __init__(self) -> instant_dbgopts_t

ida_pro.instant_dbgopts_t.attach (variable)
    should attach to a process?

ida_pro.instant_dbgopts_t.debmod (variable)
    name of debugger module

ida_pro.instant_dbgopts_t.env (variable)
    config variables for debmod. example: DEFAULT_CPU=13;MAXPACKETSIZE=-1

ida_pro.instant_dbgopts_t.event_id (variable)
    event to trigger upon attaching

ida_pro.instant_dbgopts_t.host (variable)
    remote hostname (if remote debugging)

ida_pro.instant_dbgopts_t.pid (variable)
    process to attach to (-1: ask the user)

ida_pro.instant_dbgopts_t.port (variable)
    port number for the remote debugger server

ida_pro.int64vec_t (class)
    Proxy of C++ qvector< long long > class.

ida_pro.int64vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< long long > const &

ida_pro.int64vec_t.__getitem__ (method)
    __getitem__(self, i) -> long long const &
    
    @param i: size_t

ida_pro.int64vec_t.__init__ (method)
    __init__(self) -> int64vec_t
    __init__(self, x) -> int64vec_t
    
    @param x: qvector< long long > const &

ida_pro.int64vec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.int64vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< long long > const &

ida_pro.int64vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: long long const &

ida_pro.int64vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: long long const &

ida_pro.int64vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: long long const &

ida_pro.int64vec_t.at (method)
    at(self, _idx) -> long long const &
    
    @param _idx: size_t

ida_pro.int64vec_t.begin (method)
    begin(self) -> qvector< long long >::iterator
    begin(self) -> qvector< long long >::const_iterator

ida_pro.int64vec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.int64vec_t.clear (method)
    clear(self)

ida_pro.int64vec_t.empty (method)
    empty(self) -> bool

ida_pro.int64vec_t.end (method)
    end(self) -> qvector< long long >::iterator
    end(self) -> qvector< long long >::const_iterator

ida_pro.int64vec_t.erase (method)
    erase(self, it) -> qvector< long long >::iterator
    
    @param it: qvector< long long >::iterator
    
    erase(self, first, last) -> qvector< long long >::iterator
    
    @param first: qvector< long long >::iterator
    @param last: qvector< long long >::iterator

ida_pro.int64vec_t.extract (method)
    extract(self) -> long long *

ida_pro.int64vec_t.find (method)
    find(self, x) -> qvector< long long >::iterator
    
    @param x: long long const &
    
    find(self, x) -> qvector< long long >::const_iterator
    
    @param x: long long const &

ida_pro.int64vec_t.has (method)
    has(self, x) -> bool
    
    @param x: long long const &

ida_pro.int64vec_t.inject (method)
    inject(self, s, len)
    
    @param s: long long *
    @param len: size_t

ida_pro.int64vec_t.insert (method)
    insert(self, it, x) -> qvector< long long >::iterator
    
    @param it: qvector< long long >::iterator
    @param x: long long const &

ida_pro.int64vec_t.pop_back (method)
    pop_back(self)

ida_pro.int64vec_t.push_back (method)
    push_back(self, x)
    
    @param x: long long const &
    
    push_back(self) -> long long &

ida_pro.int64vec_t.qclear (method)
    qclear(self)

ida_pro.int64vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.int64vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: long long const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.int64vec_t.size (method)
    size(self) -> size_t

ida_pro.int64vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< long long > &

ida_pro.int64vec_t.truncate (method)
    truncate(self)

ida_pro.int_pointer (class)
    Proxy of C++ int_pointer class.

ida_pro.int_pointer.__init__ (method)
    __init__(self) -> int_pointer

ida_pro.int_pointer.assign (method)
    assign(self, value)
    
    @param value: int

ida_pro.int_pointer.cast (method)
    cast(self) -> int *

ida_pro.int_pointer.frompointer (method)
    frompointer(t) -> int_pointer
    
    @param t: int *

ida_pro.int_pointer.value (method)
    value(self) -> int

ida_pro.int_pointer_frompointer (function)
    int_pointer_frompointer(t) -> int_pointer
    
    @param t: int *

ida_pro.intvec_t (class)
    Proxy of C++ qvector< int > class.

ida_pro.intvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< int > const &

ida_pro.intvec_t.__getitem__ (method)
    __getitem__(self, i) -> int const &
    
    @param i: size_t

ida_pro.intvec_t.__init__ (method)
    __init__(self) -> intvec_t
    __init__(self, x) -> intvec_t
    
    @param x: qvector< int > const &

ida_pro.intvec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.intvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< int > const &

ida_pro.intvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: int const &

ida_pro.intvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: int const &

ida_pro.intvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: int const &

ida_pro.intvec_t.at (method)
    at(self, _idx) -> int const &
    
    @param _idx: size_t

ida_pro.intvec_t.begin (method)
    begin(self) -> qvector< int >::iterator
    begin(self) -> qvector< int >::const_iterator

ida_pro.intvec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.intvec_t.clear (method)
    clear(self)

ida_pro.intvec_t.empty (method)
    empty(self) -> bool

ida_pro.intvec_t.end (method)
    end(self) -> qvector< int >::iterator
    end(self) -> qvector< int >::const_iterator

ida_pro.intvec_t.erase (method)
    erase(self, it) -> qvector< int >::iterator
    
    @param it: qvector< int >::iterator
    
    erase(self, first, last) -> qvector< int >::iterator
    
    @param first: qvector< int >::iterator
    @param last: qvector< int >::iterator

ida_pro.intvec_t.extract (method)
    extract(self) -> int *

ida_pro.intvec_t.find (method)
    find(self, x) -> qvector< int >::iterator
    
    @param x: int const &
    
    find(self, x) -> qvector< int >::const_iterator
    
    @param x: int const &

ida_pro.intvec_t.has (method)
    has(self, x) -> bool
    
    @param x: int const &

ida_pro.intvec_t.inject (method)
    inject(self, s, len)
    
    @param s: int *
    @param len: size_t

ida_pro.intvec_t.insert (method)
    insert(self, it, x) -> qvector< int >::iterator
    
    @param it: qvector< int >::iterator
    @param x: int const &

ida_pro.intvec_t.pop_back (method)
    pop_back(self)

ida_pro.intvec_t.push_back (method)
    push_back(self, x)
    
    @param x: int const &
    
    push_back(self) -> int &

ida_pro.intvec_t.qclear (method)
    qclear(self)

ida_pro.intvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.intvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: int const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.intvec_t.size (method)
    size(self) -> size_t

ida_pro.intvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< int > &

ida_pro.intvec_t.truncate (method)
    truncate(self)

ida_pro.is_control_tty (function)
    is_control_tty(fd) -> enum tty_control_t
    Check if the current process is the owner of the TTY specified by 'fd'
    (typically an opened descriptor to /dev/tty).
    
    @param fd: (C++: int)

ida_pro.is_cvt64 (function)
    is_cvt64() -> bool
    is IDA converting IDB into I64?

ida_pro.is_main_thread (function)
    is_main_thread() -> bool
    Are we running in the main thread?

ida_pro.log2ceil (function)
    log2ceil(d64) -> int
    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 == 0
    
    @param d64: (C++: uint64)

ida_pro.log2floor (function)
    log2floor(d64) -> int
    
    @param d64: uint64

ida_pro.parse_dbgopts (function)
    parse_dbgopts(ido, r_switch) -> bool
    Parse the -r command line switch (for instant debugging). r_switch points to the
    value of the -r switch. Example: win32@localhost+
    
    @param ido: (C++: struct instant_dbgopts_t *) instant_dbgopts_t *
    @param r_switch: (C++: const char *) char const *
    @return: true-ok, false-parse error

ida_pro.qatoll (function)
    qatoll(nptr) -> int64
    
    @param nptr: char const *

ida_pro.qcontrol_tty (function)
    qcontrol_tty()
    Make the current terminal the controlling terminal of the calling process.
    @note: The current terminal is supposed to be /dev/tty

ida_pro.qdetach_tty (function)
    qdetach_tty()
    If the current terminal is the controlling terminal of the calling process, give
    up this controlling terminal.
    @note: The current terminal is supposed to be /dev/tty

ida_pro.qexit (function)
    qexit(code)
    Call qatexit functions, shut down UI and kernel, and exit.
    
    @param code: (C++: int) exit code

ida_pro.qmutex_locker_t (class)
    Proxy of C++ qmutex_locker_t class.

ida_pro.qmutex_locker_t.__init__ (method)
    __init__(self, _lock) -> qmutex_locker_t
    
    @param _lock: qmutex_t

ida_pro.qrefcnt_obj_t (class)
    Proxy of C++ qrefcnt_obj_t class.

ida_pro.qrefcnt_obj_t.__init__ (method)

ida_pro.qrefcnt_obj_t.refcnt (variable)
    counter

ida_pro.qrefcnt_obj_t.release (method)
    release(self)
    Call destructor. We use release() instead of operator delete() to maintain
    binary compatibility with all compilers (vc and gcc use different vtable layouts
    for operator delete)

ida_pro.qstrvec_t_add (function)
    qstrvec_t_add(_self, s) -> bool
    
    @param self: PyObject *
    @param s: char const *

ida_pro.qstrvec_t_addressof (function)
    qstrvec_t_addressof(_self, idx) -> PyObject *
    
    @param self: PyObject *
    @param idx: size_t

ida_pro.qstrvec_t_assign (function)
    qstrvec_t_assign(_self, other) -> bool
    
    @param self: PyObject *
    @param other: PyObject *

ida_pro.qstrvec_t_clear (function)
    qstrvec_t_clear(_self, qclear) -> bool
    
    @param self: PyObject *
    @param qclear: bool

ida_pro.qstrvec_t_create (function)
    qstrvec_t_create() -> PyObject *

ida_pro.qstrvec_t_destroy (function)
    qstrvec_t_destroy(py_obj) -> bool
    
    @param py_obj: PyObject *

ida_pro.qstrvec_t_from_list (function)
    qstrvec_t_from_list(_self, py_list) -> bool
    
    @param self: PyObject *
    @param py_list: PyObject *

ida_pro.qstrvec_t_get (function)
    qstrvec_t_get(_self, idx) -> PyObject *
    
    @param self: PyObject *
    @param idx: size_t

ida_pro.qstrvec_t_get_clink (function)
    qstrvec_t_get_clink(_self) -> qstrvec_t *
    
    @param self: PyObject *

ida_pro.qstrvec_t_get_clink_ptr (function)
    qstrvec_t_get_clink_ptr(_self) -> PyObject *
    
    @param self: PyObject *

ida_pro.qstrvec_t_insert (function)
    qstrvec_t_insert(_self, idx, s) -> bool
    
    @param self: PyObject *
    @param idx: size_t
    @param s: char const *

ida_pro.qstrvec_t_remove (function)
    qstrvec_t_remove(_self, idx) -> bool
    
    @param self: PyObject *
    @param idx: size_t

ida_pro.qstrvec_t_set (function)
    qstrvec_t_set(_self, idx, s) -> bool
    
    @param self: PyObject *
    @param idx: size_t
    @param s: char const *

ida_pro.qstrvec_t_size (function)
    qstrvec_t_size(_self) -> size_t
    
    @param self: PyObject *

ida_pro.qthread_equal (function)
    qthread_equal(q1, q2) -> bool
    Are two threads equal?
    
    @param q1: (C++: qthread_t)
    @param q2: (C++: qthread_t)

ida_pro.quote_cmdline_arg (function)
    quote_cmdline_arg(arg) -> bool
    Quote a command line argument if it contains escape characters. For example, *.c
    will be converted into "*.c" because * may be inadvertently expanded by the
    shell
    
    @param arg: (C++: qstring *)
    @return: true: modified 'arg'

ida_pro.qvector_reserve (function)
    qvector_reserve(vec, old, cnt, elsize) -> void *
    Change capacity of given qvector.
    
    @param vec: (C++: void *) a pointer to a qvector
    @param old: (C++: void *) a pointer to the qvector's array
    @param cnt: (C++: size_t) number of elements to reserve
    @param elsize: (C++: size_t) size of each element
    @return: a pointer to the newly allocated array

ida_pro.readbytes (function)
    readbytes(h, res, size, mf) -> int
    Read at most 4 bytes from file.
    
    @param h: (C++: int) file handle
    @param res: (C++: uint32 *) value read from file
    @param size: (C++: int) size of value in bytes (1,2,4)
    @param mf: (C++: bool) is MSB first?
    @return: 0 on success, nonzero otherwise

ida_pro.reloc_value (function)
    reloc_value(value, size, delta, mf)
    
    @param value: void *
    @param size: int
    @param delta: adiff_t
    @param mf: bool

ida_pro.relocate_relobj (function)
    relocate_relobj(_relobj, ea, mf) -> bool
    
    @param _relobj: relobj_t *
    @param ea: ea_t
    @param mf: bool

ida_pro.sel_array (class)
    Proxy of C++ sel_array class.

ida_pro.sel_array.__getitem__ (method)
    __getitem__(self, index) -> sel_t
    
    @param index: size_t

ida_pro.sel_array.__init__ (method)
    __init__(self, nelements) -> sel_array
    
    @param nelements: size_t

ida_pro.sel_array.__setitem__ (method)
    __setitem__(self, index, value)
    
    @param index: size_t
    @param value: sel_t

ida_pro.sel_array.cast (method)
    cast(self) -> sel_t *

ida_pro.sel_array.frompointer (method)
    frompointer(t) -> sel_array
    
    @param t: sel_t *

ida_pro.sel_array_frompointer (function)
    sel_array_frompointer(t) -> sel_array
    
    @param t: sel_t *

ida_pro.sel_pointer (class)
    Proxy of C++ sel_pointer class.

ida_pro.sel_pointer.__init__ (method)
    __init__(self) -> sel_pointer

ida_pro.sel_pointer.assign (method)
    assign(self, value)
    
    @param value: sel_t

ida_pro.sel_pointer.cast (method)
    cast(self) -> sel_t *

ida_pro.sel_pointer.frompointer (method)
    frompointer(t) -> sel_pointer
    
    @param t: sel_t *

ida_pro.sel_pointer.value (method)
    value(self) -> sel_t

ida_pro.sel_pointer_frompointer (function)
    sel_pointer_frompointer(t) -> sel_pointer
    
    @param t: sel_t *

ida_pro.sizevec_t (class)
    Proxy of C++ qvector< size_t > class.

ida_pro.sizevec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< size_t > const &

ida_pro.sizevec_t.__getitem__ (method)
    __getitem__(self, i) -> size_t const &
    
    @param i: size_t

ida_pro.sizevec_t.__init__ (method)
    __init__(self) -> sizevec_t
    __init__(self, x) -> sizevec_t
    
    @param x: qvector< size_t > const &

ida_pro.sizevec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.sizevec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< size_t > const &

ida_pro.sizevec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: size_t const &

ida_pro.sizevec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: size_t const &

ida_pro.sizevec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: size_t const &

ida_pro.sizevec_t.at (method)
    at(self, _idx) -> size_t const &
    
    @param _idx: size_t

ida_pro.sizevec_t.begin (method)
    begin(self) -> qvector< size_t >::iterator
    begin(self) -> qvector< size_t >::const_iterator

ida_pro.sizevec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.sizevec_t.clear (method)
    clear(self)

ida_pro.sizevec_t.empty (method)
    empty(self) -> bool

ida_pro.sizevec_t.end (method)
    end(self) -> qvector< size_t >::iterator
    end(self) -> qvector< size_t >::const_iterator

ida_pro.sizevec_t.erase (method)
    erase(self, it) -> qvector< size_t >::iterator
    
    @param it: qvector< size_t >::iterator
    
    erase(self, first, last) -> qvector< size_t >::iterator
    
    @param first: qvector< size_t >::iterator
    @param last: qvector< size_t >::iterator

ida_pro.sizevec_t.extract (method)
    extract(self) -> size_t *

ida_pro.sizevec_t.find (method)
    find(self, x) -> qvector< size_t >::iterator
    
    @param x: size_t const &
    
    find(self, x) -> qvector< size_t >::const_iterator
    
    @param x: size_t const &

ida_pro.sizevec_t.grow (method)
    grow(self, x=size_t())
    
    @param x: size_t const &

ida_pro.sizevec_t.has (method)
    has(self, x) -> bool
    
    @param x: size_t const &

ida_pro.sizevec_t.inject (method)
    inject(self, s, len)
    
    @param s: size_t *
    @param len: size_t

ida_pro.sizevec_t.insert (method)
    insert(self, it, x) -> qvector< size_t >::iterator
    
    @param it: qvector< size_t >::iterator
    @param x: size_t const &

ida_pro.sizevec_t.pop_back (method)
    pop_back(self)

ida_pro.sizevec_t.push_back (method)
    push_back(self, x)
    
    @param x: size_t const &
    
    push_back(self) -> size_t &

ida_pro.sizevec_t.qclear (method)
    qclear(self)

ida_pro.sizevec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.sizevec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: size_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.sizevec_t.size (method)
    size(self) -> size_t

ida_pro.sizevec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< size_t > &

ida_pro.sizevec_t.truncate (method)
    truncate(self)

ida_pro.str2user (function)
    str2user(str) -> str or None
    Insert C-style escape characters to string
    
    @param str: char const *
    @return: new string with escape characters inserted

ida_pro.strvec_t (class)
    Proxy of C++ qvector< simpleline_t > class.

ida_pro.strvec_t.__getitem__ (method)
    __getitem__(self, i) -> simpleline_t const &
    
    @param i: size_t

ida_pro.strvec_t.__init__ (method)
    __init__(self) -> strvec_t
    __init__(self, x) -> strvec_t
    
    @param x: qvector< simpleline_t > const &

ida_pro.strvec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.strvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: simpleline_t const &

ida_pro.strvec_t.at (method)
    at(self, _idx) -> simpleline_t const &
    
    @param _idx: size_t

ida_pro.strvec_t.begin (method)
    begin(self) -> qvector< simpleline_t >::iterator
    begin(self) -> qvector< simpleline_t >::const_iterator

ida_pro.strvec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.strvec_t.clear (method)
    clear(self)

ida_pro.strvec_t.empty (method)
    empty(self) -> bool

ida_pro.strvec_t.end (method)
    end(self) -> qvector< simpleline_t >::iterator
    end(self) -> qvector< simpleline_t >::const_iterator

ida_pro.strvec_t.erase (method)
    erase(self, it) -> qvector< simpleline_t >::iterator
    
    @param it: qvector< simpleline_t >::iterator
    
    erase(self, first, last) -> qvector< simpleline_t >::iterator
    
    @param first: qvector< simpleline_t >::iterator
    @param last: qvector< simpleline_t >::iterator

ida_pro.strvec_t.extract (method)
    extract(self) -> simpleline_t *

ida_pro.strvec_t.grow (method)
    grow(self, x=simpleline_t())
    
    @param x: simpleline_t const &

ida_pro.strvec_t.inject (method)
    inject(self, s, len)
    
    @param s: simpleline_t *
    @param len: size_t

ida_pro.strvec_t.insert (method)
    insert(self, it, x) -> qvector< simpleline_t >::iterator
    
    @param it: qvector< simpleline_t >::iterator
    @param x: simpleline_t const &

ida_pro.strvec_t.pop_back (method)
    pop_back(self)

ida_pro.strvec_t.push_back (method)
    push_back(self, x)
    
    @param x: simpleline_t const &
    
    push_back(self) -> simpleline_t &

ida_pro.strvec_t.qclear (method)
    qclear(self)

ida_pro.strvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.strvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: simpleline_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.strvec_t.size (method)
    size(self) -> size_t

ida_pro.strvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< simpleline_t > &

ida_pro.strvec_t.truncate (method)
    truncate(self)

ida_pro.sval_pointer (class)
    Proxy of C++ sval_pointer class.

ida_pro.sval_pointer.__init__ (method)
    __init__(self) -> sval_pointer

ida_pro.sval_pointer.assign (method)
    assign(self, value)
    
    @param value: sval_t

ida_pro.sval_pointer.cast (method)
    cast(self) -> sval_t *

ida_pro.sval_pointer.frompointer (method)
    frompointer(t) -> sval_pointer
    
    @param t: sval_t *

ida_pro.sval_pointer.value (method)
    value(self) -> sval_t

ida_pro.sval_pointer_frompointer (function)
    sval_pointer_frompointer(t) -> sval_pointer
    
    @param t: sval_t *

ida_pro.tid_array (class)
    Proxy of C++ tid_array class.

ida_pro.tid_array.__getitem__ (method)
    __getitem__(self, index) -> tid_t
    
    @param index: size_t

ida_pro.tid_array.__init__ (method)
    __init__(self, nelements) -> tid_array
    
    @param nelements: size_t

ida_pro.tid_array.__setitem__ (method)
    __setitem__(self, index, value)
    
    @param index: size_t
    @param value: tid_t

ida_pro.tid_array.cast (method)
    cast(self) -> tid_t *

ida_pro.tid_array.frompointer (method)
    frompointer(t) -> tid_array
    
    @param t: tid_t *

ida_pro.tid_array_frompointer (function)
    tid_array_frompointer(t) -> tid_array
    
    @param t: tid_t *

ida_pro.uchar_array (class)
    Proxy of C++ uchar_array class.

ida_pro.uchar_array.__getitem__ (method)
    __getitem__(self, index) -> uchar
    
    @param index: size_t

ida_pro.uchar_array.__init__ (method)
    __init__(self, nelements) -> uchar_array
    
    @param nelements: size_t

ida_pro.uchar_array.__setitem__ (method)
    __setitem__(self, index, value)
    
    @param index: size_t
    @param value: uchar

ida_pro.uchar_array.cast (method)
    cast(self) -> uchar *

ida_pro.uchar_array.frompointer (method)
    frompointer(t) -> uchar_array
    
    @param t: uchar *

ida_pro.uchar_array_frompointer (function)
    uchar_array_frompointer(t) -> uchar_array
    
    @param t: uchar *

ida_pro.uint64vec_t (class)
    Proxy of C++ qvector< unsigned long long > class.

ida_pro.uint64vec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< unsigned long long > const &

ida_pro.uint64vec_t.__getitem__ (method)
    __getitem__(self, i) -> unsigned long long const &
    
    @param i: size_t

ida_pro.uint64vec_t.__init__ (method)
    __init__(self) -> uint64vec_t
    __init__(self, x) -> uint64vec_t
    
    @param x: qvector< unsigned long long > const &

ida_pro.uint64vec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.uint64vec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< unsigned long long > const &

ida_pro.uint64vec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned long long const &

ida_pro.uint64vec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: unsigned long long const &

ida_pro.uint64vec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: unsigned long long const &

ida_pro.uint64vec_t.at (method)
    at(self, _idx) -> unsigned long long const &
    
    @param _idx: size_t

ida_pro.uint64vec_t.begin (method)
    begin(self) -> qvector< unsigned long long >::iterator
    begin(self) -> qvector< unsigned long long >::const_iterator

ida_pro.uint64vec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.uint64vec_t.clear (method)
    clear(self)

ida_pro.uint64vec_t.empty (method)
    empty(self) -> bool

ida_pro.uint64vec_t.end (method)
    end(self) -> qvector< unsigned long long >::iterator
    end(self) -> qvector< unsigned long long >::const_iterator

ida_pro.uint64vec_t.erase (method)
    erase(self, it) -> qvector< unsigned long long >::iterator
    
    @param it: qvector< unsigned long long >::iterator
    
    erase(self, first, last) -> qvector< unsigned long long >::iterator
    
    @param first: qvector< unsigned long long >::iterator
    @param last: qvector< unsigned long long >::iterator

ida_pro.uint64vec_t.extract (method)
    extract(self) -> unsigned long long *

ida_pro.uint64vec_t.find (method)
    find(self, x) -> qvector< unsigned long long >::iterator
    
    @param x: unsigned long long const &
    
    find(self, x) -> qvector< unsigned long long >::const_iterator
    
    @param x: unsigned long long const &

ida_pro.uint64vec_t.has (method)
    has(self, x) -> bool
    
    @param x: unsigned long long const &

ida_pro.uint64vec_t.inject (method)
    inject(self, s, len)
    
    @param s: unsigned long long *
    @param len: size_t

ida_pro.uint64vec_t.insert (method)
    insert(self, it, x) -> qvector< unsigned long long >::iterator
    
    @param it: qvector< unsigned long long >::iterator
    @param x: unsigned long long const &

ida_pro.uint64vec_t.pop_back (method)
    pop_back(self)

ida_pro.uint64vec_t.push_back (method)
    push_back(self, x)
    
    @param x: unsigned long long const &
    
    push_back(self) -> unsigned long long &

ida_pro.uint64vec_t.qclear (method)
    qclear(self)

ida_pro.uint64vec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.uint64vec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: unsigned long long const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.uint64vec_t.size (method)
    size(self) -> size_t

ida_pro.uint64vec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< unsigned long long > &

ida_pro.uint64vec_t.truncate (method)
    truncate(self)

ida_pro.uintvec_t (class)
    Proxy of C++ qvector< unsigned int > class.

ida_pro.uintvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< unsigned int > const &

ida_pro.uintvec_t.__getitem__ (method)
    __getitem__(self, i) -> unsigned int const &
    
    @param i: size_t

ida_pro.uintvec_t.__init__ (method)
    __init__(self) -> uintvec_t
    __init__(self, x) -> uintvec_t
    
    @param x: qvector< unsigned int > const &

ida_pro.uintvec_t.__len__ (method)
    __len__(self) -> size_t

ida_pro.uintvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< unsigned int > const &

ida_pro.uintvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned int const &

ida_pro.uintvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: unsigned int const &

ida_pro.uintvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: unsigned int const &

ida_pro.uintvec_t.at (method)
    at(self, _idx) -> unsigned int const &
    
    @param _idx: size_t

ida_pro.uintvec_t.begin (method)
    begin(self) -> qvector< unsigned int >::iterator
    begin(self) -> qvector< unsigned int >::const_iterator

ida_pro.uintvec_t.capacity (method)
    capacity(self) -> size_t

ida_pro.uintvec_t.clear (method)
    clear(self)

ida_pro.uintvec_t.empty (method)
    empty(self) -> bool

ida_pro.uintvec_t.end (method)
    end(self) -> qvector< unsigned int >::iterator
    end(self) -> qvector< unsigned int >::const_iterator

ida_pro.uintvec_t.erase (method)
    erase(self, it) -> qvector< unsigned int >::iterator
    
    @param it: qvector< unsigned int >::iterator
    
    erase(self, first, last) -> qvector< unsigned int >::iterator
    
    @param first: qvector< unsigned int >::iterator
    @param last: qvector< unsigned int >::iterator

ida_pro.uintvec_t.extract (method)
    extract(self) -> unsigned int *

ida_pro.uintvec_t.find (method)
    find(self, x) -> qvector< unsigned int >::iterator
    
    @param x: unsigned int const &
    
    find(self, x) -> qvector< unsigned int >::const_iterator
    
    @param x: unsigned int const &

ida_pro.uintvec_t.has (method)
    has(self, x) -> bool
    
    @param x: unsigned int const &

ida_pro.uintvec_t.inject (method)
    inject(self, s, len)
    
    @param s: unsigned int *
    @param len: size_t

ida_pro.uintvec_t.insert (method)
    insert(self, it, x) -> qvector< unsigned int >::iterator
    
    @param it: qvector< unsigned int >::iterator
    @param x: unsigned int const &

ida_pro.uintvec_t.pop_back (method)
    pop_back(self)

ida_pro.uintvec_t.push_back (method)
    push_back(self, x)
    
    @param x: unsigned int const &
    
    push_back(self) -> unsigned int &

ida_pro.uintvec_t.qclear (method)
    qclear(self)

ida_pro.uintvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_pro.uintvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: unsigned int const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_pro.uintvec_t.size (method)
    size(self) -> size_t

ida_pro.uintvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< unsigned int > &

ida_pro.uintvec_t.truncate (method)
    truncate(self)

ida_pro.uval_array (class)
    Proxy of C++ uval_array class.

ida_pro.uval_array.__getitem__ (method)
    __getitem__(self, index) -> uval_t
    
    @param index: size_t

ida_pro.uval_array.__init__ (method)
    __init__(self, nelements) -> uval_array
    
    @param nelements: size_t

ida_pro.uval_array.__setitem__ (method)
    __setitem__(self, index, value)
    
    @param index: size_t
    @param value: uval_t

ida_pro.uval_array.cast (method)
    cast(self) -> uval_t *

ida_pro.uval_array.frompointer (method)
    frompointer(t) -> uval_array
    
    @param t: uval_t *

ida_pro.uval_array_frompointer (function)
    uval_array_frompointer(t) -> uval_array
    
    @param t: uval_t *

ida_pro.writebytes (function)
    writebytes(h, l, size, mf) -> int
    Write at most 4 bytes to file.
    
    @param h: (C++: int) file handle
    @param l: (C++: uint32) value to write
    @param size: (C++: int) size of value in bytes (1,2,4)
    @param mf: (C++: bool) is MSB first?
    @return: 0 on success, nonzero otherwise

ida_problems (module)
    Functions that deal with the list of problems.
    
    There are several problem lists. An address may be inserted to any list. The
    kernel simply maintains these lists, no additional processing is done.
    
    The problem lists are accessible for the user from the View->Subviews->Problems
    menu item.
    
    Addresses in the lists are kept sorted. In general IDA just maintains these
    lists without using them during analysis (except PR_ROLLED).

ida_problems.PR_ATTN (variable)
    Attention! Probably erroneous situation.

ida_problems.PR_BADSTACK (variable)
    Failed to trace the value of the stack pointer.

ida_problems.PR_COLLISION (variable)
    FLAIR collision: the function with the given name already exists.

ida_problems.PR_DECIMP (variable)
    FLAIR match indecision: the patterns matched, but not the function(s) being
    referenced.

ida_problems.PR_DISASM (variable)
    Can't disasm.

ida_problems.PR_END (variable)
    Number of problem types.

ida_problems.PR_FINAL (variable)
    Decision to convert to instruction/data is made by IDA.

ida_problems.PR_HEAD (variable)
    Already head.

ida_problems.PR_ILLADDR (variable)
    Exec flows beyond limits.

ida_problems.PR_JUMP (variable)
    Jump by table !!!! ignored.

ida_problems.PR_MANYLINES (variable)
    Too many lines.

ida_problems.PR_NOBASE (variable)
    Can't find offset base.

ida_problems.PR_NOCMT (variable)
    Can't find comment (not used anymore)

ida_problems.PR_NOFOP (variable)
    Can't find forced op (not used anymore)

ida_problems.PR_NONAME (variable)
    Can't find name.

ida_problems.PR_NOXREFS (variable)
    Can't find references.

ida_problems.PR_ROLLED (variable)
    The decision made by IDA was wrong and rolled back.

ida_problems.forget_problem (function)
    forget_problem(type, ea) -> bool
    Remove an address from a problem list
    
    @param type: (C++: problist_id_t) problem list type
    @param ea: (C++: ea_t) linear address
    @return: success

ida_problems.get_problem (function)
    get_problem(type, lowea) -> ea_t
    Get an address from the specified problem list. The address is not removed from
    the list.
    
    @param type: (C++: problist_id_t) problem list type
    @param lowea: (C++: ea_t) the returned address will be higher or equal than the specified
                  address
    @return: linear address or BADADDR

ida_problems.get_problem_desc (function)
    get_problem_desc(t, ea) -> str
    Get the human-friendly description of the problem, if one was provided to
    remember_problem.
    
    @param t: (C++: problist_id_t) problem list type.
    @param ea: (C++: ea_t) linear address.
    @return: the message length or -1 if none

ida_problems.get_problem_name (function)
    get_problem_name(type, longname=True) -> char const *
    Get problem list description.
    
    @param type: (C++: problist_id_t)
    @param longname: (C++: bool)

ida_problems.is_problem_present (function)
    is_problem_present(t, ea) -> bool
    Check if the specified address is present in the problem list.
    
    @param t: (C++: problist_id_t)
    @param ea: (C++: ea_t)

ida_problems.remember_problem (function)
    remember_problem(type, ea, msg=None)
    Insert an address to a list of problems. Display a message saying about the
    problem (except of PR_ATTN,PR_FINAL) PR_JUMP is temporarily ignored.
    
    @param type: (C++: problist_id_t) problem list type
    @param ea: (C++: ea_t) linear address
    @param msg: (C++: const char *) a user-friendly message to be displayed instead of the default more
                generic one associated with the type of problem. Defaults to
                nullptr.

ida_problems.was_ida_decision (function)
    was_ida_decision(ea) -> bool
    
    @param ea: ea_t

ida_range (module)
    Contains the definition of range_t.
    
    A range is a non-empty continuous range of addresses (specified by its start and
    end addresses, the end address is excluded from the range).
    
    Ranges are stored in the Btree part of the IDA database. To learn more about
    Btrees (Balanced Trees): \link{http://www.bluerwhite.org/btree/}

ida_range.RANGE_KIND_FUNC (variable)
    func_t

ida_range.RANGE_KIND_HIDDEN_RANGE (variable)
    hidden_range_t

ida_range.RANGE_KIND_SEGMENT (variable)
    segment_t

ida_range.array_of_rangesets (class)
    Proxy of C++ qvector< rangeset_t > class.

ida_range.array_of_rangesets.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< rangeset_t > const &

ida_range.array_of_rangesets.__getitem__ (method)
    __getitem__(self, i) -> rangeset_t
    
    @param i: size_t

ida_range.array_of_rangesets.__init__ (method)
    __init__(self) -> array_of_rangesets
    __init__(self, x) -> array_of_rangesets
    
    @param x: qvector< rangeset_t > const &

ida_range.array_of_rangesets.__len__ (method)
    __len__(self) -> size_t

ida_range.array_of_rangesets.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< rangeset_t > const &

ida_range.array_of_rangesets.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: rangeset_t const &

ida_range.array_of_rangesets._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: rangeset_t const &

ida_range.array_of_rangesets.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: rangeset_t const &

ida_range.array_of_rangesets.at (method)
    at(self, _idx) -> rangeset_t
    
    @param _idx: size_t

ida_range.array_of_rangesets.begin (method)
    begin(self) -> rangeset_t

ida_range.array_of_rangesets.capacity (method)
    capacity(self) -> size_t

ida_range.array_of_rangesets.clear (method)
    clear(self)

ida_range.array_of_rangesets.empty (method)
    empty(self) -> bool

ida_range.array_of_rangesets.end (method)
    end(self) -> rangeset_t

ida_range.array_of_rangesets.erase (method)
    erase(self, it) -> rangeset_t
    
    @param it: qvector< rangeset_t >::iterator
    
    erase(self, first, last) -> rangeset_t
    
    @param first: qvector< rangeset_t >::iterator
    @param last: qvector< rangeset_t >::iterator

ida_range.array_of_rangesets.extract (method)
    extract(self) -> rangeset_t

ida_range.array_of_rangesets.find (method)
    find(self, x) -> rangeset_t
    
    @param x: rangeset_t const &

ida_range.array_of_rangesets.grow (method)
    grow(self, x=rangeset_t())
    
    @param x: rangeset_t const &

ida_range.array_of_rangesets.has (method)
    has(self, x) -> bool
    
    @param x: rangeset_t const &

ida_range.array_of_rangesets.inject (method)
    inject(self, s, len)
    
    @param s: rangeset_t *
    @param len: size_t

ida_range.array_of_rangesets.insert (method)
    insert(self, it, x) -> rangeset_t
    
    @param it: qvector< rangeset_t >::iterator
    @param x: rangeset_t const &

ida_range.array_of_rangesets.pop_back (method)
    pop_back(self)

ida_range.array_of_rangesets.push_back (method)
    push_back(self, x)
    
    @param x: rangeset_t const &
    
    push_back(self) -> rangeset_t

ida_range.array_of_rangesets.qclear (method)
    qclear(self)

ida_range.array_of_rangesets.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_range.array_of_rangesets.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: rangeset_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_range.array_of_rangesets.size (method)
    size(self) -> size_t

ida_range.array_of_rangesets.swap (method)
    swap(self, r)
    
    @param r: qvector< rangeset_t > &

ida_range.array_of_rangesets.truncate (method)
    truncate(self)

ida_range.range_t (class)
    Proxy of C++ range_t class.

ida_range.range_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.__init__ (method)
    __init__(self, ea1=0, ea2=0) -> range_t
    
    @param ea1: ea_t
    @param ea2: ea_t

ida_range.range_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t._print (method)
    _print(self) -> size_t

ida_range.range_t.clear (method)
    clear(self)
    Set start_ea, end_ea to 0.

ida_range.range_t.compare (method)
    compare(self, r) -> int
    
    @param r: range_t const &

ida_range.range_t.contains (method)
    contains(self, ea) -> bool
    Is every ea in 'r' also in this range_t?
    
    @param ea: ea_t
    
    contains(self, r) -> bool
    
    @param r: range_t const &

ida_range.range_t.empty (method)
    empty(self) -> bool
    Is the size of the range_t <= 0?

ida_range.range_t.end_ea (variable)
    end_ea excluded

ida_range.range_t.extend (method)
    extend(self, ea)
    Ensure that the range_t includes 'ea'.
    
    @param ea: (C++: ea_t)

ida_range.range_t.intersect (method)
    intersect(self, r)
    Assign the range_t to the intersection between the range_t and 'r'.
    
    @param r: (C++: const range_t &) range_t const &

ida_range.range_t.overlaps (method)
    overlaps(self, r) -> bool
    Is there an ea in 'r' that is also in this range_t?
    
    @param r: (C++: const range_t &) range_t const &

ida_range.range_t.size (method)
    size(self) -> asize_t
    Get end_ea - start_ea.

ida_range.range_t.start_ea (variable)
    start_ea included

ida_range.range_t_print (function)
    range_t_print(cb) -> str
    Helper function. Should not be called directly!
    
    @param cb: range_t const *

ida_range.rangeset_t (class)
    Proxy of C++ rangeset_t class.

ida_range.rangeset_t.__eq__ (method)
    __eq__(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t.__getitem__ (method)

ida_range.rangeset_t.__init__ (method)
    __init__(self) -> rangeset_t
    __init__(self, range) -> rangeset_t
    
    @param range: range_t const &
    
    __init__(self, ivs) -> rangeset_t
    
    @param ivs: rangeset_t const &

ida_range.rangeset_t.__ne__ (method)
    __ne__(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t._print (method)
    _print(self) -> size_t

ida_range.rangeset_t.add (method)
    add(self, range) -> bool
    Add each element of 'aset' to the set.
    
    @param range: range_t const &
    
    @return: false if no elements were added (the set was unchanged)
    add(self, start, _end) -> bool
    
    @param start: ea_t
    @param _end: ea_t
    
    add(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t.begin (method)
    begin(self) -> range_t
    Get an iterator that points to the first element in the set.

ida_range.rangeset_t.cached_range (method)
    cached_range(self) -> range_t
    When searching the rangeset, we keep a cached element to help speed up searches.
    
    @return: a pointer to the cached element

ida_range.rangeset_t.clear (method)
    clear(self)
    Delete all elements from the set. See qvector::clear()

ida_range.rangeset_t.contains (method)
    contains(self, ea) -> bool
    Is every element in 'aset' contained in an element of this rangeset?. See
    range_t::contains(range_t)
    
    @param ea: ea_t
    
    contains(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t.empty (method)
    empty(self) -> bool
    Does the set have zero elements.

ida_range.rangeset_t.end (method)
    end(self) -> range_t
    Get an iterator that points to the end of the set. (This is NOT the last
    element)

ida_range.rangeset_t.find_range (method)
    find_range(self, ea) -> range_t
    Get the element from the set that contains 'ea'.
    
    @param ea: (C++: ea_t)
    @return: nullptr if there is no such element

ida_range.rangeset_t.getrange (method)
    getrange(self, idx) -> range_t
    Get the range_t at index 'idx'.
    
    @param idx: (C++: int)

ida_range.rangeset_t.has_common (method)
    has_common(self, range) -> bool
    Does any element of 'aset' overlap with an element in this rangeset?. See
    range_t::overlaps()
    
    @param range: range_t const &
    
    has_common(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t.includes (method)
    includes(self, range) -> bool
    Is every ea in 'range' contained in the rangeset?
    
    @param range: (C++: const range_t &) range_t const &

ida_range.rangeset_t.intersect (method)
    intersect(self, aset) -> bool
    Set the rangeset to its intersection with 'aset'.
    
    @param aset: (C++: const rangeset_t &) rangeset_t const &
    @return: false if the set was unchanged

ida_range.rangeset_t.is_equal (method)
    is_equal(self, aset) -> bool
    Do this rangeset and 'aset' have identical elements?
    
    @param aset: (C++: const rangeset_t &) rangeset_t const &

ida_range.rangeset_t.is_subset_of (method)
    is_subset_of(self, aset) -> bool
    Is every element in the rangeset contained in an element of 'aset'?
    
    @param aset: (C++: const rangeset_t &) rangeset_t const &

ida_range.rangeset_t.lastrange (method)
    lastrange(self) -> range_t
    Get the last range_t in the set.

ida_range.rangeset_t.next_addr (method)
    next_addr(self, ea) -> ea_t
    Get the smallest ea_t value greater than 'ea' contained in the rangeset.
    
    @param ea: (C++: ea_t)

ida_range.rangeset_t.next_range (method)
    next_range(self, ea) -> ea_t
    Get the smallest ea_t value greater than 'ea' that is not in the same range as
    'ea'.
    
    @param ea: (C++: ea_t)

ida_range.rangeset_t.nranges (method)
    nranges(self) -> size_t
    Get the number of range_t elements in the set.

ida_range.rangeset_t.prev_addr (method)
    prev_addr(self, ea) -> ea_t
    Get the largest ea_t value less than 'ea' contained in the rangeset.
    
    @param ea: (C++: ea_t)

ida_range.rangeset_t.prev_range (method)
    prev_range(self, ea) -> ea_t
    Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.
    
    @param ea: (C++: ea_t)

ida_range.rangeset_t.sub (method)
    sub(self, range) -> bool
    Subtract each range in 'aset' from the set
    
    @param range: range_t const &
    
    @return: false if nothing was subtracted (the set was unchanged)
    sub(self, ea) -> bool
    
    @param ea: ea_t
    
    sub(self, aset) -> bool
    
    @param aset: rangeset_t const &

ida_range.rangeset_t.swap (method)
    swap(self, r)
    Set this = 'r' and 'r' = this. See qvector::swap()
    
    @param r: (C++: rangeset_t &)

ida_range.rangevec_base_t (class)
    Proxy of C++ qvector< range_t > class.

ida_range.rangevec_base_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< range_t > const &

ida_range.rangevec_base_t.__getitem__ (method)
    __getitem__(self, i) -> range_t
    
    @param i: size_t

ida_range.rangevec_base_t.__init__ (method)
    __init__(self) -> rangevec_base_t
    __init__(self, x) -> rangevec_base_t
    
    @param x: qvector< range_t > const &

ida_range.rangevec_base_t.__len__ (method)
    __len__(self) -> size_t

ida_range.rangevec_base_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< range_t > const &

ida_range.rangevec_base_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: range_t const &

ida_range.rangevec_base_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: range_t const &

ida_range.rangevec_base_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: range_t const &

ida_range.rangevec_base_t.at (method)
    at(self, _idx) -> range_t
    
    @param _idx: size_t

ida_range.rangevec_base_t.begin (method)
    begin(self) -> range_t

ida_range.rangevec_base_t.capacity (method)
    capacity(self) -> size_t

ida_range.rangevec_base_t.clear (method)
    clear(self)

ida_range.rangevec_base_t.empty (method)
    empty(self) -> bool

ida_range.rangevec_base_t.end (method)
    end(self) -> range_t

ida_range.rangevec_base_t.erase (method)
    erase(self, it) -> range_t
    
    @param it: qvector< range_t >::iterator
    
    erase(self, first, last) -> range_t
    
    @param first: qvector< range_t >::iterator
    @param last: qvector< range_t >::iterator

ida_range.rangevec_base_t.extract (method)
    extract(self) -> range_t

ida_range.rangevec_base_t.find (method)
    find(self, x) -> range_t
    
    @param x: range_t const &

ida_range.rangevec_base_t.grow (method)
    grow(self, x=range_t())
    
    @param x: range_t const &

ida_range.rangevec_base_t.has (method)
    has(self, x) -> bool
    
    @param x: range_t const &

ida_range.rangevec_base_t.inject (method)
    inject(self, s, len)
    
    @param s: range_t *
    @param len: size_t

ida_range.rangevec_base_t.insert (method)
    insert(self, it, x) -> range_t
    
    @param it: qvector< range_t >::iterator
    @param x: range_t const &

ida_range.rangevec_base_t.pop_back (method)
    pop_back(self)

ida_range.rangevec_base_t.push_back (method)
    push_back(self, x)
    
    @param x: range_t const &
    
    push_back(self) -> range_t

ida_range.rangevec_base_t.qclear (method)
    qclear(self)

ida_range.rangevec_base_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_range.rangevec_base_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: range_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_range.rangevec_base_t.size (method)
    size(self) -> size_t

ida_range.rangevec_base_t.swap (method)
    swap(self, r)
    
    @param r: qvector< range_t > &

ida_range.rangevec_base_t.truncate (method)
    truncate(self)

ida_range.rangevec_t (class)
    Proxy of C++ rangevec_t class.

ida_range.rangevec_t.__init__ (method)
    __init__(self) -> rangevec_t

ida_registry (module)
    Registry related functions.
    
    IDA uses the registry to store global configuration options that must persist
    after IDA has been closed.
    
    On Windows, IDA uses the Windows registry directly. On Unix systems, the
    registry is stored in a file (typically ~/.idapro/ida.reg).
    
    The root key for accessing IDA settings in the registry is defined by
    ROOT_KEY_NAME.

ida_registry.ROOT_KEY_NAME (variable)
    Default key used to store IDA settings in registry (Windows version).
    @note: this name is automatically prepended to all key names passed to functions
           in this file.

ida_registry.reg_binary (variable)
    binary data

ida_registry.reg_data_type (function)
    reg_data_type(name, subkey=None) -> regval_type_t
    Get data type of a given value.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @return: false if the [key+]value doesn't exist

ida_registry.reg_delete (function)
    reg_delete(name, subkey=None) -> bool
    Delete a value from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) parent key
    @return: success

ida_registry.reg_delete_subkey (function)
    reg_delete_subkey(name) -> bool
    Delete a key from the registry.
    
    @param name: (C++: const char *) char const *

ida_registry.reg_delete_tree (function)
    reg_delete_tree(name) -> bool
    Delete a subtree from the registry.
    
    @param name: (C++: const char *) char const *

ida_registry.reg_dword (variable)
    32-bit number

ida_registry.reg_exists (function)
    reg_exists(name, subkey=None) -> bool
    Is there already a value with the given name?
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) parent key

ida_registry.reg_flush (function)
    reg_flush()

ida_registry.reg_load (function)
    reg_load()

ida_registry.reg_read_binary (function)
    reg_read_binary(name, subkey=None) -> bytes or None
    Read binary data from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @return: success

ida_registry.reg_read_bool (function)
    reg_read_bool(name, defval, subkey=None) -> bool
    Read boolean value from the registry.
    
    @param name: (C++: const char *) value name
    @param defval: (C++: bool) default value
    @param subkey: (C++: const char *) key name
    @return: boolean read from registry, or 'defval' if the read failed

ida_registry.reg_read_int (function)
    reg_read_int(name, defval, subkey=None) -> int
    Read integer value from the registry.
    
    @param name: (C++: const char *) value name
    @param defval: (C++: int) default value
    @param subkey: (C++: const char *) key name
    @return: the value read from the registry, or 'defval' if the read failed

ida_registry.reg_read_string (function)
    reg_read_string(name, subkey=None, _def=None) -> str
    Read a string from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @param def: char const *
    @return: success

ida_registry.reg_read_strlist (function)
    reg_read_strlist(subkey)
    Retrieve all string values associated with the given key. Also see
    reg_update_strlist().
    
    @param subkey: (C++: const char *) char const *

ida_registry.reg_subkey_exists (function)
    reg_subkey_exists(name) -> bool
    Is there already a key with the given name?
    
    @param name: (C++: const char *) char const *

ida_registry.reg_subkey_subkeys (function)
    reg_subkey_subkeys(name) -> [str, ...]
    Get all subkey names of given key.
    
    @param name: (C++: const char *) char const *

ida_registry.reg_subkey_values (function)
    reg_subkey_values(name) -> [str, ...]
    Get all value names under given key.
    
    @param name: (C++: const char *) char const *

ida_registry.reg_sz (variable)
    utf8 string

ida_registry.reg_unknown (variable)
    unknown

ida_registry.reg_update_filestrlist (function)
    reg_update_filestrlist(subkey, add, maxrecs, rem=None)
    Update registry with a file list. Case sensitivity will vary depending on the
    target OS.
    @note: 'add' and 'rem' must be UTF-8, just like for regular string operations.
    
    @param subkey: (C++: const char *) char const *
    @param add: (C++: const char *) char const *
    @param maxrecs: (C++: size_t)
    @param rem: (C++: const char *) char const *

ida_registry.reg_update_strlist (function)
    reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)
    Update list of strings associated with given key.
    
    @param subkey: (C++: const char *) key name
    @param add: (C++: const char *) string to be added to list, can be nullptr
    @param maxrecs: (C++: size_t) limit list to this size
    @param rem: (C++: const char *) string to be removed from list, can be nullptr
    @param ignorecase: (C++: bool) ignore case for 'add' and 'rem'

ida_registry.reg_write_binary (function)
    reg_write_binary(name, py_bytes, subkey=None) -> PyObject *
    Write binary data to the registry.
    
    @param name: (C++: const char *) value name
    @param py_bytes: PyObject *
    @param subkey: (C++: const char *) key name

ida_registry.reg_write_bool (function)
    reg_write_bool(name, value, subkey=None)
    Write boolean value to the registry.
    
    @param name: (C++: const char *) value name
    @param value: (C++: int) boolean to write (nonzero = true)
    @param subkey: (C++: const char *) key name

ida_registry.reg_write_int (function)
    reg_write_int(name, value, subkey=None)
    Write integer value to the registry.
    
    @param name: (C++: const char *) value name
    @param value: (C++: int) value to write
    @param subkey: (C++: const char *) key name

ida_registry.reg_write_string (function)
    reg_write_string(name, utf8, subkey=None)
    Write a string to the registry.
    
    @param name: (C++: const char *) value name
    @param utf8: (C++: const char *) utf8-encoded string
    @param subkey: (C++: const char *) key name

ida_registry.set_registry_root (function)
    set_registry_root(name) -> bool
    
    @param name: char const *

ida_regfinder (module)
    

ida_regfinder.find_nearest_rvi (function)
    find_nearest_rvi(rvi, ea, reg) -> int
    Find the value of any of the two registers using the register tracker. First,
    this function tries to find the registers in the basic block of EA, and if it
    could not do this, then it tries to find in the entire function.
    
    @param rvi: (C++: reg_value_info_t *) the found value with additional attributes
    @param ea: (C++: ea_t) the address to find a value at
    @param reg: (C++: const int) the registers to find
    @return: the index of the found register or -1

ida_regfinder.find_reg_value (function)
    find_reg_value(ea, reg) -> int
    Find register value using the register tracker.
    @note: The returned value is valid *before* executing the instruction.
    
    @param ea: (C++: ea_t) the address to find a value at
    @param reg: (C++: int) the register to find
    @retval 0: no value (the value is varying or the find depth is not enough to
               find a value)
    @retval 1: the found value is in VAL
    @retval -1: the processor module does not support a register tracker

ida_regfinder.find_reg_value_info (function)
    find_reg_value_info(rvi, ea, reg, max_depth=0) -> bool
    Find register value using the register tracker.
    @note: The returned value is valid *before* executing the instruction.
    @note: The _undefined_ value means that there is no execution flow to EA, e.g.
           we try to find a value after the call of NORET function.
    @note: The _unknown_ value means that the value is:
    * a result of unsupported instruction, e.g. the result of a call,
    * a function argument,
    * is varying, e.g. it is a loop counter.
    
    @param rvi: (C++: reg_value_info_t *) the found value with additional attributes
    @param ea: (C++: ea_t) the address to find a value at
    @param reg: (C++: int) the register to find
    @param max_depth: (C++: int) the number of basic blocks to look before aborting the search
                      and returning the unknown value. 0 means the value of
                      REGTRACK_MAX_DEPTH from ida.cfg for ordinal registers or
                      REGTRACK_FUNC_MAX_DEPTH for the function-wide registers, -1
                      means the value of REGTRACK_FUNC_MAX_DEPTH from ida.cfg.
    @retval 'false': the processor module does not support a register tracker
    @retval 'true': the found value is in RVI

ida_regfinder.find_sp_value (function)
    find_sp_value(ea, reg=-1) -> int
    Find a value of the SP based register using the register tracker.
    @note: The returned value is valid *before* executing the instruction.
    
    @param ea: (C++: ea_t) the address to find a value at
    @param reg: (C++: int) the register to find. by default the SP register is used.
    @retval 0: no value (the value is varying or the find depth is not enough to
               find a value)
    @retval 1: the found value is in VAL
    @retval -1: the processor module does not support a register tracker

ida_regfinder.invalidate_regfinder_cache (function)
    invalidate_regfinder_cache(ea=BADADDR)
    Remove from the register tracker cache all values at EA and all dependent
    values. As if the control flow to this instruction has changed. if EA == BADADDR
    then clear the entire cache.
    
    @param ea: (C++: ea_t)

ida_regfinder.reg_value_def_t (class)
    Proxy of C++ reg_value_def_t class.

ida_regfinder.reg_value_def_t.LIKE_GOT (variable)
    the value is like GOT only for numbers
    @see: is_num()

ida_regfinder.reg_value_def_t.NOVAL (variable)
    without a value

ida_regfinder.reg_value_def_t.PC_BASED (variable)
    the value depends on DEF_EA only for numbers
    @see: is_num()

ida_regfinder.reg_value_def_t.SHORT_INSN (variable)
    like 'addi reg, imm'

ida_regfinder.reg_value_def_t.SPVAL (variable)
    as a SP delta

ida_regfinder.reg_value_def_t.UVAL (variable)
    as a number

ida_regfinder.reg_value_def_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: reg_value_def_t const &

ida_regfinder.reg_value_def_t.__init__ (method)
    __init__(self) -> reg_value_def_t
    __init__(self, _val, ea, _flags=0) -> reg_value_def_t
    
    @param _val: uval_t
    @param ea: ea_t
    @param _flags: uint16
    
    __init__(self, _val, insn, _flags=0) -> reg_value_def_t
    
    @param _val: uval_t
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param _flags: uint16

ida_regfinder.reg_value_def_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: reg_value_def_t const &

ida_regfinder.reg_value_def_t.def_ea (variable)
    the instruction address

ida_regfinder.reg_value_def_t.def_itype (variable)
    the instruction code (processor specific)

ida_regfinder.reg_value_def_t.dstr (method)
    dstr(self, how, pm=None) -> qstring
    Return the string representation.
    
    @param how: (C++: dstr_val_t) enum reg_value_def_t::dstr_val_t
    @param pm: (C++: const procmod_t *) procmod_t const *

ida_regfinder.reg_value_def_t.flags (variable)
    additional info about the value

ida_regfinder.reg_value_def_t.is_like_got (method)
    is_like_got(self) -> bool

ida_regfinder.reg_value_def_t.is_pc_based (method)
    is_pc_based(self) -> bool

ida_regfinder.reg_value_def_t.is_short_insn (method)
    is_short_insn(self, insn) -> bool
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    
    is_short_insn(self) -> bool

ida_regfinder.reg_value_def_t.val (variable)
    the value

ida_regfinder.reg_value_info_t (class)
    Proxy of C++ reg_value_info_t class.

ida_regfinder.reg_value_info_t.CONTAINED (variable)
    L is contained in R (i.e. L\R is empty)

ida_regfinder.reg_value_info_t.CONTAINS (variable)
    L contains R (i.e. R\L is empty)

ida_regfinder.reg_value_info_t.EQUAL (variable)
    L==R.

ida_regfinder.reg_value_info_t.NOT_COMPARABLE (variable)
    L\R is not empty and R\L is not empty.

ida_regfinder.reg_value_info_t.__getitem__ (method)
    __getitem__(self, i) -> reg_value_def_t
    
    @param i: size_t

ida_regfinder.reg_value_info_t.__init__ (method)
    __init__(self) -> reg_value_info_t

ida_regfinder.reg_value_info_t.__len__ (method)
    __len__(self) -> size_t

ida_regfinder.reg_value_info_t.__str__ (method)
    __str__(self) -> qstring

ida_regfinder.reg_value_info_t.aborted (method)
    aborted(self) -> bool
    Return 'true' if the tracking process was aborted.

ida_regfinder.reg_value_info_t.add (method)
    add(self, r, insn)
    Add R to the value, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.add_num (method)
    add_num(self, r, insn)
    Add R to the value, do not change the defining instructions.
    @note: This method do nothing for unknown values.
    
    @param r: (C++: uval_t)
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    
    add_num(self, r)
    
    @param r: uval_t

ida_regfinder.reg_value_info_t.band (method)
    band(self, r, insn)
    Make bitwise AND of R to the value, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.bandnot (method)
    bandnot(self, r, insn)
    Make bitwise AND of the inverse of R to the value, save INSN as a defining
    instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.bnot (method)
    bnot(self, insn)
    Make bitwise inverse of the value, save INSN as a defining instruction.
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.bor (method)
    bor(self, r, insn)
    Make bitwise OR of R to the value, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.bxor (method)
    bxor(self, r, insn)
    Make bitwise eXclusive OR of R to the value, save INSN as a defining
    instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.clear (method)
    clear(self)
    Undefine the value.

ida_regfinder.reg_value_info_t.empty (method)
    empty(self) -> bool
    Return 'true' if we know nothing about a value.

ida_regfinder.reg_value_info_t.extend (method)
    extend(self, pm, width, is_signed)
    Sign-, or zero-extend the number or SP delta value to full size. The initial
    value is considered to be of size WIDTH.
    @note: This method do nothing for unknown values.
    
    @param pm: (C++: const procmod_t &) procmod_t const &
    @param width: (C++: int)
    @param is_signed: (C++: bool)

ida_regfinder.reg_value_info_t.get_def_ea (method)
    get_def_ea(self) -> ea_t
    Return the defining address.

ida_regfinder.reg_value_info_t.get_def_itype (method)
    get_def_itype(self) -> uint16
    Return the defining instruction code (processor specific).

ida_regfinder.reg_value_info_t.get_num (method)
    get_num(self) -> bool
    Return the number if the value is a constant.
    @see: is_num()

ida_regfinder.reg_value_info_t.get_spd (method)
    get_spd(self) -> bool
    Return the SP delta if the value depends on the stack pointer.
    @see: is_spd()

ida_regfinder.reg_value_info_t.have_all_vals_flag (method)
    have_all_vals_flag(self, val_flags) -> bool
    Check the given flag for each value.
    
    @param val_flags: (C++: uint16)

ida_regfinder.reg_value_info_t.is_all_vals_like_got (method)
    is_all_vals_like_got(self) -> bool

ida_regfinder.reg_value_info_t.is_all_vals_pc_based (method)
    is_all_vals_pc_based(self) -> bool

ida_regfinder.reg_value_info_t.is_badinsn (method)
    is_badinsn(self) -> bool
    Return 'true' if the value is unknown because of a bad insn.

ida_regfinder.reg_value_info_t.is_dead_end (method)
    is_dead_end(self) -> bool
    Return 'true' if the value is undefined because of a dead end.

ida_regfinder.reg_value_info_t.is_known (method)
    is_known(self) -> bool
    Return 'true' if the value is known (i.e. it is a number or SP delta).

ida_regfinder.reg_value_info_t.is_num (method)
    is_num(self) -> bool
    Return 'true' if the value is a constant.

ida_regfinder.reg_value_info_t.is_spd (method)
    is_spd(self) -> bool
    Return 'true' if the value depends on the stack pointer.

ida_regfinder.reg_value_info_t.is_special (method)
    is_special(self) -> bool
    Return 'true' if the value requires special handling.

ida_regfinder.reg_value_info_t.is_unkfunc (method)
    is_unkfunc(self) -> bool
    Return 'true' if the value is unknown from the function start.

ida_regfinder.reg_value_info_t.is_unkinsn (method)
    is_unkinsn(self) -> bool
    Return 'true' if the value is unknown after executing the insn.

ida_regfinder.reg_value_info_t.is_unkloop (method)
    is_unkloop(self) -> bool
    Return 'true' if the value is unknown because it changes in a loop.

ida_regfinder.reg_value_info_t.is_unkmult (method)
    is_unkmult(self) -> bool
    Return 'true' if the value is unknown because the register has incompatible
    values (a number and SP delta).

ida_regfinder.reg_value_info_t.is_unknown (method)
    is_unknown(self) -> bool
    Return 'true' if the value is unknown.

ida_regfinder.reg_value_info_t.is_value_unique (method)
    is_value_unique(self) -> bool
    Check that the value is unique.

ida_regfinder.reg_value_info_t.make_aborted (method)
    make_aborted(bblk_ea) -> reg_value_info_t
    Return the value after aborting.
    @see: aborted()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_badinsn (method)
    make_badinsn(insn_ea) -> reg_value_info_t
    Return the unknown value after a bad insn.
    @see: is_badinsn()
    
    @param insn_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_dead_end (method)
    make_dead_end(dead_end_ea) -> reg_value_info_t
    Return the undefined value because of a dead end.
    @see: is_dead_end()
    
    @param dead_end_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_initial_sp (method)
    make_initial_sp(func_ea) -> reg_value_info_t
    Return the value that is the initial stack pointer.
    @see: is_spd()
    
    @param func_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_num (method)
    make_num(rval, insn, val_flags=0) -> reg_value_info_t
    Return the value that is the RVAL number.
    @see: is_num()
    
    @param rval: (C++: uval_t)
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param val_flags: (C++: uint16)
    
    make_num(rval, val_ea, val_flags=0) -> reg_value_info_t
    
    @param rval: uval_t
    @param val_ea: ea_t
    @param val_flags: uint16

ida_regfinder.reg_value_info_t.make_unkfunc (method)
    make_unkfunc(func_ea) -> reg_value_info_t
    Return the unknown value from the function start.
    @see: is_unkfunc()
    
    @param func_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_unkinsn (method)
    make_unkinsn(insn) -> reg_value_info_t
    Return the unknown value after executing the insn.
    @see: is_unkinsn()
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.make_unkloop (method)
    make_unkloop(bblk_ea) -> reg_value_info_t
    Return the unknown value if it changes in a loop.
    @see: is_unkloop()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.make_unkmult (method)
    make_unkmult(bblk_ea) -> reg_value_info_t
    Return the unknown value if the register has incompatible values.
    @see: is_unkmult()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.neg (method)
    neg(self, insn)
    Negate the value, save INSN as a defining instruction.
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.set_aborted (method)
    set_aborted(self, bblk_ea)
    Set the value after aborting.
    @see: aborted()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.set_badinsn (method)
    set_badinsn(self, insn_ea)
    Set the value to be unknown after a bad insn.
    @see: is_badinsn()
    
    @param insn_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.set_dead_end (method)
    set_dead_end(self, dead_end_ea)
    Set the value to be undefined because of a dead end.
    @see: is_dead_end()
    
    @param dead_end_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.set_num (method)
    set_num(self, rval, insn, val_flags=0)
    Set the value to be a number before an address.
    @see: is_num()
    
    @param rval: (C++: uval_t)
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param val_flags: (C++: uint16)
    
    set_num(self, rvals, insn)
    
    @param rvals: uvalvec_t *
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    
    set_num(self, rval, val_ea, val_flags=0)
    
    @param rval: uval_t
    @param val_ea: ea_t
    @param val_flags: uint16

ida_regfinder.reg_value_info_t.set_unkfunc (method)
    set_unkfunc(self, func_ea)
    Set the value to be unknown from the function start.
    @see: is_unkfunc()
    
    @param func_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.set_unkinsn (method)
    set_unkinsn(self, insn)
    Set the value to be unknown after executing the insn.
    @see: is_unkinsn()
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.set_unkloop (method)
    set_unkloop(self, bblk_ea)
    Set the value to be unknown because it changes in a loop.
    @see: is_unkloop()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.set_unkmult (method)
    set_unkmult(self, bblk_ea)
    Set the value to be unknown because the register has incompatible values.
    @see: is_unkmult()
    
    @param bblk_ea: (C++: ea_t)

ida_regfinder.reg_value_info_t.shift_left (method)
    shift_left(self, r)
    Shift the value left by R, do not change the defining instructions.
    @note: This method do nothing for unknown values.
    
    @param r: (C++: uval_t)

ida_regfinder.reg_value_info_t.shift_right (method)
    shift_right(self, r)
    Shift the value right by R, do not change the defining instructions.
    @note: This method do nothing for unknown values.
    
    @param r: (C++: uval_t)

ida_regfinder.reg_value_info_t.sll (method)
    sll(self, r, insn)
    Shift the value left by R, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.slr (method)
    slr(self, r, insn)
    Shift the value right by R, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.sub (method)
    sub(self, r, insn)
    Subtract R from the value, save INSN as a defining instruction.
    @note: Either THIS or R must have a single value.
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t.trunc_uval (method)
    trunc_uval(self, pm)
    Truncate the number to the application bitness.
    @note: This method do nothing for non-number values.
    
    @param pm: (C++: const procmod_t &) procmod_t const &

ida_regfinder.reg_value_info_t.vals_union (method)
    vals_union(self, r) -> reg_value_info_t::set_compare_res_t
    Add values from R into THIS ignoring duplicates.
    @note: This method is the only way to get multiple values.
    @retval EQUAL: THIS is not changed
    @retval CONTAINS: THIS is not changed
    @retval CONTAINED: THIS is a copy of R
    @retval NOT_COMPARABLE: values from R are added to THIS
    
    @param r: (C++: const reg_value_info_t &) reg_value_info_t const &

ida_regfinder.reg_value_info_t_make_aborted (function)
    reg_value_info_t_make_aborted(bblk_ea) -> reg_value_info_t
    
    @param bblk_ea: ea_t

ida_regfinder.reg_value_info_t_make_badinsn (function)
    reg_value_info_t_make_badinsn(insn_ea) -> reg_value_info_t
    
    @param insn_ea: ea_t

ida_regfinder.reg_value_info_t_make_dead_end (function)
    reg_value_info_t_make_dead_end(dead_end_ea) -> reg_value_info_t
    
    @param dead_end_ea: ea_t

ida_regfinder.reg_value_info_t_make_initial_sp (function)
    reg_value_info_t_make_initial_sp(func_ea) -> reg_value_info_t
    
    @param func_ea: ea_t

ida_regfinder.reg_value_info_t_make_num (function)
    reg_value_info_t_make_num(rval, insn, val_flags=0) -> reg_value_info_t
    
    @param rval: uval_t
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param val_flags: uint16
    
    reg_value_info_t_make_num(rval, val_ea, val_flags=0) -> reg_value_info_t
    
    @param rval: uval_t
    @param val_ea: ea_t
    @param val_flags: uint16

ida_regfinder.reg_value_info_t_make_unkfunc (function)
    reg_value_info_t_make_unkfunc(func_ea) -> reg_value_info_t
    
    @param func_ea: ea_t

ida_regfinder.reg_value_info_t_make_unkinsn (function)
    reg_value_info_t_make_unkinsn(insn) -> reg_value_info_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_regfinder.reg_value_info_t_make_unkloop (function)
    reg_value_info_t_make_unkloop(bblk_ea) -> reg_value_info_t
    
    @param bblk_ea: ea_t

ida_regfinder.reg_value_info_t_make_unkmult (function)
    reg_value_info_t_make_unkmult(bblk_ea) -> reg_value_info_t
    
    @param bblk_ea: ea_t

ida_search (module)
    Middle-level search functions.
    
    They all are controlled by Search flags

ida_search.SEARCH_BRK (variable)
    return BADADDR if the search was cancelled.

ida_search.SEARCH_CASE (variable)
    case-sensitive search (case-insensitive otherwise)

ida_search.SEARCH_DOWN (variable)
    search towards higher addresses

ida_search.SEARCH_IDENT (variable)
    search for an identifier (text search). it means that the characters before and
    after the match cannot be is_visible_char().

ida_search.SEARCH_NEXT (variable)
    skip the starting address when searching. this bit is useful only for search(),
    bin_search2(), find_reg_access(). find_.. functions skip the starting address
    automatically.

ida_search.SEARCH_NOBRK (variable)
    do not test if the user clicked cancel to interrupt the search

ida_search.SEARCH_NOSHOW (variable)
    do not display the search progress/refresh screen

ida_search.SEARCH_REGEX (variable)
    regular expressions in search string (supported only for the text search)

ida_search.SEARCH_UP (variable)
    search towards lower addresses

ida_search.SEARCH_USESEL (variable)
    query the UI for a possible current selection to limit the search to

ida_search.find_binary (function)
    find_binary(arg1, arg2, arg3, arg4, arg5) -> ea_t
    Deprecated. Please use ida_bytes.bin_search() instead.
    
    @param arg1: ea_t
    @param arg2: ea_t
    @param arg3: char const *
    @param arg4: int
    @param arg5: int

ida_search.find_code (function)
    find_code(ea, sflag) -> ea_t
    Find next code address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_data (function)
    find_data(ea, sflag) -> ea_t
    Find next data address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_defined (function)
    find_defined(ea, sflag) -> ea_t
    Find next ea that is the start of an instruction or data.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_error (function)
    find_error(ea, sflag) -> ea_t
    Find next error or problem.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_imm (function)
    find_imm(ea, sflag, search_value) -> ea_t
    Find next immediate operand with the given value.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)
    @param search_value: (C++: uval_t)

ida_search.find_not_func (function)
    find_not_func(ea, sflag) -> ea_t
    Find next code address that does not belong to a function.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_notype (function)
    find_notype(ea, sflag) -> ea_t
    Find next operand without any type info.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_reg_access (function)
    find_reg_access(out, start_ea, end_ea, regname, sflag) -> ea_t
    Find access to a register.
    
    @param out: (C++: struct reg_access_t *) pointer to the output buffer. must be non-null. upon success
                contains info about the found register. upon failed search for a
                read access out->range contains the info about the non-redefined
                parts of the register.
    @param start_ea: (C++: ea_t) starting address
    @param end_ea: (C++: ea_t) ending address. BADADDR means that the end limit is missing.
                   otherwise, if the search direction is SEARCH_UP, END_EA must be
                   lower than START_EA.
    @param regname: (C++: const char *) the register to search for.
    @param sflag: (C++: int) combination of Search flags bits.
    @note: This function does not care about the control flow and probes all
           instructions in the specified range, starting from START_EA. Only direct
           references to registers are detected. Function calls and system traps are
           ignored.
    @return: the found address. BADADDR if not found or error.

ida_search.find_suspop (function)
    find_suspop(ea, sflag) -> ea_t
    Find next suspicious operand.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.find_text (function)
    find_text(start_ea, y, x, ustr, sflag) -> ea_t
    See search()
    
    @param start_ea: (C++: ea_t)
    @param y: (C++: int)
    @param x: (C++: int)
    @param ustr: (C++: const char *) char const *
    @param sflag: (C++: int)

ida_search.find_unknown (function)
    find_unknown(ea, sflag) -> ea_t
    Find next unexplored address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

ida_search.search_down (function)
    search_down(sflag) -> bool
    Is the SEARCH_DOWN bit set?
    
    @param sflag: (C++: int)

ida_segment (module)
    Functions that deal with segments.
    
    IDA requires that all program addresses belong to segments (each address must
    belong to exactly one segment). The situation when an address doesn't belong to
    any segment is allowed as a temporary situation only when the user changes
    program segmentation. Bytes outside a segment can't be converted to
    instructions, have names, comments, etc. Each segment has its start address,
    ending address and represents a contiguous range of addresses. There might be
    unused holes between segments.
    
    Each segment has its unique segment selector. This selector is used to
    distinguish the segment from other segments. For 16-bit programs the selector is
    equal to the segment base paragraph. For 32-bit programs there is special array
    to translate the selectors to the segment base paragraphs. A selector is a 32/64
    bit value.
    
    The segment base paragraph determines the offsets in the segment. If the start
    address of the segment == (base << 4) then the first offset in the segment will
    be 0. The start address should be higher or equal to (base << 4). We will call
    the offsets in the segment 'virtual addresses'. So, the virtual address of the
    first byte of the segment is
    
    (start address of segment - segment base linear address)
    
    For IBM PC, the virtual address corresponds to the offset part of the address.
    For other processors (Z80, for example), virtual addresses correspond to Z80
    addresses and linear addresses are used only internally. For MS Windows programs
    the segment base paragraph is 0 and therefore the segment virtual addresses are
    equal to linear addresses.

ida_segment.ADDSEG_FILLGAP (variable)
    fill gap between new segment and previous one. i.e. if such a gap exists, and
    this gap is less than 64K, then fill the gap by extending the previous segment
    and adding .align directive to it. This way we avoid gaps between segments. too
    many gaps lead to a virtual array failure. it cannot hold more than ~1000 gaps.

ida_segment.ADDSEG_IDBENC (variable)
    'name' and 'sclass' are given in the IDB encoding; non-ASCII bytes will be
    decoded accordingly

ida_segment.ADDSEG_NOAA (variable)
    do not mark new segment for auto-analysis

ida_segment.ADDSEG_NOSREG (variable)
    set all default segment register values to BADSEL (undefine all default segment
    registers)

ida_segment.ADDSEG_NOTRUNC (variable)
    don't truncate the new segment at the beginning of the next segment if they
    overlap. destroy/truncate old segments instead.

ida_segment.ADDSEG_OR_DIE (variable)
    qexit() if can't add a segment

ida_segment.ADDSEG_QUIET (variable)
    silent mode, no "Adding segment..." in the messages window

ida_segment.ADDSEG_SPARSE (variable)
    use sparse storage method for the new ranges of the created segment. please note
    that the ranges that were already enabled before creating the segment will not
    change their storage type.

ida_segment.CSS_BREAK (variable)
    memory reading process stopped by user

ida_segment.CSS_NODBG (variable)
    debugger is not running

ida_segment.CSS_NOMEM (variable)
    not enough memory (might be because the segment is too big)

ida_segment.CSS_NORANGE (variable)
    could not find corresponding memory range

ida_segment.CSS_OK (variable)
    ok

ida_segment.MAX_GROUPS (variable)
    max number of segment groups

ida_segment.MAX_SEGM_TRANSLATIONS (variable)
    max number of segment translations

ida_segment.MOVE_SEGM_CHUNK (variable)
    Too many chunks are defined, can't move.

ida_segment.MOVE_SEGM_DEBUG (variable)
    Debugger segments cannot be moved.

ida_segment.MOVE_SEGM_IDP (variable)
    IDP module forbids moving the segment.

ida_segment.MOVE_SEGM_INVAL (variable)
    Invalid argument (delta/target does not fit the address space)

ida_segment.MOVE_SEGM_LOADER (variable)
    The segment has been moved but the loader complained.

ida_segment.MOVE_SEGM_MAPPING (variable)
    Memory mapping ranges of addresses hinder segment movement.

ida_segment.MOVE_SEGM_ODD (variable)
    Cannot move segments by an odd number of bytes.

ida_segment.MOVE_SEGM_OK (variable)
    all ok

ida_segment.MOVE_SEGM_ORPHAN (variable)
    Orphan bytes hinder segment movement.

ida_segment.MOVE_SEGM_PARAM (variable)
    The specified segment does not exist.

ida_segment.MOVE_SEGM_ROOM (variable)
    Not enough free room at the target address.

ida_segment.MOVE_SEGM_SOURCEFILES (variable)
    Source files ranges of addresses hinder segment movement.

ida_segment.MSF_FIXONCE (variable)
    call loader only once with the special calling method. valid for
    rebase_program(). see loader_t::move_segm.

ida_segment.MSF_LDKEEP (variable)
    keep the loader in the memory (optimization)

ida_segment.MSF_NETNODES (variable)
    move netnodes instead of changing inf.netdelta (this is slower); valid for
    rebase_program()

ida_segment.MSF_NOFIX (variable)
    don't call the loader to fix relocations

ida_segment.MSF_PRIORITY (variable)
    loader segments will overwrite any existing debugger segments when moved. valid
    for move_segm()

ida_segment.MSF_SILENT (variable)
    don't display a "please wait" box on the screen

ida_segment.SEGMOD_KEEP (variable)
    keep information (code & data, etc)

ida_segment.SEGMOD_KEEP0 (variable)
    flag for internal use, don't set

ida_segment.SEGMOD_KEEPSEL (variable)
    do not try to delete unused selector

ida_segment.SEGMOD_KILL (variable)
    disable addresses if segment gets shrinked or deleted

ida_segment.SEGMOD_NOMOVE (variable)
    don't move info from the start of segment to the new start address (for
    set_segm_start())

ida_segment.SEGMOD_SILENT (variable)
    be silent

ida_segment.SEGMOD_SPARSE (variable)
    use sparse storage if extending the segment (for set_segm_start(),
    set_segm_end())

ida_segment.SEGPERM_EXEC (variable)
    Execute.

ida_segment.SEGPERM_READ (variable)
    Read.

ida_segment.SEGPERM_WRITE (variable)
    Write.

ida_segment.SEG_ABSSYM (variable)
    * segment with definitions of absolute symbols

ida_segment.SEG_BSS (variable)
    uninitialized segment

ida_segment.SEG_CODE (variable)
    code segment

ida_segment.SEG_COMM (variable)
    * segment with communal definitions

ida_segment.SEG_DATA (variable)
    data segment

ida_segment.SEG_GRP (variable)
    * group of segments

ida_segment.SEG_IMEM (variable)
    internal processor memory & sfr (8051)

ida_segment.SEG_NORM (variable)
    unknown type, no assumptions

ida_segment.SEG_NULL (variable)
    zero-length segment

ida_segment.SEG_UNDF (variable)
    undefined segment type (not used)

ida_segment.SEG_XTRN (variable)
    * segment with 'extern' definitions. no instructions are allowed

ida_segment.SFL_COMORG (variable)
    IDP dependent field (IBM PC: if set, ORG directive is not commented out)

ida_segment.SFL_DEBUG (variable)
    Is the segment created for the debugger?. Such segments are temporary and do not
    have permanent flags.

ida_segment.SFL_HEADER (variable)
    Header segment (do not create offsets to it in the disassembly)

ida_segment.SFL_HIDDEN (variable)
    Is the segment hidden?

ida_segment.SFL_HIDETYPE (variable)
    Hide segment type (do not print it in the listing)

ida_segment.SFL_LOADER (variable)
    Is the segment created by the loader?

ida_segment.SFL_OBOK (variable)
    Orgbase is present? (IDP dependent field)

ida_segment.SNAP_ALL_SEG (variable)
    Take a snapshot of all segments.

ida_segment.SNAP_CUR_SEG (variable)
    Take a snapshot of current segment.

ida_segment.SNAP_LOAD_SEG (variable)
    Take a snapshot of loader segments.

ida_segment.SREG_NUM (variable)
    Maximum number of segment registers is 16 (see segregs.hpp)

ida_segment.add_segm (function)
    add_segm(para, start, end, name, sclass, flags=0) -> bool
    Add a new segment, second form. Segment alignment is set to saRelByte. Segment
    combination is "public" or "stack" (if segment class is "STACK"). Addressing
    mode of segment is taken as default (16bit or 32bit). Default segment registers
    are set to BADSEL. If a segment already exists at the specified range of
    addresses, this segment will be truncated. Instructions and data in the old
    segment will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    @param para: (C++: ea_t) segment base paragraph. if paragraph can't fit in 16bit, then a new
                 selector is allocated and mapped to the paragraph.
    @param start: (C++: ea_t) start address of the segment. if start==BADADDR then start <-
                  to_ea(para,0).
    @param end: (C++: ea_t) end address of the segment. end address should be higher than start
                address. For emulate empty segments, use SEG_NULL segment type. If
                the end address is lower than start address, then fail. If
                end==BADADDR, then a segment up to the next segment will be created
                (if the next segment doesn't exist, then 1 byte segment will be
                created). If 'end' is too high and the new segment would overlap the
                next segment, 'end' is adjusted properly.
    @param name: (C++: const char *) name of new segment. may be nullptr
    @param sclass: (C++: const char *) class of the segment. may be nullptr. type of the new segment is
                   modified if class is one of predefined names:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "CONST" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * "XTRN" -> SEG_XTRN
    * "COMM" -> SEG_COMM
    * "ABS" -> SEG_ABSSYM
    @param flags: (C++: int) Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.add_segm_ex (function)
    add_segm_ex(NONNULL_s, name, sclass, flags) -> bool
    Add a new segment. If a segment already exists at the specified range of
    addresses, this segment will be truncated. Instructions and data in the old
    segment will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    @param NONNULL_s: (C++: segment_t *)
    @param name: (C++: const char *) name of new segment. may be nullptr. if specified, the segment is
                 immediately renamed
    @param sclass: (C++: const char *) class of the segment. may be nullptr. if specified, the segment
                   class is immediately changed
    @param flags: (C++: int) Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.add_segment_translation (function)
    add_segment_translation(segstart, mappedseg) -> bool
    Add segment translation.
    
    @param segstart: (C++: ea_t) start address of the segment to add translation to
    @param mappedseg: (C++: ea_t) start address of the overlayed segment
    @retval 1: ok
    @retval 0: too many translations or bad segstart

ida_segment.allocate_selector (function)
    allocate_selector(segbase) -> sel_t
    Allocate a selector for a segment unconditionally. You must call this function
    before calling add_segm_ex(). add_segm() calls this function itself, so you
    don't need to allocate a selector. This function will allocate a new free
    selector and setup its mapping using find_free_selector() and set_selector()
    functions.
    
    @param segbase: (C++: ea_t) a new segment base paragraph
    @return: the allocated selector number

ida_segment.change_segment_status (function)
    change_segment_status(s, is_deb_segm) -> int
    Convert a debugger segment to a regular segment and vice versa. When converting
    debug->regular, the memory contents will be copied to the database.
    
    @param s: (C++: segment_t *) segment to modify
    @param is_deb_segm: (C++: bool) new status of the segment
    @return: Change segment status result codes

ida_segment.del_segm (function)
    del_segm(ea, flags) -> bool
    Delete a segment.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, no segment at 'ea'.

ida_segment.del_segment_translations (function)
    del_segment_translations(segstart)
    Delete the translation list
    
    @param segstart: (C++: ea_t) start address of the segment to delete translation list

ida_segment.del_selector (function)
    del_selector(selector)
    Delete mapping of a selector. Be wary of deleting selectors that are being used
    in the program, this can make a mess in the segments.
    
    @param selector: (C++: sel_t) number of selector to remove from the translation table

ida_segment.find_free_selector (function)
    find_free_selector() -> sel_t
    Find first unused selector.
    
    @return: a number >= 1

ida_segment.find_selector (function)
    find_selector(base) -> sel_t
    Find a selector that has mapping to the specified paragraph.
    
    @param base: (C++: ea_t) paragraph to search in the translation table
    @return: selector value or base

ida_segment.get_defsr (function)
    get_defsr(s, reg) -> sel_t
    Deprecated, use instead:
        value = s.defsr[reg]
    
    @param s: segment_t *
    @param reg: int

ida_segment.get_first_seg (function)
    get_first_seg() -> segment_t
    Get pointer to the first segment.

ida_segment.get_group_selector (function)
    get_group_selector(grpsel) -> sel_t
    Get common selector for a group of segments.
    
    @param grpsel: (C++: sel_t) selector of group segment
    @return: common selector of the group or 'grpsel' if no such group is found

ida_segment.get_last_seg (function)
    get_last_seg() -> segment_t
    Get pointer to the last segment.

ida_segment.get_next_seg (function)
    get_next_seg(ea) -> segment_t
    Get pointer to the next segment.
    
    @param ea: (C++: ea_t)

ida_segment.get_prev_seg (function)
    get_prev_seg(ea) -> segment_t
    Get pointer to the previous segment.
    
    @param ea: (C++: ea_t)

ida_segment.get_segm_base (function)
    get_segm_base(s) -> ea_t
    Get segment base linear address. Segment base linear address is used to
    calculate virtual addresses. The virtual address of the first byte of the
    segment will be (start address of segment - segment base linear address)
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: 0 if s == nullptr, otherwise segment base linear address

ida_segment.get_segm_by_name (function)
    get_segm_by_name(name) -> segment_t
    Get pointer to segment by its name. If there are several segments with the same
    name, returns the first of them.
    
    @param name: (C++: const char *) segment name. may be nullptr.
    @return: nullptr or pointer to segment structure

ida_segment.get_segm_by_sel (function)
    get_segm_by_sel(selector) -> segment_t
    Get pointer to segment structure. This function finds a segment by its selector.
    If there are several segments with the same selectors, the last one will be
    returned.
    
    @param selector: (C++: sel_t) a segment with the specified selector will be returned
    @return: pointer to segment or nullptr

ida_segment.get_segm_class (function)
    get_segm_class(s) -> str
    Get segment class. Segment class is arbitrary text (max 8 characters).
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: size of segment class (-1 if s==nullptr or bufsize<=0)

ida_segment.get_segm_name (function)
    get_segm_name(s, flags=0) -> str
    Get true segment name by pointer to segment.
    
    @param s: (C++: const segment_t *) pointer to segment
    @param flags: (C++: int) 0-return name as is; 1-substitute bad symbols with _ 1 corresponds
                  to GN_VISIBLE
    @return: size of segment name (-1 if s==nullptr)

ida_segment.get_segm_num (function)
    get_segm_num(ea) -> int
    Get number of segment by address.
    
    @param ea: (C++: ea_t) linear address belonging to the segment
    @return: -1 if no segment occupies the specified address. otherwise returns
             number of the specified segment (0..get_segm_qty()-1)

ida_segment.get_segm_para (function)
    get_segm_para(s) -> ea_t
    Get segment base paragraph. Segment base paragraph may be converted to segment
    base linear address using to_ea() function. In fact, to_ea(get_segm_para(s), 0)
    == get_segm_base(s).
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: 0 if s == nullptr, the segment base paragraph

ida_segment.get_segm_qty (function)
    get_segm_qty() -> int
    Get number of segments.

ida_segment.get_segment_alignment (function)
    get_segment_alignment(align) -> char const *
    Get text representation of segment alignment code.
    
    @param align: (C++: uchar)
    @return: text digestable by IBM PC assembler.

ida_segment.get_segment_cmt (function)
    get_segment_cmt(s, repeatable) -> str
    Get segment comment.
    
    @param s: (C++: const segment_t *) pointer to segment structure
    @param repeatable: (C++: bool) 0: get regular comment. 1: get repeatable comment.
    @return: size of comment or -1

ida_segment.get_segment_combination (function)
    get_segment_combination(comb) -> char const *
    Get text representation of segment combination code.
    
    @param comb: (C++: uchar)
    @return: text digestable by IBM PC assembler.

ida_segment.get_segment_translations (function)
    get_segment_translations(transmap, segstart) -> ssize_t
    Get segment translation list.
    
    @param transmap: (C++: eavec_t *) vector of segment start addresses for the translation list
    @param segstart: (C++: ea_t) start address of the segment to get information about
    @return: -1 if no translation list or bad segstart. otherwise returns size of
             translation list.

ida_segment.get_selector_qty (function)
    get_selector_qty() -> size_t
    Get number of defined selectors.

ida_segment.get_visible_segm_name (function)
    get_visible_segm_name(s) -> str
    Get segment name by pointer to segment.
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: size of segment name (-1 if s==nullptr)

ida_segment.getn_selector (function)
    getn_selector(n) -> bool
    Get description of selector (0..get_selector_qty()-1)
    
    @param n: (C++: int)

ida_segment.getnseg (function)
    getnseg(n) -> segment_t
    Get pointer to segment by its number.
    @warning: Obsoleted because it can slow down the debugger (it has to refresh the
              whole memory segmentation to calculate the correct answer)
    
    @param n: (C++: int) segment number in the range (0..get_segm_qty()-1)
    @return: nullptr or pointer to segment structure

ida_segment.getseg (function)
    getseg(ea) -> segment_t
    Get pointer to segment by linear address.
    
    @param ea: (C++: ea_t) linear address belonging to the segment
    @return: nullptr or pointer to segment structure

ida_segment.is_finally_visible_segm (function)
    is_finally_visible_segm(s) -> bool
    See SFL_HIDDEN, SCF_SHHID_SEGM.
    
    @param s: (C++: segment_t *)

ida_segment.is_miniidb (function)
    is_miniidb() -> bool
    Is the database a miniidb created by the debugger?.
    
    @return: true if the database contains no segments or only debugger segments

ida_segment.is_segm_locked (function)
    is_segm_locked(segm) -> bool
    Is a segment pointer locked?
    
    @param segm: (C++: const segment_t *) segment_t const *

ida_segment.is_spec_ea (function)
    is_spec_ea(ea) -> bool
    Does the address belong to a segment with a special type?. (SEG_XTRN, SEG_GRP,
    SEG_ABSSYM, SEG_COMM)
    
    @param ea: (C++: ea_t) linear address

ida_segment.is_spec_segm (function)
    is_spec_segm(seg_type) -> bool
    Has segment a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM)
    
    @param seg_type: (C++: uchar)

ida_segment.is_visible_segm (function)
    is_visible_segm(s) -> bool
    See SFL_HIDDEN.
    
    @param s: (C++: segment_t *)

ida_segment.lock_segm (function)
    lock_segm(segm, lock)
    Lock segment pointer Locked pointers are guaranteed to remain valid until they
    are unlocked. Ranges with locked pointers cannot be deleted or moved.
    
    @param segm: (C++: const segment_t *) segment_t const *
    @param lock: (C++: bool)

ida_segment.lock_segment (class)
    Proxy of C++ lock_segment class.

ida_segment.lock_segment.__init__ (method)
    __init__(self, _segm) -> lock_segment
    
    @param _segm: segment_t const *

ida_segment.move_segm (function)
    move_segm(s, to, flags=0) -> move_segm_code_t
    This function moves all information to the new address. It fixes up address
    sensitive information in the kernel. The total effect is equal to reloading the
    segment to the target address. For the file format dependent address sensitive
    information, loader_t::move_segm is called. Also IDB notification event
    idb_event::segm_moved is called.
    
    @param s: (C++: segment_t *) segment to move
    @param to: (C++: ea_t) new segment start address
    @param flags: (C++: int) Move segment flags
    @return: Move segment result codes

ida_segment.move_segm_start (function)
    move_segm_start(ea, newstart, mode) -> bool
    Move segment start. The main difference between this function and
    set_segm_start() is that this function may expand the previous segment while
    set_segm_start() never does it. So, this function allows to change bounds of two
    segments simultaneously. If the previous segment and the specified segment have
    the same addressing mode and segment base, then instructions and data are not
    destroyed - they simply move from one segment to another. Otherwise all
    instructions/data which migrate from one segment to another are destroyed.
    @note: this function never disables addresses.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newstart: (C++: ea_t) new start address of the segment note that segment start
                     address should be higher than segment base linear address.
    @param mode: (C++: int) policy for destroying defined items
    * 0: if it is necessary to destroy defined items, display a dialog box and ask
    confirmation
    * 1: if it is necessary to destroy defined items, just destroy them without
    asking the user
    * -1: if it is necessary to destroy defined items, don't destroy them (i.e.
    function will fail)
    * -2: don't destroy defined items (function will succeed)
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.move_segm_strerror (function)
    move_segm_strerror(code) -> char const *
    Return string describing error MOVE_SEGM_... code.
    
    @param code: (C++: move_segm_code_t) enum move_segm_code_t

ida_segment.rebase_program (function)
    rebase_program(delta, flags) -> int
    Rebase the whole program by 'delta' bytes.
    
    @param delta: (C++: adiff_t) number of bytes to move the program
    @param flags: (C++: int) Move segment flags it is recommended to use MSF_FIXONCE so that
                  the loader takes care of global variables it stored in the
                  database
    @return: Move segment result codes

ida_segment.saAbs (variable)
    Absolute segment.

ida_segment.saGroup (variable)
    Segment group.

ida_segment.saRel1024Bytes (variable)
    1024 bytes

ida_segment.saRel128Bytes (variable)
    128 bytes

ida_segment.saRel2048Bytes (variable)
    2048 bytes

ida_segment.saRel32Bytes (variable)
    32 bytes

ida_segment.saRel4K (variable)
    This value is used by the PharLap OMF for page (4K) alignment. It is not
    supported by LINK.

ida_segment.saRel512Bytes (variable)
    512 bytes

ida_segment.saRel64Bytes (variable)
    64 bytes

ida_segment.saRelByte (variable)
    Relocatable, byte aligned.

ida_segment.saRelDble (variable)
    Relocatable, aligned on a double word (4-byte) boundary.

ida_segment.saRelPage (variable)
    Relocatable, aligned on 256-byte boundary.

ida_segment.saRelPara (variable)
    Relocatable, paragraph (16-byte) aligned.

ida_segment.saRelQword (variable)
    8 bytes

ida_segment.saRelWord (variable)
    Relocatable, word (2-byte) aligned.

ida_segment.scCommon (variable)
    Common. Combine by overlay using maximum size.

ida_segment.scGroup (variable)
    Segment group.

ida_segment.scPriv (variable)
    Private. Do not combine with any other program segment.

ida_segment.scPub (variable)
    Public. Combine by appending at an offset that meets the alignment requirement.

ida_segment.scPub2 (variable)
    As defined by Microsoft, same as C=2 (public).

ida_segment.scPub3 (variable)
    As defined by Microsoft, same as C=2 (public).

ida_segment.scStack (variable)
    Stack. Combine as for C=2. This combine type forces byte alignment.

ida_segment.segm_adjust_diff (function)
    segm_adjust_diff(s, delta) -> adiff_t
    Truncate and sign extend a delta depending on the segment.
    
    @param s: (C++: const segment_t *) segment_t const *
    @param delta: (C++: adiff_t)

ida_segment.segm_adjust_ea (function)
    segm_adjust_ea(s, ea) -> ea_t
    Truncate an address depending on the segment.
    
    @param s: (C++: const segment_t *) segment_t const *
    @param ea: (C++: ea_t)

ida_segment.segment_defsr_array (class)
    Proxy of C++ wrapped_array_t< sel_t,SREG_NUM > class.

ida_segment.segment_defsr_array.__getitem__ (method)
    __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
    
    @param i: size_t

ida_segment.segment_defsr_array.__init__ (method)
    __init__(self, data) -> segment_defsr_array
    
    @param data: unsigned-ea-like-numeric-type (&)[SREG_NUM]

ida_segment.segment_defsr_array.__len__ (method)
    __len__(self) -> size_t

ida_segment.segment_defsr_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: unsigned-ea-like-numeric-type const &

ida_segment.segment_defsr_array._get_bytes (method)
    _get_bytes(self) -> bytevec_t

ida_segment.segment_defsr_array._set_bytes (method)
    _set_bytes(self, bts)
    
    Parameters
    ----------
    bts: bytevec_t const &

ida_segment.segment_t (class)
    Proxy of C++ segment_t class.

ida_segment.segment_t.__getDefsr (method)
    __getDefsr(self) -> segment_defsr_array

ida_segment.segment_t.__init__ (method)
    __init__(self) -> segment_t

ida_segment.segment_t.abits (method)
    abits(self) -> int
    Get number of address bits.

ida_segment.segment_t.abytes (method)
    abytes(self) -> int
    Get number of address bytes.

ida_segment.segment_t.align (variable)
    Segment alignment codes

ida_segment.segment_t.bitness (variable)
    Number of bits in the segment addressing
    * 0: 16 bits
    * 1: 32 bits
    * 2: 64 bits

ida_segment.segment_t.clr_comorg (method)
    clr_comorg(self)

ida_segment.segment_t.clr_ob_ok (method)
    clr_ob_ok(self)

ida_segment.segment_t.color (variable)
    the segment color

ida_segment.segment_t.comb (variable)
    Segment combination codes

ida_segment.segment_t.comorg (method)
    comorg(self) -> bool

ida_segment.segment_t.defsr (variable)
    default segment register values. first element of this array keeps information
    about value of processor_t::reg_first_sreg

ida_segment.segment_t.flags (variable)
    Segment flags

ida_segment.segment_t.is_16bit (method)
    is_16bit(self) -> bool
    Is a 16-bit segment?

ida_segment.segment_t.is_32bit (method)
    is_32bit(self) -> bool
    Is a 32-bit segment?

ida_segment.segment_t.is_64bit (method)
    is_64bit(self) -> bool
    Is a 64-bit segment?

ida_segment.segment_t.is_header_segm (method)
    is_header_segm(self) -> bool

ida_segment.segment_t.is_hidden_segtype (method)
    is_hidden_segtype(self) -> bool

ida_segment.segment_t.is_loader_segm (method)
    is_loader_segm(self) -> bool

ida_segment.segment_t.is_visible_segm (method)
    is_visible_segm(self) -> bool

ida_segment.segment_t.name (variable)
    use get/set_segm_name() functions

ida_segment.segment_t.ob_ok (method)
    ob_ok(self) -> bool

ida_segment.segment_t.orgbase (variable)
    this field is IDP dependent. you may keep your information about the segment
    here

ida_segment.segment_t.perm (variable)
    Segment permissions (0 means no information)

ida_segment.segment_t.sclass (variable)
    use get/set_segm_class() functions

ida_segment.segment_t.sel (variable)
    segment selector - should be unique. You can't change this field after creating
    the segment. Exception: 16bit OMF files may have several segments with the same
    selector, but this is not good (no way to denote a segment exactly) so it should
    be fixed in the future.

ida_segment.segment_t.set_comorg (method)
    set_comorg(self)

ida_segment.segment_t.set_debugger_segm (method)
    set_debugger_segm(self, debseg)
    
    @param debseg: bool

ida_segment.segment_t.set_header_segm (method)
    set_header_segm(self, on)
    
    @param on: bool

ida_segment.segment_t.set_hidden_segtype (method)
    set_hidden_segtype(self, hide)
    
    @param hide: bool

ida_segment.segment_t.set_loader_segm (method)
    set_loader_segm(self, ldrseg)
    
    @param ldrseg: bool

ida_segment.segment_t.set_ob_ok (method)
    set_ob_ok(self)

ida_segment.segment_t.set_visible_segm (method)
    set_visible_segm(self, visible)
    
    @param visible: bool

ida_segment.segment_t.type (variable)
    segment type (see Segment types). The kernel treats different segment types
    differently. Segments marked with '*' contain no instructions or data and are
    not declared as 'segments' in the disassembly.

ida_segment.segment_t.update (method)
    update(self) -> bool
    Update segment information. You must call this function after modification of
    segment characteristics. Note that not all fields of segment structure may be
    modified directly, there are special functions to modify some fields.
    
    @return: success

ida_segment.segtype (function)
    segtype(ea) -> uchar
    Get segment type.
    
    @param ea: (C++: ea_t) any linear address within the segment
    @return: Segment types, SEG_UNDF if no segment found at 'ea'

ida_segment.sel2ea (function)
    sel2ea(selector) -> ea_t
    Get mapping of a selector as a linear address.
    
    @param selector: (C++: sel_t) number of selector to translate to linear address
    @return: linear address the specified selector is mapped to. if there is no
             mapping, returns to_ea(selector,0);

ida_segment.sel2para (function)
    sel2para(selector) -> ea_t
    Get mapping of a selector.
    
    @param selector: (C++: sel_t) number of selector to translate
    @return: paragraph the specified selector is mapped to. if there is no mapping,
             returns 'selector'.

ida_segment.set_defsr (function)
    set_defsr(s, reg, value)
    Deprecated, use instead:
        s.defsr[reg] = value
    
    @param s: segment_t *
    @param reg: int
    @param value: sel_t

ida_segment.set_group_selector (function)
    set_group_selector(grp, sel) -> int
    Create a new group of segments (used OMF files).
    
    @param grp: (C++: sel_t) selector of group segment (segment type is SEG_GRP) You should
                create an 'empty' (1 byte) group segment It won't contain anything
                and will be used to redirect references to the group of segments to
                the common selector.
    @param sel: (C++: sel_t) common selector of all segments belonging to the segment You should
                create all segments within the group with the same selector value.
    @return: 1 ok
    0 too many groups (see MAX_GROUPS)

ida_segment.set_segm_addressing (function)
    set_segm_addressing(s, bitness) -> bool
    Change segment addressing mode (16, 32, 64 bits). You must use this function to
    change segment addressing, never change the 'bitness' field directly. This
    function will delete all instructions, comments and names in the segment
    
    @param s: (C++: segment_t *) pointer to segment
    @param bitness: (C++: size_t) new addressing mode of segment
    * 2: 64bit segment
    * 1: 32bit segment
    * 0: 16bit segment
    @return: success

ida_segment.set_segm_base (function)
    set_segm_base(s, newbase) -> bool
    Internal function.
    
    @param s: (C++: segment_t *)
    @param newbase: (C++: ea_t)

ida_segment.set_segm_class (function)
    set_segm_class(s, sclass, flags=0) -> int
    Set segment class.
    
    @param s: (C++: segment_t *) pointer to segment (may be nullptr)
    @param sclass: (C++: const char *) segment class (may be nullptr). If segment type is SEG_NORM and
                   segment class is one of predefined names, then segment type is
                   changed to:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * if "UNK" then segment type is reset to SEG_NORM.
    @param flags: (C++: int) Add segment flags
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is nullptr or bad or segment is nullptr

ida_segment.set_segm_end (function)
    set_segm_end(ea, newend, flags) -> bool
    Set segment end address. The next segment is shrinked to allow expansion of the
    specified segment. The kernel might even delete the next segment if necessary.
    The kernel will ask the user for a permission to destroy instructions or data
    going out of segment scope if such instructions exist.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newend: (C++: ea_t) new end address of the segment
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.set_segm_name (function)
    set_segm_name(s, name, flags=0) -> int
    Rename segment. The new name is validated (see validate_name). A segment always
    has a name. If you hadn't specified a name, the kernel will assign it "seg###"
    name where ### is segment number.
    
    @param s: (C++: segment_t *) pointer to segment (may be nullptr)
    @param name: (C++: const char *) new segment name
    @param flags: (C++: int) ADDSEG_IDBENC or 0
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is bad or segment is nullptr

ida_segment.set_segm_start (function)
    set_segm_start(ea, newstart, flags) -> bool
    Set segment start address. The previous segment is trimmed to allow expansion of
    the specified segment. The kernel might even delete the previous segment if
    necessary. The kernel will ask the user for a permission to destroy instructions
    or data going out of segment scope if such instructions exist.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newstart: (C++: ea_t) new start address of the segment note that segment start
                     address should be higher than segment base linear address.
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.set_segment_cmt (function)
    set_segment_cmt(s, cmt, repeatable)
    Set segment comment.
    
    @param s: (C++: const segment_t *) pointer to segment structure
    @param cmt: (C++: const char *) comment string, may be multiline (with '
    '). maximal size is 4096 bytes. Use empty str ("") to delete comment
    @param repeatable: (C++: bool) 0: set regular comment. 1: set repeatable comment.

ida_segment.set_segment_translations (function)
    set_segment_translations(segstart, transmap) -> bool
    Set new translation list.
    
    @param segstart: (C++: ea_t) start address of the segment to add translation to
    @param transmap: (C++: const eavec_t &) vector of segment start addresses for the translation list. If
                     transmap is empty, the translation list is deleted.
    @retval 1: ok
    @retval 0: too many translations or bad segstart

ida_segment.set_selector (function)
    set_selector(selector, paragraph) -> int
    Set mapping of selector to a paragraph. You should call this function _before_
    creating a segment which uses the selector, otherwise the creation of the
    segment will fail.
    
    @param selector: (C++: sel_t) number of selector to map
    * if selector == BADSEL, then return 0 (fail)
    * if the selector has had a mapping, old mapping is destroyed
    * if the selector number is equal to paragraph value, then the mapping is
    destroyed because we don't need to keep trivial mappings.
    @param paragraph: (C++: ea_t) paragraph to map selector
    @retval 1: ok
    @retval 0: failure (bad selector or too many mappings)

ida_segment.set_visible_segm (function)
    set_visible_segm(s, visible)
    See SFL_HIDDEN.
    
    @param s: (C++: segment_t *)
    @param visible: (C++: bool)

ida_segment.setup_selector (function)
    setup_selector(segbase) -> sel_t
    Allocate a selector for a segment if necessary. You must call this function
    before calling add_segm_ex(). add_segm() calls this function itself, so you
    don't need to allocate a selector. This function will allocate a selector if
    'segbase' requires more than 16 bits and the current processor is IBM PC.
    Otherwise it will return the segbase value.
    
    @param segbase: (C++: ea_t) a new segment base paragraph
    @return: the allocated selector number

ida_segment.std_out_segm_footer (function)
    std_out_segm_footer(ctx, seg)
    Generate segment footer line as a comment line. This function may be used in IDP
    modules to generate segment footer if the target assembler doesn't have 'ends'
    directive.
    
    @param ctx: (C++: struct outctx_t &) outctx_t &
    @param seg: (C++: segment_t *)

ida_segment.take_memory_snapshot (function)
    take_memory_snapshot(type) -> bool
    Take a memory snapshot of the running process.
    
    @param type: (C++: int) specifies which snapshot we want (see SNAP_ Snapshot types)
    @return: success

ida_segment.update_segm (function)
    update_segm(s) -> bool
    
    @param s: segment_t *

ida_segregs (module)
    Functions that deal with the segment registers.
    
    If your processor doesn't use segment registers, then these functions are of no
    use for you. However, you should define two virtual segment registers - CS and
    DS (for code segment and data segment) and specify their internal numbers in the
    LPH structure (processor_t::reg_code_sreg and processor_t::reg_data_sreg).

ida_segregs.SR_auto (variable)
    the value is determined by IDA

ida_segregs.SR_autostart (variable)
    used as SR_auto for segment starting address

ida_segregs.SR_inherit (variable)
    the value is inherited from the previous range

ida_segregs.SR_user (variable)
    the value is specified by the user

ida_segregs.copy_sreg_ranges (function)
    copy_sreg_ranges(dst_rg, src_rg, map_selector=False)
    Duplicate segment register ranges.
    
    @param dst_rg: (C++: int) number of destination segment register
    @param src_rg: (C++: int) copy ranges from
    @param map_selector: (C++: bool) map selectors to linear addresses using sel2ea()

ida_segregs.del_sreg_range (function)
    del_sreg_range(ea, rg) -> bool
    Delete segment register range started at ea. When a segment register range is
    deleted, the previous range is extended to cover the empty space. The segment
    register range at the beginning of a segment cannot be deleted.
    
    @param ea: (C++: ea_t) start_ea of the deleted range
    @param rg: (C++: int) the segment register number
    @return: success

ida_segregs.get_prev_sreg_range (function)
    get_prev_sreg_range(out, ea, rg) -> bool
    Get segment register range previous to one with address.
    @note: more efficient then get_sreg_range(reg, ea-1)
    
    @param out: (C++: sreg_range_t *) segment register range
    @param ea: (C++: ea_t) any linear address in the program
    @param rg: (C++: int) the segment register number
    @return: success

ida_segregs.get_sreg (function)
    get_sreg(ea, rg) -> sel_t
    Get value of a segment register. This function uses segment register range and
    default segment register values stored in the segment structure.
    
    @param ea: (C++: ea_t) linear address in the program
    @param rg: (C++: int) number of the segment register
    @return: value of the segment register, BADSEL if value is unknown.

ida_segregs.get_sreg_range (function)
    get_sreg_range(out, ea, rg) -> bool
    Get segment register range by linear address.
    
    @param out: (C++: sreg_range_t *) segment register range
    @param ea: (C++: ea_t) any linear address in the program
    @param rg: (C++: int) the segment register number
    @return: success

ida_segregs.get_sreg_range_num (function)
    get_sreg_range_num(ea, rg) -> int
    Get number of segment register range by address.
    
    @param ea: (C++: ea_t) any address in the range
    @param rg: (C++: int) the segment register number
    @return: -1 if no range occupies the specified address. otherwise returns number
             of the specified range (0..get_srranges_qty()-1)

ida_segregs.get_sreg_ranges_qty (function)
    get_sreg_ranges_qty(rg) -> size_t
    Get number of segment register ranges.
    
    @param rg: (C++: int) the segment register number

ida_segregs.getn_sreg_range (function)
    getn_sreg_range(out, rg, n) -> bool
    Get segment register range by its number.
    
    @param out: (C++: sreg_range_t *) segment register range
    @param rg: (C++: int) the segment register number
    @param n: (C++: int) number of range (0..qty()-1)
    @return: success

ida_segregs.set_default_dataseg (function)
    set_default_dataseg(ds_sel)
    Set default value of DS register for all segments.
    
    @param ds_sel: (C++: sel_t)

ida_segregs.set_default_sreg_value (function)
    set_default_sreg_value(sg, rg, value) -> bool
    Set default value of a segment register for a segment.
    
    @param sg: (C++: segment_t *) pointer to segment structure if nullptr, then set the register for
               all segments
    @param rg: (C++: int) number of segment register
    @param value: (C++: sel_t) its default value. this value will be used by get_sreg() if value
                  of the register is unknown at the specified address.
    @return: success

ida_segregs.set_sreg_at_next_code (function)
    set_sreg_at_next_code(ea1, ea2, rg, value)
    Set the segment register value at the next instruction. This function is
    designed to be called from idb_event::sgr_changed handler in order to contain
    the effect of changing a segment register value only until the next instruction.
    
    It is useful, for example, in the ARM module: the modification of the T register
    does not affect existing instructions later in the code.
    
    @param ea1: (C++: ea_t) address to start to search for an instruction
    @param ea2: (C++: ea_t) the maximal address
    @param rg: (C++: int) the segment register number
    @param value: (C++: sel_t) the segment register value

ida_segregs.split_sreg_range (function)
    split_sreg_range(ea, rg, v, tag, silent=False) -> bool
    Create a new segment register range. This function is used when the IDP emulator
    detects that a segment register changes its value.
    
    @param ea: (C++: ea_t) linear address where the segment register will have a new value. if
               ea==BADADDR, nothing to do.
    @param rg: (C++: int) the number of the segment register
    @param v: (C++: sel_t) the new value of the segment register. If the value is unknown, you
              should specify BADSEL.
    @param tag: (C++: uchar) the register info tag. see Segment register range tags
    @param silent: (C++: bool) if false, display a warning() in the case of failure
    @return: success

ida_segregs.sreg_range_t (class)
    Proxy of C++ sreg_range_t class.

ida_segregs.sreg_range_t.__init__ (method)
    __init__(self) -> sreg_range_t

ida_segregs.sreg_range_t.tag (variable)
    Segment register range tags

ida_segregs.sreg_range_t.val (variable)
    segment register value

ida_srclang (module)
    Third-party compiler support.

ida_srclang.SRCLANG_C (variable)
    C.

ida_srclang.SRCLANG_CPP (variable)
    C++.

ida_srclang.SRCLANG_GO (variable)
    Golang (not supported yet)

ida_srclang.SRCLANG_OBJC (variable)
    Objective-C.

ida_srclang.SRCLANG_SWIFT (variable)
    Swift (not supported yet)

ida_srclang.parse_decls_for_srclang (function)
    parse_decls_for_srclang(lang, til, input, is_path) -> int
    Parse type declarations in the specified language
    
    @param lang: (C++: srclang_t) the source language(s) expected in the input
    @param til: (C++: til_t *) type library to store the types
    @param input: (C++: const char *) input source. can be a file path or decl string
    @param is_path: (C++: bool) true if input parameter is a path to a source file, false if the
                    input is an in-memory source snippet
    @retval -1: no parser was found that supports the given source language(s)
    @retval else: the number of errors encountered in the input source

ida_srclang.parse_decls_with_parser (function)
    parse_decls_with_parser(parser_name, til, input, is_path) -> int
    Parse type declarations using the parser with the specified name
    
    @param parser_name: (C++: const char *) name of the target parser
    @param til: (C++: til_t *) type library to store the types
    @param input: (C++: const char *) input source. can be a file path or decl string
    @param is_path: (C++: bool) true if input parameter is a path to a source file, false if the
                    input is an in-memory source snippet
    @retval -1: no parser was found with the given name
    @retval else: the number of errors encountered in the input source

ida_srclang.select_parser_by_name (function)
    select_parser_by_name(name) -> bool
    Set the parser with the given name as the current parser. Pass nullptr or an
    empty string to select the default parser.
    
    @param name: (C++: const char *) char const *
    @return: false if no parser was found with the given name

ida_srclang.select_parser_by_srclang (function)
    select_parser_by_srclang(lang) -> bool
    Set the parser that supports the given language(s) as the current parser. The
    selected parser must support all languages specified by the given srclang_t.
    
    @param lang: (C++: srclang_t)
    @return: false if no such parser was found

ida_srclang.set_parser_argv (function)
    set_parser_argv(parser_name, argv) -> int
    Set the command-line args to use for invocations of the parser with the given
    name
    
    @param parser_name: (C++: const char *) name of the target parser
    @param argv: (C++: const char *) argument list
    @retval -1: no parser was found with the given name
    @retval -2: the operation is not supported by the given parser
    @retval 0: success

ida_strlist (module)
    Functions that deal with the string list.
    
    While the kernel keeps the string list, it does not update it. The string list
    is not used by the kernel because keeping it up-to-date would slow down IDA
    without any benefit. If the string list is not cleared using clear_strlist(),
    the list will be saved to the database and restored on the next startup.
    
    The users of this list should call build_strlist() if they need an up-to-date
    version.

ida_strlist.build_strlist (function)
    build_strlist()
    Rebuild the string list.

ida_strlist.clear_strlist (function)
    clear_strlist()
    Clear the string list.

ida_strlist.get_strlist_item (function)
    get_strlist_item(si, n) -> bool
    Get nth element of the string list (n=0..get_strlist_qty()-1)
    
    @param si: (C++: string_info_t *)
    @param n: (C++: size_t)

ida_strlist.get_strlist_options (function)
    get_strlist_options() -> strwinsetup_t
    Get the static string list options.

ida_strlist.get_strlist_qty (function)
    get_strlist_qty() -> size_t
    Get number of elements in the string list. The list will be loaded from the
    database (if saved) or built from scratch.

ida_strlist.string_info_t (class)
    Proxy of C++ string_info_t class.

ida_strlist.string_info_t.__init__ (method)
    __init__(self, _ea=BADADDR) -> string_info_t
    
    @param _ea: ea_t

ida_strlist.string_info_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: string_info_t const &

ida_strlist.strwinsetup_t (class)
    Proxy of C++ strwinsetup_t class.

ida_strlist.strwinsetup_t.__init__ (method)
    __init__(self) -> strwinsetup_t

ida_strlist.strwinsetup_t._get_strtypes (method)
    _get_strtypes(self) -> PyObject *

ida_strlist.strwinsetup_t._set_strtypes (method)
    _set_strtypes(self, py_t) -> PyObject *
    
    Parameters
    ----------
    py_t: PyObject *

ida_struct (module)
    Structure type management (assembly level types)

ida_struct.MF_BASECLASS (variable)
    a special member representing base class

ida_struct.MF_BYTIL (variable)
    the member was created due to the type system

ida_struct.MF_DTOR (variable)
    a special member representing destructor

ida_struct.MF_DUPNAME (variable)
    duplicate name resolved with _N suffix (N==soff)

ida_struct.MF_HASTI (variable)
    has type information?

ida_struct.MF_HASUNI (variable)
    has members of type "union"?

ida_struct.MF_OK (variable)
    is the member ok? (always yes)

ida_struct.MF_UNIMEM (variable)
    is a member of a union?

ida_struct.SET_MEMTI_BYTIL (variable)
    new type was created by the type subsystem

ida_struct.SET_MEMTI_COMPATIBLE (variable)
    new type must be compatible with the old

ida_struct.SET_MEMTI_FUNCARG (variable)
    mptr is function argument (cannot create arrays)

ida_struct.SET_MEMTI_MAY_DESTROY (variable)
    may destroy other members

ida_struct.SET_MEMTI_USERTI (variable)
    user-specified type

ida_struct.SF_ALIGN (variable)
    alignment (shift amount: 0..31)

ida_struct.SF_FRAME (variable)
    the structure is a function frame

ida_struct.SF_GHOST (variable)
    ghost copy of a local type

ida_struct.SF_HASUNI (variable)
    has members of type "union"?

ida_struct.SF_HIDDEN (variable)
    the structure is collapsed

ida_struct.SF_NOLIST (variable)
    don't include in the chooser list

ida_struct.SF_TYPLIB (variable)
    the structure comes from type library

ida_struct.SF_UNION (variable)
    is a union? varunions are prohibited!

ida_struct.SF_VAR (variable)
    is variable size structure (varstruct)? a variable size structure is one with
    the zero size last member. if the last member is a varstruct, then the current
    structure is a varstruct too.

ida_struct.SMT_ARRAY (variable)
    arrays are forbidden as function arguments

ida_struct.SMT_BADARG (variable)
    bad parameters

ida_struct.SMT_FAILED (variable)
    failed to set new member type

ida_struct.SMT_KEEP (variable)
    no need to change the member type, the old type is better

ida_struct.SMT_NOCOMPAT (variable)
    the new type is not compatible with the old type

ida_struct.SMT_OVERLAP (variable)
    member would overlap with members that cannot be deleted

ida_struct.SMT_SIZE (variable)
    the new type is incompatible with the member size

ida_struct.SMT_WORSE (variable)
    the new type is worse than the old type

ida_struct.STRNFL_REGEX (variable)
    apply regular expressions to beautify the name

ida_struct.STRUC_ERROR_MEMBER_LTUDT (variable)
    failed to change corresponding local type

ida_struct.STRUC_ERROR_MEMBER_NAME (variable)
    already has member with this name (bad name)

ida_struct.STRUC_ERROR_MEMBER_NESTED (variable)
    recursive structure nesting is forbidden

ida_struct.STRUC_ERROR_MEMBER_OFFSET (variable)
    already has member at this offset

ida_struct.STRUC_ERROR_MEMBER_OK (variable)
    success

ida_struct.STRUC_ERROR_MEMBER_SIZE (variable)
    bad number of bytes or bad sizeof(type)

ida_struct.STRUC_ERROR_MEMBER_STRUCT (variable)
    bad struct id (the 1st argument)

ida_struct.STRUC_ERROR_MEMBER_TINFO (variable)
    bad typeid parameter

ida_struct.STRUC_ERROR_MEMBER_UNIVAR (variable)
    unions can't have variable sized members

ida_struct.STRUC_ERROR_MEMBER_VARLAST (variable)
    variable sized member should be the last member in the structure

ida_struct.STRUC_SEPARATOR (variable)
    structname.fieldname

ida_struct.add_struc (function)
    add_struc(idx, name, is_union=False) -> tid_t
    Create a structure type. if idx==BADADDR then add as the last idx. if
    name==nullptr then a name will be generated "struct_%d".
    
    @param idx: (C++: uval_t)
    @param name: (C++: const char *) char const *
    @param is_union: (C++: bool)

ida_struct.add_struc_member (function)
    add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t
    Add member to existing structure.
    
    @param sptr: (C++: struc_t *) structure to modify
    @param fieldname: (C++: const char *) if nullptr, then "anonymous_#" name will be generated
    @param offset: (C++: ea_t) BADADDR means add to the end of structure
    @param flag: (C++: flags64_t) type + representation bits
    @param mt: (C++: const opinfo_t *) additional info about member type. must be present for structs,
               offsets, enums, strings, struct offsets.
    @param nbytes: (C++: asize_t) if == 0 then the structure will be a varstruct. in this case the
                   member should be the last member in the structure

ida_struct.del_member_tinfo (function)
    del_member_tinfo(sptr, mptr) -> bool
    Delete tinfo for given member.
    
    @param sptr: (C++: struc_t *)
    @param mptr: (C++: member_t *)

ida_struct.del_struc (function)
    del_struc(sptr) -> bool
    Delete a structure type This function deletes as well local type synced with the
    structure
    
    @param sptr: (C++: struc_t *)

ida_struct.del_struc_member (function)
    del_struc_member(sptr, offset) -> bool
    Delete member at given offset.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)

ida_struct.del_struc_members (function)
    del_struc_members(sptr, off1, off2) -> int
    Delete members which occupy range of offsets (off1..off2).
    
    @param sptr: (C++: struc_t *)
    @param off1: (C++: ea_t)
    @param off2: (C++: ea_t)
    @return: number of deleted members or -1 on error

ida_struct.dyn_member_ref_array (class)
    Proxy of C++ dynamic_wrapped_array_t< member_t > class.

ida_struct.dyn_member_ref_array.__getitem__ (method)
    __getitem__(self, i) -> member_t
    
    @param i: size_t

ida_struct.dyn_member_ref_array.__init__ (method)
    __init__(self, _data, _count) -> dyn_member_ref_array
    
    @param _data: member_t *
    @param _count: size_t

ida_struct.dyn_member_ref_array.__len__ (method)
    __len__(self) -> size_t

ida_struct.dyn_member_ref_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: member_t const &

ida_struct.expand_struc (function)
    expand_struc(sptr, offset, delta, recalc=True) -> bool
    Expand/Shrink structure type.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param delta: (C++: adiff_t)
    @param recalc: (C++: bool)

ida_struct.get_best_fit_member (function)
    get_best_fit_member(sptr, offset) -> member_t
    Get member that is most likely referenced by the specified offset. Useful for
    offsets > sizeof(struct).
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

ida_struct.get_first_struc_idx (function)
    get_first_struc_idx() -> uval_t
    Get index of first structure.
    
    @return: BADADDR if no known structures, 0 otherwise

ida_struct.get_innermost_member (function)
    get_innermost_member(sptr, offset) -> (member_t, struc_t, int)
    Get the innermost member at the given offset
    
    @param sptr: the starting structure
    @param offset: offset into the starting structure
    @return:     - None on failure
        - tuple(member_t, struct_t, offset)
          where member_t: a member in SPTR (it is not a structure),
                struct_t: the innermost structure,
                offset:   remaining offset into the returned member

ida_struct.get_last_struc_idx (function)
    get_last_struc_idx() -> uval_t
    Get index of last structure.
    
    @return: BADADDR if no known structures, get_struc_qty()-1 otherwise

ida_struct.get_max_offset (function)
    get_max_offset(sptr) -> ea_t
    For unions: returns number of members, for structs: returns size of structure.
    
    @param sptr: (C++: struc_t *)

ida_struct.get_member (function)
    get_member(sptr, offset) -> member_t
    Get member at given offset.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

ida_struct.get_member_by_fullname (function)
    get_member_by_fullname(fullname) -> member_t
    Get a member by its fully qualified name, "struct.field".
    
    @param fullname: (C++: const char *) char const *

ida_struct.get_member_by_id (function)
    get_member_by_id(mid) -> member_t
    Check if the specified member id points to a struct member. convenience
    function.
    
    @param mid: (C++: tid_t)

ida_struct.get_member_by_name (function)
    get_member_by_name(sptr, membername) -> member_t
    Get a member by its name, like "field44".
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param membername: (C++: const char *) char const *

ida_struct.get_member_cmt (function)
    get_member_cmt(mid, repeatable) -> str
    Get comment of structure member.
    
    @param mid: (C++: tid_t)
    @param repeatable: (C++: bool)

ida_struct.get_member_fullname (function)
    get_member_fullname(mid) -> str
    Get a member's fully qualified name, "struct.field".
    
    @param mid: (C++: tid_t)

ida_struct.get_member_id (function)
    get_member_id(sptr, offset) -> tid_t
    Get member id at given offset.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

ida_struct.get_member_name (function)
    get_member_name(mid) -> str
    
    @param mid: tid_t

ida_struct.get_member_size (function)
    get_member_size(NONNULL_mptr) -> asize_t
    Get size of structure member. May return 0 for the last member of varstruct. For
    union members, returns member_t::eoff.
    
    @param NONNULL_mptr: (C++: const member_t *) member_t const *

ida_struct.get_member_struc (function)
    get_member_struc(fullname) -> struc_t
    Get containing structure of member by its full name "struct.field".
    
    @param fullname: (C++: const char *) char const *

ida_struct.get_member_tinfo (function)
    get_member_tinfo(tif, mptr) -> bool
    Get tinfo for given member.
    
    @param tif: (C++: tinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

ida_struct.get_next_member_idx (function)
    get_next_member_idx(sptr, off) -> ssize_t
    Get the next member idx, if it does not exist, return -1.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param off: (C++: asize_t)

ida_struct.get_next_struc_idx (function)
    get_next_struc_idx(idx) -> uval_t
    Get next struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is out of bounds, otherwise idx++

ida_struct.get_or_guess_member_tinfo (function)
    get_or_guess_member_tinfo(tif, mptr) -> bool
    Try to get tinfo for given member - if failed, generate a tinfo using
    information about the member id from the disassembly
    
    @param tif: (C++: tinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

ida_struct.get_prev_member_idx (function)
    get_prev_member_idx(sptr, off) -> ssize_t
    Get the prev member idx, if it does not exist, return -1.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param off: (C++: asize_t)

ida_struct.get_prev_struc_idx (function)
    get_prev_struc_idx(idx) -> uval_t
    Get previous struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is negative, otherwise idx - 1

ida_struct.get_sptr (function)
    get_sptr(mptr) -> struc_t
    Get child struct if member is a struct.
    
    @param mptr: (C++: const member_t *) member_t const *

ida_struct.get_struc (function)
    get_struc(id) -> struc_t
    Get pointer to struct type info.
    
    @param id: (C++: tid_t)

ida_struct.get_struc_by_idx (function)
    get_struc_by_idx(idx) -> tid_t
    Get struct id by struct number.
    
    @param idx: (C++: uval_t)

ida_struct.get_struc_cmt (function)
    get_struc_cmt(id, repeatable) -> str
    Get struct comment.
    
    @param id: (C++: tid_t)
    @param repeatable: (C++: bool)

ida_struct.get_struc_first_offset (function)
    get_struc_first_offset(sptr) -> ea_t
    Get offset of first member.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @return: BADADDR if memqty == 0

ida_struct.get_struc_id (function)
    get_struc_id(name) -> tid_t
    Get struct id by name.
    
    @param name: (C++: const char *) char const *

ida_struct.get_struc_idx (function)
    get_struc_idx(id) -> uval_t
    Get internal number of the structure.
    
    @param id: (C++: tid_t)

ida_struct.get_struc_last_offset (function)
    get_struc_last_offset(sptr) -> ea_t
    Get offset of last member.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @return: BADADDR if memqty == 0

ida_struct.get_struc_name (function)
    get_struc_name(id, flags=0) -> str
    
    @param id: tid_t
    @param flags: int

ida_struct.get_struc_next_offset (function)
    get_struc_next_offset(sptr, offset) -> ea_t
    Get offset of member with smallest offset larger than 'offset'.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: ea_t)
    @return: BADADDR if no next offset

ida_struct.get_struc_prev_offset (function)
    get_struc_prev_offset(sptr, offset) -> ea_t
    Get offset of member with largest offset less than 'offset'.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: ea_t)
    @return: BADADDR if no prev offset

ida_struct.get_struc_qty (function)
    get_struc_qty() -> size_t
    Get number of known structures.

ida_struct.get_struc_size (function)
    get_struc_size(sptr) -> asize_t
    Get struct size (also see get_struc_size(const struc_t *))
    
    @param sptr: struc_t const *
    
    get_struc_size(id) -> asize_t
    
    @param id: tid_t

ida_struct.is_anonymous_member_name (function)
    is_anonymous_member_name(name) -> bool
    Is member name prefixed with "anonymous"?
    
    @param name: (C++: const char *) char const *

ida_struct.is_dummy_member_name (function)
    is_dummy_member_name(name) -> bool
    Is member name an auto-generated name?
    
    @param name: (C++: const char *) char const *

ida_struct.is_member_id (function)
    is_member_id(mid) -> bool
    Is a member id?
    
    @param mid: (C++: tid_t)

ida_struct.is_special_member (function)
    is_special_member(id) -> bool
    Is a special member with the name beginning with ' '?
    
    @param id: (C++: tid_t)

ida_struct.is_union (function)
    is_union(id) -> bool
    Is a union?
    
    @param id: (C++: tid_t)

ida_struct.is_varmember (function)
    is_varmember(mptr) -> bool
    Is variable size member?
    
    @param mptr: (C++: const member_t *) member_t const *

ida_struct.is_varstr (function)
    is_varstr(id) -> bool
    Is variable size structure?
    
    @param id: (C++: tid_t)

ida_struct.member_t (class)
    Proxy of C++ member_t class.

ida_struct.member_t.__init__ (method)
    __init__(self) -> member_t

ida_struct.member_t.by_til (method)
    by_til(self) -> bool
    Was the member created due to the type system?

ida_struct.member_t.eoff (variable)
    end offset

ida_struct.member_t.flag (variable)
    type+representation bits

ida_struct.member_t.get_size (method)
    get_size(self) -> asize_t
    Get member size.

ida_struct.member_t.get_soff (method)
    get_soff(self) -> ea_t
    Get start offset (for unions - returns 0)

ida_struct.member_t.has_ti (method)
    has_ti(self) -> bool
    Has type information?

ida_struct.member_t.has_union (method)
    has_union(self) -> bool
    Has members of type "union"?

ida_struct.member_t.id (variable)
    name(), cmt, rptcmt

ida_struct.member_t.is_baseclass (method)
    is_baseclass(self) -> bool
    Is a base class member?

ida_struct.member_t.is_destructor (method)
    is_destructor(self) -> bool
    Is a virtual destructor?

ida_struct.member_t.is_dupname (method)
    is_dupname(self) -> bool
    Duplicate name was resolved during import?

ida_struct.member_t.props (variable)
    Struct member properties

ida_struct.member_t.soff (variable)
    start offset (for unions - number of the member 0..n)

ida_struct.member_t.unimem (method)
    unimem(self) -> bool
    Is a member of a union?

ida_struct.retrieve_member_info (function)
    retrieve_member_info(buf, mptr) -> opinfo_t
    Get operand type info for member.
    
    @param buf: (C++: opinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

ida_struct.save_struc (function)
    save_struc(sptr, may_update_ltypes=True)
    Update struct information in the database (internal function)
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param may_update_ltypes: (C++: bool)

ida_struct.set_member_cmt (function)
    set_member_cmt(mptr, cmt, repeatable) -> bool
    Set member comment.
    
    @param mptr: (C++: member_t *)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

ida_struct.set_member_name (function)
    set_member_name(sptr, offset, name) -> bool
    Set name of member at given offset.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param name: (C++: const char *) char const *

ida_struct.set_member_tinfo (function)
    set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t
    Set tinfo for given member.
    
    @param sptr: (C++: struc_t *) containing struct
    @param mptr: (C++: member_t *) target member
    @param memoff: (C++: uval_t) offset within member
    @param tif: (C++: const tinfo_t &) type info
    @param flags: (C++: int) Set member tinfo flags

ida_struct.set_member_type (function)
    set_member_type(sptr, offset, flag, mt, nbytes) -> bool
    Set type of member at given offset (also see add_struc_member())
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param flag: (C++: flags64_t)
    @param mt: (C++: const opinfo_t *) opinfo_t const *
    @param nbytes: (C++: asize_t)

ida_struct.set_struc_align (function)
    set_struc_align(sptr, shift) -> bool
    Set structure alignment (SF_ALIGN)
    
    @param sptr: (C++: struc_t *)
    @param shift: (C++: int)

ida_struct.set_struc_cmt (function)
    set_struc_cmt(id, cmt, repeatable) -> bool
    Set structure comment.
    
    @param id: (C++: tid_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

ida_struct.set_struc_hidden (function)
    set_struc_hidden(sptr, is_hidden)
    Hide/unhide a struct type.
    
    @param sptr: (C++: struc_t *)
    @param is_hidden: (C++: bool)

ida_struct.set_struc_idx (function)
    set_struc_idx(sptr, idx) -> bool
    Set internal number of struct. Also see get_struc_idx(), get_struc_by_idx().
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param idx: (C++: uval_t)

ida_struct.set_struc_listed (function)
    set_struc_listed(sptr, is_listed)
    Add/remove a struct type from the struct list.
    
    @param sptr: (C++: struc_t *)
    @param is_listed: (C++: bool)

ida_struct.set_struc_name (function)
    set_struc_name(id, name) -> bool
    Set structure name.
    
    @param id: (C++: tid_t)
    @param name: (C++: const char *) char const *

ida_struct.stroff_as_size (function)
    stroff_as_size(plen, sptr, value) -> bool
    
    @param plen: int
    @param sptr: struc_t const *
    @param value: asize_t
    
    stroff_as_size(plen, tif, value) -> bool
    
    @param plen: int
    @param tif: tinfo_t const &
    @param value: asize_t

ida_struct.struc_t (class)
    Proxy of C++ struc_t class.

ida_struct.struc_t.__get_members__ (method)
    __get_members__(self) -> dyn_member_ref_array

ida_struct.struc_t.__init__ (method)

ida_struct.struc_t.age (variable)
    not used

ida_struct.struc_t.from_til (method)
    from_til(self) -> bool
    Does structure come from a type library?

ida_struct.struc_t.get_alignment (method)
    get_alignment(self) -> int
    See SF_ALIGN.

ida_struct.struc_t.get_last_member (method)
    get_last_member(self) -> member_t

ida_struct.struc_t.get_member (method)

ida_struct.struc_t.has_union (method)
    has_union(self) -> bool
    Has members of type "union"?

ida_struct.struc_t.id (variable)
    struct id

ida_struct.struc_t.is_choosable (method)
    is_choosable(self) -> bool
    Is included in chooser list? Use set_struc_listed to change the listed status

ida_struct.struc_t.is_copyof (method)
    is_copyof(self) -> bool
    Is copied from a local type?

ida_struct.struc_t.is_frame (method)
    is_frame(self) -> bool
    Is this structure a function frame?

ida_struct.struc_t.is_ghost (method)
    is_ghost(self) -> bool
    Is a ghost copy of a local type?

ida_struct.struc_t.is_hidden (method)
    is_hidden(self) -> bool
    Is the structure collapsed? Use set_struc_hidden to change the hidden status

ida_struct.struc_t.is_mappedto (method)
    is_mappedto(self) -> bool
    Is mapped to a local type?

ida_struct.struc_t.is_synced (method)
    is_synced(self) -> bool
    Is synced with a local type?

ida_struct.struc_t.is_union (method)
    is_union(self) -> bool
    Is a union?

ida_struct.struc_t.is_varstr (method)
    is_varstr(self) -> bool
    Is variable size structure?

ida_struct.struc_t.like_union (method)
    like_union(self) -> bool
    Is a union or contains members of type "union"?

ida_struct.struc_t.members (variable)
    only defined members are stored here. there may be gaps between members.

ida_struct.struc_t.memqty (variable)
    number of members

ida_struct.struc_t.ordinal (variable)
    corresponding local type ordinal number

ida_struct.struc_t.props (variable)
    Structure properties

ida_struct.struc_t.set_alignment (method)
    set_alignment(self, shift)
    Do not use; use set_struc_align()
    
    @param shift: (C++: int)

ida_struct.struct_field_visitor_t (class)
    Proxy of C++ struct_field_visitor_t class.

ida_struct.struct_field_visitor_t.__disown__ (method)

ida_struct.struct_field_visitor_t.__init__ (method)
    __init__(self) -> struct_field_visitor_t
    
    @param self: PyObject *

ida_struct.struct_field_visitor_t.visit_field (method)
    visit_field(self, sptr, mptr) -> int
    
    @param sptr: struc_t *
    @param mptr: member_t *

ida_struct.udm_visitor_t (class)
    Proxy of C++ udm_visitor_t class.

ida_struct.udm_visitor_t.__disown__ (method)

ida_struct.udm_visitor_t.__init__ (method)
    __init__(self) -> udm_visitor_t
    
    @param self: PyObject *

ida_struct.udm_visitor_t.visit_udm (method)
    visit_udm(self, tid, tif, udt, idx) -> int
    
    @param tid: (C++: tid_t) udt tid
    @param tif: (C++: const tinfo_t *) udt type info (may be nullptr for corrupted idbs)
    @param udt: (C++: const udt_type_data_t *) udt type data (may be nullptr for corrupted idbs)
    @param idx: (C++: ssize_t) the index of udt the member (may be -1 if udm was not found)

ida_struct.unsync_and_delete_struc (function)
    unsync_and_delete_struc(sptr)
    Delete the structure but leave synced ltudt unchanged. Note del_struc() deletes
    both ASM struc and the corresponding local type
    
    @param sptr: (C++: struc_t *)

ida_struct.visit_stroff_fields (function)
    visit_stroff_fields(sfv, path, disp, appzero) -> flags64_t
    
    @param sfv: struct_field_visitor_t &
    @param path: tid_t const *
    @param disp: adiff_t *
    @param appzero: bool

ida_struct.visit_stroff_udms (function)
    visit_stroff_udms(sfv, path, disp, appzero) -> int
    Visit structure fields in a stroff expression or in a reference to a struct data
    variable. This function can be used to enumerate all components of an expression
    like 'a.b.c'.
    
    @param sfv: (C++: udm_visitor_t &) visitor object
    @param path: (C++: const tid_t *) struct path (path[0] contains the initial struct id)
    @param disp: (C++: adiff_t *) offset into structure
    @param appzero: (C++: bool) should visit field at offset zero?
    @return: visitor result

ida_tryblks (module)
    Architecture independent exception handling info.
    
    Try blocks have the following general properties:
    * A try block specifies a possibly fragmented guarded code region.
    * Each try block has always at least one catch/except block description
    * Each catch block contains its boundaries and a filter.
    * Additionally a catch block can hold sp adjustment and the offset to the
    exception object offset (C++).
    * Try blocks can be nested. Nesting is automatically calculated at the retrieval
    time.
    * There may be (nested) multiple try blocks starting at the same address.
    
    See examples in tests/input/src/eh_tests.

ida_tryblks.TBERR_EMPTY (variable)
    empty try block

ida_tryblks.TBERR_END (variable)
    bad end address

ida_tryblks.TBERR_INTERSECT (variable)
    range would intersect inner tryblk

ida_tryblks.TBERR_KIND (variable)
    illegal try block kind

ida_tryblks.TBERR_NO_CATCHES (variable)
    no catch blocks at all

ida_tryblks.TBERR_OK (variable)
    ok

ida_tryblks.TBERR_ORDER (variable)
    bad address order

ida_tryblks.TBERR_START (variable)
    bad start address

ida_tryblks.add_tryblk (function)
    add_tryblk(tb) -> int
    Add one try block information.
    
    @param tb: (C++: const tryblk_t &) try block to add.
    @return: error code; 0 means good

ida_tryblks.catch_t (class)
    Proxy of C++ catch_t class.

ida_tryblks.catch_t.__init__ (method)
    __init__(self) -> catch_t

ida_tryblks.catchvec_t (class)
    Proxy of C++ qvector< catch_t > class.

ida_tryblks.catchvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< catch_t > const &

ida_tryblks.catchvec_t.__getitem__ (method)
    __getitem__(self, i) -> catch_t
    
    @param i: size_t

ida_tryblks.catchvec_t.__init__ (method)
    __init__(self) -> catchvec_t
    __init__(self, x) -> catchvec_t
    
    @param x: qvector< catch_t > const &

ida_tryblks.catchvec_t.__len__ (method)
    __len__(self) -> size_t

ida_tryblks.catchvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< catch_t > const &

ida_tryblks.catchvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: catch_t const &

ida_tryblks.catchvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: catch_t const &

ida_tryblks.catchvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: catch_t const &

ida_tryblks.catchvec_t.at (method)
    at(self, _idx) -> catch_t
    
    @param _idx: size_t

ida_tryblks.catchvec_t.begin (method)
    begin(self) -> catch_t

ida_tryblks.catchvec_t.capacity (method)
    capacity(self) -> size_t

ida_tryblks.catchvec_t.clear (method)
    clear(self)

ida_tryblks.catchvec_t.empty (method)
    empty(self) -> bool

ida_tryblks.catchvec_t.end (method)
    end(self) -> catch_t

ida_tryblks.catchvec_t.erase (method)
    erase(self, it) -> catch_t
    
    @param it: qvector< catch_t >::iterator
    
    erase(self, first, last) -> catch_t
    
    @param first: qvector< catch_t >::iterator
    @param last: qvector< catch_t >::iterator

ida_tryblks.catchvec_t.extract (method)
    extract(self) -> catch_t

ida_tryblks.catchvec_t.find (method)
    find(self, x) -> catch_t
    
    @param x: catch_t const &

ida_tryblks.catchvec_t.grow (method)
    grow(self, x=catch_t())
    
    @param x: catch_t const &

ida_tryblks.catchvec_t.has (method)
    has(self, x) -> bool
    
    @param x: catch_t const &

ida_tryblks.catchvec_t.inject (method)
    inject(self, s, len)
    
    @param s: catch_t *
    @param len: size_t

ida_tryblks.catchvec_t.insert (method)
    insert(self, it, x) -> catch_t
    
    @param it: qvector< catch_t >::iterator
    @param x: catch_t const &

ida_tryblks.catchvec_t.pop_back (method)
    pop_back(self)

ida_tryblks.catchvec_t.push_back (method)
    push_back(self, x)
    
    @param x: catch_t const &
    
    push_back(self) -> catch_t

ida_tryblks.catchvec_t.qclear (method)
    qclear(self)

ida_tryblks.catchvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_tryblks.catchvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: catch_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_tryblks.catchvec_t.size (method)
    size(self) -> size_t

ida_tryblks.catchvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< catch_t > &

ida_tryblks.catchvec_t.truncate (method)
    truncate(self)

ida_tryblks.del_tryblks (function)
    del_tryblks(range)
    Delete try block information in the specified range.
    
    @param range: (C++: const range_t &) the range to be cleared

ida_tryblks.find_syseh (function)
    find_syseh(ea) -> ea_t
    Find the start address of the system eh region including the argument.
    
    @param ea: (C++: ea_t) search address
    @return: start address of surrounding tryblk, otherwise BADADDR

ida_tryblks.get_tryblks (function)
    get_tryblks(tbv, range) -> size_t
    Retrieve try block information from the specified address range. Try blocks are
    sorted by starting address and their nest levels calculated.
    
    @param tbv: (C++: tryblks_t *) output buffer; may be nullptr
    @param range: (C++: const range_t &) address range to change
    @return: number of found try blocks

ida_tryblks.is_ea_tryblks (function)
    is_ea_tryblks(ea, flags) -> bool
    Check if the given address ea is part of tryblks description.
    
    @param ea: (C++: ea_t) address to check
    @param flags: (C++: uint32) combination of flags for is_ea_tryblks()

ida_tryblks.seh_t (class)
    Proxy of C++ seh_t class.

ida_tryblks.seh_t.__init__ (method)
    __init__(self) -> seh_t

ida_tryblks.seh_t.clear (method)
    clear(self)

ida_tryblks.try_handler_t (class)
    Proxy of C++ try_handler_t class.

ida_tryblks.try_handler_t.__init__ (method)
    __init__(self) -> try_handler_t

ida_tryblks.try_handler_t.clear (method)
    clear(self)

ida_tryblks.tryblk_t (class)
    Proxy of C++ tryblk_t class.

ida_tryblks.tryblk_t.__init__ (method)
    __init__(self) -> tryblk_t
    __init__(self, r) -> tryblk_t
    
    @param r: tryblk_t const &

ida_tryblks.tryblk_t.clear (method)
    clear(self)

ida_tryblks.tryblk_t.cpp (method)
    cpp(self) -> catchvec_t

ida_tryblks.tryblk_t.empty (method)
    empty(self) -> bool

ida_tryblks.tryblk_t.get_kind (method)
    get_kind(self) -> uchar

ida_tryblks.tryblk_t.is_cpp (method)
    is_cpp(self) -> bool

ida_tryblks.tryblk_t.is_seh (method)
    is_seh(self) -> bool

ida_tryblks.tryblk_t.seh (method)
    seh(self) -> seh_t

ida_tryblks.tryblk_t.set_cpp (method)
    set_cpp(self) -> catchvec_t

ida_tryblks.tryblk_t.set_seh (method)
    set_seh(self) -> seh_t

ida_tryblks.tryblks_t (class)
    Proxy of C++ qvector< tryblk_t > class.

ida_tryblks.tryblks_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< tryblk_t > const &

ida_tryblks.tryblks_t.__getitem__ (method)
    __getitem__(self, i) -> tryblk_t
    
    @param i: size_t

ida_tryblks.tryblks_t.__init__ (method)
    __init__(self) -> tryblks_t
    __init__(self, x) -> tryblks_t
    
    @param x: qvector< tryblk_t > const &

ida_tryblks.tryblks_t.__len__ (method)
    __len__(self) -> size_t

ida_tryblks.tryblks_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< tryblk_t > const &

ida_tryblks.tryblks_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: tryblk_t const &

ida_tryblks.tryblks_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: tryblk_t const &

ida_tryblks.tryblks_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: tryblk_t const &

ida_tryblks.tryblks_t.at (method)
    at(self, _idx) -> tryblk_t
    
    @param _idx: size_t

ida_tryblks.tryblks_t.begin (method)
    begin(self) -> tryblk_t

ida_tryblks.tryblks_t.capacity (method)
    capacity(self) -> size_t

ida_tryblks.tryblks_t.clear (method)
    clear(self)

ida_tryblks.tryblks_t.empty (method)
    empty(self) -> bool

ida_tryblks.tryblks_t.end (method)
    end(self) -> tryblk_t

ida_tryblks.tryblks_t.erase (method)
    erase(self, it) -> tryblk_t
    
    @param it: qvector< tryblk_t >::iterator
    
    erase(self, first, last) -> tryblk_t
    
    @param first: qvector< tryblk_t >::iterator
    @param last: qvector< tryblk_t >::iterator

ida_tryblks.tryblks_t.extract (method)
    extract(self) -> tryblk_t

ida_tryblks.tryblks_t.find (method)
    find(self, x) -> tryblk_t
    
    @param x: tryblk_t const &

ida_tryblks.tryblks_t.grow (method)
    grow(self, x=tryblk_t())
    
    @param x: tryblk_t const &

ida_tryblks.tryblks_t.has (method)
    has(self, x) -> bool
    
    @param x: tryblk_t const &

ida_tryblks.tryblks_t.inject (method)
    inject(self, s, len)
    
    @param s: tryblk_t *
    @param len: size_t

ida_tryblks.tryblks_t.insert (method)
    insert(self, it, x) -> tryblk_t
    
    @param it: qvector< tryblk_t >::iterator
    @param x: tryblk_t const &

ida_tryblks.tryblks_t.pop_back (method)
    pop_back(self)

ida_tryblks.tryblks_t.push_back (method)
    push_back(self, x)
    
    @param x: tryblk_t const &
    
    push_back(self) -> tryblk_t

ida_tryblks.tryblks_t.qclear (method)
    qclear(self)

ida_tryblks.tryblks_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_tryblks.tryblks_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: tryblk_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_tryblks.tryblks_t.size (method)
    size(self) -> size_t

ida_tryblks.tryblks_t.swap (method)
    swap(self, r)
    
    @param r: qvector< tryblk_t > &

ida_tryblks.tryblks_t.truncate (method)
    truncate(self)

ida_typeinf (module)
    Describes the type information records in IDA.
    
    The recommended way of using type info is to use the tinfo_t class. The type
    information is internally kept as an array of bytes terminated by 0.
    
    Items in brackets [] are optional and sometimes are omitted. type_t... means a
    sequence of type_t bytes which defines a type.
    
    @note: to work with the types of instructions or data in the database, use
           get_tinfo()/set_tinfo() and similar functions.

ida_typeinf.ADDTIL_ABORTED (variable)
    til was not loaded (incompatible til rejected by user)

ida_typeinf.ADDTIL_COMP (variable)
    ok, but til is not compatible with the current compiler

ida_typeinf.ADDTIL_DEFAULT (variable)
    default behavior

ida_typeinf.ADDTIL_FAILED (variable)
    something bad, the warning is displayed

ida_typeinf.ADDTIL_INCOMP (variable)
    load incompatible tils

ida_typeinf.ADDTIL_OK (variable)
    ok, til is loaded

ida_typeinf.ADDTIL_SILENT (variable)
    do not ask any questions

ida_typeinf.ALOC_CUSTOM (variable)
    custom argloc (7 or higher)

ida_typeinf.ALOC_DIST (variable)
    distributed (scattered)

ida_typeinf.ALOC_NONE (variable)
    none

ida_typeinf.ALOC_REG1 (variable)
    one register (and offset within it)

ida_typeinf.ALOC_REG2 (variable)
    register pair

ida_typeinf.ALOC_RREL (variable)
    register relative

ida_typeinf.ALOC_STACK (variable)
    stack offset

ida_typeinf.ALOC_STATIC (variable)
    global address

ida_typeinf.ARGREGS_BY_SLOTS (variable)
    fixed FP/GP register per each slot (like vc64)

ida_typeinf.ARGREGS_FP_CONSUME_GP (variable)
    FP register also consumes one or more GP regs but not vice versa (aix ppc ABI)

ida_typeinf.ARGREGS_GP_ONLY (variable)
    GP registers used for all arguments.

ida_typeinf.ARGREGS_INDEPENDENT (variable)
    FP/GP registers used separately (like gcc64)

ida_typeinf.ARGREGS_MIPS_O32 (variable)
    MIPS ABI o32.

ida_typeinf.BADSIZE (variable)
    bad type size

ida_typeinf.BFA_FUNC_EXT_FORMAT (variable)
    This is NOT a real attribute (used internally as marker for extended format)

ida_typeinf.BFA_FUNC_MARKER (variable)
    This is NOT a cc! (used internally as a marker)

ida_typeinf.BFA_HIGH (variable)
    high level prototype (with possibly hidden args)

ida_typeinf.BFA_NORET (variable)
    __noreturn

ida_typeinf.BFA_PURE (variable)
    __pure

ida_typeinf.BFA_STATIC (variable)
    static

ida_typeinf.BFA_VIRTUAL (variable)
    virtual

ida_typeinf.BTE_ALWAYS (variable)
    this bit MUST be present

ida_typeinf.BTE_BITMASK (variable)
    'subarrays'. In this case ANY record has the following format:
    * 'de' mask (has name)
    * 'dt' cnt
    * cnt records of 'de' values (cnt CAN be 0)
    @note: delta for ALL subsegment is ONE

ida_typeinf.BTE_CHAR (variable)
    char or hex

ida_typeinf.BTE_HEX (variable)
    hex

ida_typeinf.BTE_OUT_MASK (variable)
    output style mask

ida_typeinf.BTE_RESERVED (variable)
    must be 0, in order to distinguish from a tah-byte

ida_typeinf.BTE_SDEC (variable)
    signed decimal

ida_typeinf.BTE_SIZE_MASK (variable)
    storage size.
    * if == 0 then inf_get_cc_size_e()
    * else 1 << (n -1) = 1,2,4,8
    * n == 5,6,7 are reserved

ida_typeinf.BTE_UDEC (variable)
    unsigned decimal

ida_typeinf.BTF_BOOL (variable)
    boolean

ida_typeinf.BTF_BYTE (variable)
    byte

ida_typeinf.BTF_CHAR (variable)
    signed char

ida_typeinf.BTF_DOUBLE (variable)
    double

ida_typeinf.BTF_ENUM (variable)
    enum

ida_typeinf.BTF_FLOAT (variable)
    float

ida_typeinf.BTF_INT (variable)
    int, unknown signedness

ida_typeinf.BTF_INT128 (variable)
    signed 128-bit value

ida_typeinf.BTF_INT16 (variable)
    signed short

ida_typeinf.BTF_INT32 (variable)
    signed int

ida_typeinf.BTF_INT64 (variable)
    signed long

ida_typeinf.BTF_INT8 (variable)
    signed byte

ida_typeinf.BTF_LDOUBLE (variable)
    long double

ida_typeinf.BTF_SINT (variable)
    singed int

ida_typeinf.BTF_STRUCT (variable)
    struct

ida_typeinf.BTF_TBYTE (variable)
    see BTMT_SPECFLT

ida_typeinf.BTF_TYPEDEF (variable)
    typedef

ida_typeinf.BTF_UCHAR (variable)
    unsigned char

ida_typeinf.BTF_UINT (variable)
    unsigned int

ida_typeinf.BTF_UINT128 (variable)
    unsigned 128-bit value

ida_typeinf.BTF_UINT16 (variable)
    unsigned short

ida_typeinf.BTF_UINT32 (variable)
    unsigned int

ida_typeinf.BTF_UINT64 (variable)
    unsigned long

ida_typeinf.BTF_UINT8 (variable)
    unsigned byte

ida_typeinf.BTF_UNION (variable)
    union

ida_typeinf.BTF_UNK (variable)
    unknown

ida_typeinf.BTF_VOID (variable)
    void

ida_typeinf.BTMT_ARRESERV (variable)
    reserved bit

ida_typeinf.BTMT_BFLDI16 (variable)
    __int16

ida_typeinf.BTMT_BFLDI32 (variable)
    __int32

ida_typeinf.BTMT_BFLDI64 (variable)
    __int64

ida_typeinf.BTMT_BFLDI8 (variable)
    __int8

ida_typeinf.BTMT_BOOL1 (variable)
    size 1byte

ida_typeinf.BTMT_BOOL2 (variable)
    size 2bytes - !inf_is_64bit()

ida_typeinf.BTMT_BOOL4 (variable)
    size 4bytes

ida_typeinf.BTMT_BOOL8 (variable)
    size 8bytes - inf_is_64bit()

ida_typeinf.BTMT_CHAR (variable)
    specify char or segment register
    * BT_INT8 - char
    * BT_INT - segment register
    * other BT_INT... - don't use

ida_typeinf.BTMT_CLOSURE (variable)
    closure.
    * if ptr to BT_FUNC - __closure. in this case next byte MUST be RESERVED_BYTE,
    and after it BT_FUNC
    * else the next byte contains sizeof(ptr) allowed values are 1 - ph.max_ptr_size
    * if value is bigger than ph.max_ptr_size, based_ptr_name_and_size() is called
    to find out the typeinfo

ida_typeinf.BTMT_DEFBOOL (variable)
    size is model specific or unknown(?)

ida_typeinf.BTMT_DEFCALL (variable)
    call method - default for model or unknown

ida_typeinf.BTMT_DEFPTR (variable)
    default for model

ida_typeinf.BTMT_DOUBLE (variable)
    double (8 bytes)

ida_typeinf.BTMT_FAR (variable)
    far

ida_typeinf.BTMT_FARCALL (variable)
    function returns by retf

ida_typeinf.BTMT_FLOAT (variable)
    float (4 bytes)

ida_typeinf.BTMT_INTCALL (variable)
    function returns by iret in this case cc MUST be 'unknown'

ida_typeinf.BTMT_LNGDBL (variable)
    long double (compiler specific)

ida_typeinf.BTMT_NEAR (variable)
    near

ida_typeinf.BTMT_NEARCALL (variable)
    function returns by retn

ida_typeinf.BTMT_NONBASED (variable)
    if set
    array base==0
    format: dt num_elem; [tah-typeattrs]; type_t...
    if num_elem==0 then the array size is unknown
    else
    format: da num_elem, base; [tah-typeattrs]; type_t...
    used only for serialization

ida_typeinf.BTMT_SIGNED (variable)
    signed

ida_typeinf.BTMT_SIZE0 (variable)
    BT_VOID - normal void; BT_UNK - don't use

ida_typeinf.BTMT_SIZE12 (variable)
    size = 1 byte if BT_VOID; 2 if BT_UNK

ida_typeinf.BTMT_SIZE128 (variable)
    size = 16 bytes if BT_VOID; unknown if BT_UNK (IN struct alignment - see below)

ida_typeinf.BTMT_SIZE48 (variable)
    size = 4 bytes if BT_VOID; 8 if BT_UNK

ida_typeinf.BTMT_SPECFLT (variable)
    float (variable size). if processor_t::use_tbyte() then use
    processor_t::tbyte_size, otherwise 2 bytes

ida_typeinf.BTMT_TYPEDEF (variable)
    named reference always p_string name

ida_typeinf.BTMT_UNKSIGN (variable)
    unknown signedness

ida_typeinf.BTMT_USIGNED (variable)
    unsigned

ida_typeinf.BTM_CONST (variable)
    const

ida_typeinf.BTM_VOLATILE (variable)
    volatile

ida_typeinf.BT_ARRAY (variable)
    array

ida_typeinf.BT_BITFIELD (variable)
    bitfield (only in struct) ['bitmasked' enum see below] next byte is dt ((size in
    bits << 1) | (unsigned ? 1 : 0))

ida_typeinf.BT_BOOL (variable)
    bool

ida_typeinf.BT_COMPLEX (variable)
    struct/union/enum/typedef. format:
    [dt N (N=field count) if !BTMT_TYPEDEF]
           if N == 0:
             p_string name (unnamed types have names "anon_...")
             [sdacl-typeattrs];
           else, for struct & union:
             if N == 0x7FFE   // Support for high (i.e., > 4095) members count
               N = deserialize_de()
             ALPOW = N & 0x7
             MCNT = N >> 3
             if MCNT == 0
               empty struct
             if ALPOW == 0
               ALIGN = get_default_align()
             else
               ALIGN = (1 << (ALPOW - 1))
             [sdacl-typeattrs];
           else, for enums:
             if N == 0x7FFE   // Support for high enum entries count.
               N = deserialize_de()
             [tah-typeattrs];

ida_typeinf.BT_FLOAT (variable)
    float

ida_typeinf.BT_FUNC (variable)
    function. format:
    optional: CM_CC_SPOILED | num_of_spoiled_regs
                    if num_of_spoiled_reg == BFA_FUNC_MARKER:
                      ::bfa_byte
                      if (bfa_byte & BFA_FUNC_EXT_FORMAT) != 0
                       ::fti_bits (only low bits: FTI_SPOILED,...,FTI_VIRTUAL)
                       num_of_spoiled_reg times: spoiled reg info (see
    extract_spoiledreg)
                      else
                        bfa_byte is function attribute byte (see Function attribute
    byte...)
                    else:
                      num_of_spoiled_reg times: spoiled reg info (see
    extract_spoiledreg)
          cm_t ... calling convention and memory model
          [tah-typeattrs];
          type_t ... return type;
          [serialized argloc_t of returned value (if CM_CC_SPECIAL{PE} && !return
    void);
          if !CM_CC_VOIDARG:
            dt N (N=number of parameters)
            if ( N == 0 )
            if CM_CC_ELLIPSIS or CM_CC_SPECIALE
                func(...)
              else
                parameters are unknown
            else
              N records:
                type_t ... (i.e. type of each parameter)
                [serialized argloc_t (if CM_CC_SPECIAL{PE})] (i.e. place of each
    parameter)
                [FAH_BYTE + de( funcarg_t::flags )]

ida_typeinf.BT_INT (variable)
    natural int. (size provided by idp module)

ida_typeinf.BT_INT128 (variable)
    __int128 (for alpha & future use)

ida_typeinf.BT_INT16 (variable)
    __int16

ida_typeinf.BT_INT32 (variable)
    __int32

ida_typeinf.BT_INT64 (variable)
    __int64

ida_typeinf.BT_INT8 (variable)
    __int8

ida_typeinf.BT_PTR (variable)
    pointer. has the following format: [db sizeof(ptr)]; [tah-typeattrs]; type_t...

ida_typeinf.BT_RESERVED (variable)
    RESERVED.

ida_typeinf.BT_SEGREG (variable)
    segment register

ida_typeinf.BT_UNK (variable)
    unknown

ida_typeinf.BT_UNKNOWN (variable)
    unknown size - for parameters

ida_typeinf.BT_UNK_BYTE (variable)
    1 byte

ida_typeinf.BT_UNK_DWORD (variable)
    4 bytes

ida_typeinf.BT_UNK_OWORD (variable)
    16 bytes

ida_typeinf.BT_UNK_QWORD (variable)
    8 bytes

ida_typeinf.BT_UNK_WORD (variable)
    2 bytes

ida_typeinf.BT_VOID (variable)
    void

ida_typeinf.CC_ALLOW_ARGPERM (variable)
    disregard argument order?

ida_typeinf.CC_ALLOW_REGHOLES (variable)
    allow holes in register argument list?

ida_typeinf.CC_CDECL_OK (variable)
    can use __cdecl calling convention?

ida_typeinf.CC_GOLANG_OK (variable)
    can use __golang calling convention

ida_typeinf.CC_HAS_ELLIPSIS (variable)
    function has a variable list of arguments?

ida_typeinf.CM_CC_CDECL (variable)
    stack

ida_typeinf.CM_CC_ELLIPSIS (variable)
    cdecl + ellipsis

ida_typeinf.CM_CC_FASTCALL (variable)
    stack, purged (x86), first args are in regs (compiler-dependent)

ida_typeinf.CM_CC_GOLANG (variable)
    (Go) arguments and return value in stack

ida_typeinf.CM_CC_INVALID (variable)
    this value is invalid

ida_typeinf.CM_CC_PASCAL (variable)
    stack, purged, reverse order of args

ida_typeinf.CM_CC_SPECIALE (variable)
    CM_CC_SPECIAL with ellipsis

ida_typeinf.CM_CC_SPECIALP (variable)
    Equal to CM_CC_SPECIAL, but with purged stack.

ida_typeinf.CM_CC_SPOILED (variable)
    This is NOT a cc! Mark of __spoil record the low nibble is count and after n
    {spoilreg_t} present real cm_t byte. if n == BFA_FUNC_MARKER, the next byte is
    the function attribute byte.

ida_typeinf.CM_CC_STDCALL (variable)
    stack, purged

ida_typeinf.CM_CC_SWIFT (variable)
    (Swift) arguments and return values in registers (compiler-dependent)

ida_typeinf.CM_CC_THISCALL (variable)
    stack, purged (x86), first arg is in reg (compiler-dependent)

ida_typeinf.CM_CC_UNKNOWN (variable)
    unknown calling convention

ida_typeinf.CM_CC_VOIDARG (variable)
    function without arguments if has other cc and argnum == 0, represent as f() -
    unknown list

ida_typeinf.CM_N16_F32 (variable)
    near 2 bytes, far 4 bytes

ida_typeinf.CM_N32_F48 (variable)
    near 4 bytes, far 6 bytes

ida_typeinf.CM_N64 (variable)
    if sizeof(int)>2: near 8 bytes, far 8 bytes

ida_typeinf.CM_N8_F16 (variable)
    if sizeof(int)<=2: near 1 byte, far 2 bytes

ida_typeinf.CM_UNKNOWN (variable)
    unknown

ida_typeinf.COMP_BC (variable)
    Borland C++.

ida_typeinf.COMP_BP (variable)
    Delphi.

ida_typeinf.COMP_GNU (variable)
    GNU C++.

ida_typeinf.COMP_MS (variable)
    Visual C++.

ida_typeinf.COMP_UNK (variable)
    Unknown.

ida_typeinf.COMP_UNSURE (variable)
    uncertain compiler id

ida_typeinf.COMP_VISAGE (variable)
    Visual Age C++.

ida_typeinf.COMP_WATCOM (variable)
    Watcom C++.

ida_typeinf.DEFMASK64 (variable)
    default bitmask 64bits

ida_typeinf.ETF_ASMENUM (variable)
    asm enum compatibility mode *-

ida_typeinf.ETF_AUTONAME (variable)
    generate a member name if was not specified (add_udm, set_udm_type)

ida_typeinf.ETF_COMPATIBLE (variable)
    new type must be compatible with the old

ida_typeinf.ETF_FORCENAME (variable)
    anyway use name, see below for more usage description

ida_typeinf.ETF_FUNCARG (variable)
    mptr is function argument (cannot create arrays)

ida_typeinf.ETF_MAY_DESTROY (variable)
    may destroy other members

ida_typeinf.ETF_NO_IDBSYNC (variable)
    do not sync type to IDB (udt only) *-

ida_typeinf.ETF_NO_LAYOUT (variable)
    don't calc type layout before editing

ida_typeinf.ETF_NO_SAVE (variable)
    don't save to til (normally typerefs are saved to til) A call with ETF_NO_SAVE
    must be followed by a call without it. Otherwise there may be inconsistencies
    between the memory and the type library.

ida_typeinf.FAH_BYTE (variable)
    function argument attribute header byte

ida_typeinf.FAI_ARRAY (variable)
    was initially an array; see "__org_typedef" or "__org_arrdim" type attributes to
    determine the original type

ida_typeinf.FAI_HIDDEN (variable)
    hidden argument

ida_typeinf.FAI_RETPTR (variable)
    pointer to return value. implies hidden

ida_typeinf.FAI_STRUCT (variable)
    was initially a structure

ida_typeinf.FAI_UNUSED (variable)
    argument is not used by the function

ida_typeinf.FIRST_NONTRIVIAL_TYPID (variable)
    Denotes the first bit describing a nontrivial type.

ida_typeinf.FRB_CHAR (variable)
    Char.

ida_typeinf.FRB_CUSTOM (variable)
    *Custom data type

ida_typeinf.FRB_ENUM (variable)
    *Enumeration

ida_typeinf.FRB_FLOAT (variable)
    Floating point number (for interpreting an integer type as a floating value)

ida_typeinf.FRB_INVBITS (variable)
    Invert bits (0x01 is represented as ~0xFE)

ida_typeinf.FRB_INVSIGN (variable)
    Invert sign (0x01 is represented as -0xFF)

ida_typeinf.FRB_LZERO (variable)
    Toggle leading zeroes (used for integers)

ida_typeinf.FRB_MASK (variable)
    Mask for the value type (* means requires additional info):

ida_typeinf.FRB_NUMB (variable)
    Binary number.

ida_typeinf.FRB_NUMD (variable)
    Decimal number.

ida_typeinf.FRB_NUMH (variable)
    Hexadecimal number.

ida_typeinf.FRB_NUMO (variable)
    Octal number.

ida_typeinf.FRB_OFFSET (variable)
    *Offset

ida_typeinf.FRB_SEG (variable)
    Segment.

ida_typeinf.FRB_SIGNED (variable)
    Force signed representation.

ida_typeinf.FRB_STRLIT (variable)
    *String literal (used for arrays)

ida_typeinf.FRB_STROFF (variable)
    *Struct offset

ida_typeinf.FRB_TABFORM (variable)
    has additional tabular parameters

ida_typeinf.FRB_UNK (variable)
    Unknown.

ida_typeinf.FTI_ALL (variable)
    all defined bits

ida_typeinf.FTI_ARGLOCS (variable)
    info about argument locations has been calculated (stkargs and retloc too)

ida_typeinf.FTI_CALLTYPE (variable)
    mask for FTI_*CALL

ida_typeinf.FTI_CONST (variable)
    const member function

ida_typeinf.FTI_CTOR (variable)
    constructor

ida_typeinf.FTI_DEFCALL (variable)
    default call

ida_typeinf.FTI_DTOR (variable)
    destructor

ida_typeinf.FTI_EXPLOCS (variable)
    all arglocs are specified explicitly

ida_typeinf.FTI_FARCALL (variable)
    far call

ida_typeinf.FTI_HIGH (variable)
    high level prototype (with possibly hidden args)

ida_typeinf.FTI_INTCALL (variable)
    interrupt call

ida_typeinf.FTI_NEARCALL (variable)
    near call

ida_typeinf.FTI_NORET (variable)
    noreturn

ida_typeinf.FTI_PURE (variable)
    __pure

ida_typeinf.FTI_SPOILED (variable)
    information about spoiled registers is present

ida_typeinf.FTI_STATIC (variable)
    static

ida_typeinf.FTI_VIRTUAL (variable)
    virtual

ida_typeinf.GTD_CALC_ARGLOCS (variable)
    calculate func arg locations

ida_typeinf.GTD_CALC_LAYOUT (variable)
    calculate udt layout

ida_typeinf.GTD_DEL_BITFLDS (variable)
    delete udt bitfields

ida_typeinf.GTD_NO_ARGLOCS (variable)
    don't calculate func arg locations please note that the locations may have been
    calculated earlier

ida_typeinf.GTD_NO_LAYOUT (variable)
    don't calculate udt layout please note that udt layout may have been calculated
    earlier

ida_typeinf.GTS_BASECLASS (variable)
    is baseclass of a udt

ida_typeinf.GTS_NESTED (variable)
    nested type (embedded into a udt)

ida_typeinf.GUESS_FUNC_FAILED (variable)
    couldn't guess the function type

ida_typeinf.GUESS_FUNC_OK (variable)
    ok, some non-trivial information is gathered

ida_typeinf.GUESS_FUNC_TRIVIAL (variable)
    the function type doesn't have interesting info

ida_typeinf.HTI_CPP (variable)
    C++ mode (not implemented)

ida_typeinf.HTI_DCL (variable)
    don't complain about redeclarations

ida_typeinf.HTI_FIL (variable)
    "input" is file name, otherwise "input" contains a C declaration

ida_typeinf.HTI_HIGH (variable)
    assume high level prototypes (with hidden args, etc)

ida_typeinf.HTI_LOWER (variable)
    lower the function prototypes

ida_typeinf.HTI_MAC (variable)
    define macros from the base tils

ida_typeinf.HTI_NDC (variable)
    don't decorate names

ida_typeinf.HTI_NER (variable)
    ignore all errors but display them

ida_typeinf.HTI_NOBASE (variable)
    do not inspect base tils

ida_typeinf.HTI_NWR (variable)
    no warning messages

ida_typeinf.HTI_PAK (variable)
    explicit structure pack value (#pragma pack)

ida_typeinf.HTI_PAK1 (variable)
    #pragma pack(1)

ida_typeinf.HTI_PAK16 (variable)
    #pragma pack(16)

ida_typeinf.HTI_PAK2 (variable)
    #pragma pack(2)

ida_typeinf.HTI_PAK4 (variable)
    #pragma pack(4)

ida_typeinf.HTI_PAK8 (variable)
    #pragma pack(8)

ida_typeinf.HTI_PAKDEF (variable)
    default pack value

ida_typeinf.HTI_PAK_SHIFT (variable)
    shift for HTI_PAK. This field should be used if you want to remember an explicit
    pack value for each structure/union type. See HTI_PAK... definitions

ida_typeinf.HTI_RAWARGS (variable)
    leave argument names unchanged (do not remove underscores)

ida_typeinf.HTI_RELAXED (variable)
    accept references to unknown namespaces

ida_typeinf.HTI_TST (variable)
    test mode: discard the result

ida_typeinf.IMPTYPE_LOCAL (variable)
    the type is local, the struct/enum won't be marked as til type. there is no need
    to specify this bit if til==idati, the kernel will set it automatically

ida_typeinf.MAX_FUNC_ARGS (variable)
    max number of function arguments

ida_typeinf.NTF_64BIT (variable)
    value is 64bit

ida_typeinf.NTF_CHKSYNC (variable)
    check that synchronization to IDB passed OK (set_numbered_type, set_named_type)

ida_typeinf.NTF_COPY (variable)
    save a new type definition, not a typeref (tinfo_t::set_numbered_type,
    tinfo_t::set_named_type)

ida_typeinf.NTF_FIXNAME (variable)
    force-validate the name of the type when setting (set_named_type,
    set_numbered_type only)

ida_typeinf.NTF_IDBENC (variable)
    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly (set_named_type, set_numbered_type only)

ida_typeinf.NTF_NOBASE (variable)
    don't inspect base tils (for get_named_type)

ida_typeinf.NTF_NOCUR (variable)
    don't inspect current til file (for get_named_type)

ida_typeinf.NTF_NO_NAMECHK (variable)
    do not validate type name (set_numbered_type, set_named_type)

ida_typeinf.NTF_REPLACE (variable)
    replace original type (for set_named_type)

ida_typeinf.NTF_SYMM (variable)
    symbol, name is mangled ('_func'); only one of NTF_TYPE and NTF_SYMU, NTF_SYMM
    can be used

ida_typeinf.NTF_SYMU (variable)
    symbol, name is unmangled ('func')

ida_typeinf.NTF_TYPE (variable)
    type name

ida_typeinf.NTF_UMANGLED (variable)
    name is unmangled (don't use this flag)

ida_typeinf.PDF_DEF_BASE (variable)
    Include base types: __int8, __int16, etc..

ida_typeinf.PDF_DEF_FWD (variable)
    Allow forward declarations.

ida_typeinf.PDF_HEADER_CMT (variable)
    Prepend output with a descriptive comment.

ida_typeinf.PDF_INCL_DEPS (variable)
    Include all type dependencies.

ida_typeinf.PIO_IGNORE_PTRS (variable)
    do not follow pointers

ida_typeinf.PIO_NOATTR_FAIL (variable)
    missing attributes are not ok

ida_typeinf.PRALOC_STKOFF (variable)
    print stack offsets

ida_typeinf.PRALOC_VERIFY (variable)
    interr if illegal argloc

ida_typeinf.PRTYPE_1LINCMT (variable)
    print comments even in the one line mode

ida_typeinf.PRTYPE_1LINE (variable)
    print to one line

ida_typeinf.PRTYPE_COLORED (variable)
    add color tag COLOR_SYMBOL for any parentheses, commas and colons

ida_typeinf.PRTYPE_CPP (variable)
    use c++ name (only for print_type())

ida_typeinf.PRTYPE_HEADER (variable)
    print only type header (only for definitions)

ida_typeinf.PRTYPE_MAXSTR (variable)
    limit the output length to 1024 bytes (the output may be slightly longer)

ida_typeinf.PRTYPE_MULTI (variable)
    print to many lines

ida_typeinf.PRTYPE_NOREGEX (variable)
    do not apply regular expressions to beautify name

ida_typeinf.PRTYPE_PRAGMA (variable)
    print pragmas for alignment

ida_typeinf.PRTYPE_SEMI (variable)
    append ; to the end

ida_typeinf.PRTYPE_TYPE (variable)
    print type declaration (not variable declaration)

ida_typeinf.PT_HIGH (variable)
    assume high level prototypes (with hidden args, etc)

ida_typeinf.PT_LOWER (variable)
    lower the function prototypes

ida_typeinf.PT_NDC (variable)
    don't decorate names

ida_typeinf.PT_PACKMASK (variable)
    mask for pack alignment values

ida_typeinf.PT_RAWARGS (variable)
    leave argument names unchanged (do not remove underscores)

ida_typeinf.PT_RELAXED (variable)
    accept references to unknown namespaces

ida_typeinf.PT_REPLACE (variable)
    replace the old type (used in idc)

ida_typeinf.PT_SIL (variable)
    silent, no messages

ida_typeinf.PT_TYP (variable)
    return declared type information

ida_typeinf.PT_VAR (variable)
    return declared object information

ida_typeinf.RESERVED_BYTE (variable)
    multifunctional purpose

ida_typeinf.SC_AUTO (variable)
    auto

ida_typeinf.SC_EXT (variable)
    extern

ida_typeinf.SC_FRIEND (variable)
    friend

ida_typeinf.SC_REG (variable)
    register

ida_typeinf.SC_STAT (variable)
    static

ida_typeinf.SC_TYPE (variable)
    typedef

ida_typeinf.SC_UNK (variable)
    unknown

ida_typeinf.SC_VIRT (variable)
    virtual

ida_typeinf.SETCOMP_BY_USER (variable)
    invoked by user, cannot be replaced by module/loader

ida_typeinf.SETCOMP_ONLY_ABI (variable)
    ignore cc field complete, use only abiname

ida_typeinf.SETCOMP_ONLY_ID (variable)
    cc has only 'id' field; the rest will be set to defaults corresponding to the
    program bitness

ida_typeinf.SETCOMP_OVERRIDE (variable)
    may override old compiler info

ida_typeinf.STI_ACCHAR (variable)
    const char[]

ida_typeinf.STI_ACHAR (variable)
    char[]

ida_typeinf.STI_ACUCHAR (variable)
    const uint8[]

ida_typeinf.STI_AEABI_LCMP (variable)
    int __fastcall __pure(int64 x, int64 y)

ida_typeinf.STI_AEABI_MEMCLR (variable)
    void __fastcall(void *, size_t)

ida_typeinf.STI_AEABI_MEMCPY (variable)
    void __fastcall(void *, const void *, size_t)

ida_typeinf.STI_AEABI_MEMSET (variable)
    void __fastcall(void *, size_t, int)

ida_typeinf.STI_AEABI_ULCMP (variable)
    int __fastcall __pure(uint64 x, uint64 y)

ida_typeinf.STI_AUCHAR (variable)
    uint8[]

ida_typeinf.STI_COMPLEX128 (variable)
    struct complex128_t { double real, imag; }

ida_typeinf.STI_COMPLEX64 (variable)
    struct complex64_t { float real, imag; }

ida_typeinf.STI_DONT_USE (variable)
    unused stock type id; should not be used

ida_typeinf.STI_FDELOP (variable)
    void __cdecl(void *)

ida_typeinf.STI_FPURGING (variable)
    void __userpurge(int)

ida_typeinf.STI_MSGSEND (variable)
    void *(void *, const char *, ...)

ida_typeinf.STI_PBYTE (variable)
    _BYTE *

ida_typeinf.STI_PCCHAR (variable)
    const char *

ida_typeinf.STI_PCHAR (variable)
    char *

ida_typeinf.STI_PCUCHAR (variable)
    const uint8 *

ida_typeinf.STI_PCVOID (variable)
    const void *

ida_typeinf.STI_PINT (variable)
    int *

ida_typeinf.STI_PPVOID (variable)
    void **

ida_typeinf.STI_PUCHAR (variable)
    uint8 *

ida_typeinf.STI_PUINT (variable)
    unsigned int *

ida_typeinf.STI_PVOID (variable)
    void *

ida_typeinf.STI_RTC_CHECK_2 (variable)
    int16 __fastcall(int16 x)

ida_typeinf.STI_RTC_CHECK_4 (variable)
    int32 __fastcall(int32 x)

ida_typeinf.STI_RTC_CHECK_8 (variable)
    int64 __fastcall(int64 x)

ida_typeinf.STI_SIZE_T (variable)
    size_t

ida_typeinf.STI_SSIZE_T (variable)
    ssize_t

ida_typeinf.STRMEM_ANON (variable)
    can be combined with STRMEM_NAME: look inside anonymous members too.

ida_typeinf.STRMEM_AUTO (variable)
    get member by offset if struct, or get member by index if union
    * nb: union: index is stored in the udm->offset field!
    * nb: struct: offset is in bytes (not in bits)!

ida_typeinf.STRMEM_CASTABLE_TO (variable)
    can be combined with STRMEM_TYPE: member type must be castable to the specified
    type

ida_typeinf.STRMEM_INDEX (variable)
    get member by number
    * in: udm->offset - is a member number

ida_typeinf.STRMEM_MAXS (variable)
    get biggest member by size.

ida_typeinf.STRMEM_MINS (variable)
    get smallest member by size.

ida_typeinf.STRMEM_NAME (variable)
    get member by name
    * in: udm->name - the desired member name.

ida_typeinf.STRMEM_OFFSET (variable)
    get member by offset
    * in: udm->offset - is a member offset in bits

ida_typeinf.STRMEM_SIZE (variable)
    get member by size.
    * in: udm->size - the desired member size.

ida_typeinf.STRMEM_SKIP_EMPTY (variable)
    can be combined with STRMEM_OFFSET, STRMEM_AUTO skip empty members (i.e. having
    zero size) only last empty member can be returned

ida_typeinf.STRMEM_TYPE (variable)
    get member by type.
    * in: udm->type - the desired member type. member types are compared with
    tinfo_t::equals_to()

ida_typeinf.STRMEM_VFTABLE (variable)
    can be combined with STRMEM_OFFSET, STRMEM_AUTO get vftable instead of the base
    class

ida_typeinf.SUDT_ALIGN (variable)
    recalculate field alignments, struct packing, etc to match the offsets and size
    info

ida_typeinf.SUDT_CONST (variable)
    only for serialize_udt: make type const

ida_typeinf.SUDT_FAST (variable)
    serialize without verifying offsets and alignments

ida_typeinf.SUDT_GAPS (variable)
    allow to fill gaps with additional members (_BYTE[])

ida_typeinf.SUDT_SORT (variable)
    fields are not sorted by offset, sort them first

ida_typeinf.SUDT_UNEX (variable)
    references to nonexistent member types are acceptable; in this case it is better
    to set the corresponding udm_t::fda field to the type alignment. If this field
    is not set, ida will try to guess the alignment.

ida_typeinf.SUDT_VOLATILE (variable)
    only for serialize_udt: make type volatile

ida_typeinf.TAFLD_METHOD (variable)
    denotes a udt member function

ida_typeinf.TAH_ALL (variable)
    all defined bits

ida_typeinf.TAH_BYTE (variable)
    type attribute header byte

ida_typeinf.TAH_HASATTRS (variable)
    has extended attributes

ida_typeinf.TA_FORMAT (variable)
    info about the 'format' argument. 3 times pack_dd: format_functype_t, argument
    number of 'format', argument number of '...'

ida_typeinf.TA_ORG_ARRDIM (variable)
    the original array dimension (pack_dd)

ida_typeinf.TA_ORG_TYPEDEF (variable)
    the original typedef name (simple string)

ida_typeinf.TA_VALUE_REPR (variable)
    serialized value_repr_t (used for scalars and arrays)

ida_typeinf.TCMP_ANYBASE (variable)
    accept any base class when casting

ida_typeinf.TCMP_AUTOCAST (variable)
    can t1 be cast into t2 automatically?

ida_typeinf.TCMP_CALL (variable)
    can t1 be called with t2 type?

ida_typeinf.TCMP_DECL (variable)
    compare declarations without resolving them

ida_typeinf.TCMP_DELPTR (variable)
    remove pointer from types before comparing

ida_typeinf.TCMP_EQUAL (variable)
    are types equal?

ida_typeinf.TCMP_IGNMODS (variable)
    ignore const/volatile modifiers

ida_typeinf.TCMP_MANCAST (variable)
    can t1 be cast into t2 manually?

ida_typeinf.TCMP_SKIPTHIS (variable)
    skip the first function argument in comparison

ida_typeinf.TERR_ALIEN_NAME (variable)
    enum member name is used in another enum

ida_typeinf.TERR_BAD_ARG (variable)
    bad argument

ida_typeinf.TERR_BAD_ARRAY (variable)
    arrays are forbidden as function arguments

ida_typeinf.TERR_BAD_BASE (variable)
    bad base class

ida_typeinf.TERR_BAD_BF (variable)
    bitfields are forbidden as function arguments

ida_typeinf.TERR_BAD_BMASK (variable)
    Bad enum member mask 0xI64X. The specified mask should not intersect with any
    existing mask in the enum. Zero masks are prohibited too.

ida_typeinf.TERR_BAD_GAP (variable)
    bad gap

ida_typeinf.TERR_BAD_GROUPS (variable)
    bad group sizes for bitmask enum

ida_typeinf.TERR_BAD_INDEX (variable)
    bad index d

ida_typeinf.TERR_BAD_LAYOUT (variable)
    failed to calculate the structure/union layout

ida_typeinf.TERR_BAD_MSKVAL (variable)
    bad bmask and value combination (value=0xI64X; bitmask 0xI64X)

ida_typeinf.TERR_BAD_NAME (variable)
    name s is not acceptable

ida_typeinf.TERR_BAD_OFFSET (variable)
    bad member offset s

ida_typeinf.TERR_BAD_REPR (variable)
    bad or incompatible field representation

ida_typeinf.TERR_BAD_SERIAL (variable)
    enum value has too many serials

ida_typeinf.TERR_BAD_SIZE (variable)
    bad size d

ida_typeinf.TERR_BAD_SUBTYPE (variable)
    recursive structure nesting is forbidden

ida_typeinf.TERR_BAD_SYNC (variable)
    failed to synchronize with IDB

ida_typeinf.TERR_BAD_TAH (variable)
    bad bits in the type attributes (TAH bits)

ida_typeinf.TERR_BAD_TYPE (variable)
    bad type

ida_typeinf.TERR_BAD_UNIVAR (variable)
    unions cannot have variable sized members

ida_typeinf.TERR_BAD_VALUE (variable)
    value 0xI64X is not acceptable

ida_typeinf.TERR_BAD_VARLAST (variable)
    variable sized member must be the last member in the structure

ida_typeinf.TERR_DUPNAME (variable)
    duplicate name s

ida_typeinf.TERR_ENUM_SIZE (variable)
    bad enum size

ida_typeinf.TERR_GRP_NOEMPTY (variable)
    could not delete group mask for not empty group 0xI64X

ida_typeinf.TERR_NESTED (variable)
    recursive structure nesting is forbidden

ida_typeinf.TERR_NOT_COMPAT (variable)
    the new type is not compatible with the old type

ida_typeinf.TERR_NOT_IMPL (variable)
    not implemented

ida_typeinf.TERR_NO_BMASK (variable)
    bitmask 0xI64X is not found

ida_typeinf.TERR_OK (variable)
    ok

ida_typeinf.TERR_OVERLAP (variable)
    the member overlaps with other members that cannot be deleted

ida_typeinf.TERR_SAVE_ERROR (variable)
    failed to save

ida_typeinf.TERR_SERIALIZE (variable)
    failed to serialize

ida_typeinf.TERR_STOCK (variable)
    stock type info cannot be modified

ida_typeinf.TERR_UNION_BF (variable)
    unions cannot have bitfields

ida_typeinf.TIL_ADD_ALREADY (variable)
    the base til was already added

ida_typeinf.TIL_ADD_FAILED (variable)
    see errbuf

ida_typeinf.TIL_ADD_OK (variable)
    some tils were added

ida_typeinf.TIL_ALI (variable)
    type aliases are present (this bit is used only on the disk)

ida_typeinf.TIL_ESI (variable)
    extended sizeof info (short, long, longlong)

ida_typeinf.TIL_MAC (variable)
    til has macro table

ida_typeinf.TIL_MOD (variable)
    til has been modified, should be saved

ida_typeinf.TIL_ORD (variable)
    type ordinal numbers are present

ida_typeinf.TIL_SLD (variable)
    sizeof(long double)

ida_typeinf.TIL_STM (variable)
    til has extra streams

ida_typeinf.TIL_UNI (variable)
    universal til for any compiler

ida_typeinf.TIL_ZIP (variable)
    pack buckets using zip

ida_typeinf.TINFO_DEFINITE (variable)
    this is a definite type

ida_typeinf.TINFO_DELAYFUNC (variable)
    if type is a function and no function exists at ea, schedule its creation and
    argument renaming to auto-analysis, otherwise try to create it immediately

ida_typeinf.TINFO_GUESSED (variable)
    this is a guessed type

ida_typeinf.TINFO_STRICT (variable)
    never convert given type to another one before applying

ida_typeinf.TVIS_CMT (variable)
    new comment is present (only for udt members)

ida_typeinf.TVIS_NAME (variable)
    new name is present (only for funcargs and udt members)

ida_typeinf.TVIS_RPTCMT (variable)
    the new comment is repeatable

ida_typeinf.TVIS_TYPE (variable)
    new type info is present

ida_typeinf.TVST_DEF (variable)
    visit type definition (meaningful for typerefs)

ida_typeinf.TVST_PRUNE (variable)
    don't visit children of current type

ida_typeinf.TYPE_BASE_MASK (variable)
    the low 4 bits define the basic type

ida_typeinf.TYPE_FLAGS_MASK (variable)
    type flags - they have different meaning depending on the basic type

ida_typeinf.TYPE_FULL_MASK (variable)
    basic type with type flags

ida_typeinf.TYPE_MODIF_MASK (variable)
    modifiers.
    * for BT_ARRAY see Derived type: array
    * BT_VOID can have them ONLY in 'void *'

ida_typeinf.TYPID_ISREF (variable)
    Identifies that a type that is a typeref.

ida_typeinf.TYPID_SHIFT (variable)
    First type detail bit.

ida_typeinf.VALSTR_OPEN (variable)
    printed opening curly brace '{'

ida_typeinf._BT_LAST_BASIC (variable)
    the last basic type, all basic types may be followed by [tah-typeattrs]

ida_typeinf._wrap_cvar (class)

ida_typeinf._wrap_cvar.__getattr__ (method)

ida_typeinf._wrap_cvar.__setattr__ (method)

ida_typeinf.add_til (function)
    add_til(name, flags) -> int
    Load a til file and add it the database type libraries list. IDA will also apply
    function prototypes for matching function names.
    
    @param name: (C++: const char *) til name
    @param flags: (C++: int) combination of Load TIL flags
    @return: one of Load TIL result codes

ida_typeinf.alloc_type_ordinal (function)
    alloc_type_ordinal(ti) -> uint32
    alloc_type_ordinals(ti, 1)
    
    @param ti: (C++: til_t *)

ida_typeinf.alloc_type_ordinals (function)
    alloc_type_ordinals(ti, qty) -> uint32
    Allocate a range of ordinal numbers for new types.
    
    @param ti: (C++: til_t *) type library
    @param qty: (C++: int) number of ordinals to allocate
    @return: the first ordinal. 0 means failure.

ida_typeinf.aloc_visitor_t (class)
    Proxy of C++ aloc_visitor_t class.

ida_typeinf.aloc_visitor_t.__disown__ (method)

ida_typeinf.aloc_visitor_t.__init__ (method)
    __init__(self) -> aloc_visitor_t
    
    @param self: PyObject *

ida_typeinf.aloc_visitor_t.visit_location (method)
    visit_location(self, v, off, size) -> int
    
    @param v: argloc_t &
    @param off: int
    @param size: int

ida_typeinf.append_abi_opts (function)
    append_abi_opts(abi_opts, user_level=False) -> bool
    Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-...
    or -opt1-opt2-...
    
    @param abi_opts: (C++: const char *) - ABI options to add/remove in form opt1-opt2-...
    @param user_level: (C++: bool) - initiated by user if TRUE (==SETCOMP_BY_USER)
    @return: success

ida_typeinf.append_argloc (function)
    append_argloc(out, vloc) -> bool
    Serialize argument location
    
    @param out: (C++: qtype *)
    @param vloc: (C++: const argloc_t &) argloc_t const &

ida_typeinf.append_tinfo_covered (function)
    append_tinfo_covered(out, typid, offset) -> bool
    
    @param out: rangeset_t *
    @param typid: uint32
    @param offset: uint64

ida_typeinf.apply_callee_tinfo (function)
    apply_callee_tinfo(caller, tif) -> bool
    Apply the type of the called function to the calling instruction. This function
    will append parameter comments and rename the local variables of the calling
    function. It also stores information about the instructions that initialize call
    arguments in the database. Use get_arg_addrs() to retrieve it if necessary.
    Alternatively it is possible to hook to processor_t::arg_addrs_ready event.
    
    @param caller: (C++: ea_t) linear address of the calling instruction. must belong to a
                   function.
    @param tif: (C++: const tinfo_t &) type info
    @return: success

ida_typeinf.apply_cdecl (function)
    apply_cdecl(til, ea, decl, flags=0) -> bool
    Apply the specified type to the address. This function parses the declaration
    and calls apply_tinfo()
    
    @param til: (C++: til_t *) type library
    @param ea: (C++: ea_t) linear address
    @param decl: (C++: const char *) type declaration in C form
    @param flags: (C++: int) flags to pass to apply_tinfo (TINFO_DEFINITE is always passed)
    @return: success

ida_typeinf.apply_named_type (function)
    apply_named_type(ea, name) -> bool
    Apply the specified named type to the address.
    
    @param ea: (C++: ea_t) linear address
    @param name: (C++: const char *) the type name, e.g. "FILE"
    @return: success

ida_typeinf.apply_once_tinfo_and_name (function)
    apply_once_tinfo_and_name(dea, tif, name) -> bool
    Apply the specified type and name to the address. This function checks if the
    address already has a type. If the old type
    does not exist or the new type is 'better' than the old type, then the
    new type will be applied. A type is considered better if it has more
    information (e.g. BTMT_STRUCT is better than BT_INT).
    The same logic is with the name: if the address already have a meaningful
    name, it will be preserved. Only if the old name does not exist or it
    is a dummy name like byte_123, it will be replaced by the new name.
    
    @param dea: (C++: ea_t) linear address
    @param tif: (C++: const tinfo_t &) type string in the internal format
    @param name: (C++: const char *) new name for the address
    @return: success

ida_typeinf.apply_tinfo (function)
    apply_tinfo(ea, tif, flags) -> bool
    Apply the specified type to the specified address. This function sets the type
    and tries to convert the item at the specified address to conform the type.
    
    @param ea: (C++: ea_t) linear address
    @param tif: (C++: const tinfo_t &) type string in internal format
    @param flags: (C++: uint32) combination of Apply tinfo flags
    @return: success

ida_typeinf.apply_tinfo_to_stkarg (function)
    apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
    Helper function for the processor modules. to be called from
    processor_t::use_stkarg_type
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: (C++: const op_t &) op_t const &
    @param v: (C++: uval_t)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param name: (C++: const char *) char const *

ida_typeinf.apply_type (function)
    apply_type(ti, type, fields, ea, flags) -> bool
    Apply the specified type to the address
    
    @param ti: Type info library. 'None' can be used.
    @param type: type_t const *
    @param fields: p_list const *
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

ida_typeinf.argloc_t (class)
    Proxy of C++ argloc_t class.

ida_typeinf.argloc_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__init__ (method)
    __init__(self) -> argloc_t
    __init__(self, r) -> argloc_t
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: argloc_t const &

ida_typeinf.argloc_t._consume_rrel (method)
    _consume_rrel(self, p) -> bool
    
    Parameters
    ----------
    p: rrel_t *

ida_typeinf.argloc_t._consume_scattered (method)
    _consume_scattered(self, p) -> bool
    
    Parameters
    ----------
    p: scattered_aloc_t *

ida_typeinf.argloc_t._set_badloc (method)
    _set_badloc(self)

ida_typeinf.argloc_t._set_biggest (method)
    _set_biggest(self, ct, data)
    
    Parameters
    ----------
    ct: argloc_type_t
    data: argloc_t::biggest_t

ida_typeinf.argloc_t._set_custom (method)
    _set_custom(self, ct, pdata)
    
    Parameters
    ----------
    ct: argloc_type_t
    pdata: void *

ida_typeinf.argloc_t._set_ea (method)
    _set_ea(self, _ea)
    
    Parameters
    ----------
    _ea: ea_t

ida_typeinf.argloc_t._set_reg1 (method)
    _set_reg1(self, reg, off=0)
    
    Parameters
    ----------
    reg: int
    off: int

ida_typeinf.argloc_t._set_reg2 (method)
    _set_reg2(self, _reg1, _reg2)
    
    Parameters
    ----------
    _reg1: int
    _reg2: int

ida_typeinf.argloc_t._set_stkoff (method)
    _set_stkoff(self, off)
    
    Parameters
    ----------
    off: sval_t

ida_typeinf.argloc_t.advance (method)
    advance(self, delta) -> bool
    Move the location to point 'delta' bytes further.
    
    @param delta: (C++: int)

ida_typeinf.argloc_t.align_reg_high (method)
    align_reg_high(self, size, _slotsize)
    Set register offset to align it to the upper part of _SLOTSIZE.
    
    @param size: (C++: size_t)
    @param _slotsize: (C++: size_t)

ida_typeinf.argloc_t.align_stkoff_high (method)
    align_stkoff_high(self, size, _slotsize)
    Set stack offset to align to the upper part of _SLOTSIZE.
    
    @param size: (C++: size_t)
    @param _slotsize: (C++: size_t)

ida_typeinf.argloc_t.atype (method)
    atype(self) -> argloc_type_t
    Get type (Argument location types)

ida_typeinf.argloc_t.calc_offset (method)
    calc_offset(self) -> sval_t
    Calculate offset that can be used to compare 2 similar arglocs.

ida_typeinf.argloc_t.compare (method)
    compare(self, r) -> int
    
    @param r: argloc_t const &

ida_typeinf.argloc_t.consume_rrel (method)
    consume_rrel(self, p)
    Set register-relative location - can't be nullptr.
    
    @param p: (C++: rrel_t *)

ida_typeinf.argloc_t.consume_scattered (method)
    consume_scattered(self, p)
    Set distributed argument location.
    
    @param p: (C++: scattered_aloc_t *) scattered_aloc_t const &

ida_typeinf.argloc_t.get_biggest (method)
    get_biggest(self) -> argloc_t::biggest_t
    Get largest element in internal union.

ida_typeinf.argloc_t.get_custom (method)
    get_custom(self) -> void *
    Get custom argloc info. Use if atype() == ALOC_CUSTOM

ida_typeinf.argloc_t.get_ea (method)
    get_ea(self) -> ea_t
    Get the global address. Use when atype() == ALOC_STATIC

ida_typeinf.argloc_t.get_reginfo (method)
    get_reginfo(self) -> uint32
    Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2

ida_typeinf.argloc_t.get_rrel (method)
    get_rrel(self) -> rrel_t
    Get register-relative info. Use when atype() == ALOC_RREL

ida_typeinf.argloc_t.has_reg (method)
    has_reg(self) -> bool
    TRUE if argloc has a register part.

ida_typeinf.argloc_t.has_stkoff (method)
    has_stkoff(self) -> bool
    TRUE if argloc has a stack part.

ida_typeinf.argloc_t.in_stack (method)
    in_stack(self) -> bool
    TRUE if argloc is in stack entirely.

ida_typeinf.argloc_t.is_badloc (method)
    is_badloc(self) -> bool
    See ALOC_NONE.

ida_typeinf.argloc_t.is_custom (method)
    is_custom(self) -> bool
    See ALOC_CUSTOM.

ida_typeinf.argloc_t.is_ea (method)
    is_ea(self) -> bool
    See ALOC_STATIC.

ida_typeinf.argloc_t.is_fragmented (method)
    is_fragmented(self) -> bool
    is_scattered() || is_reg2()

ida_typeinf.argloc_t.is_mixed_scattered (method)
    is_mixed_scattered(self) -> bool
    mixed scattered: consists of register and stack parts

ida_typeinf.argloc_t.is_reg (method)
    is_reg(self) -> bool
    is_reg1() || is_reg2()

ida_typeinf.argloc_t.is_reg1 (method)
    is_reg1(self) -> bool
    See ALOC_REG1.

ida_typeinf.argloc_t.is_reg2 (method)
    is_reg2(self) -> bool
    See ALOC_REG2.

ida_typeinf.argloc_t.is_rrel (method)
    is_rrel(self) -> bool
    See ALOC_RREL.

ida_typeinf.argloc_t.is_scattered (method)
    is_scattered(self) -> bool
    See ALOC_DIST.

ida_typeinf.argloc_t.is_stkoff (method)
    is_stkoff(self) -> bool
    See ALOC_STACK.

ida_typeinf.argloc_t.reg1 (method)
    reg1(self) -> int
    Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2

ida_typeinf.argloc_t.reg2 (method)
    reg2(self) -> int
    Get info for the second register. Use when atype() == ALOC_REG2

ida_typeinf.argloc_t.regoff (method)
    regoff(self) -> int
    Get offset from the beginning of the register in bytes. Use when atype() ==
    ALOC_REG1

ida_typeinf.argloc_t.scattered (method)
    scattered(self) -> scattered_aloc_t
    Get scattered argument info. Use when atype() == ALOC_DIST

ida_typeinf.argloc_t.set_badloc (method)
    set_badloc(self)
    Set to invalid location.

ida_typeinf.argloc_t.set_ea (method)
    set_ea(self, _ea)
    Set static ea location.
    
    @param _ea: (C++: ea_t)

ida_typeinf.argloc_t.set_reg1 (method)
    set_reg1(self, reg, off=0)
    Set register location.
    
    @param reg: (C++: int)
    @param off: (C++: int)

ida_typeinf.argloc_t.set_reg2 (method)
    set_reg2(self, _reg1, _reg2)
    Set secondary register location.
    
    @param _reg1: (C++: int)
    @param _reg2: (C++: int)

ida_typeinf.argloc_t.set_stkoff (method)
    set_stkoff(self, off)
    Set stack offset location.
    
    @param off: (C++: sval_t)

ida_typeinf.argloc_t.stkoff (method)
    stkoff(self) -> sval_t
    Get the stack offset. Use if atype() == ALOC_STACK

ida_typeinf.argloc_t.swap (method)
    swap(self, r)
    Assign this == r and r == this.
    
    @param r: (C++: argloc_t &)

ida_typeinf.argpart_t (class)
    Proxy of C++ argpart_t class.

ida_typeinf.argpart_t.__init__ (method)
    __init__(self, a) -> argpart_t
    
    @param a: argloc_t const &
    
    __init__(self) -> argpart_t

ida_typeinf.argpart_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: argpart_t const &

ida_typeinf.argpart_t.bad_offset (method)
    bad_offset(self) -> bool
    Does this argpart have a valid offset?

ida_typeinf.argpart_t.bad_size (method)
    bad_size(self) -> bool
    Does this argpart have a valid size?

ida_typeinf.argpart_t.off (variable)
    offset from the beginning of the argument

ida_typeinf.argpart_t.size (variable)
    the number of bytes

ida_typeinf.argpart_t.swap (method)
    swap(self, r)
    Assign this = r and r = this.
    
    @param r: (C++: argpart_t &)

ida_typeinf.argpartvec_t (class)
    Proxy of C++ qvector< argpart_t > class.

ida_typeinf.argpartvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< argpart_t > const &

ida_typeinf.argpartvec_t.__getitem__ (method)
    __getitem__(self, i) -> argpart_t
    
    @param i: size_t

ida_typeinf.argpartvec_t.__init__ (method)
    __init__(self) -> argpartvec_t
    __init__(self, x) -> argpartvec_t
    
    @param x: qvector< argpart_t > const &

ida_typeinf.argpartvec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.argpartvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< argpart_t > const &

ida_typeinf.argpartvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: argpart_t const &

ida_typeinf.argpartvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: argpart_t const &

ida_typeinf.argpartvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: argpart_t const &

ida_typeinf.argpartvec_t.at (method)
    at(self, _idx) -> argpart_t
    
    @param _idx: size_t

ida_typeinf.argpartvec_t.begin (method)
    begin(self) -> argpart_t

ida_typeinf.argpartvec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.argpartvec_t.clear (method)
    clear(self)

ida_typeinf.argpartvec_t.empty (method)
    empty(self) -> bool

ida_typeinf.argpartvec_t.end (method)
    end(self) -> argpart_t

ida_typeinf.argpartvec_t.erase (method)
    erase(self, it) -> argpart_t
    
    @param it: qvector< argpart_t >::iterator
    
    erase(self, first, last) -> argpart_t
    
    @param first: qvector< argpart_t >::iterator
    @param last: qvector< argpart_t >::iterator

ida_typeinf.argpartvec_t.extract (method)
    extract(self) -> argpart_t

ida_typeinf.argpartvec_t.find (method)
    find(self, x) -> argpart_t
    
    @param x: argpart_t const &

ida_typeinf.argpartvec_t.grow (method)
    grow(self, x=argpart_t())
    
    @param x: argpart_t const &

ida_typeinf.argpartvec_t.has (method)
    has(self, x) -> bool
    
    @param x: argpart_t const &

ida_typeinf.argpartvec_t.inject (method)
    inject(self, s, len)
    
    @param s: argpart_t *
    @param len: size_t

ida_typeinf.argpartvec_t.insert (method)
    insert(self, it, x) -> argpart_t
    
    @param it: qvector< argpart_t >::iterator
    @param x: argpart_t const &

ida_typeinf.argpartvec_t.pop_back (method)
    pop_back(self)

ida_typeinf.argpartvec_t.push_back (method)
    push_back(self, x)
    
    @param x: argpart_t const &
    
    push_back(self) -> argpart_t

ida_typeinf.argpartvec_t.qclear (method)
    qclear(self)

ida_typeinf.argpartvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.argpartvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: argpart_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.argpartvec_t.size (method)
    size(self) -> size_t

ida_typeinf.argpartvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< argpart_t > &

ida_typeinf.argpartvec_t.truncate (method)
    truncate(self)

ida_typeinf.argtinfo_helper_t (class)
    Proxy of C++ argtinfo_helper_t class.

ida_typeinf.argtinfo_helper_t.__disown__ (method)

ida_typeinf.argtinfo_helper_t.__init__ (method)
    __init__(self) -> argtinfo_helper_t
    
    @param self: PyObject *

ida_typeinf.argtinfo_helper_t.has_delay_slot (method)
    has_delay_slot(self, arg0) -> bool
    The call instruction with a delay slot?.
    
    @param arg0: ea_t

ida_typeinf.argtinfo_helper_t.is_stkarg_load (method)
    is_stkarg_load(self, insn, src, dst) -> bool
    Is the current insn a stkarg load?. if yes:
    * src: index of the source operand in insn_t::ops
    * dst: index of the destination operand in insn_t::ops insn_t::ops[dst].addr is
    expected to have the stack offset
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param src: (C++: int *)
    @param dst: (C++: int *)

ida_typeinf.argtinfo_helper_t.set_op_tinfo (method)
    set_op_tinfo(self, insn, x, tif, name) -> bool
    Set the operand type as specified.
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: (C++: const op_t &) op_t const &
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param name: (C++: const char *) char const *

ida_typeinf.argtinfo_helper_t.use_arg_tinfos (method)
    use_arg_tinfos(self, caller, fti, rargs)
    This function is to be called by the processor module in response to
    ev_use_arg_types.
    
    @param caller: (C++: ea_t)
    @param fti: (C++: func_type_data_t *)
    @param rargs: (C++: funcargvec_t *)

ida_typeinf.array_type_data_t (class)
    Proxy of C++ array_type_data_t class.

ida_typeinf.array_type_data_t.__init__ (method)
    __init__(self, b=0, n=0) -> array_type_data_t
    
    @param b: size_t
    @param n: size_t

ida_typeinf.array_type_data_t.base (variable)
    array base

ida_typeinf.array_type_data_t.elem_type (variable)
    element type

ida_typeinf.array_type_data_t.nelems (variable)
    number of elements

ida_typeinf.array_type_data_t.swap (method)
    swap(self, r)
    set this = r and r = this
    
    @param r: (C++: array_type_data_t &)

ida_typeinf.begin_type_updating (function)
    begin_type_updating(utp)
    Mark the beginning of a large update operation on the types. Can be used with
    add_enum_member(), add_struc_member, etc... Also see end_type_updating()
    
    @param utp: (C++: update_type_t) enum update_type_t

ida_typeinf.bitfield_type_data_t (class)
    Proxy of C++ bitfield_type_data_t class.

ida_typeinf.bitfield_type_data_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.__init__ (method)
    __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
    
    @param _nbytes: uchar
    @param _width: uchar
    @param _is_unsigned: bool

ida_typeinf.bitfield_type_data_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.compare (method)
    compare(self, r) -> int
    
    @param r: bitfield_type_data_t const &

ida_typeinf.bitfield_type_data_t.is_unsigned (variable)
    is bitfield unsigned?

ida_typeinf.bitfield_type_data_t.is_valid_bitfield (method)
    is_valid_bitfield(self) -> bool

ida_typeinf.bitfield_type_data_t.nbytes (variable)
    enclosing type size (1,2,4,8 bytes)

ida_typeinf.bitfield_type_data_t.swap (method)
    swap(self, r)
    
    @param r: bitfield_type_data_t &

ida_typeinf.bitfield_type_data_t.width (variable)
    number of bits

ida_typeinf.calc_c_cpp_name (function)
    calc_c_cpp_name(name, type, ccn_flags) -> str
    Get C or C++ form of the name.
    
    @param name: (C++: const char *) original (mangled or decorated) name
    @param type: (C++: const tinfo_t *) name type if known, otherwise nullptr
    @param ccn_flags: (C++: int) one of C/C++ naming flags

ida_typeinf.calc_number_of_children (function)
    calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
    Calculate max number of lines of a formatted c data, when expanded (PTV_EXPAND).
    
    @param loc: (C++: const argloc_t &) location of the data (ALOC_STATIC or ALOC_CUSTOM)
    @param tif: (C++: const tinfo_t &) type info
    @param dont_deref_ptr: (C++: bool) consider 'ea' as the ptr value
    @retval 0: data is not expandable
    @retval -1: error, see qerrno
    @retval else: the max number of lines

ida_typeinf.calc_tinfo_gaps (function)
    calc_tinfo_gaps(out, typid) -> bool
    
    @param out: rangeset_t *
    @param typid: uint32

ida_typeinf.calc_type_size (function)
    calc_type_size(ti, tp) -> PyObject *
    Returns the size of a type
    
    @param ti: Type info library. 'None' can be passed.
    @param tp: serialized type byte string
    @return:     - None on failure
        - The size of the type

ida_typeinf.callregs_t (class)
    Proxy of C++ callregs_t class.

ida_typeinf.callregs_t.__init__ (method)
    __init__(self) -> callregs_t
    __init__(self, cc) -> callregs_t
    
    @param cc: cm_t

ida_typeinf.callregs_t.by_slots (method)
    by_slots(self) -> bool

ida_typeinf.callregs_t.fpregs (variable)
    array of fp registers

ida_typeinf.callregs_t.gpregs (variable)
    array of gp registers

ida_typeinf.callregs_t.init_regs (method)
    init_regs(self, cc)
    Init policy & registers for given CC.
    
    @param cc: (C++: cm_t)

ida_typeinf.callregs_t.nregs (variable)
    max number of registers that can be used in a call

ida_typeinf.callregs_t.policy (variable)
    argument policy

ida_typeinf.callregs_t.regcount (method)
    regcount(cc) -> int
    Get max number of registers may be used in a function call.
    
    @param cc: (C++: cm_t)

ida_typeinf.callregs_t.reginds (method)
    reginds(self, gp_ind, fp_ind, r) -> bool
    Get register indexes within GP/FP arrays. (-1 -> is not present in the
    corresponding array)
    
    @param gp_ind: (C++: int *)
    @param fp_ind: (C++: int *)
    @param r: (C++: int)

ida_typeinf.callregs_t.reset (method)
    reset(self)
    Set policy and registers to invalid values.

ida_typeinf.callregs_t.set (method)
    set(self, _policy, gprs, fprs)
    Init policy & registers (arrays are -1-terminated)
    
    @param _policy: (C++: argreg_policy_t) enum argreg_policy_t
    @param gprs: (C++: const int *) int const *
    @param fprs: (C++: const int *) int const *

ida_typeinf.callregs_t.swap (method)
    swap(self, r)
    swap two instances
    
    @param r: (C++: callregs_t &)

ida_typeinf.callregs_t_regcount (function)
    callregs_t_regcount(cc) -> int
    
    @param cc: cm_t

ida_typeinf.choose_local_tinfo (function)
    choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
    Choose a type from the local type library.
    
    @param ti: (C++: const til_t *) pointer to til
    @param title: (C++: const char *) title of listbox to display
    @param func: (C++: local_tinfo_predicate_t *) predicate to select types to display (maybe nullptr)
    @param def_ord: (C++: uint32) ordinal to position cursor before choose
    @param ud: (C++: void *) user data
    @return: == 0 means nothing is chosen, otherwise an ordinal number

ida_typeinf.choose_local_tinfo_and_delta (function)
    choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -> uint32
    Choose a type from the local type library and specify the pointer shift value.
    
    @param delta: (C++: int32 *) pointer shift value
    @param ti: (C++: const til_t *) pointer to til
    @param title: (C++: const char *) title of listbox to display
    @param func: (C++: local_tinfo_predicate_t *) predicate to select types to display (maybe nullptr)
    @param def_ord: (C++: uint32) ordinal to position cursor before choose
    @param ud: (C++: void *) user data
    @return: == 0 means nothing is chosen, otherwise an ordinal number

ida_typeinf.choose_named_type (function)
    choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
    Choose a type from a type library.
    
    @param out_sym: (C++: til_symbol_t *) pointer to be filled with the chosen type
    @param root_til: (C++: const til_t *) pointer to starting til (the function will inspect the base
                     tils if allowed by flags)
    @param title: (C++: const char *) title of listbox to display
    @param ntf_flags: (C++: int) combination of Flags for named types
    @param predicate: (C++: predicate_t *) predicate to select types to display (maybe nullptr)
    @return: false if nothing is chosen, otherwise true

ida_typeinf.clear_tinfo_t (function)
    clear_tinfo_t(_this)
    
    @param _this: tinfo_t *

ida_typeinf.compact_til (function)
    compact_til(ti) -> bool
    Collect garbage in til. Must be called before storing the til.
    
    @param ti: (C++: til_t *)
    @return: true if any memory was freed

ida_typeinf.compare_tinfo (function)
    compare_tinfo(t1, t2, tcflags) -> bool
    
    @param t1: uint32
    @param t2: uint32
    @param tcflags: int

ida_typeinf.const_aloc_visitor_t (class)
    Proxy of C++ const_aloc_visitor_t class.

ida_typeinf.const_aloc_visitor_t.__disown__ (method)

ida_typeinf.const_aloc_visitor_t.__init__ (method)
    __init__(self) -> const_aloc_visitor_t
    
    @param self: PyObject *

ida_typeinf.const_aloc_visitor_t.visit_location (method)
    visit_location(self, v, off, size) -> int
    
    @param v: argloc_t const &
    @param off: int
    @param size: int

ida_typeinf.convert_pt_flags_to_hti (function)
    convert_pt_flags_to_hti(pt_flags) -> int
    Convert Type parsing flags to Type formatting flags. Type parsing flags lesser
    than 0x10 don't have stable meaning and will be ignored (more on these flags can
    be seen in idc.idc)
    
    @param pt_flags: (C++: int)

ida_typeinf.copy_named_type (function)
    copy_named_type(dsttil, srctil, name) -> uint32
    Copy a named type from one til to another. This function will copy the specified
    type and all dependent types from the source type library to the destination
    library.
    
    @param dsttil: (C++: til_t *) Destination til. It must have orginal types enabled
    @param srctil: (C++: const til_t *) Source til.
    @param name: (C++: const char *) name of the type to copy
    @return: ordinal number of the copied type. 0 means error

ida_typeinf.copy_tinfo_t (function)
    copy_tinfo_t(_this, r)
    
    @param _this: tinfo_t *
    @param r: tinfo_t const &

ida_typeinf.create_enum_type (function)
    create_enum_type(enum_name, ei, enum_width, sign, convert_to_bitmask, enum_cmt=None) -> tid_t
    Create type enum
    
    @param enum_name: (C++: const char *) type name
    @param ei: (C++: enum_type_data_t &) enum type data
    @param enum_width: (C++: int) the width of an enum element allowed values: 0
                       (unspecified),1,2,4,8,16,32,64
    @param sign: (C++: type_sign_t) enum sign
    @param convert_to_bitmask: (C++: bool) try convert enum to bitmask enum
    @param enum_cmt: (C++: const char *) enum type comment
    @return: enum TID

ida_typeinf.create_numbered_type_name (function)
    create_numbered_type_name(ord) -> str
    Create anonymous name for numbered type. This name can be used to reference a
    numbered type by its ordinal Ordinal names have the following format: '#' +
    set_de(ord) Returns: -1 if error, otherwise the name length
    
    @param ord: (C++: int32)

ida_typeinf.create_tinfo (function)
    create_tinfo(_this, bt, bt2, ptr) -> bool
    
    @param _this: tinfo_t *
    @param bt: type_t
    @param bt2: type_t
    @param ptr: void *

ida_typeinf.create_tinfo2 (function)
    create_tinfo2(_this, bt, bt2, ptr) -> bool
    
    @param _this: tinfo_t *
    @param bt: type_t
    @param bt2: type_t
    @param ptr: void *

ida_typeinf.custom_data_type_info_t (class)
    Proxy of C++ custom_data_type_info_t class.

ida_typeinf.custom_data_type_info_t.__init__ (method)
    __init__(self) -> custom_data_type_info_t

ida_typeinf.custom_data_type_info_t.dtid (variable)
    data type id

ida_typeinf.custom_data_type_info_t.fid (variable)
    data format ids

ida_typeinf.default_compiler (function)
    default_compiler() -> comp_t
    Get compiler specified by inf.cc.

ida_typeinf.del_named_type (function)
    del_named_type(ti, name, ntf_flags) -> bool
    Delete information about a symbol.
    
    @param ti: (C++: til_t *) type library
    @param name: (C++: const char *) name of symbol
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: success

ida_typeinf.del_numbered_type (function)
    del_numbered_type(ti, ordinal) -> bool
    Delete a numbered type.
    
    @param ti: (C++: til_t *)
    @param ordinal: (C++: uint32)

ida_typeinf.del_til (function)
    del_til(name) -> bool
    Unload a til file.
    
    @param name: (C++: const char *) char const *

ida_typeinf.del_tinfo_attr (function)
    del_tinfo_attr(tif, key, make_copy) -> bool
    
    @param tif: tinfo_t *
    @param key: qstring const &
    @param make_copy: bool

ida_typeinf.del_vftable_ea (function)
    del_vftable_ea(ordinal) -> bool
    Delete the address of a vftable instance for a vftable type.
    
    @param ordinal: (C++: uint32) ordinal number of a vftable type.
    @return: success

ida_typeinf.deref_ptr (function)
    deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
    Dereference a pointer.
    
    @param ptr_ea: (C++: ea_t *) in/out parameter
    * in: address of the pointer
    * out: the pointed address
    @param tif: (C++: const tinfo_t &) type of the pointer
    @param closure_obj: (C++: ea_t *) closure object (not used yet)
    @return: success

ida_typeinf.deserialize_tinfo (function)
    deserialize_tinfo(tif, til, ptype, pfields, pfldcmts, cmt=None) -> bool
    
    @param tif: tinfo_t *
    @param til: til_t const *
    @param ptype: type_t const **
    @param pfields: p_list const **
    @param pfldcmts: p_list const **
    @param cmt: char const *

ida_typeinf.dstr_tinfo (function)
    dstr_tinfo(tif) -> char const *
    
    @param tif: tinfo_t const *

ida_typeinf.dump_func_type_data (function)
    dump_func_type_data(fti, praloc_bits) -> str
    Use func_type_data_t::dump()
    
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &
    @param praloc_bits: (C++: int)

ida_typeinf.edm_t (class)
    Proxy of C++ edm_t class.

ida_typeinf.edm_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: edm_t const &

ida_typeinf.edm_t.__init__ (method)
    __init__(self) -> edm_t

ida_typeinf.edm_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: edm_t const &

ida_typeinf.edm_t.get_tid (method)
    get_tid(self) -> tid_t

ida_typeinf.edm_t.swap (method)
    swap(self, r)
    
    @param r: edm_t &

ida_typeinf.edmvec_t (class)
    Proxy of C++ qvector< edm_t > class.

ida_typeinf.edmvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< edm_t > const &

ida_typeinf.edmvec_t.__getitem__ (method)
    __getitem__(self, i) -> edm_t
    
    @param i: size_t

ida_typeinf.edmvec_t.__init__ (method)
    __init__(self) -> edmvec_t
    __init__(self, x) -> edmvec_t
    
    @param x: qvector< edm_t > const &

ida_typeinf.edmvec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.edmvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< edm_t > const &

ida_typeinf.edmvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: edm_t const &

ida_typeinf.edmvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: edm_t const &

ida_typeinf.edmvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: edm_t const &

ida_typeinf.edmvec_t.at (method)
    at(self, _idx) -> edm_t
    
    @param _idx: size_t

ida_typeinf.edmvec_t.begin (method)
    begin(self) -> edm_t

ida_typeinf.edmvec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.edmvec_t.clear (method)
    clear(self)

ida_typeinf.edmvec_t.empty (method)
    empty(self) -> bool

ida_typeinf.edmvec_t.end (method)
    end(self) -> edm_t

ida_typeinf.edmvec_t.erase (method)
    erase(self, it) -> edm_t
    
    @param it: qvector< edm_t >::iterator
    
    erase(self, first, last) -> edm_t
    
    @param first: qvector< edm_t >::iterator
    @param last: qvector< edm_t >::iterator

ida_typeinf.edmvec_t.extract (method)
    extract(self) -> edm_t

ida_typeinf.edmvec_t.find (method)
    find(self, x) -> edm_t
    
    @param x: edm_t const &

ida_typeinf.edmvec_t.grow (method)
    grow(self, x=edm_t())
    
    @param x: edm_t const &

ida_typeinf.edmvec_t.has (method)
    has(self, x) -> bool
    
    @param x: edm_t const &

ida_typeinf.edmvec_t.inject (method)
    inject(self, s, len)
    
    @param s: edm_t *
    @param len: size_t

ida_typeinf.edmvec_t.insert (method)
    insert(self, it, x) -> edm_t
    
    @param it: qvector< edm_t >::iterator
    @param x: edm_t const &

ida_typeinf.edmvec_t.pop_back (method)
    pop_back(self)

ida_typeinf.edmvec_t.push_back (method)
    push_back(self, x)
    
    @param x: edm_t const &
    
    push_back(self) -> edm_t

ida_typeinf.edmvec_t.qclear (method)
    qclear(self)

ida_typeinf.edmvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.edmvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: edm_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.edmvec_t.size (method)
    size(self) -> size_t

ida_typeinf.edmvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< edm_t > &

ida_typeinf.edmvec_t.truncate (method)
    truncate(self)

ida_typeinf.enable_numbered_types (function)
    enable_numbered_types(ti, enable) -> bool
    Enable the use of numbered types in til. Currently it is impossible to disable
    numbered types once they are enabled
    
    @param ti: (C++: til_t *)
    @param enable: (C++: bool)

ida_typeinf.end_type_updating (function)
    end_type_updating(utp)
    Mark the end of a large update operation on the types (see
    begin_type_updating())
    
    @param utp: (C++: update_type_t) enum update_type_t

ida_typeinf.enum_type_data_t (class)
    Proxy of C++ enum_type_data_t class.

ida_typeinf.enum_type_data_t.__init__ (method)
    __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
    
    @param _bte: bte_t

ida_typeinf.enum_type_data_t.add_constant (method)
    add_constant(self, name, value, cmt=None)
    add constant for regular enum
    
    @param name: (C++: const char *) char const *
    @param value: (C++: uint64)
    @param cmt: (C++: const char *) char const *

ida_typeinf.enum_type_data_t.bte (variable)
    enum member sizes (shift amount) and style. do not manually set BTE_BITMASK, use
    set_enum_is_bitmask()

ida_typeinf.enum_type_data_t.calc_mask (method)
    calc_mask(self) -> uint64

ida_typeinf.enum_type_data_t.calc_nbytes (method)
    calc_nbytes(self) -> int
    get the width of enum in bytes

ida_typeinf.enum_type_data_t.find_member (method)
    find_member(self, name, _from=0, to=size_t(-1)) -> ssize_t
    find member (constant or bmask) by value
    
    @param name: char const *
    @param from: (C++: size_t)
    @param to: (C++: size_t)
    
    find_member(self, value, serial, _from=0, to=size_t(-1), vmask=uint64(-1)) -> ssize_t
    
    @param value: uint64
    @param serial: uchar
    @param from: size_t
    @param to: size_t
    @param vmask: uint64

ida_typeinf.enum_type_data_t.get_constant_group (method)
    get_constant_group(self, group_start_index, group_size, idx) -> bool
    get group parameters for the constant, valid for etimask enum
    
    @param group_start_index: (C++: size_t *) index of the group mask
    @param group_size: (C++: size_t *) group size (>=1)
    @param idx: (C++: size_t) constant index
    @return: success

ida_typeinf.enum_type_data_t.get_enum_radix (method)
    get_enum_radix(self) -> int
    Get enum constant radix
    
    @return: radix or 1 for BTE_CHAR

ida_typeinf.enum_type_data_t.group_sizes (variable)
    if present, specifies bitmask group sizes each non-trivial group starts with a
    mask member

ida_typeinf.enum_type_data_t.has_lzero (method)
    has_lzero(self) -> bool

ida_typeinf.enum_type_data_t.is_bf (method)
    is_bf(self) -> bool
    is bitmask or ordinary enum?

ida_typeinf.enum_type_data_t.is_bin (method)
    is_bin(self) -> bool

ida_typeinf.enum_type_data_t.is_char (method)
    is_char(self) -> bool

ida_typeinf.enum_type_data_t.is_dec (method)
    is_dec(self) -> bool

ida_typeinf.enum_type_data_t.is_group_mask_at (method)
    is_group_mask_at(self, idx) -> bool
    is the enum member at IDX a non-trivial group mask? a trivial group consist of
    one bit and has just one member, which can be considered as a mask or a bitfield
    constant
    
    @param idx: (C++: size_t) index
    @return: success

ida_typeinf.enum_type_data_t.is_hex (method)
    is_hex(self) -> bool

ida_typeinf.enum_type_data_t.is_number_signed (method)
    is_number_signed(self) -> bool

ida_typeinf.enum_type_data_t.is_oct (method)
    is_oct(self) -> bool

ida_typeinf.enum_type_data_t.is_sbin (method)
    is_sbin(self) -> bool

ida_typeinf.enum_type_data_t.is_shex (method)
    is_shex(self) -> bool

ida_typeinf.enum_type_data_t.is_soct (method)
    is_soct(self) -> bool

ida_typeinf.enum_type_data_t.is_udec (method)
    is_udec(self) -> bool

ida_typeinf.enum_type_data_t.is_valid_group_sizes (method)
    is_valid_group_sizes(self) -> bool
    is valid group sizes

ida_typeinf.enum_type_data_t.set_enum_radix (method)
    set_enum_radix(self, radix, sign)
    Set radix to display constants
    
    @param radix: (C++: int) radix with the special case 1 to display as character
    @param sign: (C++: bool)

ida_typeinf.enum_type_data_t.set_lzero (method)
    set_lzero(self, on)
    
    @param on: bool

ida_typeinf.enum_type_data_t.set_nbytes (method)
    set_nbytes(self, nbytes) -> bool
    set enum width (nbytes)
    
    @param nbytes: (C++: int)

ida_typeinf.enum_type_data_t.set_value_repr (method)
    set_value_repr(self, repr) -> tinfo_code_t
    set enum radix and other representation info
    
    @param repr: (C++: const value_repr_t &) value display info

ida_typeinf.enum_type_data_t.store_64bit_values (method)
    store_64bit_values(self) -> bool

ida_typeinf.enum_type_data_t.swap (method)
    swap(self, r)
    swap two instances
    
    @param r: (C++: enum_type_data_t &)

ida_typeinf.enum_type_data_t.taenum_bits (variable)
    Type attributes for enums

ida_typeinf.enum_type_data_t__get_max_serial (function)
    enum_type_data_t__get_max_serial(ei, value) -> uchar
    
    @param ei: enum_type_data_t const *
    @param value: uint64

ida_typeinf.extract_argloc (function)
    extract_argloc(vloc, ptype, forbid_stkoff) -> bool
    Deserialize an argument location. Argument FORBID_STKOFF checks location type.
    It can be used, for example, to check the return location of a function that
    cannot return a value in the stack
    
    @param vloc: (C++: argloc_t *)
    @param ptype: (C++: const type_t **) type_t const **
    @param forbid_stkoff: (C++: bool)

ida_typeinf.find_tinfo_udt_member (function)
    find_tinfo_udt_member(udm, typid, strmem_flags) -> int
    
    @param udm: udm_t *
    @param typid: uint32
    @param strmem_flags: int

ida_typeinf.first_named_type (function)
    first_named_type(ti, ntf_flags) -> char const *
    Enumerate types.
    
    @param ti: (C++: const til_t *) type library. nullptr means the local type library for the current
               database.
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: Type or symbol names, depending of ntf_flags. Returns mangled names.
             Never returns anonymous types. To include them, enumerate types by
             ordinals.

ida_typeinf.for_all_arglocs (function)
    for_all_arglocs(vv, vloc, size, off=0) -> int
    Compress larger argloc types and initiate the aloc visitor.
    
    @param vv: (C++: aloc_visitor_t &)
    @param vloc: (C++: argloc_t &)
    @param size: (C++: int)
    @param off: (C++: int)

ida_typeinf.for_all_const_arglocs (function)
    for_all_const_arglocs(vv, vloc, size, off=0) -> int
    See for_all_arglocs()
    
    @param vv: (C++: const_aloc_visitor_t &)
    @param vloc: (C++: const argloc_t &) argloc_t const &
    @param size: (C++: int)
    @param off: (C++: int)

ida_typeinf.free_til (function)
    free_til(ti)
    Free memory allocated by til.
    
    @param ti: (C++: til_t *)

ida_typeinf.func_has_stkframe_hole (function)
    func_has_stkframe_hole(ea, fti) -> bool
    Looks for a hole at the beginning of the stack arguments. Will make use of the
    IDB's func_t function at that place (if present) to help determine the presence
    of such a hole.
    
    @param ea: (C++: ea_t)
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &

ida_typeinf.func_type_data_t (class)
    Proxy of C++ func_type_data_t class.

ida_typeinf.func_type_data_t.__init__ (method)
    __init__(self) -> func_type_data_t

ida_typeinf.func_type_data_t.cc (variable)
    calling convention

ida_typeinf.func_type_data_t.dump (method)
    dump(self, praloc_bits=0x02) -> bool
    Dump information that is not always visible in the function prototype. (argument
    locations, return location, total stkarg size)
    
    @param praloc_bits: (C++: int)

ida_typeinf.func_type_data_t.flags (variable)
    Function type data property bits

ida_typeinf.func_type_data_t.get_call_method (method)
    get_call_method(self) -> int

ida_typeinf.func_type_data_t.guess_cc (method)
    guess_cc(self, purged, cc_flags) -> cm_t
    Guess function calling convention use the following info: argument locations and
    'stkargs'
    
    @param purged: (C++: int)
    @param cc_flags: (C++: int)

ida_typeinf.func_type_data_t.is_const (method)
    is_const(self) -> bool

ida_typeinf.func_type_data_t.is_ctor (method)
    is_ctor(self) -> bool

ida_typeinf.func_type_data_t.is_dtor (method)
    is_dtor(self) -> bool

ida_typeinf.func_type_data_t.is_golang_cc (method)
    is_golang_cc(self) -> bool

ida_typeinf.func_type_data_t.is_high (method)
    is_high(self) -> bool

ida_typeinf.func_type_data_t.is_noret (method)
    is_noret(self) -> bool

ida_typeinf.func_type_data_t.is_pure (method)
    is_pure(self) -> bool

ida_typeinf.func_type_data_t.is_static (method)
    is_static(self) -> bool

ida_typeinf.func_type_data_t.is_swift_cc (method)
    is_swift_cc(self) -> bool

ida_typeinf.func_type_data_t.is_vararg_cc (method)
    is_vararg_cc(self) -> bool

ida_typeinf.func_type_data_t.is_virtual (method)
    is_virtual(self) -> bool

ida_typeinf.func_type_data_t.retloc (variable)
    return location

ida_typeinf.func_type_data_t.rettype (variable)
    return type

ida_typeinf.func_type_data_t.spoiled (variable)
    spoiled register information. if spoiled register info is present, it overrides
    the standard spoil info (eax, edx, ecx for x86)

ida_typeinf.func_type_data_t.stkargs (variable)
    size of stack arguments (not used in build_func_type)

ida_typeinf.func_type_data_t.swap (method)
    swap(self, r)
    
    @param r: func_type_data_t &

ida_typeinf.funcarg_t (class)
    Proxy of C++ funcarg_t class.

ida_typeinf.funcarg_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: funcarg_t const &

ida_typeinf.funcarg_t.__init__ (method)
    __init__(self) -> funcarg_t

ida_typeinf.funcarg_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: funcarg_t const &

ida_typeinf.funcarg_t.argloc (variable)
    argument location

ida_typeinf.funcarg_t.cmt (variable)
    argument comment (may be empty)

ida_typeinf.funcarg_t.flags (variable)
    Function argument property bits

ida_typeinf.funcarg_t.name (variable)
    argument name (may be empty)

ida_typeinf.funcarg_t.type (variable)
    argument type

ida_typeinf.funcargvec_t (class)
    Proxy of C++ qvector< funcarg_t > class.

ida_typeinf.funcargvec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< funcarg_t > const &

ida_typeinf.funcargvec_t.__getitem__ (method)
    __getitem__(self, i) -> funcarg_t
    
    @param i: size_t

ida_typeinf.funcargvec_t.__init__ (method)
    __init__(self) -> funcargvec_t
    __init__(self, x) -> funcargvec_t
    
    @param x: qvector< funcarg_t > const &

ida_typeinf.funcargvec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.funcargvec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< funcarg_t > const &

ida_typeinf.funcargvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: funcarg_t const &

ida_typeinf.funcargvec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: funcarg_t const &

ida_typeinf.funcargvec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: funcarg_t const &

ida_typeinf.funcargvec_t.at (method)
    at(self, _idx) -> funcarg_t
    
    @param _idx: size_t

ida_typeinf.funcargvec_t.begin (method)
    begin(self) -> funcarg_t

ida_typeinf.funcargvec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.funcargvec_t.clear (method)
    clear(self)

ida_typeinf.funcargvec_t.empty (method)
    empty(self) -> bool

ida_typeinf.funcargvec_t.end (method)
    end(self) -> funcarg_t

ida_typeinf.funcargvec_t.erase (method)
    erase(self, it) -> funcarg_t
    
    @param it: qvector< funcarg_t >::iterator
    
    erase(self, first, last) -> funcarg_t
    
    @param first: qvector< funcarg_t >::iterator
    @param last: qvector< funcarg_t >::iterator

ida_typeinf.funcargvec_t.extract (method)
    extract(self) -> funcarg_t

ida_typeinf.funcargvec_t.find (method)
    find(self, x) -> funcarg_t
    
    @param x: funcarg_t const &

ida_typeinf.funcargvec_t.grow (method)
    grow(self, x=funcarg_t())
    
    @param x: funcarg_t const &

ida_typeinf.funcargvec_t.has (method)
    has(self, x) -> bool
    
    @param x: funcarg_t const &

ida_typeinf.funcargvec_t.inject (method)
    inject(self, s, len)
    
    @param s: funcarg_t *
    @param len: size_t

ida_typeinf.funcargvec_t.insert (method)
    insert(self, it, x) -> funcarg_t
    
    @param it: qvector< funcarg_t >::iterator
    @param x: funcarg_t const &

ida_typeinf.funcargvec_t.pop_back (method)
    pop_back(self)

ida_typeinf.funcargvec_t.push_back (method)
    push_back(self, x)
    
    @param x: funcarg_t const &
    
    push_back(self) -> funcarg_t

ida_typeinf.funcargvec_t.qclear (method)
    qclear(self)

ida_typeinf.funcargvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.funcargvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: funcarg_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.funcargvec_t.size (method)
    size(self) -> size_t

ida_typeinf.funcargvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< funcarg_t > &

ida_typeinf.funcargvec_t.truncate (method)
    truncate(self)

ida_typeinf.gcc_layout (function)
    gcc_layout() -> bool
    Should use the struct/union layout as done by gcc?

ida_typeinf.gen_decorate_name (function)
    gen_decorate_name(name, mangle, cc, type) -> str
    Generic function for decorate_name() (may be used in IDP modules)
    
    @param name: (C++: const char *) char const *
    @param mangle: (C++: bool)
    @param cc: (C++: cm_t)
    @param type: (C++: const tinfo_t *) tinfo_t const *

ida_typeinf.gen_use_arg_tinfos (function)
    gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
    
    @param caller: ea_t
    @param fti: func_type_data_t *
    @param rargs: funcargvec_t *
    @param set_optype: set_op_tinfo_t *
    @param is_stkarg_load: is_stkarg_load_t *
    @param has_delay_slot: has_delay_slot_t *

ida_typeinf.gen_use_arg_tinfos2 (function)
    gen_use_arg_tinfos2(_this, caller, fti, rargs)
    Do not call this function directly, use argtinfo_helper_t.
    
    @param _this: (C++: struct argtinfo_helper_t *) argtinfo_helper_t *
    @param caller: (C++: ea_t)
    @param fti: (C++: func_type_data_t *)
    @param rargs: (C++: funcargvec_t *)

ida_typeinf.get_abi_name (function)
    get_abi_name() -> str
    Get ABI name.
    
    @return: length of the name (>=0)

ida_typeinf.get_alias_target (function)
    get_alias_target(ti, ordinal) -> uint32
    Find the final alias destination. If the ordinal has not been aliased, return
    the specified ordinal itself If failed, returns 0.
    
    @param ti: (C++: const til_t *) til_t const *
    @param ordinal: (C++: uint32)

ida_typeinf.get_arg_addrs (function)
    get_arg_addrs(caller) -> PyObject *
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses

ida_typeinf.get_base_type (function)
    get_base_type(t) -> type_t
    Get get basic type bits (TYPE_BASE_MASK)
    
    @param t: (C++: type_t)

ida_typeinf.get_c_header_path (function)
    get_c_header_path() -> str
    Get the include directory path of the target compiler.

ida_typeinf.get_c_macros (function)
    get_c_macros() -> str
    Get predefined macros for the target compiler.

ida_typeinf.get_comp (function)
    get_comp(comp) -> comp_t
    Get compiler bits.
    
    @param comp: (C++: comp_t)

ida_typeinf.get_compiler_abbr (function)
    get_compiler_abbr(id) -> char const *
    Get abbreviated compiler name.
    
    @param id: (C++: comp_t)

ida_typeinf.get_compiler_name (function)
    get_compiler_name(id) -> char const *
    Get full compiler name.
    
    @param id: (C++: comp_t)

ida_typeinf.get_compilers (function)
    get_compilers(ids, names, abbrs)
    Get names of all built-in compilers.
    
    @param ids: (C++: compvec_t *)
    @param names: (C++: qstrvec_t *)
    @param abbrs: (C++: qstrvec_t *)

ida_typeinf.get_enum_member_expr (function)
    get_enum_member_expr(tif, serial, value) -> str
    Return a C expression that can be used to represent an enum member. If the value
    does not correspond to any single enum member, this function tries to find a
    bitwise combination of enum members that correspond to it. If more than half of
    value bits do not match any enum members, it fails.
    
    @param tif: (C++: const tinfo_t &) enumeration type
    @param serial: (C++: int) which enumeration member to use (0 means the first with the given
                   value)
    @param value: (C++: uint64) value to search in the enumeration type
    @return: success

ida_typeinf.get_full_type (function)
    get_full_type(t) -> type_t
    Get basic type bits + type flags (TYPE_FULL_MASK)
    
    @param t: (C++: type_t)

ida_typeinf.get_idainfo64_by_type (function)
    get_idainfo64_by_type(out_flags, tif) -> bool
    Extract information from a tinfo_t.
    
    @param out_flags: (C++: flags64_t *) description of type using flags64_t
    @param tif: (C++: const tinfo_t &) the type to inspect

ida_typeinf.get_idainfo_by_type (function)
    get_idainfo_by_type(tif) -> bool
    Extract information from a tinfo_t.
    
    @param tif: (C++: const tinfo_t &) the type to inspect

ida_typeinf.get_idati (function)
    get_idati() -> til_t
    Pointer to the local type library - this til is private for each IDB file
    Functions that accept til_t* default to `idati` when is nullptr provided.

ida_typeinf.get_named_type (function)
    get_named_type(til, name, ntf_flags) -> (int, bytes, bytes, NoneType, NoneType, int, int)
    Get a type data by its name.
    
    @param til: the type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:     None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success

ida_typeinf.get_named_type64 (function)
    get_named_type64(til, name, ntf_flags) -> (int, bytes, NoneType, NoneType, NoneType, int, int)
    See get_named_type() above.
    @note: If the value in the 'ti' library is 32-bit, it will be sign-extended
           before being stored in the 'value' pointer.
    
    @param til: til_t const *
    @param name: (C++: const char *) char const *
    @param ntf_flags: (C++: int)

ida_typeinf.get_named_type_tid (function)
    get_named_type_tid(name) -> tid_t
    Get named local type TID
    
    @param name: (C++: const char *) type name
    @return: TID or BADADDR

ida_typeinf.get_numbered_type (function)
    get_numbered_type(til, ordinal) -> (bytes, NoneType, NoneType, NoneType, int), (bytes, bytes, NoneType, NoneType, int)
    Retrieve a type by its ordinal number.
    
    @param til: til_t const *
    @param ordinal: (C++: uint32)

ida_typeinf.get_numbered_type_name (function)
    get_numbered_type_name(ti, ordinal) -> char const *
    Get type name (if exists) by its ordinal. If the type is anonymous, returns "".
    If failed, returns nullptr
    
    @param ti: (C++: const til_t *) til_t const *
    @param ordinal: (C++: uint32)

ida_typeinf.get_ordinal_count (function)
    get_ordinal_count(ti=None) -> uint32
    Get number of allocated ordinals.
    
    @param ti: (C++: const til_t *) type library; nullptr means the local types for the current database.
    @return: 0 if ordinals have not been enabled for the til.

ida_typeinf.get_ordinal_from_idb_type (function)
    get_ordinal_from_idb_type(name, type) -> int
    Get ordinal number of an idb type (struct/enum). The 'type' parameter is used
    only to determine the kind of the type (struct or enum) Use this function to
    find out the correspondence between idb types and til types
    
    @param name: (C++: const char *) char const *
    @param type: (C++: const type_t *) type_t const *

ida_typeinf.get_ordinal_limit (function)
    get_ordinal_limit(ti=None) -> uint32
    Get number of allocated ordinals + 1. If there are no allocated ordinals, return
    0. To enumerate all ordinals, use: for ( uint32 i = 1; i < limit; ++i )
    
    @param ti: (C++: const til_t *) type library; nullptr means the local types for the current database.
    @return: uint32(-1) if ordinals have not been enabled for the til. For local
             types (idati), ordinals are always enabled.

ida_typeinf.get_ordinal_qty (function)
    get_ordinal_qty(ti) -> uint32
    
    @param ti: til_t const *

ida_typeinf.get_scalar_bt (function)
    get_scalar_bt(size) -> type_t
    
    @param size: int

ida_typeinf.get_stock_tinfo (function)
    get_stock_tinfo(tif, id) -> bool
    
    @param tif: tinfo_t *
    @param id: enum stock_type_id_t

ida_typeinf.get_tid_name (function)
    get_tid_name(tid) -> str
    Get a type name for the specified TID
    
    @param tid: (C++: tid_t) type TID
    @return: true if there is type with TID
    @note: this function is the inverse to get_named_type_tid

ida_typeinf.get_tid_ordinal (function)
    get_tid_ordinal(tid) -> uint32
    Get type ordinal number for TID
    
    @param tid: (C++: tid_t) type/enum constant/udt member TID
    @return: type ordinal number or 0

ida_typeinf.get_tinfo_attr (function)
    get_tinfo_attr(typid, key, bv, all_attrs) -> bool
    
    @param typid: uint32
    @param key: qstring const &
    @param bv: bytevec_t *
    @param all_attrs: bool

ida_typeinf.get_tinfo_attrs (function)
    get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
    
    @param typid: uint32
    @param tav: type_attrs_t *
    @param include_ref_attrs: bool

ida_typeinf.get_tinfo_by_flags (function)
    get_tinfo_by_flags(out, flags) -> bool
    Get tinfo object that corresponds to data flags
    
    @param out: (C++: tinfo_t *) type info
    @param flags: (C++: flags64_t) simple flags (byte, word, ..., zword)

ida_typeinf.get_tinfo_details (function)
    get_tinfo_details(typid, bt2, buf) -> bool
    
    @param typid: uint32
    @param bt2: type_t
    @param buf: void *

ida_typeinf.get_tinfo_details2 (function)
    get_tinfo_details2(typid, bt2, buf) -> bool
    
    @param typid: uint32
    @param bt2: type_t
    @param buf: void *

ida_typeinf.get_tinfo_pdata (function)
    get_tinfo_pdata(outptr, typid, what) -> size_t
    
    @param outptr: void *
    @param typid: uint32
    @param what: int

ida_typeinf.get_tinfo_property (function)
    get_tinfo_property(typid, gta_prop) -> size_t
    
    @param typid: uint32
    @param gta_prop: int

ida_typeinf.get_tinfo_property4 (function)
    get_tinfo_property4(typid, gta_prop, p1, p2, p3, p4) -> size_t
    
    @param typid: uint32
    @param gta_prop: int
    @param p1: size_t
    @param p2: size_t
    @param p3: size_t
    @param p4: size_t

ida_typeinf.get_tinfo_size (function)
    get_tinfo_size(p_effalign, typid, gts_code) -> size_t
    
    @param p_effalign: uint32 *
    @param typid: uint32
    @param gts_code: int

ida_typeinf.get_tinfo_tid (function)
    get_tinfo_tid(tif, force_tid) -> tid_t
    
    @param tif: tinfo_t *
    @param force_tid: bool

ida_typeinf.get_type_flags (function)
    get_type_flags(t) -> type_t
    Get type flags (TYPE_FLAGS_MASK)
    
    @param t: (C++: type_t)

ida_typeinf.get_type_ordinal (function)
    get_type_ordinal(ti, name) -> int32
    Get type ordinal by its name.
    
    @param ti: (C++: const til_t *) til_t const *
    @param name: (C++: const char *) char const *

ida_typeinf.get_udm_by_fullname (function)
    get_udm_by_fullname(udm, fullname) -> ssize_t
    Get udt member by full name
    
    @param udm: (C++: udm_t *) member, can be NULL
    @param fullname: (C++: const char *) udt member name in format <udt name>.<member name>
    @return: member index into udt_type_data_t or -1

ida_typeinf.get_udm_tid (function)
    get_udm_tid(udm, udt_name) -> tid_t
    
    @param udm: udm_t const *
    @param udt_name: char const *

ida_typeinf.get_vftable_ea (function)
    get_vftable_ea(ordinal) -> ea_t
    Get address of a virtual function table.
    
    @param ordinal: (C++: uint32) ordinal number of a vftable type.
    @return: address of the corresponding virtual function table in the current
             database.

ida_typeinf.get_vftable_ordinal (function)
    get_vftable_ordinal(vftable_ea) -> uint32
    Get ordinal number of the virtual function table.
    
    @param vftable_ea: (C++: ea_t) address of a virtual function table.
    @return: ordinal number of the corresponding vftable type. 0 - failure.

ida_typeinf.guess_func_cc (function)
    guess_func_cc(fti, npurged, cc_flags) -> cm_t
    Use func_type_data_t::guess_cc()
    
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &
    @param npurged: (C++: int)
    @param cc_flags: (C++: int)

ida_typeinf.guess_tinfo (function)
    guess_tinfo(out, id) -> int
    Generate a type information about the id from the disassembly. id can be a
    structure/union/enum id or an address.
    
    @param out: (C++: tinfo_t *)
    @param id: (C++: tid_t)
    @return: one of Guess tinfo codes

ida_typeinf.ida_lowertype_helper_t (class)
    Proxy of C++ ida_lowertype_helper_t class.

ida_typeinf.ida_lowertype_helper_t.__init__ (method)
    __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
    
    @param _tif: tinfo_t const &
    @param _ea: ea_t
    @param _pb: int

ida_typeinf.ida_lowertype_helper_t.func_has_stkframe_hole (method)
    func_has_stkframe_hole(self, candidate, candidate_data) -> bool
    
    @param candidate: tinfo_t const &
    @param candidate_data: func_type_data_t const &

ida_typeinf.ida_lowertype_helper_t.get_func_purged_bytes (method)
    get_func_purged_bytes(self, candidate, arg3) -> int
    
    @param candidate: tinfo_t const &
    @param arg3: func_type_data_t const &

ida_typeinf.idc_get_local_type (function)
    idc_get_local_type(ordinal, flags) -> str
    
    @param ordinal: int
    @param flags: int

ida_typeinf.idc_get_local_type_name (function)
    idc_get_local_type_name(ordinal) -> str
    
    @param ordinal: int

ida_typeinf.idc_get_local_type_raw (function)
    idc_get_local_type_raw(ordinal) -> (bytes, bytes)
    
    @param ordinal: int

ida_typeinf.idc_get_type (function)
    idc_get_type(ea) -> str
    
    @param ea: ea_t

ida_typeinf.idc_get_type_raw (function)
    idc_get_type_raw(ea) -> PyObject *
    
    @param ea: ea_t

ida_typeinf.idc_guess_type (function)
    idc_guess_type(ea) -> str
    
    @param ea: ea_t

ida_typeinf.idc_parse_decl (function)
    idc_parse_decl(ti, decl, flags) -> (str, bytes, bytes) or None
    
    @param ti: til_t *
    @param decl: char const *
    @param flags: int

ida_typeinf.idc_parse_types (function)
    idc_parse_types(input, flags) -> int
    
    @param input: char const *
    @param flags: int

ida_typeinf.idc_print_type (function)
    idc_print_type(type, fields, name, flags) -> str
    
    @param type: type_t const *
    @param fields: p_list const *
    @param name: char const *
    @param flags: int

ida_typeinf.idc_set_local_type (function)
    idc_set_local_type(ordinal, dcl, flags) -> int
    
    @param ordinal: int
    @param dcl: char const *
    @param flags: int

ida_typeinf.import_type (function)
    import_type(til, idx, name, flags=0) -> tid_t
    Copy a named type from til to idb.
    
    @param til: (C++: const til_t *) type library
    @param idx: (C++: int) the position of the new type in the list of types (structures or
                enums). -1 means at the end of the list
    @param name: (C++: const char *) the type name
    @param flags: (C++: int) combination of Import type flags
    @return: BADNODE on error

ida_typeinf.inf_big_arg_align (function)
    inf_big_arg_align() -> bool
    inf_big_arg_align(cc) -> bool
    
    @param cc: cm_t

ida_typeinf.inf_huge_arg_align (function)
    inf_huge_arg_align() -> bool
    inf_huge_arg_align(cc) -> bool
    
    @param cc: cm_t

ida_typeinf.inf_pack_stkargs (function)
    inf_pack_stkargs() -> bool
    inf_pack_stkargs(cc) -> bool
    
    @param cc: cm_t

ida_typeinf.is_autosync (function)
    is_autosync(name, type) -> bool
    Is the specified idb type automatically synchronized?
    
    @param name: (C++: const char *) char const *
    @param type: type_t const *
    
    is_autosync(name, tif) -> bool
    
    @param name: char const *
    @param tif: tinfo_t const &

ida_typeinf.is_code_far (function)
    is_code_far(cm) -> bool
    Does the given model specify far code?.
    
    @param cm: (C++: cm_t)

ida_typeinf.is_comp_unsure (function)
    is_comp_unsure(comp) -> comp_t
    See COMP_UNSURE.
    
    @param comp: (C++: comp_t)

ida_typeinf.is_data_far (function)
    is_data_far(cm) -> bool
    Does the given model specify far data?.
    
    @param cm: (C++: cm_t)

ida_typeinf.is_gcc (function)
    is_gcc() -> bool
    Is the target compiler COMP_GNU?

ida_typeinf.is_gcc32 (function)
    is_gcc32() -> bool
    Is the target compiler 32 bit gcc?

ida_typeinf.is_gcc64 (function)
    is_gcc64() -> bool
    Is the target compiler 64 bit gcc?

ida_typeinf.is_golang_cc (function)
    is_golang_cc(cc) -> bool
    GO language calling convention (return value in stack)?
    
    @param cc: (C++: cm_t)

ida_typeinf.is_ordinal_name (function)
    is_ordinal_name(name, ord=None) -> bool
    Check if the name is an ordinal name. Ordinal names have the following format:
    '#' + set_de(ord)
    
    @param name: (C++: const char *) char const *
    @param ord: (C++: uint32 *)

ida_typeinf.is_purging_cc (function)
    is_purging_cc(cm) -> bool
    Does the calling convention clean the stack arguments upon return?.
    @note: this function is valid only for x86 code
    
    @param cm: (C++: cm_t)

ida_typeinf.is_restype_enum (function)
    is_restype_enum(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

ida_typeinf.is_restype_struct (function)
    is_restype_struct(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

ida_typeinf.is_restype_struni (function)
    is_restype_struni(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

ida_typeinf.is_restype_void (function)
    is_restype_void(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

ida_typeinf.is_sdacl_byte (function)
    is_sdacl_byte(t) -> bool
    Identify an sdacl byte. The first sdacl byte has the following format: 11xx000x.
    The sdacl bytes are appended to udt fields. They indicate the start of type
    attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers
    instead of the tah-byte. This is done for compatibility with old databases, they
    were already using sdacl bytes in udt headers and as udt field postfixes. (see
    "sdacl-typeattrs" in the type bit definitions)
    
    @param t: (C++: type_t)

ida_typeinf.is_swift_cc (function)
    is_swift_cc(cc) -> bool
    Swift calling convention (arguments and return values in registers)?
    
    @param cc: (C++: cm_t)

ida_typeinf.is_tah_byte (function)
    is_tah_byte(t) -> bool
    The TAH byte (type attribute header byte) denotes the start of type attributes.
    (see "tah-typeattrs" in the type bit definitions)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_arithmetic (function)
    is_type_arithmetic(t) -> bool
    Is the type an arithmetic type? (floating or integral)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_array (function)
    is_type_array(t) -> bool
    See BT_ARRAY.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_bitfld (function)
    is_type_bitfld(t) -> bool
    See BT_BITFIELD.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_bool (function)
    is_type_bool(t) -> bool
    See BTF_BOOL.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_char (function)
    is_type_char(t) -> bool
    Does the type specify a char value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_choosable (function)
    is_type_choosable(ti, ordinal) -> bool
    Check if a struct/union type is choosable
    
    @param ti: (C++: const til_t *) type library
    @param ordinal: (C++: uint32) ordinal number of a UDT type

ida_typeinf.is_type_complex (function)
    is_type_complex(t) -> bool
    See BT_COMPLEX.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_const (function)
    is_type_const(t) -> bool
    See BTM_CONST.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_double (function)
    is_type_double(t) -> bool
    See BTF_DOUBLE.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_enum (function)
    is_type_enum(t) -> bool
    See BTF_ENUM.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_ext_arithmetic (function)
    is_type_ext_arithmetic(t) -> bool
    Is the type an extended arithmetic type? (arithmetic or enum)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_ext_integral (function)
    is_type_ext_integral(t) -> bool
    Is the type an extended integral type? (integral or enum)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_float (function)
    is_type_float(t) -> bool
    See BTF_FLOAT.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_floating (function)
    is_type_floating(t) -> bool
    Is the type a floating point type?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_func (function)
    is_type_func(t) -> bool
    See BT_FUNC.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_int (function)
    is_type_int(bt) -> bool
    Does the type_t specify one of the basic types in Basic type: integer?
    
    @param bt: (C++: type_t)

ida_typeinf.is_type_int128 (function)
    is_type_int128(t) -> bool
    Does the type specify a 128-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_int16 (function)
    is_type_int16(t) -> bool
    Does the type specify a 16-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_int32 (function)
    is_type_int32(t) -> bool
    Does the type specify a 32-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_int64 (function)
    is_type_int64(t) -> bool
    Does the type specify a 64-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_integral (function)
    is_type_integral(t) -> bool
    Is the type an integral type (char/short/int/long/bool)?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_ldouble (function)
    is_type_ldouble(t) -> bool
    See BTF_LDOUBLE.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_paf (function)
    is_type_paf(t) -> bool
    Is the type a pointer, array, or function type?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_partial (function)
    is_type_partial(t) -> bool
    Identifies an unknown or void type with a known size (see Basic type: unknown &
    void)
    
    @param t: (C++: type_t)

ida_typeinf.is_type_ptr (function)
    is_type_ptr(t) -> bool
    See BT_PTR.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_ptr_or_array (function)
    is_type_ptr_or_array(t) -> bool
    Is the type a pointer or array type?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_struct (function)
    is_type_struct(t) -> bool
    See BTF_STRUCT.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_struni (function)
    is_type_struni(t) -> bool
    Is the type a struct or union?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_sue (function)
    is_type_sue(t) -> bool
    Is the type a struct/union/enum?
    
    @param t: (C++: type_t)

ida_typeinf.is_type_tbyte (function)
    is_type_tbyte(t) -> bool
    See BTF_FLOAT.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_typedef (function)
    is_type_typedef(t) -> bool
    See BTF_TYPEDEF.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uchar (function)
    is_type_uchar(t) -> bool
    See BTF_UCHAR.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uint (function)
    is_type_uint(t) -> bool
    See BTF_UINT.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uint128 (function)
    is_type_uint128(t) -> bool
    See BTF_UINT128.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uint16 (function)
    is_type_uint16(t) -> bool
    See BTF_UINT16.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uint32 (function)
    is_type_uint32(t) -> bool
    See BTF_UINT32.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_uint64 (function)
    is_type_uint64(t) -> bool
    See BTF_UINT64.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_union (function)
    is_type_union(t) -> bool
    See BTF_UNION.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_unknown (function)
    is_type_unknown(t) -> bool
    See BT_UNKNOWN.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_void (function)
    is_type_void(t) -> bool
    See BTF_VOID.
    
    @param t: (C++: type_t)

ida_typeinf.is_type_volatile (function)
    is_type_volatile(t) -> bool
    See BTM_VOLATILE.
    
    @param t: (C++: type_t)

ida_typeinf.is_typeid_last (function)
    is_typeid_last(t) -> bool
    Is the type_t the last byte of type declaration? (there are no additional bytes
    after a basic type, see _BT_LAST_BASIC)
    
    @param t: (C++: type_t)

ida_typeinf.is_user_cc (function)
    is_user_cc(cm) -> bool
    Does the calling convention specify argument locations explicitly?
    
    @param cm: (C++: cm_t)

ida_typeinf.is_vararg_cc (function)
    is_vararg_cc(cm) -> bool
    Does the calling convention use ellipsis?
    
    @param cm: (C++: cm_t)

ida_typeinf.lexcompare_tinfo (function)
    lexcompare_tinfo(t1, t2, arg3) -> int
    
    @param t1: uint32
    @param t2: uint32
    @param arg3: int

ida_typeinf.load_til (function)
    load_til(name, tildir=None) -> til_t
    Load til from a file without adding it to the database list (see also add_til).
    Failure to load base tils are reported into 'errbuf'. They do not prevent
    loading of the main til.
    
    @param name: (C++: const char *) filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @param tildir: (C++: const char *) directory where to load the til from. nullptr means default til
                   subdirectories.
    @return: pointer to resulting til, nullptr if failed and error message is in
             errbuf

ida_typeinf.load_til_header (function)
    load_til_header(tildir, name) -> til_t
    Get human-readable til description.
    
    @param tildir: (C++: const char *) char const *
    @param name: (C++: const char *) char const *

ida_typeinf.lower_type (function)
    lower_type(til, tif, name=None, _helper=None) -> int
    Lower type. Inspect the type and lower all function subtypes using
    lower_func_type().
    We call the prototypes usually encountered in source files "high level"
    They may have implicit arguments, array arguments, big structure retvals, etc
    We introduce explicit arguments (i.e. 'this' pointer) and call the result
    "low level prototype". See FTI_HIGH.
    
    In order to improve heuristics for recognition of big structure retvals,
    it is recommended to pass a helper that will be used to make decisions.
    That helper will be used only for lowering 'tif', and not for the children
    types walked through by recursion.
    @retval 1: removed FTI_HIGH,
    @retval 2: made substantial changes
    @retval -1: failure
    
    @param til: (C++: til_t *)
    @param tif: (C++: tinfo_t *)
    @param name: (C++: const char *) char const *
    @param _helper: (C++: lowertype_helper_t *)

ida_typeinf.lowertype_helper_t (class)
    Proxy of C++ lowertype_helper_t class.

ida_typeinf.lowertype_helper_t.__init__ (method)

ida_typeinf.lowertype_helper_t.func_has_stkframe_hole (method)
    func_has_stkframe_hole(self, candidate, candidate_data) -> bool
    
    @param candidate: tinfo_t const &
    @param candidate_data: func_type_data_t const &

ida_typeinf.lowertype_helper_t.get_func_purged_bytes (method)
    get_func_purged_bytes(self, candidate, candidate_data) -> int
    
    @param candidate: tinfo_t const &
    @param candidate_data: func_type_data_t const &

ida_typeinf.new_til (function)
    new_til(name, desc) -> til_t
    Initialize a til.
    
    @param name: (C++: const char *) char const *
    @param desc: (C++: const char *) char const *

ida_typeinf.next_named_type (function)
    next_named_type(ti, name, ntf_flags) -> char const *
    Enumerate types.
    
    @param ti: (C++: const til_t *) type library. nullptr means the local type library for the current
               database.
    @param name: (C++: const char *) the current name. the name that follows this one will be returned.
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: Type or symbol names, depending of ntf_flags. Returns mangled names.
             Never returns anonymous types. To include them, enumerate types by
             ordinals.

ida_typeinf.no_sign (variable)
    no sign, or unknown

ida_typeinf.optimize_argloc (function)
    optimize_argloc(vloc, size, gaps) -> bool
    Verify and optimize scattered argloc into simple form. All new arglocs must be
    processed by this function.
    @retval true: success
    @retval false: the input argloc was illegal
    
    @param vloc: (C++: argloc_t *)
    @param size: (C++: int)
    @param gaps: (C++: const rangeset_t *) rangeset_t const *

ida_typeinf.pack_idcobj_to_bv (function)
    pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
    Write a typed idc object to the byte vector. Byte vector may be non-empty, this
    function will append data to it
    
    @param obj: (C++: const idc_value_t *) idc_value_t const *
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param bytes: (C++: relobj_t *)
    @param objoff: (C++: void *)
    @param pio_flags: (C++: int)

ida_typeinf.pack_idcobj_to_idb (function)
    pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
    Write a typed idc object to the database.
    
    @param obj: (C++: const idc_value_t *) idc_value_t const *
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param ea: (C++: ea_t)
    @param pio_flags: (C++: int)

ida_typeinf.pack_object_to_bv (function)
    pack_object_to_bv(py_obj, ti, type, fields, base_ea, pio_flags=0) -> PyObject *
    Packs a typed object to a string
    
    @param py_obj: PyObject *
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:     tuple(0, err_code) on failure
        tuple(1, packed_buf) on success

ida_typeinf.pack_object_to_idb (function)
    pack_object_to_idb(py_obj, ti, type, fields, ea, pio_flags=0) -> PyObject *
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param py_obj: PyObject *
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking

ida_typeinf.parse_decl (function)
    parse_decl(out_tif, til, decl, pt_flags) -> str
    Parse ONE declaration. If the input string contains more than one declaration,
    the first complete type declaration (PT_TYP) or the last variable declaration
    (PT_VAR) will be used.
    @note: name & tif may be empty after the call!
    
    @param out_tif: (C++: tinfo_t *) type info
    @param til: (C++: til_t *) type library to use. may be nullptr
    @param decl: (C++: const char *) C declaration to parse
    @param pt_flags: (C++: int) combination of Type parsing flags bits
    @retval true: ok
    @retval false: declaration is bad, the error message is displayed if !PT_SIL

ida_typeinf.parse_decls (function)
    parse_decls(til, input, printer, hti_flags) -> int
    Parse many declarations and store them in a til. If there are any errors, they
    will be printed using 'printer'. This function uses default include path and
    predefined macros from the database settings. It always uses the HTI_DCL bit.
    
    @param til: (C++: til_t *) type library to store the result
    @param input: (C++: const char *) input string or file name (see hti_flags)
    @param printer: (C++: printer_t *) function to output error messages (use msg or nullptr or your
                    own callback)
    @param hti_flags: (C++: int) combination of Type formatting flags
    @return: number of errors, 0 means ok.

ida_typeinf.predicate_t (class)
    Proxy of C++ predicate_t class.

ida_typeinf.predicate_t.__disown__ (method)

ida_typeinf.predicate_t.__init__ (method)
    __init__(self) -> predicate_t
    
    @param self: PyObject *

ida_typeinf.predicate_t.should_display (method)
    should_display(self, til, name, type, fields) -> bool
    
    @param til: til_t const *
    @param name: char const *
    @param type: type_t const *
    @param fields: p_list const *

ida_typeinf.print_argloc (function)
    print_argloc(vloc, size=0, vflags=0) -> str
    Convert an argloc to human readable form.
    
    @param vloc: (C++: const argloc_t &) argloc_t const &
    @param size: (C++: int)
    @param vflags: (C++: int)

ida_typeinf.print_decls (function)
    print_decls(printer, til, py_ordinals, flags) -> int
    Print types (and possibly their dependencies) in a format suitable for using in
    a header file. This is the reverse parse_decls().
    
    @param printer: (C++: text_sink_t &) a handler for printing text
    @param til: (C++: til_t *) the type library holding the ordinals
    @param py_ordinals: ordinals of types to export. nullptr means: all ordinals in til
    @param pdf_flags: (C++: uint32) flags for the algorithm. A combination of PDF_ constants
    @retval >0: the number of types exported
    @retval 0: an error occurred
    @retval <0: the negated number of types exported. There were minor errors and
                the resulting output might not be compilable.

ida_typeinf.print_tinfo (function)
    print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> str
    
    @param prefix: char const *
    @param indent: int
    @param cmtindent: int
    @param flags: int
    @param tif: tinfo_t const *
    @param name: char const *
    @param cmt: char const *

ida_typeinf.print_type (function)
    print_type(ea, prtype_flags) -> str
    Get type declaration for the specified address.
    
    @param ea: (C++: ea_t) address
    @param prtype_flags: (C++: int) combination of Type printing flags
    @return: success

ida_typeinf.ptr_type_data_t (class)
    Proxy of C++ ptr_type_data_t class.

ida_typeinf.ptr_type_data_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: ptr_type_data_t const &

ida_typeinf.ptr_type_data_t.__init__ (method)
    __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
    
    @param c: tinfo_t
    @param bps: uchar
    @param p: tinfo_t
    @param d: int32

ida_typeinf.ptr_type_data_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: ptr_type_data_t const &

ida_typeinf.ptr_type_data_t.closure (variable)
    cannot have both closure and based_ptr_size

ida_typeinf.ptr_type_data_t.delta (variable)
    Offset from the beginning of the parent struct.

ida_typeinf.ptr_type_data_t.is_code_ptr (method)
    is_code_ptr(self) -> bool
    Are we pointing to code?

ida_typeinf.ptr_type_data_t.is_shifted (method)
    is_shifted(self) -> bool

ida_typeinf.ptr_type_data_t.obj_type (variable)
    pointed object type

ida_typeinf.ptr_type_data_t.parent (variable)
    Parent struct.

ida_typeinf.ptr_type_data_t.swap (method)
    swap(self, r)
    Set this = r and r = this.
    
    @param r: (C++: ptr_type_data_t &)

ida_typeinf.ptr_type_data_t.taptr_bits (variable)
    TAH bits.

ida_typeinf.read_tinfo_bitfield_value (function)
    read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
    
    @param typid: uint32
    @param v: uint64
    @param bitoff: int

ida_typeinf.reginfovec_t (class)
    Proxy of C++ qvector< reg_info_t > class.

ida_typeinf.reginfovec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< reg_info_t > const &

ida_typeinf.reginfovec_t.__getitem__ (method)
    __getitem__(self, i) -> reg_info_t
    
    @param i: size_t

ida_typeinf.reginfovec_t.__init__ (method)
    __init__(self) -> reginfovec_t
    __init__(self, x) -> reginfovec_t
    
    @param x: qvector< reg_info_t > const &

ida_typeinf.reginfovec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.reginfovec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< reg_info_t > const &

ida_typeinf.reginfovec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: reg_info_t const &

ida_typeinf.reginfovec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: reg_info_t const &

ida_typeinf.reginfovec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: reg_info_t const &

ida_typeinf.reginfovec_t.at (method)
    at(self, _idx) -> reg_info_t
    
    @param _idx: size_t

ida_typeinf.reginfovec_t.begin (method)
    begin(self) -> reg_info_t

ida_typeinf.reginfovec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.reginfovec_t.clear (method)
    clear(self)

ida_typeinf.reginfovec_t.empty (method)
    empty(self) -> bool

ida_typeinf.reginfovec_t.end (method)
    end(self) -> reg_info_t

ida_typeinf.reginfovec_t.erase (method)
    erase(self, it) -> reg_info_t
    
    @param it: qvector< reg_info_t >::iterator
    
    erase(self, first, last) -> reg_info_t
    
    @param first: qvector< reg_info_t >::iterator
    @param last: qvector< reg_info_t >::iterator

ida_typeinf.reginfovec_t.extract (method)
    extract(self) -> reg_info_t

ida_typeinf.reginfovec_t.find (method)
    find(self, x) -> reg_info_t
    
    @param x: reg_info_t const &

ida_typeinf.reginfovec_t.grow (method)
    grow(self, x=reg_info_t())
    
    @param x: reg_info_t const &

ida_typeinf.reginfovec_t.has (method)
    has(self, x) -> bool
    
    @param x: reg_info_t const &

ida_typeinf.reginfovec_t.inject (method)
    inject(self, s, len)
    
    @param s: reg_info_t *
    @param len: size_t

ida_typeinf.reginfovec_t.insert (method)
    insert(self, it, x) -> reg_info_t
    
    @param it: qvector< reg_info_t >::iterator
    @param x: reg_info_t const &

ida_typeinf.reginfovec_t.pop_back (method)
    pop_back(self)

ida_typeinf.reginfovec_t.push_back (method)
    push_back(self, x)
    
    @param x: reg_info_t const &
    
    push_back(self) -> reg_info_t

ida_typeinf.reginfovec_t.qclear (method)
    qclear(self)

ida_typeinf.reginfovec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.reginfovec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: reg_info_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.reginfovec_t.size (method)
    size(self) -> size_t

ida_typeinf.reginfovec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< reg_info_t > &

ida_typeinf.reginfovec_t.truncate (method)
    truncate(self)

ida_typeinf.regobj_t (class)
    Proxy of C++ regobj_t class.

ida_typeinf.regobj_t.__init__ (method)
    __init__(self) -> regobj_t

ida_typeinf.regobj_t.regidx (variable)
    index into dbg->registers

ida_typeinf.regobj_t.relocate (variable)
    0-plain num, 1-must relocate

ida_typeinf.regobj_t.size (method)
    size(self) -> size_t

ida_typeinf.regobjs_t (class)
    Proxy of C++ regobjs_t class.

ida_typeinf.regobjs_t.__init__ (method)
    __init__(self) -> regobjs_t

ida_typeinf.regobjvec_t (class)
    Proxy of C++ qvector< regobj_t > class.

ida_typeinf.regobjvec_t.__getitem__ (method)
    __getitem__(self, i) -> regobj_t
    
    @param i: size_t

ida_typeinf.regobjvec_t.__init__ (method)
    __init__(self) -> regobjvec_t
    __init__(self, x) -> regobjvec_t
    
    @param x: qvector< regobj_t > const &

ida_typeinf.regobjvec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.regobjvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: regobj_t const &

ida_typeinf.regobjvec_t.at (method)
    at(self, _idx) -> regobj_t
    
    @param _idx: size_t

ida_typeinf.regobjvec_t.begin (method)
    begin(self) -> regobj_t

ida_typeinf.regobjvec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.regobjvec_t.clear (method)
    clear(self)

ida_typeinf.regobjvec_t.empty (method)
    empty(self) -> bool

ida_typeinf.regobjvec_t.end (method)
    end(self) -> regobj_t

ida_typeinf.regobjvec_t.erase (method)
    erase(self, it) -> regobj_t
    
    @param it: qvector< regobj_t >::iterator
    
    erase(self, first, last) -> regobj_t
    
    @param first: qvector< regobj_t >::iterator
    @param last: qvector< regobj_t >::iterator

ida_typeinf.regobjvec_t.extract (method)
    extract(self) -> regobj_t

ida_typeinf.regobjvec_t.grow (method)
    grow(self, x=regobj_t())
    
    @param x: regobj_t const &

ida_typeinf.regobjvec_t.inject (method)
    inject(self, s, len)
    
    @param s: regobj_t *
    @param len: size_t

ida_typeinf.regobjvec_t.insert (method)
    insert(self, it, x) -> regobj_t
    
    @param it: qvector< regobj_t >::iterator
    @param x: regobj_t const &

ida_typeinf.regobjvec_t.pop_back (method)
    pop_back(self)

ida_typeinf.regobjvec_t.push_back (method)
    push_back(self, x)
    
    @param x: regobj_t const &
    
    push_back(self) -> regobj_t

ida_typeinf.regobjvec_t.qclear (method)
    qclear(self)

ida_typeinf.regobjvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.regobjvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: regobj_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.regobjvec_t.size (method)
    size(self) -> size_t

ida_typeinf.regobjvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< regobj_t > &

ida_typeinf.regobjvec_t.truncate (method)
    truncate(self)

ida_typeinf.remove_abi_opts (function)
    remove_abi_opts(abi_opts, user_level=False) -> bool
    
    @param abi_opts: char const *
    @param user_level: bool

ida_typeinf.remove_pointer (function)
    remove_pointer(tif) -> tinfo_t
    
    @param BT_PTR: If the current type is a pointer, return the pointed object. If the
    current type is not a pointer, return the current type. See also
    get_ptrarr_object() and get_pointed_object()

ida_typeinf.remove_tinfo_pointer (function)
    remove_tinfo_pointer(tif, name, til) -> (bool, NoneType), (bool, str)
    Remove pointer of a type. (i.e. convert "char *" into "char"). Optionally remove
    the "lp" (or similar) prefix of the input name. If the input type is not a
    pointer, then fail.
    
    @param tif: (C++: tinfo_t *)
    @param name: char const *
    @param til: (C++: const til_t *) til_t const *

ida_typeinf.replace_ordinal_typerefs (function)
    replace_ordinal_typerefs(til, tif) -> int
    Replace references to ordinal types by name references. This function 'unties'
    the type from the current local type library and makes it easier to export it.
    
    @param til: (C++: til_t *) type library to use. may be nullptr.
    @param tif: (C++: tinfo_t *) type to modify (in/out)
    @retval number: of replaced subtypes, -1 on failure

ida_typeinf.resolve_typedef (function)
    resolve_typedef(til, type) -> type_t const *
    
    @param til: til_t const *
    @param type: type_t const *

ida_typeinf.rrel_t (class)
    Proxy of C++ rrel_t class.

ida_typeinf.rrel_t.__init__ (method)
    __init__(self) -> rrel_t

ida_typeinf.rrel_t.off (variable)
    displacement from the address pointed by the register

ida_typeinf.rrel_t.reg (variable)
    register index (into ph.reg_names)

ida_typeinf.save_tinfo (function)
    save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
    
    @param tif: tinfo_t *
    @param til: til_t *
    @param ord: size_t
    @param name: char const *
    @param ntf_flags: int

ida_typeinf.scattered_aloc_t (class)
    Proxy of C++ scattered_aloc_t class.

ida_typeinf.scattered_aloc_t.__init__ (method)
    __init__(self) -> scattered_aloc_t

ida_typeinf.score_tinfo (function)
    score_tinfo(tif) -> uint32
    
    @param tif: tinfo_t const *

ida_typeinf.serialize_tinfo (function)
    serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
    
    @param type: qtype *
    @param fields: qtype *
    @param fldcmts: qtype *
    @param tif: tinfo_t const *
    @param sudt_flags: int

ida_typeinf.set_abi_name (function)
    set_abi_name(abiname, user_level=False) -> bool
    Set abi name (see Compiler IDs)
    
    @param abiname: (C++: const char *) char const *
    @param user_level: (C++: bool)

ida_typeinf.set_c_header_path (function)
    set_c_header_path(incdir)
    Set include directory path the target compiler.
    
    @param incdir: (C++: const char *) char const *

ida_typeinf.set_c_macros (function)
    set_c_macros(macros)
    Set predefined macros for the target compiler.
    
    @param macros: (C++: const char *) char const *

ida_typeinf.set_compiler (function)
    set_compiler(cc, flags, abiname=None) -> bool
    Change current compiler.
    
    @param cc: (C++: const compiler_info_t &) compiler to switch to
    @param flags: (C++: int) Set compiler flags
    @param abiname: (C++: const char *) ABI name
    @return: success

ida_typeinf.set_compiler_id (function)
    set_compiler_id(id, abiname=None) -> bool
    Set the compiler id (see Compiler IDs)
    
    @param id: (C++: comp_t)
    @param abiname: (C++: const char *) char const *

ida_typeinf.set_compiler_string (function)
    set_compiler_string(compstr, user_level) -> bool
    
    @param compstr: (C++: const char *) - compiler description in form <abbr>:<abiname>
    @param user_level: (C++: bool) - initiated by user if TRUE
    @return: success

ida_typeinf.set_numbered_type (function)
    set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
    Store a type in the til. 'name' may be nullptr for anonymous types. To replace
    the existed type use NTF_REPLACE
    
    @param ti: (C++: til_t *)
    @param ordinal: (C++: uint32)
    @param ntf_flags: (C++: int)
    @param name: (C++: const char *) char const *
    @param type: (C++: const type_t *) type_t const *
    @param fields: (C++: const p_list *) p_list const *
    @param cmt: (C++: const char *) char const *
    @param fldcmts: (C++: const p_list *) p_list const *
    @param sclass: (C++: const sclass_t *) sclass_t const *

ida_typeinf.set_tinfo_attr (function)
    set_tinfo_attr(tif, ta, may_overwrite) -> bool
    
    @param tif: tinfo_t *
    @param ta: type_attr_t const &
    @param may_overwrite: bool

ida_typeinf.set_tinfo_attrs (function)
    set_tinfo_attrs(tif, ta) -> bool
    
    @param tif: tinfo_t *
    @param ta: type_attrs_t *

ida_typeinf.set_tinfo_property (function)
    set_tinfo_property(tif, sta_prop, x) -> size_t
    
    @param tif: tinfo_t *
    @param sta_prop: int
    @param x: size_t

ida_typeinf.set_tinfo_property4 (function)
    set_tinfo_property4(tif, sta_prop, p1, p2, p3, p4) -> size_t
    
    @param tif: tinfo_t *
    @param sta_prop: int
    @param p1: size_t
    @param p2: size_t
    @param p3: size_t
    @param p4: size_t

ida_typeinf.set_type_alias (function)
    set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
    Create a type alias. Redirects all references to source type to the destination
    type. This is equivalent to instantaneous replacement all references to srctype
    by dsttype.
    
    @param ti: (C++: til_t *)
    @param src_ordinal: (C++: uint32)
    @param dst_ordinal: (C++: uint32)

ida_typeinf.set_type_choosable (function)
    set_type_choosable(ti, ordinal, value)
    Enable/disable 'choosability' flag for a struct/union type
    
    @param ti: (C++: til_t *) type library
    @param ordinal: (C++: uint32) ordinal number of a UDT type
    @param value: (C++: bool) flag value

ida_typeinf.set_vftable_ea (function)
    set_vftable_ea(ordinal, vftable_ea) -> bool
    Set the address of a vftable instance for a vftable type.
    
    @param ordinal: (C++: uint32) ordinal number of the corresponding vftable type.
    @param vftable_ea: (C++: ea_t) address of a virtual function table.
    @return: success

ida_typeinf.simd_info_t (class)
    Proxy of C++ simd_info_t class.

ida_typeinf.simd_info_t.__init__ (method)
    __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
    
    @param nm: char const *
    @param sz: uint16
    @param memt: type_t

ida_typeinf.simd_info_t.match_pattern (method)
    match_pattern(self, pattern) -> bool
    
    @param pattern: simd_info_t const *

ida_typeinf.simd_info_t.memtype (variable)
    member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32/64/128 BTF_INT - integrals of
    any size/sign BTF_FLOAT, BTF_DOUBLE BTF_TBYTE - floatings of any size BTF_UNION
    - union of integral and floating types BTF_UNK - undefined

ida_typeinf.simd_info_t.name (variable)
    name of SIMD type (nullptr-undefined)

ida_typeinf.simd_info_t.size (variable)
    SIMD type size in bytes (0-undefined)

ida_typeinf.simd_info_t.tif (variable)
    SIMD type (empty-undefined)

ida_typeinf.stkarg_area_info_t (class)
    Proxy of C++ stkarg_area_info_t class.

ida_typeinf.stkarg_area_info_t.__init__ (method)
    __init__(self) -> stkarg_area_info_t

ida_typeinf.stkarg_area_info_t.linkage_area (variable)
    Size of the linkage area. explanations at: \link{https://www.ibm.com/docs/en/xl-
    fortran-aix/16.1.0?topic=conventions-linkage-area} examples: pc: 0, hppa: 0, ppc
    aix: 0x18 (equal to stkarg_offset)

ida_typeinf.stkarg_area_info_t.shadow_size (variable)
    Size of the shadow area. explanations at:
    \link{https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-
    in-x64-assembly} examples: x64 Visual Studio C++: 0x20, x64 gcc: 0, ppc aix:
    0x20

ida_typeinf.stkarg_area_info_t.stkarg_offset (variable)
    Offset from the SP to the first stack argument (can include linkage area)
    examples: pc: 0, hppa: -0x34, ppc aix: 0x18

ida_typeinf.store_til (function)
    store_til(ti, tildir, name) -> bool
    Store til to a file. If the til contains garbage, it will be collected before
    storing the til. Your plugin should call compact_til() before calling
    store_til().
    
    @param ti: (C++: til_t *) type library to store
    @param tildir: (C++: const char *) directory where to store the til. nullptr means current
                   directory.
    @param name: (C++: const char *) filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @return: success

ida_typeinf.switch_to_golang (function)
    switch_to_golang()
    switch to GOLANG calling convention (to be used as default CC)

ida_typeinf.text_sink_t (class)
    Proxy of C++ text_sink_t class.

ida_typeinf.text_sink_t.__disown__ (method)

ida_typeinf.text_sink_t.__init__ (method)
    __init__(self) -> text_sink_t
    
    @param self: PyObject *

ida_typeinf.text_sink_t._print (method)
    _print(self, str) -> int
    
    Parameters
    ----------
    str: char const *

ida_typeinf.til_symbol_t (class)
    Proxy of C++ til_symbol_t class.

ida_typeinf.til_symbol_t.__init__ (method)
    __init__(self, n=None, t=None) -> til_symbol_t
    
    @param n: char const *
    @param t: til_t const *

ida_typeinf.til_symbol_t.name (variable)
    symbol name

ida_typeinf.til_symbol_t.til (variable)
    pointer to til

ida_typeinf.til_t (class)
    Proxy of C++ til_t class.

ida_typeinf.til_t.__init__ (method)
    __init__(self) -> til_t

ida_typeinf.til_t.base (method)
    base(self, n) -> til_t
    tils that our til is based on
    
    @param n: int

ida_typeinf.til_t.cc (variable)
    information about the target compiler

ida_typeinf.til_t.desc (variable)
    human readable til description

ida_typeinf.til_t.flags (variable)
    Type info library property bits

ida_typeinf.til_t.is_dirty (method)
    is_dirty(self) -> bool
    Has the til been modified? (TIL_MOD)

ida_typeinf.til_t.name (variable)
    short file name (without path and extension)

ida_typeinf.til_t.nbases (variable)
    number of base tils

ida_typeinf.til_t.nrefs (variable)
    number of references to the til

ida_typeinf.til_t.nstreams (variable)
    number of extra streams

ida_typeinf.til_t.set_dirty (method)
    set_dirty(self)
    Mark the til as modified (TIL_MOD)

ida_typeinf.til_t.streams (variable)
    symbol stream storage

ida_typeinf.tinfo_errstr (function)
    tinfo_errstr(code) -> char const *
    Helper function to convert an error code into a printable string. Additional
    arguments are handled using the functions from err.h
    
    @param code: (C++: tinfo_code_t) enum tinfo_code_t

ida_typeinf.tinfo_t (class)
    Proxy of C++ tinfo_t class.

ida_typeinf.tinfo_t.ENUMBM_AUTO (variable)
    convert to bitmask if the outcome is nice and useful

ida_typeinf.tinfo_t.ENUMBM_OFF (variable)
    convert to ordinal enum

ida_typeinf.tinfo_t.ENUMBM_ON (variable)
    convert to bitmask enum

ida_typeinf.tinfo_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__gt__ (method)
    __gt__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__init__ (method)
    __init__(self) -> tinfo_t
    __init__(self, decl_type) -> tinfo_t
    
    @param decl_type: type_t
    
    __init__(self, r) -> tinfo_t
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__le__ (method)
    __le__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.__str__ (method)
    __str__(self) -> qstring

ida_typeinf.tinfo_t._print (method)
    _print(self, name=None, prtype_flags=0, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
    
    Parameters
    ----------
    name: char const *
    prtype_flags: int
    indent: int
    cmtindent: int
    prefix: char const *
    cmt: char const *

ida_typeinf.tinfo_t.add_edm (method)
    add_edm(self, edm, bmask=bmask64_t(-1), etf_flags=0, idx=-1) -> tinfo_code_t
    Add a new enum member (a new symbolic constant)
    
    @param edm: (C++: const edm_t &) the constant name, value, and comment
    @param bmask: (C++: bmask64_t) bmask of the group to add the constant to
    @note: 1. For non-bitmask enum push back constant, BMASK is not used (set it ot
           -1), never failed 2. For bitmask enum:
    * if VAL and BMASK are not agreed, return TERR_BAD_MSKVAL
    * if group with BMASK exists, push back constant to group
    * otherwise use constant as bitmask for a new group
    @note: ETF_NO_SAVE is ignored

ida_typeinf.tinfo_t.add_udm (method)
    add_udm(self, udm, etf_flags=0, times=1, idx=-1) -> tinfo_code_t
    Add a structure/union member.
    
    @param udm: (C++: const udm_t &) member to add
    @param etf_flags: (C++: uint) edit_type() flags flags
    @param times: (C++: size_t) how many times to add. if times > 1, the member name will be
                  appended a suffix like "_2" and so on
    @param idx: (C++: ssize_t) the index in the udm array where the new udm should be placed. if
                the specified index cannot be honored because it would spoil the udm
                sorting order, it is silently ignored.
    @note: ETF_NO_SAVE is ignored

ida_typeinf.tinfo_t.append_covered (method)
    append_covered(self, out, offset=0) -> bool
    Calculate set of covered bytes for the type
    
    @param out: (C++: rangeset_t *) pointer to the output buffer. covered bytes will be appended to it.
    @param offset: (C++: uint64) delta in bytes to add to all calculations. used internally during
                   recurion.

ida_typeinf.tinfo_t.calc_gaps (method)
    calc_gaps(self, out) -> bool
    Calculate set of padding bytes for the type
    
    @param out: (C++: rangeset_t *) pointer to the output buffer; old buffer contents will be lost.

ida_typeinf.tinfo_t.calc_purged_bytes (method)
    calc_purged_bytes(self) -> int

ida_typeinf.tinfo_t.calc_score (method)
    calc_score(self) -> uint32
    Calculate the type score (the higher - the nicer is the type)

ida_typeinf.tinfo_t.calc_udt_aligns (method)
    calc_udt_aligns(self, sudt_flags=0x0004) -> bool
    Calculate the udt alignments using the field offsets/sizes and the total udt
    size This function does not work on typerefs
    
    @param sudt_flags: (C++: int)

ida_typeinf.tinfo_t.change_sign (method)
    change_sign(self, sign) -> bool
    Change the type sign. Works only for the types that may have sign.
    
    @param sign: (C++: type_sign_t)

ida_typeinf.tinfo_t.clear (method)
    clear(self)
    Clear contents of this tinfo, and remove from the type system.

ida_typeinf.tinfo_t.clr_const (method)
    clr_const(self) -> bool

ida_typeinf.tinfo_t.clr_const_volatile (method)
    clr_const_volatile(self) -> bool

ida_typeinf.tinfo_t.clr_decl_const_volatile (method)
    clr_decl_const_volatile(self)

ida_typeinf.tinfo_t.clr_volatile (method)
    clr_volatile(self) -> bool

ida_typeinf.tinfo_t.compare (method)
    compare(self, r) -> int
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.compare_with (method)
    compare_with(self, r, tcflags=0) -> bool
    Compare two types, based on given flags (see tinfo_t comparison flags)
    
    @param r: (C++: const tinfo_t &) tinfo_t const &
    @param tcflags: (C++: int)

ida_typeinf.tinfo_t.convert_array_to_ptr (method)
    convert_array_to_ptr(self) -> bool
    Convert an array into a pointer. type[] => type *

ida_typeinf.tinfo_t.copy (method)
    copy(self) -> tinfo_t

ida_typeinf.tinfo_t.copy_type (method)
    copy_type(self, til, name, ntf_flags=0x0001|0x1000) -> tinfo_code_t
    
    @param til: til_t *
    @param name: char const *
    @param ntf_flags: int

ida_typeinf.tinfo_t.create_array (method)
    create_array(self, p, decl_type=BT_ARRAY) -> bool
    
    @param p: array_type_data_t const &
    @param decl_type: type_t
    
    create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
    
    @param tif: tinfo_t const &
    @param nelems: uint32
    @param base: uint32
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_bitfield (method)
    create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
    
    @param p: bitfield_type_data_t const &
    @param decl_type: type_t
    
    create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
    
    @param nbytes: uchar
    @param width: uchar
    @param is_unsigned: bool
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_enum (method)
    create_enum(self, p, decl_type=BTF_ENUM) -> bool
    
    @param p: enum_type_data_t &
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_forward_decl (method)
    create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
    Create a forward declaration. decl_type: BTF_STRUCT, BTF_UNION, or BTF_ENUM
    
    @param til: (C++: til_t *)
    @param decl_type: (C++: type_t)
    @param name: (C++: const char *) char const *
    @param ntf_flags: (C++: int)

ida_typeinf.tinfo_t.create_func (method)
    create_func(self, p, decl_type=BT_FUNC) -> bool
    
    @param p: func_type_data_t &
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_ptr (method)
    create_ptr(self, p, decl_type=BT_PTR) -> bool
    
    @param p: ptr_type_data_t const &
    @param decl_type: type_t
    
    create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
    
    @param tif: tinfo_t const &
    @param bps: uchar
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_simple_type (method)
    create_simple_type(self, decl_type) -> bool
    
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_typedef (method)
    create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
    
    @param p: typedef_type_data_t const &
    @param decl_type: type_t
    @param try_ordinal: bool
    
    create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
    
    @param til: til_t const *
    @param name: char const *
    @param decl_type: type_t
    @param try_ordinal: bool
    
    create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
    
    @param til: til_t const *
    @param ord: uint
    @param decl_type: type_t

ida_typeinf.tinfo_t.create_udt (method)
    create_udt(self, p) -> bool
    
    @param p: udt_type_data_t &
    
    create_udt(self, p, decl_type) -> bool
    
    @param p: udt_type_data_t &
    @param decl_type: type_t

ida_typeinf.tinfo_t.del_attr (method)
    del_attr(self, key, make_copy=True) -> bool
    Del a type attribute. typerefs cannot be modified by this function.
    
    @param key: (C++: const qstring &) qstring const &
    @param make_copy: (C++: bool)

ida_typeinf.tinfo_t.del_attrs (method)
    del_attrs(self)
    Del all type attributes. typerefs cannot be modified by this function.

ida_typeinf.tinfo_t.del_edm (method)
    del_edm(self, idx, etf_flags=0) -> tinfo_code_t
    
    @param idx: size_t
    @param etf_flags: uint

ida_typeinf.tinfo_t.del_edms (method)
    del_edms(self, idx1, idx2, etf_flags=0) -> tinfo_code_t
    Delete enum members
    
    @param idx1: (C++: size_t) index in edmvec_t
    @param idx2: (C++: size_t) index in edmvec_t or size_t(-1)
    @param etf_flags: (C++: uint) etf_flag_t Delete enum members in [idx1, idx2)
    @note: For bitmask enum, the first member of a non-trivial group (having 2 or
           more members) is considered as a group mask. It is impossible to delete
           the group mask of a non-trivial group, other members of the group must be
           deleted first. Empty groups are automatically deleted.

ida_typeinf.tinfo_t.del_udm (method)
    del_udm(self, index, etf_flags=0) -> tinfo_code_t
    Delete a structure/union member.
    
    @param index: (C++: size_t)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.del_udms (method)
    del_udms(self, idx1, idx2, etf_flags=0) -> tinfo_code_t
    Delete structure/union members in the range [idx1, idx2)
    
    @param idx1: (C++: size_t)
    @param idx2: (C++: size_t)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.deserialize (method)
    deserialize(self, til, ptype, pfields=None, pfldcmts=None, cmt=None) -> bool
    Deserialize a type string into a tinfo_t object.
    
    @param til: (C++: const til_t *) til_t const *
    @param ptype: (C++: const qtype *) type_t const **
    @param pfields: (C++: const qtype *) p_list const **
    @param pfldcmts: (C++: const qtype *) p_list const **
    @param cmt: (C++: const char *) char const *
    
    deserialize(self, til, type, fields, cmts=None) -> bool
    
    @param til: til_t const *
    @param type: type_t const *
    @param fields: p_list const *
    @param cmts: p_list const *

ida_typeinf.tinfo_t.dstr (method)
    dstr(self) -> char const *
    Function to facilitate debugging.

ida_typeinf.tinfo_t.edit_array (method)
    edit_array(self, editor, etf_flags=0) -> tinfo_code_t
    
    @param editor: std::function< tinfo_code_t (array_type_data_t *) > const &
    @param etf_flags: uint

ida_typeinf.tinfo_t.edit_bitfield (method)
    edit_bitfield(self, editor, etf_flags=0) -> tinfo_code_t
    
    @param editor: std::function< tinfo_code_t (bitfield_type_data_t *) > const &
    @param etf_flags: uint

ida_typeinf.tinfo_t.edit_edm (method)
    edit_edm(self, idx, value, bmask=bmask64_t(-1), etf_flags=0) -> tinfo_code_t
    Change constant value and/or bitmask
    
    @param idx: (C++: size_t) index in edmvec_t
    @param value: (C++: uint64) old or new value
    @param bmask: (C++: bmask64_t) old or new bitmask
    @note: if new bitmask is specified the index of constant may be changed

ida_typeinf.tinfo_t.edit_enum (method)
    edit_enum(self, editor, etf_flags=0) -> tinfo_code_t
    
    @param editor: std::function< tinfo_code_t (enum_type_data_t *) > const &
    @param etf_flags: uint

ida_typeinf.tinfo_t.edit_func (method)
    edit_func(self, editor, etf_flags=0) -> tinfo_code_t
    
    @param editor: std::function< tinfo_code_t (func_type_data_t *) > const &
    @param etf_flags: uint

ida_typeinf.tinfo_t.edit_ptr (method)
    edit_ptr(self, editor, etf_flags=0) -> tinfo_code_t
    
    @param editor: std::function< tinfo_code_t (ptr_type_data_t *) > const &
    @param etf_flags: uint

ida_typeinf.tinfo_t.edit_udt (method)
    edit_udt(self, editor, etf_flags=0) -> tinfo_code_t
    Edit udt/enum/func/array/ptr/bitfield. These functions may be used if the
    desired functionality is not provided by the STA_... based functions.
    
    @param editor: (C++: const std::function< tinfo_code_t(udt_type_data_t *)> &) callback to modify the type details; should return true on
                   success
    @param etf_flags: (C++: uint) combination of etf_flag_t constants

ida_typeinf.tinfo_t.empty (method)
    empty(self) -> bool
    Was tinfo_t initialized with some type info or not?

ida_typeinf.tinfo_t.equals_to (method)
    equals_to(self, r) -> bool
    
    @param r: tinfo_t const &

ida_typeinf.tinfo_t.expand_udt (method)
    expand_udt(self, idx, delta, etf_flags=0) -> tinfo_code_t
    Expand/shtrink a structure by adding/removing a gap before the specified member.
    
    @param idx: (C++: size_t) index of the member
    @param delta: (C++: adiff_t) number of bytes to add or remove
    @param etf_flags: (C++: uint) etf_flag_t Please note that it is impossible to add a gap at
                      the very end of a structure. However, adding before a regular
                      member is possible. This function can be used to remove gaps
                      in the middle of a structure by specifying a negative delta
                      value.

ida_typeinf.tinfo_t.find_edm (method)
    find_edm(self, edm, value, bmask=bmask64_t(-1), serial=0) -> tinfo_code_t
    Find enum member
    
    @param edm: (C++: edm_t *) enum type member
    @param value: uint64
    @param bmask: bmask64_t
    find_edm(self, edm, name) -> tinfo_code_t
    
    @param edm: edm_t *
    @param name: char const *

ida_typeinf.tinfo_t.find_udm (method)
    find_udm(self, udm, strmem_flags) -> int
    BTF_STRUCT,BTF_UNION: Find a udt member.
    * at the specified offset (STRMEM_OFFSET)
    * with the specified index (STRMEM_INDEX)
    * with the specified type (STRMEM_TYPE)
    * with the specified name (STRMEM_NAME)
    
    @param udm: (C++: struct udm_t *) udm_t *
    @param strmem_flags: (C++: int)
    @return: the index of the found member or -1

ida_typeinf.tinfo_t.force_tid (method)
    force_tid(self) -> tid_t
    Get the type tid. Create if it does not exist yet. If the type comes from a base
    til, the type will be copied to the local til and a new tid will be created for
    it. (if the type comes from a base til, it does not have a tid yet). If the type
    comes from the local til, this function is equivalent to get_tid()
    
    @return: tid or BADADDR

ida_typeinf.tinfo_t.get_alias_target (method)
    get_alias_target(self) -> uint32
    Get type alias If the type has no alias, return 0.

ida_typeinf.tinfo_t.get_array_details (method)
    get_array_details(self, ai) -> bool
    Get the array specific info.
    
    @param ai: (C++: array_type_data_t *)

ida_typeinf.tinfo_t.get_array_element (method)
    get_array_element(self) -> tinfo_t

ida_typeinf.tinfo_t.get_array_nelems (method)
    get_array_nelems(self) -> int

ida_typeinf.tinfo_t.get_attr (method)
    get_attr(self, key, all_attrs=True) -> str or None
    Get a type attribute.
    
    @param key: (C++: const qstring &) qstring const &
    @param all_attrs: (C++: bool)

ida_typeinf.tinfo_t.get_attrs (method)
    get_attrs(self, tav, all_attrs=False) -> bool
    Get type attributes (all_attrs: include attributes of referenced types, if any)
    
    @param tav: (C++: type_attrs_t *)
    @param all_attrs: (C++: bool)

ida_typeinf.tinfo_t.get_bit_buckets (method)
    get_bit_buckets(self, buckets) -> bool
    ::BT_STRUCT: get bit buckets Bit buckets are used to layout bitfields
    
    @param buckets: (C++: range64vec_t *)
    @return: false if wrong type was passed

ida_typeinf.tinfo_t.get_bitfield_details (method)
    get_bitfield_details(self, bi) -> bool
    Get the bitfield specific info.
    
    @param bi: (C++: bitfield_type_data_t *)

ida_typeinf.tinfo_t.get_declalign (method)
    get_declalign(self) -> uchar
    Get declared alignment of the type.

ida_typeinf.tinfo_t.get_decltype (method)
    get_decltype(self) -> type_t
    Get declared type (without resolving type references; they are returned as is).
    Obviously this is a very fast function and should be used instead of
    get_realtype() if possible. Please note that for typerefs this function will
    return BTF_TYPEDEF. To determine if a typeref is a typedef, use is_typedef()

ida_typeinf.tinfo_t.get_edm (method)
    get_edm(self, edm, idx) -> tinfo_code_t
    Get enum member
    
    @param edm: (C++: edm_t *) enum type member
    @param idx: (C++: size_t) enum member index

ida_typeinf.tinfo_t.get_edm_by_tid (method)
    get_edm_by_tid(self, edm, tid) -> ssize_t
    
    @param edm: edm_t *
    @param tid: tid_t

ida_typeinf.tinfo_t.get_enum_base_type (method)
    get_enum_base_type(self) -> type_t
    Get enum base type (convert enum to integer type) Returns BT_UNK if failed to
    convert

ida_typeinf.tinfo_t.get_enum_details (method)
    get_enum_details(self, ei) -> bool
    Get the enum specific info.
    
    @param ei: (C++: enum_type_data_t *)

ida_typeinf.tinfo_t.get_enum_radix (method)
    get_enum_radix(self) -> int
    Get enum constant radix
    
    @return: radix or 1 for BTE_CHAR enum_type_data_t::get_enum_radix()

ida_typeinf.tinfo_t.get_final_element (method)
    get_final_element(self) -> tinfo_t
    repeat recursively: if an array, return the type of its element; else return the
    type itself.

ida_typeinf.tinfo_t.get_final_ordinal (method)
    get_final_ordinal(self) -> uint32
    Get final type ordinal (0 if none)

ida_typeinf.tinfo_t.get_final_type_name (method)
    get_final_type_name(self) -> bool
    Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
    
    @return: the name of the last type in the chain (TYPEn). if there is no chain,
             returns TYPE1

ida_typeinf.tinfo_t.get_forward_type (method)
    get_forward_type(self) -> type_t
    Get type of a forward declaration. For a forward declaration this function
    returns its base type. In other cases it returns BT_UNK

ida_typeinf.tinfo_t.get_func_details (method)
    get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
    Get only the function specific info for this tinfo_t.
    
    @param fi: (C++: func_type_data_t *)
    @param gtd: (C++: gtd_func_t) enum gtd_func_t

ida_typeinf.tinfo_t.get_innermost_udm (method)
    get_innermost_udm(self, bitoffset) -> tinfo_t
    Get the innermost member at the given offset
    
    @param bitoffset: (C++: uint64) bit offset into the structure
    @retval udt: with the innermost member
    @retval empty: type if it is not a struct type or OFFSET could not be found

ida_typeinf.tinfo_t.get_methods (method)
    get_methods(self, methods) -> bool
    
    @param BT_COMPLEX: get a list of member functions declared in this udt.
    @return: false if no member functions exist

ida_typeinf.tinfo_t.get_modifiers (method)
    get_modifiers(self) -> type_t

ida_typeinf.tinfo_t.get_named_type (method)
    get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
    Create a tinfo_t object for an existing named type.
    
    @param til: (C++: const til_t *) type library to use
    @param name: (C++: const char *) name of the type to link to
    @param decl_type: (C++: type_t) if the reference was explicitly specified with the type tag
    (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may specify it.
    the kernel will accept only the specified tag after resolving
    the type. If the resolved type does not correspond to the
    explicitly specified tag, the type will be considered as undefined
    @param resolve: (C++: bool) true: immediately resolve the type and return success code.
    @param try_ordinal: (C++: bool) true: try to replace name reference by an ordinal reference

ida_typeinf.tinfo_t.get_nargs (method)
    get_nargs(self) -> int
    BT_FUNC or BT_PTR BT_FUNC: Calculate number of arguments (-1 - error)

ida_typeinf.tinfo_t.get_next_type_name (method)
    get_next_type_name(self) -> bool
    Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
    
    @return: the name of the next type in the chain (TYPE2). if there is no chain,
             returns failure

ida_typeinf.tinfo_t.get_nice_type_name (method)
    get_nice_type_name(self) -> bool
    Get the beautified type name. Get the referenced name and apply regular
    expressions from goodname.cfg to beautify the name

ida_typeinf.tinfo_t.get_nth_arg (method)
    get_nth_arg(self, n) -> tinfo_t
    BT_FUNC or BT_PTR BT_FUNC: Get type of n-th arg (-1 means return type, see
    get_rettype())
    
    @param n: (C++: int)

ida_typeinf.tinfo_t.get_numbered_type (method)
    get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
    Create a tinfo_t object for an existing ordinal type.
    
    @param til: (C++: const til_t *) type library to use
    @param ordinal: (C++: uint32) number of the type to link to
    @param decl_type: (C++: type_t) if the reference was explicitly specified with the type tag
                      (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may specify it. the kernel
                      will accept only the specified tag after resolving the type.
                      If the resolved type does not correspond to the explicitly
                      specified tag, the type will be considered as undefined
    @param resolve: (C++: bool) true: immediately resolve the type and return success code

ida_typeinf.tinfo_t.get_onemember_type (method)
    get_onemember_type(self) -> tinfo_t
    For objects consisting of one member entirely: return type of the member.

ida_typeinf.tinfo_t.get_ordinal (method)
    get_ordinal(self) -> uint32
    Get type ordinal (only if the type was created as a numbered type, 0 if none)

ida_typeinf.tinfo_t.get_pointed_object (method)
    get_pointed_object(self) -> tinfo_t

ida_typeinf.tinfo_t.get_ptr_details (method)
    get_ptr_details(self, pi) -> bool
    Get the pointer info.
    
    @param pi: (C++: ptr_type_data_t *)

ida_typeinf.tinfo_t.get_ptrarr_object (method)
    get_ptrarr_object(self) -> tinfo_t
    BT_PTR & BT_ARRAY: get the pointed object or array element. If the current type
    is not a pointer or array, return empty type info.

ida_typeinf.tinfo_t.get_ptrarr_objsize (method)
    get_ptrarr_objsize(self) -> int
    BT_PTR & BT_ARRAY: get size of pointed object or array element. On error returns
    -1

ida_typeinf.tinfo_t.get_realtype (method)
    get_realtype(self, full=False) -> type_t
    Get the resolved base type. Deserialization options:
    * if full=true, the referenced type will be deserialized fully, this may not
    always be desirable (slows down things)
    * if full=false, we just return the base type, the referenced type will be
    resolved again later if necessary (this may lead to multiple resolvings of the
    same type) imho full=false is a better approach because it does not perform
    unnecessary actions just in case. however, in some cases the caller knows that
    it is very likely that full type info will be required. in those cases full=true
    makes sense
    
    @param full: (C++: bool)

ida_typeinf.tinfo_t.get_rettype (method)
    get_rettype(self) -> tinfo_t
    BT_FUNC or BT_PTR BT_FUNC: Get the function's return type

ida_typeinf.tinfo_t.get_sign (method)
    get_sign(self) -> type_sign_t
    Get type sign.

ida_typeinf.tinfo_t.get_size (method)
    get_size(self, p_effalign=None, gts_code=0) -> size_t
    Get the type size in bytes.
    
    @param p_effalign: (C++: uint32 *) buffer for the alignment value
    @param gts_code: (C++: int) combination of GTS_... constants
    @return: BADSIZE in case of problems

ida_typeinf.tinfo_t.get_stock (method)
    get_stock(id) -> tinfo_t
    Get stock type information. This function can be used to get tinfo_t for some
    common types. The same tinfo_t will be returned for the same id, thus saving
    memory and increasing the speed Please note that retrieving the STI_SIZE_T or
    STI_SSIZE_T stock type, will also have the side-effect of adding that type to
    the 'idati' TIL, under the well-known name 'size_t' or 'ssize_t' (respectively).
    The same is valid for STI_COMPLEX64 and STI_COMPLEX64 stock types with names
    'complex64_t' and 'complex128_t' (respectively).
    
    @param id: (C++: stock_type_id_t) enum stock_type_id_t

ida_typeinf.tinfo_t.get_tid (method)
    get_tid(self) -> tid_t
    Get the type tid Each type in the local type library has a so-called `tid`
    associated with it. The tid is used to collect xrefs to the type. The tid is
    created when the type is created in the local type library and does not change
    afterwards. It can be passed to xref-related functions instead of the address.
    
    @return: tid or BADADDR
    @note: types that do not come from a type library (that exist only in the
           memory) can not have a tid.

ida_typeinf.tinfo_t.get_til (method)
    get_til(self) -> til_t
    Get the type library for tinfo_t.

ida_typeinf.tinfo_t.get_type_by_edm_name (method)
    get_type_by_edm_name(self, mname, til=None) -> bool
    Retrieve enum tinfo using enum member name
    
    @param mname: (C++: const char *) enum type member name
    @param til: (C++: til_t *) type library
    @return: success If the function fails, THIS object becomes empty.

ida_typeinf.tinfo_t.get_type_by_tid (method)
    get_type_by_tid(self, tid) -> bool
    
    @param tid: tid_t

ida_typeinf.tinfo_t.get_type_cmt (method)
    get_type_cmt(self) -> int
    Get type comment
    
    @return: 0-failed, 1-returned regular comment, 2-returned repeatable comment

ida_typeinf.tinfo_t.get_type_name (method)
    get_type_name(self) -> bool
    Does a type refer to a name?. If yes, fill the provided buffer with the type
    name and return true. Names are returned for numbered types too: either a user-
    defined nice name or, if a user-provided name does not exist, an ordinal name
    (like #xx, see create_numbered_type_name()).

ida_typeinf.tinfo_t.get_type_rptcmt (method)
    get_type_rptcmt(self) -> bool
    Get type comment only if it is repeatable.

ida_typeinf.tinfo_t.get_udm_by_tid (method)
    get_udm_by_tid(self, udm, tid) -> ssize_t
    Retrive tinfo using type TID or struct/enum member MID
    
    @param udm: (C++: udm_t *) [out]: place to save the found member to, may be nullptr
    @param tid: (C++: tid_t) tid can denote a type tid or a member tid.
    @return: if a member tid was specified, returns the member index, otherwise
             returns -1. if the function fails, THIS object becomes empty.

ida_typeinf.tinfo_t.get_udm_tid (method)
    get_udm_tid(self, idx) -> tid_t
    Get udt member TID
    
    @param idx: (C++: size_t) the index of udt the member
    @return: tid or BADADDR The tid is used to collect xrefs to the member, it can
             be passed to xref-related functions instead of the address.

ida_typeinf.tinfo_t.get_udt_details (method)
    get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
    Get the udt specific info.
    
    @param udt: (C++: udt_type_data_t *)
    @param gtd: (C++: gtd_udt_t) enum gtd_udt_t

ida_typeinf.tinfo_t.get_udt_nmembers (method)
    get_udt_nmembers(self) -> int
    Get number of udt members. -1-error.

ida_typeinf.tinfo_t.get_unpadded_size (method)
    get_unpadded_size(self) -> size_t
    Get the type size in bytes without the final padding, in bytes. For some UDTs
    get_unpadded_size() != get_size()

ida_typeinf.tinfo_t.has_details (method)
    has_details(self) -> bool
    Does this type refer to a nontrivial type?

ida_typeinf.tinfo_t.has_union (method)
    has_union(self) -> bool
    Has a member of type "union"?

ida_typeinf.tinfo_t.has_vftable (method)
    has_vftable(self) -> bool
    Has a vftable?

ida_typeinf.tinfo_t.is_aliased (method)
    is_aliased(self) -> bool

ida_typeinf.tinfo_t.is_anonymous_udt (method)
    is_anonymous_udt(self) -> bool
    Is an anonymous struct/union? We assume that types with names are anonymous if
    the name starts with $

ida_typeinf.tinfo_t.is_arithmetic (method)
    is_arithmetic(self) -> bool
    is_type_arithmetic(get_realtype())

ida_typeinf.tinfo_t.is_array (method)
    is_array(self) -> bool
    is_type_array(get_realtype())

ida_typeinf.tinfo_t.is_bitfield (method)
    is_bitfield(self) -> bool
    is_type_bitfld(get_realtype())

ida_typeinf.tinfo_t.is_bitmask_enum (method)
    is_bitmask_enum(self) -> bool
    Is bitmask enum?
    
    @return: true for bitmask enum and false in other cases
             enum_type_data_t::is_bf()

ida_typeinf.tinfo_t.is_bool (method)
    is_bool(self) -> bool
    is_type_bool(get_realtype())

ida_typeinf.tinfo_t.is_castable_to (method)
    is_castable_to(self, target) -> bool
    
    @param target: tinfo_t const &

ida_typeinf.tinfo_t.is_char (method)
    is_char(self) -> bool
    is_type_char(get_realtype())

ida_typeinf.tinfo_t.is_complex (method)
    is_complex(self) -> bool
    is_type_complex(get_realtype())

ida_typeinf.tinfo_t.is_const (method)
    is_const(self) -> bool
    is_type_const(get_realtype())

ida_typeinf.tinfo_t.is_correct (method)
    is_correct(self) -> bool
    Is the type object correct?. It is possible to create incorrect types. For
    example, we can define a function that returns an enum and then delete the enum
    type. If this function returns false, the type should not be used in
    disassembly. Please note that this function does not verify all involved types:
    for example, pointers to undefined types are permitted.

ida_typeinf.tinfo_t.is_decl_array (method)
    is_decl_array(self) -> bool
    is_type_array(get_decltype())

ida_typeinf.tinfo_t.is_decl_bitfield (method)
    is_decl_bitfield(self) -> bool
    is_type_bitfld(get_decltype())

ida_typeinf.tinfo_t.is_decl_bool (method)
    is_decl_bool(self) -> bool
    is_type_bool(get_decltype())

ida_typeinf.tinfo_t.is_decl_char (method)
    is_decl_char(self) -> bool
    is_type_char(get_decltype())

ida_typeinf.tinfo_t.is_decl_complex (method)
    is_decl_complex(self) -> bool
    is_type_complex(get_decltype())

ida_typeinf.tinfo_t.is_decl_const (method)
    is_decl_const(self) -> bool
    is_type_const(get_decltype())

ida_typeinf.tinfo_t.is_decl_double (method)
    is_decl_double(self) -> bool
    is_type_double(get_decltype())

ida_typeinf.tinfo_t.is_decl_enum (method)
    is_decl_enum(self) -> bool
    is_type_enum(get_decltype())

ida_typeinf.tinfo_t.is_decl_float (method)
    is_decl_float(self) -> bool
    is_type_float(get_decltype())

ida_typeinf.tinfo_t.is_decl_floating (method)
    is_decl_floating(self) -> bool
    is_type_floating(get_decltype())

ida_typeinf.tinfo_t.is_decl_func (method)
    is_decl_func(self) -> bool
    is_type_func(get_decltype())

ida_typeinf.tinfo_t.is_decl_int (method)
    is_decl_int(self) -> bool
    is_type_int(get_decltype())

ida_typeinf.tinfo_t.is_decl_int128 (method)
    is_decl_int128(self) -> bool
    is_type_int128(get_decltype())

ida_typeinf.tinfo_t.is_decl_int16 (method)
    is_decl_int16(self) -> bool
    is_type_int16(get_decltype())

ida_typeinf.tinfo_t.is_decl_int32 (method)
    is_decl_int32(self) -> bool
    is_type_int32(get_decltype())

ida_typeinf.tinfo_t.is_decl_int64 (method)
    is_decl_int64(self) -> bool
    is_type_int64(get_decltype())

ida_typeinf.tinfo_t.is_decl_last (method)
    is_decl_last(self) -> bool
    is_typeid_last(get_decltype())

ida_typeinf.tinfo_t.is_decl_ldouble (method)
    is_decl_ldouble(self) -> bool
    is_type_ldouble(get_decltype())

ida_typeinf.tinfo_t.is_decl_paf (method)
    is_decl_paf(self) -> bool
    is_type_paf(get_decltype())

ida_typeinf.tinfo_t.is_decl_partial (method)
    is_decl_partial(self) -> bool
    is_type_partial(get_decltype())

ida_typeinf.tinfo_t.is_decl_ptr (method)
    is_decl_ptr(self) -> bool
    is_type_ptr(get_decltype())

ida_typeinf.tinfo_t.is_decl_struct (method)
    is_decl_struct(self) -> bool
    is_type_struct(get_decltype())

ida_typeinf.tinfo_t.is_decl_sue (method)
    is_decl_sue(self) -> bool
    is_type_sue(get_decltype())

ida_typeinf.tinfo_t.is_decl_tbyte (method)
    is_decl_tbyte(self) -> bool
    is_type_tbyte(get_decltype())

ida_typeinf.tinfo_t.is_decl_typedef (method)
    is_decl_typedef(self) -> bool
    is_type_typedef(get_decltype())

ida_typeinf.tinfo_t.is_decl_uchar (method)
    is_decl_uchar(self) -> bool
    is_type_uchar(get_decltype())

ida_typeinf.tinfo_t.is_decl_udt (method)
    is_decl_udt(self) -> bool
    is_type_struni(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint (method)
    is_decl_uint(self) -> bool
    is_type_uint(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint128 (method)
    is_decl_uint128(self) -> bool
    is_type_uint128(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint16 (method)
    is_decl_uint16(self) -> bool
    is_type_uint16(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint32 (method)
    is_decl_uint32(self) -> bool
    is_type_uint32(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint64 (method)
    is_decl_uint64(self) -> bool
    is_type_uint64(get_decltype())

ida_typeinf.tinfo_t.is_decl_union (method)
    is_decl_union(self) -> bool
    is_type_union(get_decltype())

ida_typeinf.tinfo_t.is_decl_unknown (method)
    is_decl_unknown(self) -> bool
    is_type_unknown(get_decltype())

ida_typeinf.tinfo_t.is_decl_void (method)
    is_decl_void(self) -> bool
    is_type_void(get_decltype())

ida_typeinf.tinfo_t.is_decl_volatile (method)
    is_decl_volatile(self) -> bool
    is_type_volatile(get_decltype())

ida_typeinf.tinfo_t.is_double (method)
    is_double(self) -> bool
    is_type_double(get_realtype())

ida_typeinf.tinfo_t.is_empty_udt (method)
    is_empty_udt(self) -> bool
    Is an empty struct/union? (has no fields)

ida_typeinf.tinfo_t.is_enum (method)
    is_enum(self) -> bool
    is_type_enum(get_realtype())

ida_typeinf.tinfo_t.is_ext_arithmetic (method)
    is_ext_arithmetic(self) -> bool
    is_type_ext_arithmetic(get_realtype())

ida_typeinf.tinfo_t.is_ext_integral (method)
    is_ext_integral(self) -> bool
    is_type_ext_integral(get_realtype())

ida_typeinf.tinfo_t.is_float (method)
    is_float(self) -> bool
    is_type_float(get_realtype())

ida_typeinf.tinfo_t.is_floating (method)
    is_floating(self) -> bool
    is_type_floating(get_realtype())

ida_typeinf.tinfo_t.is_forward_decl (method)
    is_forward_decl(self) -> bool
    Is this a forward declaration?. Forward declarations are placeholders: the type
    definition does not exist

ida_typeinf.tinfo_t.is_forward_enum (method)
    is_forward_enum(self) -> bool

ida_typeinf.tinfo_t.is_forward_struct (method)
    is_forward_struct(self) -> bool

ida_typeinf.tinfo_t.is_forward_union (method)
    is_forward_union(self) -> bool

ida_typeinf.tinfo_t.is_from_subtil (method)
    is_from_subtil(self) -> bool
    Was the named type found in some base type library (not the top level type
    library)?. If yes, it usually means that the type comes from some loaded type
    library, not the local type library for the database

ida_typeinf.tinfo_t.is_func (method)
    is_func(self) -> bool
    is_type_func(get_realtype())

ida_typeinf.tinfo_t.is_funcptr (method)
    is_funcptr(self) -> bool
    Is this pointer to a function?

ida_typeinf.tinfo_t.is_high_func (method)
    is_high_func(self) -> bool

ida_typeinf.tinfo_t.is_int (method)
    is_int(self) -> bool
    is_type_int(get_realtype())

ida_typeinf.tinfo_t.is_int128 (method)
    is_int128(self) -> bool
    is_type_int128(get_realtype())

ida_typeinf.tinfo_t.is_int16 (method)
    is_int16(self) -> bool
    is_type_int16(get_realtype())

ida_typeinf.tinfo_t.is_int32 (method)
    is_int32(self) -> bool
    is_type_int32(get_realtype())

ida_typeinf.tinfo_t.is_int64 (method)
    is_int64(self) -> bool
    is_type_int64(get_realtype())

ida_typeinf.tinfo_t.is_integral (method)
    is_integral(self) -> bool
    is_type_integral(get_realtype())

ida_typeinf.tinfo_t.is_ldouble (method)
    is_ldouble(self) -> bool
    is_type_ldouble(get_realtype())

ida_typeinf.tinfo_t.is_manually_castable_to (method)
    is_manually_castable_to(self, target) -> bool
    
    @param target: tinfo_t const &

ida_typeinf.tinfo_t.is_one_fpval (method)
    is_one_fpval(self) -> bool
    Floating value or an object consisting of one floating member entirely.

ida_typeinf.tinfo_t.is_paf (method)
    is_paf(self) -> bool
    is_type_paf(get_realtype())

ida_typeinf.tinfo_t.is_partial (method)
    is_partial(self) -> bool
    is_type_partial(get_realtype())

ida_typeinf.tinfo_t.is_ptr (method)
    is_ptr(self) -> bool
    is_type_ptr(get_realtype())

ida_typeinf.tinfo_t.is_ptr_or_array (method)
    is_ptr_or_array(self) -> bool
    is_type_ptr_or_array(get_realtype())

ida_typeinf.tinfo_t.is_purging_cc (method)
    is_purging_cc(self) -> bool
    is_purging_cc(get_cc())

ida_typeinf.tinfo_t.is_pvoid (method)
    is_pvoid(self) -> bool
    Is "void *"?. This function does not check the pointer attributes and type
    modifiers.

ida_typeinf.tinfo_t.is_scalar (method)
    is_scalar(self) -> bool
    Does the type represent a single number?

ida_typeinf.tinfo_t.is_shifted_ptr (method)
    is_shifted_ptr(self) -> bool
    Is a shifted pointer?

ida_typeinf.tinfo_t.is_signed (method)
    is_signed(self) -> bool
    Is this a signed type?

ida_typeinf.tinfo_t.is_small_udt (method)
    is_small_udt(self) -> bool
    Is a small udt? (can fit a register or a pair of registers)

ida_typeinf.tinfo_t.is_sse_type (method)
    is_sse_type(self) -> bool
    Is a SSE vector type?

ida_typeinf.tinfo_t.is_struct (method)
    is_struct(self) -> bool
    is_type_struct(get_realtype())

ida_typeinf.tinfo_t.is_sue (method)
    is_sue(self) -> bool
    is_type_sue(get_realtype())

ida_typeinf.tinfo_t.is_tbyte (method)
    is_tbyte(self) -> bool
    is_type_tbyte(get_realtype())

ida_typeinf.tinfo_t.is_typedef (method)
    is_typedef(self) -> bool
    Is this a typedef?. This function will return true for a reference to a local
    type that is declared as a typedef.

ida_typeinf.tinfo_t.is_typeref (method)
    is_typeref(self) -> bool
    Is this type a type reference?.

ida_typeinf.tinfo_t.is_uchar (method)
    is_uchar(self) -> bool
    is_type_uchar(get_realtype())

ida_typeinf.tinfo_t.is_udt (method)
    is_udt(self) -> bool
    is_type_struni(get_realtype())

ida_typeinf.tinfo_t.is_uint (method)
    is_uint(self) -> bool
    is_type_uint(get_realtype())

ida_typeinf.tinfo_t.is_uint128 (method)
    is_uint128(self) -> bool
    is_type_uint128(get_realtype())

ida_typeinf.tinfo_t.is_uint16 (method)
    is_uint16(self) -> bool
    is_type_uint16(get_realtype())

ida_typeinf.tinfo_t.is_uint32 (method)
    is_uint32(self) -> bool
    is_type_uint32(get_realtype())

ida_typeinf.tinfo_t.is_uint64 (method)
    is_uint64(self) -> bool
    is_type_uint64(get_realtype())

ida_typeinf.tinfo_t.is_union (method)
    is_union(self) -> bool
    is_type_union(get_realtype())

ida_typeinf.tinfo_t.is_unknown (method)
    is_unknown(self) -> bool
    is_type_unknown(get_realtype())

ida_typeinf.tinfo_t.is_unsigned (method)
    is_unsigned(self) -> bool
    Is this an unsigned type?

ida_typeinf.tinfo_t.is_user_cc (method)
    is_user_cc(self) -> bool
    is_user_cc(get_cc())

ida_typeinf.tinfo_t.is_vararg_cc (method)
    is_vararg_cc(self) -> bool
    is_vararg_cc(get_cc())

ida_typeinf.tinfo_t.is_varmember (method)
    is_varmember(self) -> bool
    Can the type be of a variable struct member? This function checks for:
    is_array() && array.nelems==0 Such a member can be only the very last member of
    a structure

ida_typeinf.tinfo_t.is_varstruct (method)
    is_varstruct(self) -> bool
    Is a variable-size structure?

ida_typeinf.tinfo_t.is_vftable (method)
    is_vftable(self) -> bool
    Is a vftable type?

ida_typeinf.tinfo_t.is_void (method)
    is_void(self) -> bool
    is_type_void(get_realtype())

ida_typeinf.tinfo_t.is_volatile (method)
    is_volatile(self) -> bool
    is_type_volatile(get_realtype())

ida_typeinf.tinfo_t.is_well_defined (method)
    is_well_defined(self) -> bool
    !(empty()) && !(is_decl_partial())

ida_typeinf.tinfo_t.parse (method)
    parse(self, decl, til=None, pt_flags=0) -> bool
    Convenience function to parse a string with a type declaration
    
    @param decl: (C++: const char *) a type declaration
    @param til: (C++: til_t *) type library to use
    @param pt_flags: (C++: int) combination of Type parsing flags bits

ida_typeinf.tinfo_t.present (method)
    present(self) -> bool
    Is the type really present? (not a reference to a missing type, for example)

ida_typeinf.tinfo_t.read_bitfield_value (method)
    read_bitfield_value(self, v, bitoff) -> uint64
    
    @param v: uint64
    @param bitoff: int

ida_typeinf.tinfo_t.remove_ptr_or_array (method)
    remove_ptr_or_array(self) -> bool
    Replace the current type with the ptr obj or array element. This function
    performs one of the following conversions:
    * type[] => type
    * type* => type If the conversion is performed successfully, return true

ida_typeinf.tinfo_t.rename_edm (method)
    rename_edm(self, idx, name, etf_flags=0) -> tinfo_code_t
    Rename a enum member
    
    @param idx: (C++: size_t) index in edmvec_t
    @param name: (C++: const char *) new name
    @param etf_flags: (C++: uint) etf_flag_t ETF_FORCENAME may be used in case of
                      TERR_ALIEN_NAME
    @note: ETF_NO_SAVE is ignored

ida_typeinf.tinfo_t.rename_type (method)
    rename_type(self, name, ntf_flags=0) -> tinfo_code_t
    Rename a type
    
    @param name: (C++: const char *) new type name
    @param ntf_flags: (C++: int) Flags for named types
    @note: The change is saved immediately

ida_typeinf.tinfo_t.rename_udm (method)
    rename_udm(self, index, name, etf_flags=0) -> tinfo_code_t
    Rename a structure/union member. The new name must be unique.
    @note: ETF_NO_SAVE is ignored
    
    @param index: (C++: size_t)
    @param name: (C++: const char *) char const *
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.requires_qualifier (method)
    requires_qualifier(self, name, offset) -> bool
    Requires full qualifier? (name is not unique)
    
    @param name: (C++: const char *) field name
    @param offset: (C++: uint64) field offset in bits
    @return: if the name is not unique, returns true

ida_typeinf.tinfo_t.save_type (method)
    save_type(self, ntf_flags=0x0001|0x0004) -> tinfo_code_t
    
    @param ntf_flags: int

ida_typeinf.tinfo_t.serialize (method)
    serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> (bytes, NoneType, NoneType), (bytes, bytes, NoneType)
    Serialize tinfo_t object into a type string.
    
    @param sudt_flags: (C++: int)

ida_typeinf.tinfo_t.set_attr (method)
    set_attr(self, ta, may_overwrite=True) -> bool
    Set a type attribute. If necessary, a new typid will be created.
    
    @param ta: (C++: const type_attr_t &) type_attr_t const &
    @param may_overwrite: (C++: bool)

ida_typeinf.tinfo_t.set_attrs (method)
    set_attrs(self, tav) -> bool
    Set type attributes. If necessary, a new typid will be created. this function
    modifies tav! (returns old attributes, if any)
    
    @param tav: (C++: type_attrs_t *)
    @return: false: bad attributes

ida_typeinf.tinfo_t.set_const (method)
    set_const(self)

ida_typeinf.tinfo_t.set_declalign (method)
    set_declalign(self, declalign) -> bool
    
    @param declalign: uchar

ida_typeinf.tinfo_t.set_edm_cmt (method)
    set_edm_cmt(self, idx, cmt, etf_flags=0) -> tinfo_code_t
    Set a comment for an enum member. Such comments are always considered as
    repeatable.
    
    @param idx: (C++: size_t) index in edmvec_t
    @param cmt: (C++: const char *) comment
    @param etf_flags: (C++: uint) etf_flag_t

ida_typeinf.tinfo_t.set_enum_is_bitmask (method)
    set_enum_is_bitmask(self, stance=ENUMBM_ON, etf_flags=0) -> tinfo_code_t
    
    @param stance: enum tinfo_t::bitmask_cvt_stance_t
    @param etf_flags: uint

ida_typeinf.tinfo_t.set_enum_repr (method)
    set_enum_repr(self, repr, etf_flags=0) -> tinfo_code_t
    Set the representation of enum members.
    
    @param repr: (C++: const value_repr_t &) value_repr_t
    @param etf_flags: (C++: uint) etf_flag_t

ida_typeinf.tinfo_t.set_enum_sign (method)
    set_enum_sign(self, sign, etf_flags=0) -> tinfo_code_t
    Set enum sign
    
    @param sign: (C++: type_sign_t)
    @param etf_flags: (C++: uint) etf_flag_t

ida_typeinf.tinfo_t.set_enum_width (method)
    set_enum_width(self, nbytes, etf_flags=0) -> tinfo_code_t
    Set the width of enum base type
    
    @param nbytes: (C++: int) width of enum base type, allowed values: 0
                   (unspecified),1,2,4,8,16,32,64
    @param etf_flags: (C++: uint) etf_flag_t

ida_typeinf.tinfo_t.set_methods (method)
    set_methods(self, methods) -> bool
    
    @param BT_COMPLEX: set the list of member functions. This function consumes 'methods'
    (makes it empty).
    @return: false if this type is not a udt, or if the given list is empty

ida_typeinf.tinfo_t.set_modifiers (method)
    set_modifiers(self, mod)
    
    @param mod: type_t

ida_typeinf.tinfo_t.set_named_type (method)
    set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
    
    @param til: til_t *
    @param name: char const *
    @param ntf_flags: int

ida_typeinf.tinfo_t.set_numbered_type (method)
    set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
    
    @param til: til_t *
    @param ord: uint32
    @param ntf_flags: int
    @param name: char const *

ida_typeinf.tinfo_t.set_symbol_type (method)
    set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
    
    @param til: til_t *
    @param name: char const *
    @param ntf_flags: int

ida_typeinf.tinfo_t.set_type_alias (method)
    set_type_alias(self, dest_ord) -> bool
    Set type alias Redirects all references to source type to the destination type.
    This is equivalent to instantaneous replacement all references to srctype by
    dsttype.
    
    @param dest_ord: (C++: uint32)

ida_typeinf.tinfo_t.set_type_alignment (method)
    set_type_alignment(self, declalign, etf_flags=0) -> tinfo_code_t
    Set type alignment.
    
    @param declalign: (C++: uchar)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_type_cmt (method)
    set_type_cmt(self, cmt, is_regcmt=False, etf_flags=0) -> tinfo_code_t
    Set type comment This function works only for non-trivial types
    
    @param cmt: (C++: const char *) char const *
    @param is_regcmt: (C++: bool)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_udm_cmt (method)
    set_udm_cmt(self, index, cmt, is_regcmt=False, etf_flags=0) -> tinfo_code_t
    Set a comment for a structure/union member. A member may have just one comment,
    and it is either repeatable or regular.
    
    @param index: (C++: size_t)
    @param cmt: (C++: const char *) char const *
    @param is_regcmt: (C++: bool)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_udm_repr (method)
    set_udm_repr(self, index, repr, etf_flags=0) -> tinfo_code_t
    Set the representation of a structure/union member.
    
    @param index: (C++: size_t)
    @param repr: (C++: const value_repr_t &) value_repr_t const &
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_udm_type (method)
    set_udm_type(self, index, tif, etf_flags=0, repr=None) -> tinfo_code_t
    Set type of a structure/union member.
    
    @param index: (C++: size_t) member index in the udm array
    @param tif: (C++: const tinfo_t &) new type for the member
    @param etf_flags: (C++: uint) etf_flag_t
    @param repr: (C++: const value_repr_t *) new representation for the member (optional)
    @return: tinfo_code_t

ida_typeinf.tinfo_t.set_udt_alignment (method)
    set_udt_alignment(self, sda, etf_flags=0) -> tinfo_code_t
    Set declared structure alignment (sda) This alignment supersedes the alignment
    returned by get_declalign() and is really used when calculating the struct
    layout. However, the effective structure alignment may differ from `sda` because
    of packing. The type editing functions (they accept etf_flags) may overwrite
    this attribute.
    
    @param sda: (C++: int)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_udt_pack (method)
    set_udt_pack(self, pack, etf_flags=0) -> tinfo_code_t
    Set structure packing. The value controls how little a structure member
    alignment can be. Example: if pack=1, then it is possible to align a double to a
    byte. __attribute__((aligned(1))) double x; However, if pack=3, a double will be
    aligned to 8 (2**3) even if requested to be aligned to a byte. pack==0 will have
    the same effect. The type editing functions (they accept etf_flags) may
    overwrite this attribute.
    
    @param pack: (C++: int)
    @param etf_flags: (C++: uint)

ida_typeinf.tinfo_t.set_volatile (method)
    set_volatile(self)

ida_typeinf.tinfo_t.swap (method)
    swap(self, r)
    Assign this = r and r = this.
    
    @param r: (C++: tinfo_t &)

ida_typeinf.tinfo_t.write_bitfield_value (method)
    write_bitfield_value(self, dst, v, bitoff) -> uint64
    
    @param dst: uint64
    @param v: uint64
    @param bitoff: int

ida_typeinf.tinfo_t_get_stock (function)
    tinfo_t_get_stock(id) -> tinfo_t
    
    @param id: enum stock_type_id_t

ida_typeinf.tinfo_visitor_t (class)
    Proxy of C++ tinfo_visitor_t class.

ida_typeinf.tinfo_visitor_t.__disown__ (method)

ida_typeinf.tinfo_visitor_t.__init__ (method)
    __init__(self, s=0) -> tinfo_visitor_t
    
    @param s: int

ida_typeinf.tinfo_visitor_t.apply_to (method)
    apply_to(self, tif, out=None, name=None, cmt=None) -> int
    Call this function to initiate the traversal.
    
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param out: (C++: type_mods_t *)
    @param name: (C++: const char *) char const *
    @param cmt: (C++: const char *) char const *

ida_typeinf.tinfo_visitor_t.prune_now (method)
    prune_now(self)
    To refuse to visit children of the current type, use this:

ida_typeinf.tinfo_visitor_t.state (variable)
    tinfo visitor states

ida_typeinf.tinfo_visitor_t.visit_type (method)
    visit_type(self, out, tif, name, cmt) -> int
    Visit a subtype. this function must be implemented in the derived class. it may
    optionally fill out with the new type info. this can be used to modify types (in
    this case the 'out' argument of apply_to() may not be nullptr) return 0 to
    continue the traversal. return !=0 to stop the traversal.
    
    @param out: (C++: type_mods_t *)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param name: (C++: const char *) char const *
    @param cmt: (C++: const char *) char const *

ida_typeinf.type_attr_t (class)
    Proxy of C++ type_attr_t class.

ida_typeinf.type_attr_t.__ge__ (method)
    __ge__(self, r) -> bool
    
    @param r: type_attr_t const &

ida_typeinf.type_attr_t.__init__ (method)
    __init__(self) -> type_attr_t

ida_typeinf.type_attr_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: type_attr_t const &

ida_typeinf.type_attr_t.key (variable)
    one symbol keys are reserved to be used by the kernel the ones starting with an
    underscore are reserved too

ida_typeinf.type_attr_t.value (variable)
    attribute bytes

ida_typeinf.type_attrs_t (class)
    Proxy of C++ qvector< type_attr_t > class.

ida_typeinf.type_attrs_t.__getitem__ (method)
    __getitem__(self, i) -> type_attr_t
    
    @param i: size_t

ida_typeinf.type_attrs_t.__init__ (method)
    __init__(self) -> type_attrs_t
    __init__(self, x) -> type_attrs_t
    
    @param x: qvector< type_attr_t > const &

ida_typeinf.type_attrs_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.type_attrs_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: type_attr_t const &

ida_typeinf.type_attrs_t.at (method)
    at(self, _idx) -> type_attr_t
    
    @param _idx: size_t

ida_typeinf.type_attrs_t.begin (method)
    begin(self) -> type_attr_t

ida_typeinf.type_attrs_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.type_attrs_t.clear (method)
    clear(self)

ida_typeinf.type_attrs_t.empty (method)
    empty(self) -> bool

ida_typeinf.type_attrs_t.end (method)
    end(self) -> type_attr_t

ida_typeinf.type_attrs_t.erase (method)
    erase(self, it) -> type_attr_t
    
    @param it: qvector< type_attr_t >::iterator
    
    erase(self, first, last) -> type_attr_t
    
    @param first: qvector< type_attr_t >::iterator
    @param last: qvector< type_attr_t >::iterator

ida_typeinf.type_attrs_t.extract (method)
    extract(self) -> type_attr_t

ida_typeinf.type_attrs_t.grow (method)
    grow(self, x=type_attr_t())
    
    @param x: type_attr_t const &

ida_typeinf.type_attrs_t.inject (method)
    inject(self, s, len)
    
    @param s: type_attr_t *
    @param len: size_t

ida_typeinf.type_attrs_t.insert (method)
    insert(self, it, x) -> type_attr_t
    
    @param it: qvector< type_attr_t >::iterator
    @param x: type_attr_t const &

ida_typeinf.type_attrs_t.pop_back (method)
    pop_back(self)

ida_typeinf.type_attrs_t.push_back (method)
    push_back(self, x)
    
    @param x: type_attr_t const &
    
    push_back(self) -> type_attr_t

ida_typeinf.type_attrs_t.qclear (method)
    qclear(self)

ida_typeinf.type_attrs_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.type_attrs_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: type_attr_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.type_attrs_t.size (method)
    size(self) -> size_t

ida_typeinf.type_attrs_t.swap (method)
    swap(self, r)
    
    @param r: qvector< type_attr_t > &

ida_typeinf.type_attrs_t.truncate (method)
    truncate(self)

ida_typeinf.type_mods_t (class)
    Proxy of C++ type_mods_t class.

ida_typeinf.type_mods_t.__init__ (method)
    __init__(self) -> type_mods_t

ida_typeinf.type_mods_t.clear (method)
    clear(self)

ida_typeinf.type_mods_t.cmt (variable)
    comment for current type

ida_typeinf.type_mods_t.flags (variable)
    Type modification bits

ida_typeinf.type_mods_t.has_cmt (method)
    has_cmt(self) -> bool

ida_typeinf.type_mods_t.has_info (method)
    has_info(self) -> bool

ida_typeinf.type_mods_t.has_name (method)
    has_name(self) -> bool

ida_typeinf.type_mods_t.has_type (method)
    has_type(self) -> bool

ida_typeinf.type_mods_t.is_rptcmt (method)
    is_rptcmt(self) -> bool

ida_typeinf.type_mods_t.name (variable)
    current type name

ida_typeinf.type_mods_t.set_new_cmt (method)
    set_new_cmt(self, c, rptcmt)
    
    @param c: qstring const &
    @param rptcmt: bool

ida_typeinf.type_mods_t.set_new_name (method)
    set_new_name(self, n)
    
    @param n: qstring const &

ida_typeinf.type_mods_t.set_new_type (method)
    set_new_type(self, t)
    The visit_type() function may optionally save the modified type info. Use the
    following functions for that. The new name and comment will be applied only if
    the current tinfo element has storage for them.
    
    @param t: (C++: const tinfo_t &) tinfo_t const &

ida_typeinf.type_mods_t.type (variable)
    current type

ida_typeinf.type_signed (variable)
    signed type

ida_typeinf.type_unsigned (variable)
    unsigned type

ida_typeinf.typedef_type_data_t (class)
    Proxy of C++ typedef_type_data_t class.

ida_typeinf.typedef_type_data_t.__init__ (method)
    __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
    
    @param _til: til_t const *
    @param _name: char const *
    @param _resolve: bool
    
    __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
    
    @param _til: til_t const *
    @param ord: uint32
    @param _resolve: bool

ida_typeinf.typedef_type_data_t.is_ordref (variable)
    is reference by ordinal?

ida_typeinf.typedef_type_data_t.name (variable)
    is_ordref=false: target type name. we do not own this pointer!

ida_typeinf.typedef_type_data_t.ordinal (variable)
    is_ordref=true: type ordinal number

ida_typeinf.typedef_type_data_t.resolve (variable)
    should resolve immediately?

ida_typeinf.typedef_type_data_t.swap (method)
    swap(self, r)
    
    @param r: typedef_type_data_t &

ida_typeinf.typedef_type_data_t.til (variable)
    type library to use when resolving

ida_typeinf.udm_t (class)
    Proxy of C++ udm_t class.

ida_typeinf.udm_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: udm_t const &

ida_typeinf.udm_t.__init__ (method)
    __init__(self) -> udm_t

ida_typeinf.udm_t.__lt__ (method)
    __lt__(self, r) -> bool
    
    @param r: udm_t const &

ida_typeinf.udm_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: udm_t const &

ida_typeinf.udm_t.begin (method)
    begin(self) -> uint64

ida_typeinf.udm_t.can_be_dtor (method)
    can_be_dtor(self) -> bool

ida_typeinf.udm_t.can_rename (method)
    can_rename(self) -> bool

ida_typeinf.udm_t.clr_baseclass (method)
    clr_baseclass(self)

ida_typeinf.udm_t.clr_method (method)
    clr_method(self)

ida_typeinf.udm_t.clr_unaligned (method)
    clr_unaligned(self)

ida_typeinf.udm_t.clr_vftable (method)
    clr_vftable(self)

ida_typeinf.udm_t.clr_virtbase (method)
    clr_virtbase(self)

ida_typeinf.udm_t.cmt (variable)
    member comment

ida_typeinf.udm_t.effalign (variable)
    effective field alignment (in bytes)

ida_typeinf.udm_t.end (method)
    end(self) -> uint64

ida_typeinf.udm_t.fda (variable)
    field alignment (shift amount)

ida_typeinf.udm_t.is_anonymous_udm (method)
    is_anonymous_udm(self) -> bool

ida_typeinf.udm_t.is_baseclass (method)
    is_baseclass(self) -> bool

ida_typeinf.udm_t.is_bitfield (method)
    is_bitfield(self) -> bool

ida_typeinf.udm_t.is_gap (method)
    is_gap(self) -> bool

ida_typeinf.udm_t.is_method (method)
    is_method(self) -> bool

ida_typeinf.udm_t.is_regcmt (method)
    is_regcmt(self) -> bool

ida_typeinf.udm_t.is_unaligned (method)
    is_unaligned(self) -> bool

ida_typeinf.udm_t.is_vftable (method)
    is_vftable(self) -> bool

ida_typeinf.udm_t.is_virtbase (method)
    is_virtbase(self) -> bool

ida_typeinf.udm_t.is_zero_bitfield (method)
    is_zero_bitfield(self) -> bool

ida_typeinf.udm_t.make_gap (method)
    make_gap(self, byteoff, nbytes) -> bool
    
    @param byteoff: uval_t
    @param nbytes: uval_t

ida_typeinf.udm_t.name (variable)
    member name

ida_typeinf.udm_t.offset (variable)
    member offset in bits

ida_typeinf.udm_t.repr (variable)
    radix, refinfo, strpath, custom_id, strtype

ida_typeinf.udm_t.set_baseclass (method)
    set_baseclass(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.set_method (method)
    set_method(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.set_regcmt (method)
    set_regcmt(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.set_unaligned (method)
    set_unaligned(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.set_value_repr (method)
    set_value_repr(self, r)
    
    @param r: value_repr_t const &

ida_typeinf.udm_t.set_vftable (method)
    set_vftable(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.set_virtbase (method)
    set_virtbase(self, on=True)
    
    @param on: bool

ida_typeinf.udm_t.size (variable)
    size in bits

ida_typeinf.udm_t.swap (method)
    swap(self, r)
    
    @param r: udm_t &

ida_typeinf.udm_t.tafld_bits (variable)
    TAH bits.

ida_typeinf.udm_t.type (variable)
    member type

ida_typeinf.udm_t__make_gap (function)
    udm_t__make_gap(_this, byteoff, nbytes) -> bool
    
    @param _this: udm_t *
    @param byteoff: uval_t
    @param nbytes: uval_t

ida_typeinf.udt_type_data_t (class)
    Proxy of C++ udt_type_data_t class.

ida_typeinf.udt_type_data_t.__init__ (method)
    __init__(self) -> udt_type_data_t

ida_typeinf.udt_type_data_t.effalign (variable)
    effective structure alignment (in bytes)

ida_typeinf.udt_type_data_t.find_member (method)
    find_member(self, pattern_udm, strmem_flags) -> ssize_t
    
    @param pattern_udm: udm_t *
    @param strmem_flags: int
    
    find_member(self, name) -> ssize_t
    
    @param name: char const *
    
    find_member(self, bit_offset) -> ssize_t
    
    @param bit_offset: uint64

ida_typeinf.udt_type_data_t.get_best_fit_member (method)
    get_best_fit_member(self, disp) -> ssize_t
    Get member that is most likely referenced by the specified offset. Useful for
    offsets > sizeof(struct).
    
    @param disp: (C++: asize_t)

ida_typeinf.udt_type_data_t.is_cppobj (method)
    is_cppobj(self) -> bool

ida_typeinf.udt_type_data_t.is_last_baseclass (method)
    is_last_baseclass(self, idx) -> bool
    
    @param idx: size_t

ida_typeinf.udt_type_data_t.is_msstruct (method)
    is_msstruct(self) -> bool

ida_typeinf.udt_type_data_t.is_unaligned (method)
    is_unaligned(self) -> bool

ida_typeinf.udt_type_data_t.is_union (variable)
    is union or struct?

ida_typeinf.udt_type_data_t.is_vftable (method)
    is_vftable(self) -> bool

ida_typeinf.udt_type_data_t.pack (variable)
    #pragma pack() alignment (shift amount)

ida_typeinf.udt_type_data_t.sda (variable)
    declared structure alignment (shift amount+1). 0 - unspecified

ida_typeinf.udt_type_data_t.set_vftable (method)
    set_vftable(self, on=True)
    
    @param on: bool

ida_typeinf.udt_type_data_t.swap (method)
    swap(self, r)
    
    @param r: udt_type_data_t &

ida_typeinf.udt_type_data_t.taudt_bits (variable)
    TA... and TAUDT... bits.

ida_typeinf.udt_type_data_t.total_size (variable)
    total structure size in bytes

ida_typeinf.udt_type_data_t.unpadded_size (variable)
    unpadded structure size in bytes

ida_typeinf.udt_type_data_t.version (variable)
    version of udt_type_data_t

ida_typeinf.udt_type_data_t__find_member (function)
    udt_type_data_t__find_member(_this, udm, strmem_flags) -> ssize_t
    
    @param _this: udt_type_data_t const *
    @param udm: udm_t *
    @param strmem_flags: int

ida_typeinf.udt_type_data_t__get_best_fit_member (function)
    udt_type_data_t__get_best_fit_member(_this, disp) -> ssize_t
    
    @param _this: udt_type_data_t const *
    @param disp: asize_t

ida_typeinf.udtmembervec_t (class)
    Proxy of C++ udtmembervec_t class.

ida_typeinf.udtmembervec_t.__init__ (method)
    __init__(self) -> udtmembervec_t

ida_typeinf.udtmembervec_template_t (class)
    Proxy of C++ qvector< udm_t > class.

ida_typeinf.udtmembervec_template_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< udm_t > const &

ida_typeinf.udtmembervec_template_t.__getitem__ (method)
    __getitem__(self, i) -> udm_t
    
    @param i: size_t

ida_typeinf.udtmembervec_template_t.__init__ (method)
    __init__(self) -> udtmembervec_template_t
    __init__(self, x) -> udtmembervec_template_t
    
    @param x: qvector< udm_t > const &

ida_typeinf.udtmembervec_template_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.udtmembervec_template_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< udm_t > const &

ida_typeinf.udtmembervec_template_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: udm_t const &

ida_typeinf.udtmembervec_template_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: udm_t const &

ida_typeinf.udtmembervec_template_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: udm_t const &

ida_typeinf.udtmembervec_template_t.at (method)
    at(self, _idx) -> udm_t
    
    @param _idx: size_t

ida_typeinf.udtmembervec_template_t.begin (method)
    begin(self) -> udm_t

ida_typeinf.udtmembervec_template_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.udtmembervec_template_t.clear (method)
    clear(self)

ida_typeinf.udtmembervec_template_t.empty (method)
    empty(self) -> bool

ida_typeinf.udtmembervec_template_t.end (method)
    end(self) -> udm_t

ida_typeinf.udtmembervec_template_t.erase (method)
    erase(self, it) -> udm_t
    
    @param it: qvector< udm_t >::iterator
    
    erase(self, first, last) -> udm_t
    
    @param first: qvector< udm_t >::iterator
    @param last: qvector< udm_t >::iterator

ida_typeinf.udtmembervec_template_t.extract (method)
    extract(self) -> udm_t

ida_typeinf.udtmembervec_template_t.find (method)
    find(self, x) -> udm_t
    
    @param x: udm_t const &

ida_typeinf.udtmembervec_template_t.grow (method)
    grow(self, x=udm_t())
    
    @param x: udm_t const &

ida_typeinf.udtmembervec_template_t.has (method)
    has(self, x) -> bool
    
    @param x: udm_t const &

ida_typeinf.udtmembervec_template_t.inject (method)
    inject(self, s, len)
    
    @param s: udm_t *
    @param len: size_t

ida_typeinf.udtmembervec_template_t.insert (method)
    insert(self, it, x) -> udm_t
    
    @param it: qvector< udm_t >::iterator
    @param x: udm_t const &

ida_typeinf.udtmembervec_template_t.pop_back (method)
    pop_back(self)

ida_typeinf.udtmembervec_template_t.push_back (method)
    push_back(self, x)
    
    @param x: udm_t const &
    
    push_back(self) -> udm_t

ida_typeinf.udtmembervec_template_t.qclear (method)
    qclear(self)

ida_typeinf.udtmembervec_template_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.udtmembervec_template_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: udm_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.udtmembervec_template_t.size (method)
    size(self) -> size_t

ida_typeinf.udtmembervec_template_t.swap (method)
    swap(self, r)
    
    @param r: qvector< udm_t > &

ida_typeinf.udtmembervec_template_t.truncate (method)
    truncate(self)

ida_typeinf.unpack_idcobj_from_bv (function)
    unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
    Read a typed idc object from the byte vector.
    
    @param obj: (C++: idc_value_t *)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param bytes: (C++: const bytevec_t &) bytevec_t const &
    @param pio_flags: (C++: int)

ida_typeinf.unpack_idcobj_from_idb (function)
    unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
    Collection of register objects.
    
    Read a typed idc object from the database
    
    @param obj: (C++: idc_value_t *)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param ea: (C++: ea_t)
    @param off0: (C++: const bytevec_t *) bytevec_t const *
    @param pio_flags: (C++: int)

ida_typeinf.unpack_object_from_bv (function)
    unpack_object_from_bv(ti, type, fields, bytes, pio_flags=0) -> PyObject *
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:     - tuple(0, err) on failure
        - tuple(1, obj) on success

ida_typeinf.unpack_object_from_idb (function)
    unpack_object_from_idb(ti, type, fields, ea, pio_flags=0) -> PyObject *
    
    @param ti: til_t *
    @param type: type_t const *
    @param fields: p_list const *
    @param ea: ea_t
    @param pio_flags: int

ida_typeinf.use_golang_cc (function)
    use_golang_cc() -> bool
    is GOLANG calling convention used by default?

ida_typeinf.valstr_t (class)
    Proxy of C++ valstr_t class.

ida_typeinf.valstr_t.__init__ (method)
    __init__(self) -> valstr_t

ida_typeinf.valstr_t.info (variable)
    additional info

ida_typeinf.valstr_t.length (variable)
    length if printed on one line

ida_typeinf.valstr_t.members (variable)
    strings for members, each member separately

ida_typeinf.valstr_t.oneline (variable)
    result if printed on one line in UTF-8 encoding

ida_typeinf.valstr_t.props (variable)
    temporary properties, used internally

ida_typeinf.valstrs_t (class)
    Proxy of C++ valstrs_t class.

ida_typeinf.valstrs_t.__init__ (method)
    __init__(self) -> valstrs_t

ida_typeinf.valstrvec_t (class)
    Proxy of C++ qvector< valstr_t > class.

ida_typeinf.valstrvec_t.__getitem__ (method)
    __getitem__(self, i) -> valstr_t
    
    @param i: size_t

ida_typeinf.valstrvec_t.__init__ (method)
    __init__(self) -> valstrvec_t
    __init__(self, x) -> valstrvec_t
    
    @param x: qvector< valstr_t > const &

ida_typeinf.valstrvec_t.__len__ (method)
    __len__(self) -> size_t

ida_typeinf.valstrvec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: valstr_t const &

ida_typeinf.valstrvec_t.at (method)
    at(self, _idx) -> valstr_t
    
    @param _idx: size_t

ida_typeinf.valstrvec_t.begin (method)
    begin(self) -> valstr_t

ida_typeinf.valstrvec_t.capacity (method)
    capacity(self) -> size_t

ida_typeinf.valstrvec_t.clear (method)
    clear(self)

ida_typeinf.valstrvec_t.empty (method)
    empty(self) -> bool

ida_typeinf.valstrvec_t.end (method)
    end(self) -> valstr_t

ida_typeinf.valstrvec_t.erase (method)
    erase(self, it) -> valstr_t
    
    @param it: qvector< valstr_t >::iterator
    
    erase(self, first, last) -> valstr_t
    
    @param first: qvector< valstr_t >::iterator
    @param last: qvector< valstr_t >::iterator

ida_typeinf.valstrvec_t.extract (method)
    extract(self) -> valstr_t

ida_typeinf.valstrvec_t.grow (method)
    grow(self, x=valstr_t())
    
    @param x: valstr_t const &

ida_typeinf.valstrvec_t.inject (method)
    inject(self, s, len)
    
    @param s: valstr_t *
    @param len: size_t

ida_typeinf.valstrvec_t.insert (method)
    insert(self, it, x) -> valstr_t
    
    @param it: qvector< valstr_t >::iterator
    @param x: valstr_t const &

ida_typeinf.valstrvec_t.pop_back (method)
    pop_back(self)

ida_typeinf.valstrvec_t.push_back (method)
    push_back(self, x)
    
    @param x: valstr_t const &
    
    push_back(self) -> valstr_t

ida_typeinf.valstrvec_t.qclear (method)
    qclear(self)

ida_typeinf.valstrvec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_typeinf.valstrvec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: valstr_t const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_typeinf.valstrvec_t.size (method)
    size(self) -> size_t

ida_typeinf.valstrvec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< valstr_t > &

ida_typeinf.valstrvec_t.truncate (method)
    truncate(self)

ida_typeinf.value_repr_t (class)
    Proxy of C++ value_repr_t class.

ida_typeinf.value_repr_t.__init__ (method)
    __init__(self) -> value_repr_t

ida_typeinf.value_repr_t.__str__ (method)
    __str__(self) -> qstring

ida_typeinf.value_repr_t._print (method)
    _print(self, colored=False) -> size_t
    
    Parameters
    ----------
    colored: bool

ida_typeinf.value_repr_t.ap (variable)
    FRB_TABFORM, AP_SIGNED is ignored, use FRB_SIGNED instead

ida_typeinf.value_repr_t.cd (variable)
    FRB_CUSTOM.

ida_typeinf.value_repr_t.clear (method)
    clear(self)

ida_typeinf.value_repr_t.delta (variable)
    FRB_STROFF.

ida_typeinf.value_repr_t.empty (method)
    empty(self) -> bool

ida_typeinf.value_repr_t.from_opinfo (method)
    from_opinfo(self, flags, afl, opinfo, _ap) -> bool
    
    @param flags: flags64_t
    @param afl: aflags_t
    @param opinfo: opinfo_t const *
    @param _ap: array_parameters_t const *

ida_typeinf.value_repr_t.get_vtype (method)
    get_vtype(self) -> uint64

ida_typeinf.value_repr_t.has_lzeroes (method)
    has_lzeroes(self) -> bool

ida_typeinf.value_repr_t.has_tabform (method)
    has_tabform(self) -> bool

ida_typeinf.value_repr_t.init_ap (method)
    init_ap(self, _ap)
    
    @param _ap: array_parameters_t *

ida_typeinf.value_repr_t.is_custom (method)
    is_custom(self) -> bool

ida_typeinf.value_repr_t.is_enum (method)
    is_enum(self) -> bool

ida_typeinf.value_repr_t.is_offset (method)
    is_offset(self) -> bool

ida_typeinf.value_repr_t.is_signed (method)
    is_signed(self) -> bool

ida_typeinf.value_repr_t.is_strlit (method)
    is_strlit(self) -> bool

ida_typeinf.value_repr_t.is_stroff (method)
    is_stroff(self) -> bool

ida_typeinf.value_repr_t.is_typref (method)
    is_typref(self) -> bool

ida_typeinf.value_repr_t.parse_value_repr (method)
    parse_value_repr(self, attr, target_type=BTF_STRUCT) -> bool
    
    @param attr: qstring const &
    @param target_type: type_t

ida_typeinf.value_repr_t.ri (variable)
    FRB_OFFSET.

ida_typeinf.value_repr_t.set_ap (method)
    set_ap(self, _ap)
    
    @param _ap: array_parameters_t const &

ida_typeinf.value_repr_t.set_lzeroes (method)
    set_lzeroes(self, on)
    
    @param on: bool

ida_typeinf.value_repr_t.set_signed (method)
    set_signed(self, on)
    
    @param on: bool

ida_typeinf.value_repr_t.set_tabform (method)
    set_tabform(self, on)
    
    @param on: bool

ida_typeinf.value_repr_t.set_vtype (method)
    set_vtype(self, vt)
    
    @param vt: uint64

ida_typeinf.value_repr_t.strtype (variable)
    FRB_STRLIT.

ida_typeinf.value_repr_t.swap (method)
    swap(self, r)
    
    @param r: value_repr_t &

ida_typeinf.value_repr_t.type_ordinal (variable)
    FRB_STROFF, FRB_ENUM.

ida_typeinf.value_repr_t__from_opinfo (function)
    value_repr_t__from_opinfo(_this, flags, afl, opinfo, ap) -> bool
    
    @param _this: value_repr_t *
    @param flags: flags64_t
    @param afl: aflags_t
    @param opinfo: opinfo_t const *
    @param ap: array_parameters_t const *

ida_typeinf.value_repr_t__print_ (function)
    value_repr_t__print_(_this, colored) -> str
    
    @param _this: value_repr_t const *
    @param colored: bool

ida_typeinf.verify_argloc (function)
    verify_argloc(vloc, size, gaps) -> int
    Verify argloc_t.
    
    @param vloc: (C++: const argloc_t &) argloc to verify
    @param size: (C++: int) total size of the variable
    @param gaps: (C++: const rangeset_t *) if not nullptr, specifies gaps in structure definition. these gaps
                 should not map to any argloc, but everything else must be covered
    @return: 0 if ok, otherwise an interr code.

ida_typeinf.verify_tinfo (function)
    verify_tinfo(typid) -> int
    
    @param typid: uint32

ida_typeinf.visit_subtypes (function)
    visit_subtypes(visitor, out, tif, name, cmt) -> int
    
    @param visitor: tinfo_visitor_t *
    @param out: type_mods_t *
    @param tif: tinfo_t const &
    @param name: char const *
    @param cmt: char const *

ida_typeinf.write_tinfo_bitfield_value (function)
    write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
    
    @param typid: uint32
    @param dst: uint64
    @param v: uint64
    @param bitoff: int

ida_ua (module)
    Functions that deal with the disassembling of program instructions.
    
    There are 2 kinds of functions:
    * functions that are called from the kernel to disassemble an instruction. These
    functions call IDP module for it.
    * functions that are called from IDP module to disassemble an instruction. We
    will call them 'helper functions'.
    
    Disassembly of an instruction is made in three steps:
    1. analysis: ana.cpp
    2. emulation: emu.cpp
    3. conversion to text: out.cpp
    
    The kernel calls the IDP module to perform these steps. At first, the kernel
    always calls the analysis. The analyzer must decode the instruction and fill the
    insn_t instance that it receives through its callback. It must not change
    anything in the database.
    
    The second step, the emulation, is called for each instruction. This step must
    make necessary changes to the database, plan analysis of subsequent
    instructions, track register values, memory contents, etc. Please keep in mind
    that the kernel may call the emulation step for any address in the program -
    there is no ordering of addresses. Usually, the emulation is called for
    consecutive addresses but this is not guaranteed.
    
    The last step, conversion to text, is called each time an instruction is
    displayed on the screen. The kernel will always call the analysis step before
    calling the text conversion step. The emulation and the text conversion steps
    should use the information stored in the insn_t instance they receive. They
    should not access the bytes of the instruction and decode it again - this should
    only be done in the analysis step.

ida_ua.FCBF_CONT (variable)
    don't stop on decoding, or any other kind of error

ida_ua.FCBF_DELIM (variable)
    add the 'ash'-specified delimiters around the generated data. Note: if those are
    not defined and the INFFL_ALLASM is not set, format_charlit() will return an
    error

ida_ua.FCBF_ERR_REPL (variable)
    in case of an error, use a CP_REPLCHAR instead of a hex representation of the
    problematic byte

ida_ua.FCBF_FF_LIT (variable)
    in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER Y WITH
    DIAERESIS). If both this, and FCBF_REPL are specified, this will take precedence

ida_ua.INSN_64BIT (variable)
    belongs to 64bit segment?

ida_ua.INSN_MACRO (variable)
    macro instruction

ida_ua.INSN_MODMAC (variable)
    may modify the database to make room for the macro insn

ida_ua.OF_NO_BASE_DISP (variable)
    base displacement doesn't exist. meaningful only for o_displ type. if set, base
    displacement (op_t::addr) doesn't exist.

ida_ua.OF_NUMBER (variable)
    the operand can be converted to a number only

ida_ua.OF_OUTER_DISP (variable)
    outer displacement exists. meaningful only for o_displ type. if set, outer
    displacement (op_t::value) exists.

ida_ua.OF_SHOW (variable)
    should the operand be displayed?

ida_ua.OOFS_IFSIGN (variable)
    output sign if needed

ida_ua.OOFS_NEEDSIGN (variable)
    always out sign (+-)

ida_ua.OOFS_NOSIGN (variable)
    don't output sign, forbid the user to change the sign

ida_ua.OOFW_16 (variable)
    16 bit width

ida_ua.OOFW_24 (variable)
    24 bit width

ida_ua.OOFW_32 (variable)
    32 bit width

ida_ua.OOFW_64 (variable)
    64 bit width

ida_ua.OOFW_8 (variable)
    8 bit width

ida_ua.OOFW_IMM (variable)
    take from x.dtype

ida_ua.OOF_ADDR (variable)
    output x.addr, otherwise x.value

ida_ua.OOF_ANYSERIAL (variable)
    if enum: select first available serial

ida_ua.OOF_LZEROES (variable)
    print leading zeroes

ida_ua.OOF_NOBNOT (variable)
    prohibit use of binary not

ida_ua.OOF_NO_LZEROES (variable)
    do not print leading zeroes; if none of OOF_LZEROES and OOF_NO_LZEROES was
    specified, is_lzero() is used

ida_ua.OOF_NUMBER (variable)
    always as a number

ida_ua.OOF_OUTER (variable)
    output outer operand

ida_ua.OOF_SIGNED (variable)
    output as signed if < 0

ida_ua.OOF_SIGNMASK (variable)
    sign symbol (+/-) output

ida_ua.OOF_SPACES (variable)
    do not suppress leading spaces; currently works only for floating point numbers

ida_ua.OOF_WIDTHMASK (variable)
    width of value in bits

ida_ua.OOF_ZSTROFF (variable)
    meaningful only if is_stroff(F); append a struct field name if the field offset
    is zero? if AFL_ZSTROFF is set, then this flag is ignored.

ida_ua.PACK_FORM_DEF (variable)
    packed factor defined. (!o_reg + dt_packreal)

ida_ua.STKVAR_VALID_SIZE (variable)
    x.dtype contains correct variable type (for insns like 'lea' this bit must be
    off). in general, dr_O references do not allow to determine the variable size

ida_ua.calc_dataseg (function)
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
    Get data segment for the instruction operand. 'opnum' and 'rgnum' are meaningful
    only if the processor has segment registers.
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param n: (C++: int)
    @param rgnum: (C++: int)

ida_ua.can_decode (function)
    can_decode(ea) -> bool
    Can the bytes at address 'ea' be decoded as instruction?
    
    @param ea: (C++: ea_t) linear address
    @return: whether or not the contents at that address could be a valid
             instruction

ida_ua.construct_macro (function)
    construct_macro(insn, enable, build_macro) -> bool
    See ua.hpp's construct_macro().
    
    @param insn: insn_t &
    @param enable: bool
    @param build_macro: PyObject *

ida_ua.construct_macro2 (function)
    construct_macro2(_this, insn, enable) -> bool
    
    @param _this: macro_constructor_t *
    @param insn: insn_t *
    @param enable: bool

ida_ua.create_insn (function)
    create_insn(ea, out=None) -> int
    Create an instruction at the specified address. This function checks if an
    instruction is present at the specified address and will try to create one if
    there is none. It will fail if there is a data item or other items hindering the
    creation of the new instruction. This function will also fill the 'out'
    structure.
    
    @param ea: (C++: ea_t) linear address
    @param out: (C++: insn_t *) the resulting instruction
    @return: the length of the instruction or 0

ida_ua.create_outctx (function)
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t
    Create a new output context. To delete it, just use "delete pctx"
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags64_t)
    @param suspop: (C++: int)

ida_ua.decode_insn (function)
    decode_insn(out, ea) -> int
    Analyze the specified address and fill 'out'. This function does not modify the
    database. It just tries to interpret the specified address as an instruction and
    fills the 'out' structure.
    
    @param out: (C++: insn_t *) the resulting instruction
    @param ea: (C++: ea_t) linear address
    @return: the length of the (possible) instruction or 0

ida_ua.decode_preceding_insn (function)
    decode_preceding_insn(out, ea) -> (int, int)
    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    
    @param out: instruction storage
    @param ea: current ea
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)

ida_ua.decode_prev_insn (function)
    decode_prev_insn(out, ea) -> ea_t
    Decode previous instruction if it exists, fill 'out'.
    
    @param out: (C++: insn_t *) the resulting instruction
    @param ea: (C++: ea_t) the address to decode the previous instruction from
    @return: the previous instruction address (BADADDR-no such insn)

ida_ua.dt_bitfild (variable)
    bit field (mc680x0)

ida_ua.dt_byte (variable)
    8 bit integer

ida_ua.dt_byte16 (variable)
    128 bit integer

ida_ua.dt_byte32 (variable)
    256 bit integer

ida_ua.dt_byte64 (variable)
    512 bit integer

ida_ua.dt_code (variable)
    ptr to code (not used?)

ida_ua.dt_double (variable)
    8 byte floating point

ida_ua.dt_dword (variable)
    32 bit integer

ida_ua.dt_float (variable)
    4 byte floating point

ida_ua.dt_fword (variable)
    48 bit

ida_ua.dt_half (variable)
    2-byte floating point

ida_ua.dt_ldbl (variable)
    long double (which may be different from tbyte)

ida_ua.dt_packreal (variable)
    packed real format for mc68040

ida_ua.dt_qword (variable)
    64 bit integer

ida_ua.dt_string (variable)
    pointer to asciiz string

ida_ua.dt_tbyte (variable)
    variable size ( processor_t::tbyte_size) floating point

ida_ua.dt_unicode (variable)
    pointer to unicode string

ida_ua.dt_void (variable)
    none

ida_ua.dt_word (variable)
    16 bit integer

ida_ua.get_dtype_by_size (function)
    get_dtype_by_size(size) -> int
    Get op_t::dtype from size.
    
    @param size: (C++: asize_t)

ida_ua.get_dtype_flag (function)
    get_dtype_flag(dtype) -> flags64_t
    Get flags for op_t::dtype field.
    
    @param dtype: (C++: op_dtype_t)

ida_ua.get_dtype_size (function)
    get_dtype_size(dtype) -> size_t
    Get size of opt_::dtype field.
    
    @param dtype: (C++: op_dtype_t)

ida_ua.get_immvals (function)
    get_immvals(ea, n, F=0) -> [int, ...]
    Get immediate values at the specified address. This function decodes instruction
    at the specified address or inspects the data item. It finds immediate values
    and copies them to 'out'. This function will store the original value of the
    operands in 'out', unless the last bits of 'F' are "...0 11111111", in which
    case the transformed values (as needed for printing) will be stored instead.
    
    @param ea: (C++: ea_t) address to analyze
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    @param F: (C++: flags64_t) flags for the specified address
    @return: number of immediate values (0..2*UA_MAXOP)

ida_ua.get_lookback (function)
    get_lookback() -> int
    Number of instructions to look back. This variable is not used by the kernel.
    Its value may be specified in ida.cfg: LOOKBACK = <number>. IDP may use it as
    you like it. (TMS module uses it)

ida_ua.get_printable_immvals (function)
    get_printable_immvals(ea, n, F=0) -> PyObject *
    Get immediate ready-to-print values at the specified address
    
    @param ea: (C++: ea_t) address to analyze
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    @param F: (C++: flags64_t) flags for the specified address
    @return: number of immediate values (0..2*UA_MAXOP)

ida_ua.insn_add_cref (function)
    insn_add_cref(insn, to, opoff, type)
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param to: ea_t
    @param opoff: int
    @param type: enum cref_t

ida_ua.insn_add_dref (function)
    insn_add_dref(insn, to, opoff, type)
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param to: ea_t
    @param opoff: int
    @param type: enum dref_t

ida_ua.insn_add_off_drefs (function)
    insn_add_off_drefs(insn, x, type, outf) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: op_t const &
    @param type: enum dref_t
    @param outf: int

ida_ua.insn_create_stkvar (function)
    insn_create_stkvar(insn, x, v, flags) -> bool
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: op_t const &
    @param v: adiff_t
    @param flags: int

ida_ua.insn_t (class)
    Proxy of C++ insn_t class.

ida_ua.insn_t.__get_auxpref__ (method)
    __get_auxpref__(self) -> uint32

ida_ua.insn_t.__get_operand__ (method)
    __get_operand__(self, n) -> op_t
    
    @param n: int

ida_ua.insn_t.__get_ops__ (method)
    __get_ops__(self) -> operands_array

ida_ua.insn_t.__getitem__ (method)
    Operands can be accessed directly as indexes
    @return: op_t: Returns an operand of type op_t

ida_ua.insn_t.__init__ (method)
    __init__(self) -> insn_t

ida_ua.insn_t.__iter__ (method)

ida_ua.insn_t.__set_auxpref__ (method)
    __set_auxpref__(self, v)
    
    @param v: uint32

ida_ua.insn_t.add_cref (method)
    add_cref(self, to, opoff, type)
    Add a code cross-reference from the instruction.
    
    @param to: (C++: ea_t) target linear address
    @param opoff: (C++: int) offset of the operand from the start of instruction. if the offset
                  is unknown, then 0.
    @param type: (C++: cref_t) type of xref

ida_ua.insn_t.add_dref (method)
    add_dref(self, to, opoff, type)
    Add a data cross-reference from the instruction. See add_off_drefs() - usually
    it can be used in most cases.
    
    @param to: (C++: ea_t) target linear address
    @param opoff: (C++: int) offset of the operand from the start of instruction if the offset
                  is unknown, then 0
    @param type: (C++: dref_t) type of xref

ida_ua.insn_t.add_off_drefs (method)
    add_off_drefs(self, x, type, outf) -> ea_t
    Add xrefs for an operand of the instruction. This function creates all cross
    references for 'enum', 'offset' and 'structure offset' operands. Use
    add_off_drefs() in the presence of negative offsets.
    
    @param x: (C++: const op_t &) reference to operand
    @param type: (C++: dref_t) type of xref
    @param outf: (C++: int) out_value() flags. These flags should match the flags used to
                 output the operand
    @return: if is_off(): the reference target address (the same as
             calc_reference_data). if is_stroff(): BADADDR because for stroffs the
             target address is unknown else: BADADDR because enums do not represent
             addresses

ida_ua.insn_t.assign (method)
    assign(self, other)
    
    @param other: an ida_ua.insn_t, or an address (C++: const insn_t &)

ida_ua.insn_t.auxpref (variable)
    processor dependent field

ida_ua.insn_t.create_op_data (method)
    create_op_data(self, ea_, opoff, dtype) -> bool
    Convenient alias.
    
    @param ea_: (C++: ea_t)
    @param opoff: int
    @param dtype: op_dtype_t
    
    create_op_data(self, ea_, op) -> bool
    
    @param ea_: ea_t
    @param op: op_t const &

ida_ua.insn_t.create_stkvar (method)
    create_stkvar(self, x, v, flags_) -> bool
    Create or modify a stack variable in the function frame. The emulator could use
    this function to create stack variables in the function frame before converting
    the operand to a stack variable. Please check with may_create_stkvars() before
    calling this function.
    
    @param x: (C++: const op_t &) operand (used to determine the addressing type)
    @param v: (C++: adiff_t) a displacement in the operand
    @param flags_: (C++: int) Stack variable flags
    @retval 1: ok, a stack variable exists now
    @retval 0: no, couldn't create stack variable

ida_ua.insn_t.cs (variable)
    Current segment base paragraph. Initialized by the kernel.

ida_ua.insn_t.ea (variable)
    Linear address of the instruction. Initialized by the kernel.

ida_ua.insn_t.flags (variable)
    Instruction flags

ida_ua.insn_t.get_canon_feature (method)
    get_canon_feature(self, ph) -> uint32
    see instruc_t::feature
    
    @param ph: (C++: const processor_t &) processor_t const &
    
    get_canon_feature(self) -> uint32

ida_ua.insn_t.get_canon_mnem (method)
    get_canon_mnem(self, ph) -> char const
    see instruc_t::name
    
    @param ph: (C++: const processor_t &) processor_t const &
    
    get_canon_mnem(self) -> char const *

ida_ua.insn_t.get_next_byte (method)
    get_next_byte(self) -> uint8

ida_ua.insn_t.get_next_dword (method)
    get_next_dword(self) -> uint32

ida_ua.insn_t.get_next_qword (method)
    get_next_qword(self) -> uint64

ida_ua.insn_t.get_next_word (method)
    get_next_word(self) -> uint16

ida_ua.insn_t.insnpref (variable)
    processor dependent field

ida_ua.insn_t.ip (variable)
    Virtual address of the instruction (address within the segment). Initialized by
    the kernel.

ida_ua.insn_t.is_64bit (method)
    is_64bit(self) -> bool
    Belongs to a 64bit segment?

ida_ua.insn_t.is_canon_insn (method)
    is_canon_insn(self, ph) -> bool
    see processor_t::is_canon_insn()
    
    @param ph: (C++: const processor_t &) processor_t const &
    
    is_canon_insn(self) -> bool

ida_ua.insn_t.is_macro (method)
    is_macro(self) -> bool
    Is a macro instruction?

ida_ua.insn_t.itype (variable)
    Internal code of instruction (only for canonical insns - not user defined!). IDP
    should define its own instruction codes. These codes are usually defined in
    ins.hpp. The array of instruction names and features (ins.cpp) is accessed using
    this code.

ida_ua.insn_t.ops (variable)
    array of operands

ida_ua.insn_t.segpref (variable)
    processor dependent field

ida_ua.insn_t.size (variable)
    Size of instruction in bytes. The analyzer should put here the actual size of
    the instruction.

ida_ua.insn_t__from_ptrval__ (function)
    insn_t__from_ptrval__(ptrval) -> insn_t
    
    @param ptrval: size_t

ida_ua.is_floating_dtype (function)
    is_floating_dtype(dtype) -> bool
    Is a floating type operand?
    
    @param dtype: (C++: op_dtype_t)

ida_ua.macro_constructor_t (class)
    Proxy of C++ macro_constructor_t class.

ida_ua.macro_constructor_t.__disown__ (method)

ida_ua.macro_constructor_t.__init__ (method)
    __init__(self) -> macro_constructor_t
    
    @param self: PyObject *

ida_ua.macro_constructor_t.build_macro (method)
    build_macro(self, insn, may_go_forward) -> bool
    Try to extend the instruction.
    
    @param insn: (C++: insn_t *) Instruction to modify, usually the first instruction of the macro
    @param may_go_forward: (C++: bool) Is it ok to consider the next instruction for the macro?
                           This argument may be false, for example, if there is a
                           cross reference to the end of INSN. In this case creating
                           a macro is not desired. However, it may still be useful
                           to perform minor tweaks to the instruction using the
                           information about the surrounding instructions.
    @return: true if created an macro instruction. This function may modify 'insn'
             and return false; these changes will be accepted by the kernel but the
             instruction will not be considered as a macro.

ida_ua.map_code_ea (function)
    map_code_ea(insn, addr, opnum) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    
    map_code_ea(insn, op) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &

ida_ua.map_data_ea (function)
    map_data_ea(insn, addr, opnum=-1) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    
    map_data_ea(insn, op) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &

ida_ua.map_ea (function)
    map_ea(insn, op, iscode) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &
    @param iscode: bool
    
    map_ea(insn, addr, opnum, iscode) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    @param iscode: bool

ida_ua.o_displ (variable)
    Memory Ref [Base Reg + Index Reg + Displacement].
    
    A memory reference using register contents with displacement. The displacement
    should be stored in the op_t::addr field. The rest of information is stored the
    same way as in o_phrase.

ida_ua.o_far (variable)
    Immediate Far Address (CODE).
    
    If the current processor has a special addressing mode for inter-segment
    references, then this operand type should be used instead of o_near. If you
    want, you may use PR_CHK_XREF in processor_t::flag to disable inter-segment
    calls if o_near operand type is used. Currently only IBM PC uses this flag.

ida_ua.o_idpspec0 (variable)
    processor specific type.

ida_ua.o_idpspec1 (variable)
    processor specific type.

ida_ua.o_idpspec2 (variable)
    processor specific type.

ida_ua.o_idpspec3 (variable)
    processor specific type.

ida_ua.o_idpspec4 (variable)
    processor specific type.

ida_ua.o_idpspec5 (variable)
    processor specific type. (there can be more processor specific types)

ida_ua.o_imm (variable)
    Immediate Value.
    
    Any operand consisting of only a number is represented by this operand type. The
    value should be stored in op_t::value. You may sign extend short (1-2 byte)
    values. In any case don't forget to specify op_t::dtype (should be set for all
    operand types).

ida_ua.o_mem (variable)
    Direct Memory Reference (DATA).
    
    A direct memory data reference whose target address is known at compilation
    time. The target virtual address is stored in op_t::addr and the full address is
    calculated as to_ea(  insn_t::cs, op_t::addr ). For the processors with complex
    memory organization the final address can be calculated using other segment
    registers. For flat memories, op_t::addr is the final address and insn_t::cs is
    usually equal to zero. In any case, the address within the segment should be
    stored in op_t::addr.

ida_ua.o_near (variable)
    Immediate Near Address (CODE).
    
    A direct memory code reference whose target address is known at the compilation
    time. The target virtual address is stored in op_t::addr and the final address
    is always to_ea( insn_t::cs, op_t::addr). Usually this operand type is used for
    the branches and calls whose target address is known. If the current processor
    has 2 different types of references for inter-segment and intra-segment
    references, then this should be used only for intra-segment references.
    
    If the above operand types do not cover all possible addressing modes, then use
    o_idpspec... operand types.

ida_ua.o_phrase (variable)
    Memory Ref [Base Reg + Index Reg].
    
    A memory reference using register contents. Indexed, register based, and other
    addressing modes can be represented with the operand type. This addressing mode
    cannot contain immediate values (use o_displ instead). The phrase number should
    be stored in op_t::phrase. To denote the pre-increment and similar features
    please use additional operand fields like op_t::specflag... Usually op_t::phrase
    contains the register number and additional information is stored in
    op_t::specflags... Please note that this operand type cannot contain immediate
    values (except the scaling coefficients).

ida_ua.o_reg (variable)
    General Register (al,ax,es,ds...).
    
    The register number should be stored in op_t::reg. All processor registers,
    including special registers, can be represented by this operand type.

ida_ua.o_void (variable)
    No Operand.

ida_ua.op_t (class)
    Proxy of C++ op_t class.

ida_ua.op_t.__get_addr__ (method)
    __get_addr__(self) -> ea_t

ida_ua.op_t.__get_reg_phrase__ (method)
    __get_reg_phrase__(self) -> uint16

ida_ua.op_t.__get_specval__ (method)
    __get_specval__(self) -> ea_t

ida_ua.op_t.__get_value64__ (method)
    __get_value64__(self) -> uint64

ida_ua.op_t.__get_value__ (method)
    __get_value__(self) -> ea_t

ida_ua.op_t.__init__ (method)
    __init__(self) -> op_t

ida_ua.op_t.__set_addr__ (method)
    __set_addr__(self, v)
    
    @param v: ea_t

ida_ua.op_t.__set_reg_phrase__ (method)
    __set_reg_phrase__(self, r)
    
    @param r: uint16

ida_ua.op_t.__set_specval__ (method)
    __set_specval__(self, v)
    
    @param v: ea_t

ida_ua.op_t.__set_value64__ (method)
    __set_value64__(self, v)
    
    @param v: uint64

ida_ua.op_t.__set_value__ (method)
    __set_value__(self, v)
    
    @param v: ea_t

ida_ua.op_t.addr (variable)
    virtual address pointed or used by the operand. (o_mem,o_displ,o_far,o_near)

ida_ua.op_t.assign (method)
    assign(self, other)
    
    @param other: op_t const &

ida_ua.op_t.clr_shown (method)
    clr_shown(self)
    Set operand to hidden.

ida_ua.op_t.dtype (variable)
    Type of operand value (see Operand value types). Usually first 9 types are used.
    This is the type of the operand itself, not the size of the addressing mode. for
    example, byte ptr [epb+32_bit_offset] will have dt_byte type.

ida_ua.op_t.flags (variable)
    Operand flags

ida_ua.op_t.has_reg (method)
    Checks if the operand accesses the given processor register

ida_ua.op_t.is_imm (method)
    is_imm(self, v) -> bool
    Is immediate operand?
    
    @param v: (C++: uval_t)

ida_ua.op_t.is_reg (method)
    is_reg(self, r) -> bool
    Is register operand?
    
    @param r: (C++: int)

ida_ua.op_t.n (variable)
    Number of operand (0,1,2). Initialized once at the start of work. You have no
    right to change its value.

ida_ua.op_t.offb (variable)
    Offset of operand value from the instruction start (0 means unknown). Of course
    this field is meaningful only for certain types of operands. Leave it equal to
    zero if the operand has no offset. This offset should point to the 'interesting'
    part of operand. For example, it may point to the address of a function in
    call func  or it may point to bytes holding '5' in
    mov  ax, [bx+5]  Usually bytes pointed to this offset are relocated (have fixup
    information).

ida_ua.op_t.offo (variable)
    Same as offb (some operands have 2 numeric values used to form an operand). This
    field is used for the second part of operand if it exists. Currently this field
    is used only for outer offsets of Motorola processors. Leave it equal to zero if
    the operand has no offset.

ida_ua.op_t.phrase (variable)
    number of register phrase (o_phrase,o_displ). you yourself define numbers of
    phrases as you like

ida_ua.op_t.reg (variable)
    number of register (o_reg)

ida_ua.op_t.set_shown (method)
    set_shown(self)
    Set operand to be shown.

ida_ua.op_t.shown (method)
    shown(self) -> bool
    Is operand set to be shown?

ida_ua.op_t.specval (variable)
    This field may be used as you want.

ida_ua.op_t.type (variable)
    Type of operand (see Operand types)

ida_ua.op_t.value (variable)
    operand value (o_imm) or outer displacement (o_displ+OF_OUTER_DISP). integer
    values should be in IDA's (little-endian) order. when using ieee_realcvt(),
    floating point values should be in the processor's native byte order. dt_double
    and dt_qword values take up 8 bytes (value and addr fields for 32-bit modules).
    NB: in case a dt_dword/dt_qword immediate is forced to float by user, the kernel
    converts it to processor's native order before calling FP conversion routines.

ida_ua.op_t__from_ptrval__ (function)
    op_t__from_ptrval__(ptrval) -> op_t
    
    @param ptrval: size_t

ida_ua.operands_array (class)
    Proxy of C++ wrapped_array_t< op_t,8 > class.

ida_ua.operands_array.__getitem__ (method)
    __getitem__(self, i) -> op_t
    
    @param i: size_t

ida_ua.operands_array.__init__ (method)
    __init__(self, data) -> operands_array
    
    @param data: op_t (&)[8]

ida_ua.operands_array.__len__ (method)
    __len__(self) -> size_t

ida_ua.operands_array.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: op_t const &

ida_ua.operands_array._get_bytes (method)
    _get_bytes(self) -> bytevec_t

ida_ua.operands_array._set_bytes (method)
    _set_bytes(self, bts)
    
    Parameters
    ----------
    bts: bytevec_t const &

ida_ua.outctx_base_t (class)
    Proxy of C++ outctx_base_t class.

ida_ua.outctx_base_t.__init__ (method)

ida_ua.outctx_base_t.close_comment (method)
    close_comment(self)

ida_ua.outctx_base_t.clr_gen_label (method)
    clr_gen_label(self)

ida_ua.outctx_base_t.display_voids (method)
    display_voids(self) -> bool

ida_ua.outctx_base_t.flush_buf (method)
    flush_buf(self, buf, indent=-1) -> bool
    Append contents of 'buf' to the line array. Behaves like flush_outbuf but
    accepts an arbitrary buffer
    
    @param buf: (C++: const char *) char const *
    @param indent: (C++: int)

ida_ua.outctx_base_t.flush_outbuf (method)
    flush_outbuf(self, indent=-1) -> bool
    Functions to populate the output line array (lnar) Move the contents of the
    output buffer to the line array (outbuf->lnar) The kernel augments the outbuf
    contents with additional text like the line prefix, user-defined comments,
    xrefs, etc at this call.
    
    @param indent: (C++: int)

ida_ua.outctx_base_t.forbid_annotations (method)
    forbid_annotations(self) -> int

ida_ua.outctx_base_t.force_code (method)
    force_code(self) -> bool

ida_ua.outctx_base_t.gen_block_cmt (method)
    gen_block_cmt(self, cmt, color) -> bool
    Generate big non-indented comment lines.
    
    @param cmt: (C++: const char *) comment text. may contain \n characters to denote new lines. should
                not contain comment character (;)
    @param color: (C++: color_t) color of comment text (one of Color tags)
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_border_line (method)
    gen_border_line(self, solid=False) -> bool
    Generate thin border line. This function does nothing if generation of border
    lines is disabled.
    
    @param solid: (C++: bool) generate solid border line (with =), otherwise with -
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_cmt_line (method)
    gen_cmt_line(self, format) -> bool
    Generate one non-indented comment line, colored with COLOR_AUTOCMT.
    
    @param format: (C++: const char *) printf() style format line. The resulting comment line should not
                   include comment character (;)
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_collapsed_line (method)
    gen_collapsed_line(self, format) -> bool
    Generate one non-indented comment line, colored with COLOR_COLLAPSED.
    
    @param format: (C++: const char *) printf() style format line. The resulting comment line should not
                   include comment character (;)
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_empty_line (method)
    gen_empty_line(self) -> bool
    Generate empty line. This function does nothing if generation of empty lines is
    disabled.
    
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_empty_line_without_annotations (method)
    gen_empty_line_without_annotations(self)

ida_ua.outctx_base_t.gen_printf (method)
    gen_printf(self, indent, format) -> bool
    printf-like function to add lines to the line array.
    
    @param indent: (C++: int) indention of the line. if indent == -1, the kernel will indent
                   the line at idainfo::indent. if indent < 0, -indent will be used
                   for indention. The first line printed with indent < 0 is
                   considered as the most important line at the current address.
                   Usually it is the line with the instruction itself. This line
                   will be displayed in the cross-reference lists and other places.
                   If you need to output an additional line before the main line
                   then pass DEFAULT_INDENT instead of -1. The kernel will know that
                   your line is not the most important one.
    @param format: (C++: const char *) printf style colored line to generate
    @return: overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_xref_lines (method)
    gen_xref_lines(self) -> bool

ida_ua.outctx_base_t.getF (method)
    getF(self) -> flags64_t

ida_ua.outctx_base_t.get_stkvar (method)
    get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
    
    @param arg2: op_t const &
    @param arg3: uval_t
    @param arg4: sval_t *
    @param arg5: int *

ida_ua.outctx_base_t.init_lines_array (method)
    init_lines_array(self, answers, maxsize)
    
    @param answers: qstrvec_t *
    @param maxsize: int

ida_ua.outctx_base_t.multiline (method)
    multiline(self) -> bool

ida_ua.outctx_base_t.only_main_line (method)
    only_main_line(self) -> bool

ida_ua.outctx_base_t.out_addr_tag (method)
    out_addr_tag(self, ea)
    Output "address" escape sequence.
    
    @param ea: (C++: ea_t)

ida_ua.outctx_base_t.out_btoa (method)
    out_btoa(self, Word, radix=0)
    Output a number with the specified base (binary, octal, decimal, hex) The number
    is output without color codes. see also out_long()
    
    @param Word: (C++: uval_t)
    @param radix: (C++: char)

ida_ua.outctx_base_t.out_char (method)
    out_char(self, c)
    Output one character. The character is output without color codes. see also
    out_symbol()
    
    @param c: (C++: char)

ida_ua.outctx_base_t.out_chars (method)
    out_chars(self, c, n)
    Append a character multiple times.
    
    @param c: (C++: char)
    @param n: (C++: int)

ida_ua.outctx_base_t.out_colored_register_line (method)
    out_colored_register_line(self, str)
    Output a colored line with register names in it. The register names will be
    substituted by user-defined names (regvar_t) Please note that out_tagoff tries
    to make substitutions too (when called with COLOR_REG)
    
    @param str: (C++: const char *) char const *

ida_ua.outctx_base_t.out_keyword (method)
    out_keyword(self, str)
    Output a string with COLOR_KEYWORD color.
    
    @param str: (C++: const char *) char const *

ida_ua.outctx_base_t.out_line (method)
    out_line(self, str, color=0)
    Output a string with the specified color.
    
    @param str: (C++: const char *) char const *
    @param color: (C++: color_t)

ida_ua.outctx_base_t.out_long (method)
    out_long(self, v, radix)
    Output a number with appropriate color. Low level function. Use out_value() if
    you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of
    COLOR_NUMBER. 'suspop' is initialized:
    * in out_one_operand()
    * in ..\ida\gl.cpp (before calling processor_t::d_out())
    
    @param v: (C++: sval_t) value to output
    @param radix: (C++: char) base (2,8,10,16)

ida_ua.outctx_base_t.out_name_expr (method)
    out_name_expr(self, x, ea, off=BADADDR) -> bool
    Output a name expression.
    
    @param x: (C++: const op_t &) instruction operand referencing the name expression
    @param ea: (C++: ea_t) address to convert to name expression
    @param off: (C++: adiff_t) the value of name expression. this parameter is used only to check
                that the name expression will have the wanted value. You may pass
                BADADDR for this parameter but I discourage it because it prohibits
                checks.
    @return: true if the name expression has been produced

ida_ua.outctx_base_t.out_printf (method)
    out_printf(self, format) -> size_t
    Functions to append text to the current output buffer (outbuf) Append a
    formatted string to the output string.
    
    @param format: (C++: const char *) char const *
    @return: the number of characters appended

ida_ua.outctx_base_t.out_register (method)
    out_register(self, str)
    Output a character with COLOR_REG color.
    
    @param str: (C++: const char *) char const *

ida_ua.outctx_base_t.out_spaces (method)
    out_spaces(self, len)
    Appends spaces to outbuf until its tag_strlen becomes 'len'.
    
    @param len: (C++: ssize_t)

ida_ua.outctx_base_t.out_symbol (method)
    out_symbol(self, c)
    Output a character with COLOR_SYMBOL color.
    
    @param c: (C++: char)

ida_ua.outctx_base_t.out_tagoff (method)
    out_tagoff(self, tag)
    Output "turn color off" escape sequence.
    
    @param tag: (C++: color_t)

ida_ua.outctx_base_t.out_tagon (method)
    out_tagon(self, tag)
    Output "turn color on" escape sequence.
    
    @param tag: (C++: color_t)

ida_ua.outctx_base_t.out_value (method)
    out_value(self, x, outf=0) -> flags64_t
    Output immediate value. Try to use this function to output all constants of
    instruction operands. This function outputs a number from x.addr or x.value in
    the form determined by F. It outputs colored text.
    
    @param x: (C++: const op_t &) value to output
    @param outf: (C++: int) Output value flags
    @return: flags of the output value, otherwise: -1 if printed a number with
             COLOR_ERROR 0 if printed a nice number or character or segment or enum

ida_ua.outctx_base_t.print_label_now (method)
    print_label_now(self) -> bool

ida_ua.outctx_base_t.restore_ctxflags (method)
    restore_ctxflags(self, saved_flags)
    
    @param saved_flags: int

ida_ua.outctx_base_t.retrieve_cmt (method)
    retrieve_cmt(self) -> ssize_t

ida_ua.outctx_base_t.retrieve_name (method)
    retrieve_name(self, arg2, arg3) -> ssize_t
    
    @param arg2: qstring *
    @param arg3: color_t *

ida_ua.outctx_base_t.set_comment_addr (method)
    set_comment_addr(self, ea)
    
    @param ea: ea_t

ida_ua.outctx_base_t.set_dlbind_opnd (method)
    set_dlbind_opnd(self)

ida_ua.outctx_base_t.set_gen_cmt (method)
    set_gen_cmt(self, on=True)
    
    @param on: bool

ida_ua.outctx_base_t.set_gen_demangled_label (method)
    set_gen_demangled_label(self)

ida_ua.outctx_base_t.set_gen_label (method)
    set_gen_label(self)

ida_ua.outctx_base_t.set_gen_xrefs (method)
    set_gen_xrefs(self, on=True)
    
    @param on: bool

ida_ua.outctx_base_t.setup_outctx (method)
    setup_outctx(self, prefix, makeline_flags)
    Initialization; normally used only by the kernel.
    
    @param prefix: (C++: const char *) char const *
    @param makeline_flags: (C++: int)

ida_ua.outctx_base_t.stack_view (method)
    stack_view(self) -> bool

ida_ua.outctx_base_t.term_outctx (method)
    term_outctx(self, prefix=None) -> int
    Finalize the output context.
    
    @param prefix: (C++: const char *) char const *
    @return: the number of generated lines.

ida_ua.outctx_base_t__from_ptrval__ (function)
    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
    
    @param ptrval: size_t

ida_ua.outctx_t (class)
    Proxy of C++ outctx_t class.

ida_ua.outctx_t.__init__ (method)

ida_ua.outctx_t.gen_func_footer (method)
    gen_func_footer(self, pfn)
    
    @param pfn: func_t const *

ida_ua.outctx_t.gen_func_header (method)
    gen_func_header(self, pfn)
    
    @param pfn: func_t *

ida_ua.outctx_t.gen_header (method)
    gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
    
    @param flags: int
    @param proc_name: char const *
    @param proc_flavour: char const *

ida_ua.outctx_t.gen_header_extra (method)
    gen_header_extra(self)

ida_ua.outctx_t.gen_xref_lines (method)
    gen_xref_lines(self) -> bool

ida_ua.outctx_t.out_btoa (method)
    out_btoa(self, Word, radix=0)
    Output a number with the specified base (binary, octal, decimal, hex) The number
    is output without color codes. see also out_long()
    
    @param Word: (C++: uval_t)
    @param radix: (C++: char)

ida_ua.outctx_t.out_custom_mnem (method)
    out_custom_mnem(self, mnem, width=8, postfix=None)
    Output custom mnemonic for 'insn'. E.g. if it should differ from the one in
    'ph.instruc'. This function outputs colored text. See out_mnem
    
    @param mnem: (C++: const char *) custom mnemonic
    @param width: (C++: int) width of field with mnemonic. if < 0, then 'postfix' will be
                  output before the mnemonic, i.e. as a prefix
    @param postfix: (C++: const char *) optional postfix added to 'mnem'

ida_ua.outctx_t.out_data (method)
    out_data(self, analyze_only)
    
    @param analyze_only: bool

ida_ua.outctx_t.out_fcref_names (method)
    out_fcref_names(self)
    Print addresses referenced *from* the specified address as commented symbolic
    names. This function is used to show, for example, multiple callees of an
    indirect call. This function outputs colored text.

ida_ua.outctx_t.out_immchar_cmts (method)
    out_immchar_cmts(self)
    Print all operand values as commented character constants. This function is used
    to comment void operands with their representation in the form of character
    constants. This function outputs colored text.

ida_ua.outctx_t.out_mnem (method)
    out_mnem(self, width=8, postfix=None)
    Output instruction mnemonic for 'insn' using information in 'ph.instruc' array.
    This function outputs colored text. It should be called from
    processor_t::ev_out_insn() or processor_t::ev_out_mnem() handler. It will output
    at least one space after the instruction. mnemonic even if the specified 'width'
    is not enough.
    
    @param width: (C++: int) width of field with mnemonic. if < 0, then 'postfix' will be
                  output before the mnemonic, i.e. as a prefix
    @param postfix: (C++: const char *) optional postfix added to the instruction mnemonic

ida_ua.outctx_t.out_mnemonic (method)
    out_mnemonic(self)
    Output instruction mnemonic using information in 'insn'. It should be called
    from processor_t::ev_out_insn() and it will call processor_t::ev_out_mnem() or
    out_mnem. This function outputs colored text.

ida_ua.outctx_t.out_one_operand (method)
    out_one_operand(self, n) -> bool
    Use this function to output an operand of an instruction. This function checks
    for the existence of a manually defined operand and will output it if it exists.
    It should be called from processor_t::ev_out_insn() and it will call
    processor_t::ev_out_operand(). This function outputs colored text.
    
    @param n: (C++: int) 0..UA_MAXOP-1 operand number
    @retval 1: operand is displayed
    @retval 0: operand is hidden

ida_ua.outctx_t.out_specea (method)
    out_specea(self, segtype) -> bool
    
    @param segtype: uchar

ida_ua.outctx_t.retrieve_cmt (method)
    retrieve_cmt(self) -> ssize_t

ida_ua.outctx_t.retrieve_name (method)
    retrieve_name(self, arg2, arg3) -> ssize_t
    
    @param arg2: qstring *
    @param arg3: color_t *

ida_ua.outctx_t.set_bin_state (method)
    set_bin_state(self, value)
    
    @param value: int

ida_ua.outctx_t.setup_outctx (method)
    setup_outctx(self, prefix, flags)
    Initialization; normally used only by the kernel.
    
    @param prefix: (C++: const char *) char const *
    @param flags: int

ida_ua.outctx_t.term_outctx (method)
    term_outctx(self, prefix=None) -> int
    Finalize the output context.
    
    @param prefix: (C++: const char *) char const *
    @return: the number of generated lines.

ida_ua.outctx_t__from_ptrval__ (function)
    outctx_t__from_ptrval__(ptrval) -> outctx_t
    
    @param ptrval: size_t

ida_ua.print_insn_mnem (function)
    print_insn_mnem(ea) -> str
    Print instruction mnemonics.
    
    @param ea: (C++: ea_t) linear address of the instruction
    @return: success

ida_ua.print_operand (function)
    print_operand(ea, n, getn_flags=0, newtype=None) -> str
    Generate text representation for operand #n. This function will generate the
    text representation of the specified operand (includes color codes.)
    
    @param ea: (C++: ea_t) the item address (instruction or data)
    @param n: (C++: int) 0..UA_MAXOP-1 operand number, meaningful only for instructions
    @param getn_flags: (C++: int) Name expression flags Currently only GETN_NODUMMY is
                       accepted.
    @param newtype: (C++: struct printop_t *) if specified, print the operand using the specified type
    @return: success

ida_xref (module)
    Functions that deal with cross-references.
    
    There are 2 types of xrefs: CODE and DATA references. All xrefs are kept in the
    bTree except ordinary execution flow to the next instruction. Ordinary execution
    flow to the next instruction is kept in flags (see bytes.hpp)
    
    The source address of a cross-reference must be an item head (is_head) or a
    structure member id.
    
    Cross-references are automatically sorted.

ida_xref.XREF_ALL (variable)
    return all references

ida_xref.XREF_BASE (variable)
    Reference to the base part of an offset.

ida_xref.XREF_DATA (variable)
    return data references only

ida_xref.XREF_FAR (variable)
    don't return ordinary flow xrefs

ida_xref.XREF_MASK (variable)
    Mask to get xref type.

ida_xref.XREF_PASTEND (variable)
    Reference is past item. This bit may be passed to add_dref() functions but it
    won't be saved in the database. It will prevent the destruction of eventual
    alignment directives.

ida_xref.XREF_TAIL (variable)
    Reference to tail byte in extrn symbols.

ida_xref.XREF_USER (variable)
    User specified xref. This xref will not be deleted by IDA. This bit should be
    combined with the existing xref types (cref_t & dref_t) Cannot be used for fl_F
    xrefs

ida_xref.add_cref (function)
    add_cref(frm, to, type) -> bool
    Create a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param type: (C++: cref_t) cross-reference type
    @return: success

ida_xref.add_dref (function)
    add_dref(frm, to, type) -> bool
    Create a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data
    @param type: (C++: dref_t) cross-reference type
    @return: success (may fail if user-defined xref exists from->to)

ida_xref.calc_switch_cases (function)
    calc_switch_cases(ea, si) -> cases_and_targets_t
    Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: a structure with 2 members: 'cases', and 'targets'.

ida_xref.cases_and_targets_t (class)
    Proxy of C++ cases_and_targets_t class.

ida_xref.cases_and_targets_t.__init__ (method)
    __init__(self) -> cases_and_targets_t

ida_xref.casevec_t (class)
    Proxy of C++ qvector< qvector< sval_t > > class.

ida_xref.casevec_t.__eq__ (method)
    __eq__(self, r) -> bool
    
    @param r: qvector< qvector< signed-ea-like-numeric-type > > const &

ida_xref.casevec_t.__getitem__ (method)
    __getitem__(self, i) -> qvector< signed-ea-like-numeric-type > const &
    
    @param i: size_t

ida_xref.casevec_t.__init__ (method)
    __init__(self) -> casevec_t
    __init__(self, x) -> casevec_t
    
    @param x: qvector< qvector< signed-ea-like-numeric-type > > const &

ida_xref.casevec_t.__len__ (method)
    __len__(self) -> size_t

ida_xref.casevec_t.__ne__ (method)
    __ne__(self, r) -> bool
    
    @param r: qvector< qvector< signed-ea-like-numeric-type > > const &

ida_xref.casevec_t.__setitem__ (method)
    __setitem__(self, i, v)
    
    @param i: size_t
    @param v: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t._del (method)
    _del(self, x) -> bool
    
    Parameters
    ----------
    x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.add_unique (method)
    add_unique(self, x) -> bool
    
    @param x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.at (method)
    at(self, _idx) -> qvector< signed-ea-like-numeric-type > const &
    
    @param _idx: size_t

ida_xref.casevec_t.begin (method)
    begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator

ida_xref.casevec_t.capacity (method)
    capacity(self) -> size_t

ida_xref.casevec_t.clear (method)
    clear(self)

ida_xref.casevec_t.empty (method)
    empty(self) -> bool

ida_xref.casevec_t.end (method)
    end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator

ida_xref.casevec_t.erase (method)
    erase(self, it) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    
    @param it: qvector< qvector< signed-ea-like-numeric-type > >::iterator
    
    erase(self, first, last) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    
    @param first: qvector< qvector< signed-ea-like-numeric-type > >::iterator
    @param last: qvector< qvector< signed-ea-like-numeric-type > >::iterator

ida_xref.casevec_t.extract (method)
    extract(self) -> qvector< signed-ea-like-numeric-type > *

ida_xref.casevec_t.find (method)
    find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    
    @param x: qvector< signed-ea-like-numeric-type > const &
    
    find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
    
    @param x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.grow (method)
    grow(self, x=qvector< signed-ea-like-numeric-type >())
    
    @param x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.has (method)
    has(self, x) -> bool
    
    @param x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.inject (method)
    inject(self, s, len)
    
    @param s: qvector< signed-ea-like-numeric-type > *
    @param len: size_t

ida_xref.casevec_t.insert (method)
    insert(self, it, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
    
    @param it: qvector< qvector< signed-ea-like-numeric-type > >::iterator
    @param x: qvector< signed-ea-like-numeric-type > const &

ida_xref.casevec_t.pop_back (method)
    pop_back(self)

ida_xref.casevec_t.push_back (method)
    push_back(self, x)
    
    @param x: qvector< signed-ea-like-numeric-type > const &
    
    push_back(self) -> qvector< signed-ea-like-numeric-type > &

ida_xref.casevec_t.qclear (method)
    qclear(self)

ida_xref.casevec_t.reserve (method)
    reserve(self, cnt)
    
    @param cnt: size_t

ida_xref.casevec_t.resize (method)
    resize(self, _newsize, x)
    
    @param _newsize: size_t
    @param x: qvector< signed-ea-like-numeric-type > const &
    
    resize(self, _newsize)
    
    @param _newsize: size_t

ida_xref.casevec_t.size (method)
    size(self) -> size_t

ida_xref.casevec_t.swap (method)
    swap(self, r)
    
    @param r: qvector< qvector< signed-ea-like-numeric-type > > &

ida_xref.casevec_t.truncate (method)
    truncate(self)

ida_xref.create_switch_table (function)
    create_switch_table(ea, si) -> bool
    Create switch table from the switch information
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

ida_xref.create_switch_xrefs (function)
    create_switch_xrefs(ea, si) -> bool
    This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

ida_xref.del_cref (function)
    del_cref(frm, to, expand) -> bool
    Delete a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param expand: (C++: bool) policy to delete the referenced instruction
    * 1: plan to delete the referenced instruction if it has no more references.
    * 0: don't delete the referenced instruction even if no more cross-references
    point to it
    @retval true: if the referenced instruction will be deleted

ida_xref.del_dref (function)
    del_dref(frm, to)
    Delete a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data

ida_xref.delete_switch_table (function)
    delete_switch_table(jump_ea, si)
    
    @param jump_ea: ea_t
    @param si: switch_info_t const &

ida_xref.dr_I (variable)
    Informational (a derived java class references its base class informationally)

ida_xref.dr_O (variable)
    Offset The reference uses 'offset' of data rather than its value OR The
    reference appeared because the "OFFSET" flag of instruction is set. The meaning
    of this type is IDP dependent.

ida_xref.dr_R (variable)
    Read access.

ida_xref.dr_S (variable)
    Reference to enum member (symbolic constant)

ida_xref.dr_T (variable)
    Text (for forced operands only) Name of data is used in manual operand

ida_xref.dr_U (variable)
    Unknown - for compatibility with old versions. Should not be used anymore.

ida_xref.dr_W (variable)
    Write access.

ida_xref.fl_CF (variable)
    Call Far This xref creates a function at the referenced location

ida_xref.fl_CN (variable)
    Call Near This xref creates a function at the referenced location

ida_xref.fl_F (variable)
    Ordinary flow: used to specify execution flow to the next instruction.

ida_xref.fl_JF (variable)
    Jump Far.

ida_xref.fl_JN (variable)
    Jump Near.

ida_xref.fl_U (variable)
    unknown - for compatibility with old versions. Should not be used anymore.

ida_xref.fl_USobsolete (variable)
    User specified (obsolete)

ida_xref.get_first_cref_from (function)
    get_first_cref_from(frm) -> ea_t
    Get first instruction referenced from the specified instruction. If the
    specified instruction passes execution to the next instruction then the next
    instruction is returned. Otherwise the lowest referenced address is returned
    (remember that xrefs are kept sorted!).
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @return: first referenced address. If the specified instruction doesn't
             reference to other instructions then returns BADADDR.

ida_xref.get_first_cref_to (function)
    get_first_cref_to(to) -> ea_t
    Get first instruction referencing to the specified instruction. If the specified
    instruction may be executed immediately after its previous instruction then the
    previous instruction is returned. Otherwise the lowest referencing address is
    returned. (remember that xrefs are kept sorted!).
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @return: linear address of the first referencing instruction or BADADDR.

ida_xref.get_first_dref_from (function)
    get_first_dref_from(frm) -> ea_t
    Get first data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @return: linear address of first (lowest) data referenced from the specified
             address. Return BADADDR if the specified instruction/data doesn't
             reference to anything.

ida_xref.get_first_dref_to (function)
    get_first_dref_to(to) -> ea_t
    Get address of instruction/data referencing to the specified data.
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @return: BADADDR if nobody refers to the specified data.

ida_xref.get_first_fcref_from (function)
    get_first_fcref_from(frm) -> ea_t
    
    @param from: ea_t

ida_xref.get_first_fcref_to (function)
    get_first_fcref_to(to) -> ea_t
    
    @param to: ea_t

ida_xref.get_next_cref_from (function)
    get_next_cref_from(frm, current) -> ea_t
    Get next instruction referenced from the specified instruction.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_from() or previous call to
                    get_next_cref_from() functions.
    @return: next referenced address or BADADDR.

ida_xref.get_next_cref_to (function)
    get_next_cref_to(to, current) -> ea_t
    Get next instruction referencing to the specified instruction.
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_to() or previous call to
                    get_next_cref_to() functions.
    @return: linear address of the next referencing instruction or BADADDR.

ida_xref.get_next_dref_from (function)
    get_next_dref_from(frm, current) -> ea_t
    Get next data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) linear address of current referenced data. This value is
                    returned by get_first_dref_from() or previous call to
                    get_next_dref_from() functions.
    @return: linear address of next data or BADADDR.

ida_xref.get_next_dref_to (function)
    get_next_dref_to(to, current) -> ea_t
    Get address of instruction/data referencing to the specified data
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) current linear address. This value is returned by
                    get_first_dref_to() or previous call to get_next_dref_to()
                    functions.
    @return: BADADDR if nobody refers to the specified data.

ida_xref.get_next_fcref_from (function)
    get_next_fcref_from(frm, current) -> ea_t
    
    @param from: ea_t
    @param current: ea_t

ida_xref.get_next_fcref_to (function)
    get_next_fcref_to(to, current) -> ea_t
    
    @param to: ea_t
    @param current: ea_t

ida_xref.has_external_refs (function)
    has_external_refs(pfn, ea) -> bool
    Does 'ea' have references from outside of 'pfn'?
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

ida_xref.xrefblk_t (class)
    Proxy of C++ xrefblk_t class.

ida_xref.xrefblk_t.__init__ (method)
    __init__(self) -> xrefblk_t

ida_xref.xrefblk_t.crefs_from (method)
    Provide an iterator on code references from ea including flow references

ida_xref.xrefblk_t.crefs_to (method)
    Provide an iterator on code references to ea including flow references

ida_xref.xrefblk_t.drefs_from (method)
    Provide an iterator on data references from ea

ida_xref.xrefblk_t.drefs_to (method)
    Provide an iterator on data references to ea

ida_xref.xrefblk_t.fcrefs_from (method)
    Provide an iterator on code references from ea

ida_xref.xrefblk_t.fcrefs_to (method)
    Provide an iterator on code references to ea

ida_xref.xrefblk_t.first_from (method)
    first_from(self, _from, flags) -> bool
    Get first xref from the given address (store in to)
    
    @param _from: (C++: ea_t)
    @param flags: (C++: int)

ida_xref.xrefblk_t.first_to (method)
    first_to(self, _to, flags) -> bool
    Get xref to given address (store in from)
    
    @param _to: (C++: ea_t)
    @param flags: (C++: int)

ida_xref.xrefblk_t.iscode (variable)
    1-is code reference; 0-is data reference

ida_xref.xrefblk_t.next_from (method)
    next_from(self) -> bool
    Get xref from '_from' that comes after '_to'.
    next_from(self, _from, _to, flags) -> bool
    
    @param _from: ea_t
    @param _to: ea_t
    @param flags: int

ida_xref.xrefblk_t.next_to (method)
    next_to(self) -> bool
    Get xref to '_to' that comes after '_from'.
    next_to(self, _from, _to, flags) -> bool
    
    @param _from: ea_t
    @param _to: ea_t
    @param flags: int

ida_xref.xrefblk_t.refs_from (method)
    Provide an iterator on from reference represented by flag

ida_xref.xrefblk_t.refs_from._copy_xref (function)
    Make a private copy of the xref class to preserve its contents 

ida_xref.xrefblk_t.refs_to (method)
    Provide an iterator on to reference represented by flag

ida_xref.xrefblk_t.refs_to._copy_xref (function)
    Make a private copy of the xref class to preserve its contents 

ida_xref.xrefblk_t.to (variable)
    the referenced address - filled by first_from(), next_from()

ida_xref.xrefblk_t.type (variable)
    type of the last returned reference (cref_t & dref_t)

ida_xref.xrefblk_t.user (variable)
    1-is user defined xref, 0-defined by ida

ida_xref.xrefchar (function)
    xrefchar(xrtype) -> char
    Get character describing the xref type.
    
    @param xrtype: (C++: char) combination of Cross-Reference type flags and a cref_t of dref_t
                   value

